<Type Name="Expression" FullName="System.Linq.Expressions.Expression">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="8d7399087ab69cfbf5452abe2298465ee636d83d" />
    <Meta Name="ms.sourcegitcommit" Value="9e06b87bcfa4347dbbaaa4b3cc36b43b93b5badb" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="pt-BR" />
    <Meta Name="ms.lasthandoff" Value="11/20/2018" />
    <Meta Name="ms.locfileid" Value="52248484" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class Expression" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit Expression extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Linq.Expressions.Expression" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Expression" />
  <TypeSignature Language="C++ CLI" Value="public ref class Expression abstract" />
  <TypeSignature Language="F#" Value="type Expression = class" />
  <AssemblyInfo>
    <AssemblyName>System.Linq.Expressions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>
      <span data-ttu-id="f7da9-101">Fornece a classe base da qual são derivadas as classes que representam nós de árvore de expressão.</span>
      <span class="sxs-lookup">
        <span data-stu-id="f7da9-101">Provides the base class from which the classes that represent expression tree nodes are derived.</span>
      </span>
      <span data-ttu-id="f7da9-102">Também contém métodos de fábrica <see langword="static" /> (<see langword="Shared" /> no Visual Basic) para criar os diferentes tipos de nós.</span>
      <span class="sxs-lookup">
        <span data-stu-id="f7da9-102">It also contains <see langword="static" /> (<see langword="Shared" /> in Visual Basic) factory methods to create the various node types.</span>
      </span>
      <span data-ttu-id="f7da9-103">Esta é uma classe <see langword="abstract" />.</span>
      <span class="sxs-lookup">
        <span data-stu-id="f7da9-103">This is an <see langword="abstract" /> class.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="f7da9-104">O exemplo de código a seguir mostra como criar uma expressão de bloco.</span><span class="sxs-lookup"><span data-stu-id="f7da9-104">The following code example shows how to create a block expression.</span></span> <span data-ttu-id="f7da9-105">A expressão de bloco consiste em dois <xref:System.Linq.Expressions.MethodCallExpression> objetos e um <xref:System.Linq.Expressions.ConstantExpression> objeto.</span><span class="sxs-lookup"><span data-stu-id="f7da9-105">The block expression consists of two <xref:System.Linq.Expressions.MethodCallExpression> objects and one <xref:System.Linq.Expressions.ConstantExpression> object.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#13)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#13)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f7da9-106">Constrói uma nova instância de <see cref="T:System.Linq.Expressions.Expression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-106">Constructs a new instance of <see cref="T:System.Linq.Expressions.Expression" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Expression ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Expression();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="f7da9-107">Constrói uma nova instância de <see cref="T:System.Linq.Expressions.Expression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-107">Constructs a new instance of <see cref="T:System.Linq.Expressions.Expression" />.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Expression (System.Linq.Expressions.ExpressionType nodeType, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(valuetype System.Linq.Expressions.ExpressionType nodeType, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.#ctor(System.Linq.Expressions.ExpressionType,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Expression(System::Linq::Expressions::ExpressionType nodeType, Type ^ type);" />
      <MemberSignature Language="F#" Value="new System.Linq.Expressions.Expression : System.Linq.Expressions.ExpressionType * Type -&gt; System.Linq.Expressions.Expression" Usage="new System.Linq.Expressions.Expression (nodeType, type)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("use a different constructor that does not take ExpressionType. Then override NodeType and Type properties to provide the values that would be specified to this constructor.")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="nodeType" Type="System.Linq.Expressions.ExpressionType" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="nodeType">
          <span data-ttu-id="f7da9-108">O <see cref="T:System.Linq.Expressions.ExpressionType" /> para definir como tipo de nó.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-108">The <see cref="T:System.Linq.Expressions.ExpressionType" /> to set as the node type.</span>
          </span>
        </param>
        <param name="type">
          <span data-ttu-id="f7da9-109">O <see cref="P:System.Linq.Expressions.Expression.Type" /> desse <see cref="T:System.Linq.Expressions.Expression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-109">The <see cref="P:System.Linq.Expressions.Expression.Type" /> of this <see cref="T:System.Linq.Expressions.Expression" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-110">Inicializa uma nova instância da classe <see cref="T:System.Linq.Expressions.Expression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-110">Initializes a new instance of the <see cref="T:System.Linq.Expressions.Expression" /> class.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-111">Este construtor é chamado de construtores em classes derivadas.</span><span class="sxs-lookup"><span data-stu-id="f7da9-111">This constructor is called from constructors in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Accept">
      <MemberSignature Language="C#" Value="protected internal virtual System.Linq.Expressions.Expression Accept (System.Linq.Expressions.ExpressionVisitor visitor);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.Linq.Expressions.Expression Accept(class System.Linq.Expressions.ExpressionVisitor visitor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Accept(System.Linq.Expressions.ExpressionVisitor)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function Accept (visitor As ExpressionVisitor) As Expression" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Linq::Expressions::Expression ^ Accept(System::Linq::Expressions::ExpressionVisitor ^ visitor);" />
      <MemberSignature Language="F#" Value="abstract member Accept : System.Linq.Expressions.ExpressionVisitor -&gt; System.Linq.Expressions.Expression&#xA;override this.Accept : System.Linq.Expressions.ExpressionVisitor -&gt; System.Linq.Expressions.Expression" Usage="expression.Accept visitor" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="visitor" Type="System.Linq.Expressions.ExpressionVisitor" />
      </Parameters>
      <Docs>
        <param name="visitor">
          <span data-ttu-id="f7da9-112">O visitante com o qual visitar esse nó.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-112">The visitor to visit this node with.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-113">Expede o método específico de visita para esse tipo de nó.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-113">Dispatches to the specific visit method for this node type.</span>
          </span>
          <span data-ttu-id="f7da9-114">Por exemplo, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> chama o <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-114">For example, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> calls the <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-115">O resultado de visitar esse nó.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-115">The result of visiting this node.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-116">Essa implementação padrão para <xref:System.Linq.Expressions.ExpressionType.Extension> chamadas nós <xref:System.Linq.Expressions.ExpressionVisitor.VisitExtension%2A>.</span><span class="sxs-lookup"><span data-stu-id="f7da9-116">This default implementation for <xref:System.Linq.Expressions.ExpressionType.Extension> nodes calls <xref:System.Linq.Expressions.ExpressionVisitor.VisitExtension%2A>.</span></span> <span data-ttu-id="f7da9-117">Substitua este método para chamar um método mais específico em uma classe derivada de visitante do <xref:System.Linq.Expressions.ExpressionVisitor> classe.</span><span class="sxs-lookup"><span data-stu-id="f7da9-117">Override this method to call into a more specific method on a derived visitor class of the <xref:System.Linq.Expressions.ExpressionVisitor> class.</span></span> <span data-ttu-id="f7da9-118">No entanto, ele ainda deve suportar visitantes desconhecidos chamando <xref:System.Linq.Expressions.ExpressionVisitor.VisitExtension%2A>.</span><span class="sxs-lookup"><span data-stu-id="f7da9-118">However, it should still support unknown visitors by calling <xref:System.Linq.Expressions.ExpressionVisitor.VisitExtension%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Add">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f7da9-119">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação aritmética de adição que não tem verificação de estouro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-119">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic addition operation that does not have overflow checking.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Add (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Add(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Add(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Add(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member Add : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Add (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="f7da9-120">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-120">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="f7da9-121">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-121">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-122">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação aritmética de adição que não tem verificação de estouro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-122">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic addition operation that does not have overflow checking.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-123">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Add" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-123">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Add" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-124">Resultante <xref:System.Linq.Expressions.BinaryExpression> tem o <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriedade definida como o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-124">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="f7da9-125">O <xref:System.Linq.Expressions.Expression.Type%2A> estiver definida como o tipo de nó.</span><span class="sxs-lookup"><span data-stu-id="f7da9-125">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="f7da9-126">Se o nó é elevado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> e <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriedades estiverem `true`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-126">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="f7da9-127">Caso contrário, eles são `false`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-127">Otherwise, they are `false`.</span></span> <span data-ttu-id="f7da9-128">A propriedade <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> é `null`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-128">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="f7da9-129">As informações a seguir descrevem o método de implementação, o tipo de nó, e se um nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-129">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="f7da9-130">Implementando método</span><span class="sxs-lookup"><span data-stu-id="f7da9-130">Implementing Method</span></span>  
 <span data-ttu-id="f7da9-131">As seguintes regras de determinam o método de implementação selecionado para a operação:</span><span class="sxs-lookup"><span data-stu-id="f7da9-131">The following rules determine the selected implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="f7da9-132">Se o <xref:System.Linq.Expressions.Expression.Type%2A> propriedade deles `left` ou `right` representa um tipo definido pelo usuário que sobrecarrega o operador de adição, o <xref:System.Reflection.MethodInfo> que representa que o método é o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-132">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the addition operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="f7da9-133">Caso contrário, se `left`. Tipo e `right`. Tipo de tipos numéricos, o método de implementação está `null`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-133">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="f7da9-134">Tipo de nó e versão com comparação de precisão x sem comparação de precisão</span><span class="sxs-lookup"><span data-stu-id="f7da9-134">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="f7da9-135">Se o método de implementação não for `null`:</span><span class="sxs-lookup"><span data-stu-id="f7da9-135">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="f7da9-136">Se `left`. Tipo e `right`. Tipo podem ser atribuídos aos tipos de argumento correspondente do método de implementação, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-136">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="f7da9-137">O tipo do nó é o tipo de retorno do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-137">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="f7da9-138">Se as duas seguintes condições forem atendidas, o nó é levantado e o tipo de nó é o tipo que permite valor nulo que corresponde ao tipo de retorno do método de implementação:</span><span class="sxs-lookup"><span data-stu-id="f7da9-138">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="f7da9-139">`left`. Tipo e `right`. Tipo são os dois tipos de valor de que pelo menos um é anulável e os tipos não anuláveis correspondentes são iguais para os tipos de argumento correspondente do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-139">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="f7da9-140">O tipo de retorno do método de implementação é um tipo de valor não anulável.</span><span class="sxs-lookup"><span data-stu-id="f7da9-140">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="f7da9-141">Se o método de implementação é `null`:</span><span class="sxs-lookup"><span data-stu-id="f7da9-141">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="f7da9-142">Se `left`. Tipo e `right`. Tipo são não anuláveis, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-142">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="f7da9-143">O tipo do nó é o tipo de resultado do operador de adição predefinidos.</span><span class="sxs-lookup"><span data-stu-id="f7da9-143">The type of the node is the result type of the predefined addition operator.</span></span>  
  
-   <span data-ttu-id="f7da9-144">Se `left`. Tipo e `right`. Tipo são anuláveis, o nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-144">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="f7da9-145">O tipo de nó é o tipo que permite valor nulo que corresponde ao tipo de resultado do operador de adição predefinidos.</span><span class="sxs-lookup"><span data-stu-id="f7da9-145">The type of the node is the nullable type that corresponds to the result type of the predefined addition operator.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f7da9-146">O exemplo de código a seguir mostra como criar uma expressão que adiciona dois números inteiros.</span><span class="sxs-lookup"><span data-stu-id="f7da9-146">The following code example shows how to create an expression that adds two integers.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#1)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f7da9-147">
            <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-147">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f7da9-148">O operador de adição não foi definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-148">The addition operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Add (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Add(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Add(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Add(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member Add : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Add (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="f7da9-149">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-149">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="f7da9-150">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-150">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="f7da9-151">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-151">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-152">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação aritmética de adição que não tem verificação de estouro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-152">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic addition operation that does not have overflow checking.</span>
          </span>
          <span data-ttu-id="f7da9-153">O método de implementação pode ser especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-153">The implementing method can be specified.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-154">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Add" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas para os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-154">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Add" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-155">Resultante <xref:System.Linq.Expressions.BinaryExpression> tem o <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriedade definida como o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-155">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="f7da9-156">O <xref:System.Linq.Expressions.Expression.Type%2A> estiver definida como o tipo de nó.</span><span class="sxs-lookup"><span data-stu-id="f7da9-156">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="f7da9-157">Se o nó é elevado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> e <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriedades estiverem `true`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-157">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="f7da9-158">Caso contrário, eles são `false`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-158">Otherwise, they are `false`.</span></span> <span data-ttu-id="f7da9-159">A propriedade <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> é `null`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-159">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="f7da9-160">As informações a seguir descrevem o método de implementação, o tipo de nó, e se um nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-160">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="f7da9-161">Implementando método</span><span class="sxs-lookup"><span data-stu-id="f7da9-161">Implementing Method</span></span>  
 <span data-ttu-id="f7da9-162">As regras a seguir determinam o método de implementação para a operação:</span><span class="sxs-lookup"><span data-stu-id="f7da9-162">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="f7da9-163">Se `method` não é `null` e representa um não-nulo, `static` (`Shared` no Visual Basic) método que usa dois argumentos, é o método de implementação para o nó.</span><span class="sxs-lookup"><span data-stu-id="f7da9-163">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method for the node.</span></span>  
  
-   <span data-ttu-id="f7da9-164">Caso contrário, se o <xref:System.Linq.Expressions.Expression.Type%2A> propriedade deles `left` ou `right` representa um tipo definido pelo usuário que sobrecarrega o operador de adição, o <xref:System.Reflection.MethodInfo> que representa que o método é o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-164">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the addition operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="f7da9-165">Caso contrário, se `left`. Tipo e `right`. Tipo de tipos numéricos, o método de implementação está `null`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-165">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="f7da9-166">Tipo de nó e versão com comparação de precisão x sem comparação de precisão</span><span class="sxs-lookup"><span data-stu-id="f7da9-166">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="f7da9-167">Se o método de implementação não for `null`:</span><span class="sxs-lookup"><span data-stu-id="f7da9-167">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="f7da9-168">Se `left`. Tipo e `right`. Tipo podem ser atribuídos aos tipos de argumento correspondente do método de implementação, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-168">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="f7da9-169">O tipo do nó é o tipo de retorno do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-169">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="f7da9-170">Se as duas seguintes condições forem atendidas, o nó é levantado e o tipo de nó é o tipo que permite valor nulo que corresponde ao tipo de retorno do método de implementação:</span><span class="sxs-lookup"><span data-stu-id="f7da9-170">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="f7da9-171">`left`. Tipo e `right`. Tipo são os dois tipos de valor de que pelo menos um é anulável e os tipos não anuláveis correspondentes são iguais para os tipos de argumento correspondente do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-171">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="f7da9-172">O tipo de retorno do método de implementação é um tipo de valor não anulável.</span><span class="sxs-lookup"><span data-stu-id="f7da9-172">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="f7da9-173">Se o método de implementação é `null`:</span><span class="sxs-lookup"><span data-stu-id="f7da9-173">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="f7da9-174">Se `left`. Tipo e `right`. Tipo são não anuláveis, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-174">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="f7da9-175">O tipo do nó é o tipo de resultado do operador de adição predefinidos.</span><span class="sxs-lookup"><span data-stu-id="f7da9-175">The type of the node is the result type of the predefined addition operator.</span></span>  
  
-   <span data-ttu-id="f7da9-176">Se `left`. Tipo e `right`. Tipo são anuláveis, o nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-176">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="f7da9-177">O tipo de nó é o tipo que permite valor nulo que corresponde ao tipo de resultado do operador de adição predefinidos.</span><span class="sxs-lookup"><span data-stu-id="f7da9-177">The type of the node is the nullable type that corresponds to the result type of the predefined addition operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f7da9-178">
            <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-178">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f7da9-179">
            <paramref name="method" /> não é <see langword="null" /> e o método que ele representa retorna <see langword="void" />, não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) ou não tem exatamente dois argumentos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-179">
              <paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f7da9-180">
            <paramref name="method" /> é <see langword="null" /> e o operador de adição não foi definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-180">
              <paramref name="method" /> is <see langword="null" /> and the addition operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f7da9-181">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição de adição que não tem a verificação de estouro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-181">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an addition assignment operation that does not have overflow checking.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AddAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AddAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AddAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AddAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AddAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member AddAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.AddAssign (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="f7da9-182">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-182">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="f7da9-183">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-183">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-184">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição de adição que não tem a verificação de estouro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-184">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an addition assignment operation that does not have overflow checking.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-185">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.AddAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-185">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.AddAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="f7da9-186">O exemplo de código a seguir mostra como criar uma expressão que adiciona um valor para uma variável de inteiro e, em seguida, atribui o resultado da operação para a variável.</span><span class="sxs-lookup"><span data-stu-id="f7da9-186">The following code example shows how to create an expression that adds a value to an integer variable and then assigns the result of the operation to the variable.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#18)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#18)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AddAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AddAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AddAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AddAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AddAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member AddAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.AddAssign (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="f7da9-187">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-187">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="f7da9-188">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-188">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="f7da9-189">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-189">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-190">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição de adição que não tem a verificação de estouro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-190">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an addition assignment operation that does not have overflow checking.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-191">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.AddAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-191">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.AddAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AddAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AddAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AddAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AddAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AddAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member AddAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.AddAssign (left, right, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="f7da9-192">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-192">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="f7da9-193">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-193">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="f7da9-194">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-194">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <param name="conversion">
          <span data-ttu-id="f7da9-195">Um <see cref="T:System.Linq.Expressions.LambdaExpression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-195">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-196">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição de adição que não tem a verificação de estouro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-196">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an addition assignment operation that does not have overflow checking.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-197">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.AddAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-197">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.AddAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddAssignChecked">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f7da9-198">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição de adição que tem verificação de estouro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-198">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an addition assignment operation that has overflow checking.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AddAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AddAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AddAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AddAssignChecked (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AddAssignChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member AddAssignChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.AddAssignChecked (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="f7da9-199">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-199">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="f7da9-200">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-200">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-201">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição de adição que tem verificação de estouro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-201">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an addition assignment operation that has overflow checking.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-202">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.AddAssignChecked" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-202">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.AddAssignChecked" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AddAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AddAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AddAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AddAssignChecked (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AddAssignChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member AddAssignChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.AddAssignChecked (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="f7da9-203">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-203">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="f7da9-204">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-204">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="f7da9-205">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-205">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-206">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição de adição que tem verificação de estouro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-206">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an addition assignment operation that has overflow checking.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-207">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.AddAssignChecked" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-207">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.AddAssignChecked" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AddAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AddAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AddAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AddAssignChecked (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AddAssignChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member AddAssignChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.AddAssignChecked (left, right, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="f7da9-208">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-208">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="f7da9-209">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-209">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="f7da9-210">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-210">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <param name="conversion">
          <span data-ttu-id="f7da9-211">Um <see cref="T:System.Linq.Expressions.LambdaExpression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-211">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-212">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição de adição que tem verificação de estouro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-212">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an addition assignment operation that has overflow checking.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-213">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.AddAssignChecked" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-213">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.AddAssignChecked" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddChecked">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f7da9-214">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação aritmética de adição que tem verificação de estouro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-214">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic addition operation that has overflow checking.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AddChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AddChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AddChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AddChecked (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AddChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member AddChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.AddChecked (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="f7da9-215">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-215">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="f7da9-216">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-216">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-217">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação aritmética de adição que tem verificação de estouro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-217">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic addition operation that has overflow checking.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-218">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.AddChecked" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-218">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.AddChecked" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-219">Resultante <xref:System.Linq.Expressions.BinaryExpression> tem o <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriedade definida como o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-219">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="f7da9-220">O <xref:System.Linq.Expressions.Expression.Type%2A> estiver definida como o tipo de nó.</span><span class="sxs-lookup"><span data-stu-id="f7da9-220">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="f7da9-221">Se o nó é elevado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> e <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriedades estiverem `true`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-221">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="f7da9-222">Caso contrário, eles são `false`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-222">Otherwise, they are `false`.</span></span> <span data-ttu-id="f7da9-223">A propriedade <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> é `null`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-223">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="f7da9-224">As informações a seguir descrevem o método de implementação, o tipo de nó, e se um nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-224">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="f7da9-225">Implementando método</span><span class="sxs-lookup"><span data-stu-id="f7da9-225">Implementing Method</span></span>  
 <span data-ttu-id="f7da9-226">As regras a seguir determinam o método de implementação para a operação:</span><span class="sxs-lookup"><span data-stu-id="f7da9-226">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="f7da9-227">Se o <xref:System.Linq.Expressions.Expression.Type%2A> propriedade deles `left` ou `right` representa um tipo definido pelo usuário que sobrecarrega o operador de adição, o <xref:System.Reflection.MethodInfo> que representa que o método é o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-227">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the addition operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="f7da9-228">Caso contrário, se `left`. Tipo e `right`. Tipo de tipos numéricos, o método de implementação está `null`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-228">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="f7da9-229">Tipo de nó e versão com comparação de precisão x sem comparação de precisão</span><span class="sxs-lookup"><span data-stu-id="f7da9-229">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="f7da9-230">Se o método de implementação não for `null`:</span><span class="sxs-lookup"><span data-stu-id="f7da9-230">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="f7da9-231">Se `left`. Tipo e `right`. Tipo podem ser atribuídos aos tipos de argumento correspondente do método de implementação, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-231">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="f7da9-232">O tipo do nó é o tipo de retorno do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-232">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="f7da9-233">Se as duas seguintes condições forem atendidas, o nó é levantado e o tipo de nó é o tipo que permite valor nulo que corresponde ao tipo de retorno do método de implementação:</span><span class="sxs-lookup"><span data-stu-id="f7da9-233">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="f7da9-234">`left`. Tipo e `right`. Tipo são os dois tipos de valor de que pelo menos um é anulável e os tipos não anuláveis correspondentes são iguais para os tipos de argumento correspondente do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-234">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="f7da9-235">O tipo de retorno do método de implementação é um tipo de valor não anulável.</span><span class="sxs-lookup"><span data-stu-id="f7da9-235">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="f7da9-236">Se o método de implementação é `null`:</span><span class="sxs-lookup"><span data-stu-id="f7da9-236">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="f7da9-237">Se `left`. Tipo e `right`. Tipo são não anuláveis, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-237">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="f7da9-238">O tipo do nó é o tipo de resultado do operador de adição predefinidos.</span><span class="sxs-lookup"><span data-stu-id="f7da9-238">The type of the node is the result type of the predefined addition operator.</span></span>  
  
-   <span data-ttu-id="f7da9-239">Se `left`. Tipo e `right`. Tipo são anuláveis, o nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-239">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="f7da9-240">O tipo de nó é o tipo que permite valor nulo que corresponde ao tipo de resultado do operador de adição predefinidos.</span><span class="sxs-lookup"><span data-stu-id="f7da9-240">The type of the node is the nullable type that corresponds to the result type of the predefined addition operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f7da9-241">
            <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-241">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f7da9-242">O operador de adição não foi definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-242">The addition operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="AddChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AddChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AddChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AddChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AddChecked (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AddChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member AddChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.AddChecked (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="f7da9-243">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-243">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="f7da9-244">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-244">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="f7da9-245">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-245">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-246">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação aritmética de adição que tem verificação de estouro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-246">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic addition operation that has overflow checking.</span>
          </span>
          <span data-ttu-id="f7da9-247">O método de implementação pode ser especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-247">The implementing method can be specified.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-248">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.AddChecked" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas para os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-248">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.AddChecked" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-249">Resultante <xref:System.Linq.Expressions.BinaryExpression> tem o <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriedade definida como o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-249">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="f7da9-250">O <xref:System.Linq.Expressions.Expression.Type%2A> estiver definida como o tipo de nó.</span><span class="sxs-lookup"><span data-stu-id="f7da9-250">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="f7da9-251">Se o nó é elevado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> e <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriedades estiverem `true`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-251">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="f7da9-252">Caso contrário, eles são `false`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-252">Otherwise, they are `false`.</span></span> <span data-ttu-id="f7da9-253">A propriedade <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> é `null`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-253">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="f7da9-254">As informações a seguir descrevem o método de implementação, o tipo de nó, e se um nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-254">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="f7da9-255">Implementando método</span><span class="sxs-lookup"><span data-stu-id="f7da9-255">Implementing Method</span></span>  
 <span data-ttu-id="f7da9-256">O método de implementação para a operação é escolhido com base nas seguintes regras:</span><span class="sxs-lookup"><span data-stu-id="f7da9-256">The implementing method for the operation is chosen based on the following rules:</span></span>  
  
-   <span data-ttu-id="f7da9-257">Se `method` não é `null` e representa um não-nulo, `static` (`Shared` no Visual Basic) método que usa dois argumentos, é o método de implementação para o nó.</span><span class="sxs-lookup"><span data-stu-id="f7da9-257">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method for the node.</span></span>  
  
-   <span data-ttu-id="f7da9-258">Caso contrário, se o <xref:System.Linq.Expressions.Expression.Type%2A> propriedade deles `left` ou `right` representa um tipo definido pelo usuário que sobrecarrega o operador de adição, o <xref:System.Reflection.MethodInfo> que representa que o método é o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-258">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the addition operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="f7da9-259">Caso contrário, se `left`. Tipo e `right`. Tipo de tipos numéricos, o método de implementação está `null`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-259">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="f7da9-260">Tipo de nó e versão com comparação de precisão x sem comparação de precisão</span><span class="sxs-lookup"><span data-stu-id="f7da9-260">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="f7da9-261">Se o método de implementação não for `null`:</span><span class="sxs-lookup"><span data-stu-id="f7da9-261">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="f7da9-262">Se `left`. Tipo e `right`. Tipo podem ser atribuídos aos tipos de argumento correspondente do método de implementação, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-262">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="f7da9-263">O tipo do nó é o tipo de retorno do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-263">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="f7da9-264">Se as duas seguintes condições forem atendidas, o nó é levantado e o tipo de nó é o tipo que permite valor nulo que corresponde ao tipo de retorno do método de implementação:</span><span class="sxs-lookup"><span data-stu-id="f7da9-264">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="f7da9-265">`left`. Tipo e `right`. Tipo são os dois tipos de valor de que pelo menos um é anulável e os tipos não anuláveis correspondentes são iguais para os tipos de argumento correspondente do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-265">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="f7da9-266">O tipo de retorno do método de implementação é um tipo de valor não anulável.</span><span class="sxs-lookup"><span data-stu-id="f7da9-266">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="f7da9-267">Se o método de implementação é `null`:</span><span class="sxs-lookup"><span data-stu-id="f7da9-267">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="f7da9-268">Se `left`. Tipo e `right`. Tipo são não anuláveis, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-268">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="f7da9-269">O tipo do nó é o tipo de resultado do operador de adição predefinidos.</span><span class="sxs-lookup"><span data-stu-id="f7da9-269">The type of the node is the result type of the predefined addition operator.</span></span>  
  
-   <span data-ttu-id="f7da9-270">Se `left`. Tipo e `right`. Tipo são anuláveis, o nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-270">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="f7da9-271">O tipo de nó é o tipo que permite valor nulo que corresponde ao tipo de resultado do operador de adição predefinidos.</span><span class="sxs-lookup"><span data-stu-id="f7da9-271">The type of the node is the nullable type that corresponds to the result type of the predefined addition operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f7da9-272">
            <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-272">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f7da9-273">
            <paramref name="method" /> não é <see langword="null" /> e o método que ele representa retorna <see langword="void" />, não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) ou não tem exatamente dois argumentos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-273">
              <paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f7da9-274">
            <paramref name="method" /> é <see langword="null" /> e o operador de adição não foi definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-274">
              <paramref name="method" /> is <see langword="null" /> and the addition operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="And">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f7da9-275">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação <see langword="AND" /> bit a bit.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-275">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise <see langword="AND" /> operation.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="And">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression And (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression And(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.And(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function And (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ And(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member And : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.And (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="f7da9-276">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-276">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="f7da9-277">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-277">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-278">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação <see langword="AND" /> bit a bit.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-278">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise <see langword="AND" /> operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-279">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.And" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-279">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.And" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-280">Resultante <xref:System.Linq.Expressions.BinaryExpression> tem o <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriedade definida como o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-280">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="f7da9-281">O <xref:System.Linq.Expressions.Expression.Type%2A> estiver definida como o tipo de nó.</span><span class="sxs-lookup"><span data-stu-id="f7da9-281">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="f7da9-282">Se o nó é elevado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> e <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriedades estiverem `true`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-282">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="f7da9-283">Caso contrário, eles são `false`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-283">Otherwise, they are `false`.</span></span> <span data-ttu-id="f7da9-284">A propriedade <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> é `null`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-284">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="f7da9-285">As informações a seguir descrevem o método de implementação, o tipo de nó, e se um nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-285">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="f7da9-286">Implementando método</span><span class="sxs-lookup"><span data-stu-id="f7da9-286">Implementing Method</span></span>  
 <span data-ttu-id="f7da9-287">As regras a seguir determinam o método de implementação para a operação:</span><span class="sxs-lookup"><span data-stu-id="f7da9-287">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="f7da9-288">Se o <xref:System.Linq.Expressions.Expression.Type%2A> propriedade deles `left` ou `right` representa um tipo definido pelo usuário que sobrecarrega o bit a bit `AND` operador, o <xref:System.Reflection.MethodInfo> que representa que o método é o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-288">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the bitwise `AND` operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="f7da9-289">Caso contrário, se `left`. Tipo e `right`. Tipo são tipos de inteiros ou boolianos, o método de implementação é `null`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-289">Otherwise, if `left`.Type and `right`.Type are integral or Boolean types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="f7da9-290">Tipo de nó e versão com comparação de precisão x sem comparação de precisão</span><span class="sxs-lookup"><span data-stu-id="f7da9-290">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="f7da9-291">Se o método de implementação não for `null`:</span><span class="sxs-lookup"><span data-stu-id="f7da9-291">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="f7da9-292">Se `left`. Tipo e `right`. Tipo podem ser atribuídos aos tipos de argumento correspondente do método de implementação, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-292">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="f7da9-293">O tipo do nó é o tipo de retorno do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-293">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="f7da9-294">Se as duas seguintes condições forem atendidas, o nó é levantado e o tipo de nó é o tipo que permite valor nulo que corresponde ao tipo de retorno do método de implementação:</span><span class="sxs-lookup"><span data-stu-id="f7da9-294">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="f7da9-295">`left`. Tipo e `right`. Tipo são os dois tipos de valor de que pelo menos um é anulável e os tipos não anuláveis correspondentes são iguais para os tipos de argumento correspondente do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-295">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="f7da9-296">O tipo de retorno do método de implementação é um tipo de valor não anulável.</span><span class="sxs-lookup"><span data-stu-id="f7da9-296">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="f7da9-297">Se o método de implementação é `null`:</span><span class="sxs-lookup"><span data-stu-id="f7da9-297">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="f7da9-298">Se `left`. Tipo e `right`. Tipo são não anuláveis, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-298">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="f7da9-299">O tipo do nó é o tipo de resultado de predefinida bit a bit `AND` operador.</span><span class="sxs-lookup"><span data-stu-id="f7da9-299">The type of the node is the result type of the predefined bitwise `AND` operator.</span></span>  
  
-   <span data-ttu-id="f7da9-300">Se `left`. Tipo e `right`. Tipo são anuláveis, o nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-300">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="f7da9-301">O tipo do nó é o tipo que permite valor nulo que corresponde ao tipo de resultado de predefinida bit a bit `AND` operador.</span><span class="sxs-lookup"><span data-stu-id="f7da9-301">The type of the node is the nullable type that corresponds to the result type of the predefined bitwise `AND` operator.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f7da9-302">O exemplo de código a seguir mostra como criar uma expressão que representa uma operação AND lógica em dois valores Boolean.</span><span class="sxs-lookup"><span data-stu-id="f7da9-302">The following code example shows how to create an expression that represents a logical AND operation on two Boolean values.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#2)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f7da9-303">
            <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-303">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f7da9-304">O operador <see langword="AND" /> bit a bit não está definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-304">The bitwise <see langword="AND" /> operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="And">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression And (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression And(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.And(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function And (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ And(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member And : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.And (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="f7da9-305">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-305">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="f7da9-306">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-306">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="f7da9-307">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-307">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-308">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação <see langword="AND" /> bit a bit.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-308">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise <see langword="AND" /> operation.</span>
          </span>
          <span data-ttu-id="f7da9-309">O método de implementação pode ser especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-309">The implementing method can be specified.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-310">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.And" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-310">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.And" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-311">Resultante <xref:System.Linq.Expressions.BinaryExpression> tem o <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriedade definida como o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-311">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="f7da9-312">O <xref:System.Linq.Expressions.Expression.Type%2A> estiver definida como o tipo de nó.</span><span class="sxs-lookup"><span data-stu-id="f7da9-312">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="f7da9-313">Se o nó é elevado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> e <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriedades estiverem `true`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-313">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="f7da9-314">Caso contrário, eles são `false`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-314">Otherwise, they are `false`.</span></span> <span data-ttu-id="f7da9-315">A propriedade <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> é `null`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-315">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="f7da9-316">As informações a seguir descrevem o método de implementação, o tipo de nó, e se um nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-316">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="f7da9-317">Implementando método</span><span class="sxs-lookup"><span data-stu-id="f7da9-317">Implementing Method</span></span>  
 <span data-ttu-id="f7da9-318">O método de implementação para a operação é escolhido com base nas seguintes regras:</span><span class="sxs-lookup"><span data-stu-id="f7da9-318">The implementing method for the operation is chosen based on the following rules:</span></span>  
  
-   <span data-ttu-id="f7da9-319">Se `method` não é `null` e representa um não-nulo, `static` (`Shared` no Visual Basic) método que usa dois argumentos, é o método de implementação para o nó.</span><span class="sxs-lookup"><span data-stu-id="f7da9-319">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method for the node.</span></span>  
  
-   <span data-ttu-id="f7da9-320">Caso contrário, se o <xref:System.Linq.Expressions.Expression.Type%2A> propriedade deles `left` ou `right` representa um tipo definido pelo usuário que sobrecarrega o bit a bit `AND` operador, o <xref:System.Reflection.MethodInfo> que representa que o método é o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-320">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the bitwise `AND` operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="f7da9-321">Caso contrário, se `left`. Tipo e `right`. Tipo são tipos de inteiros ou boolianos, o método de implementação é `null`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-321">Otherwise, if `left`.Type and `right`.Type are integral or Boolean types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="f7da9-322">Tipo de nó e versão com comparação de precisão x sem comparação de precisão</span><span class="sxs-lookup"><span data-stu-id="f7da9-322">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="f7da9-323">Se o método de implementação não for `null`:</span><span class="sxs-lookup"><span data-stu-id="f7da9-323">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="f7da9-324">Se `left`. Tipo e `right`. Tipo podem ser atribuídos aos tipos de argumento correspondente do método de implementação, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-324">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="f7da9-325">O tipo do nó é o tipo de retorno do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-325">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="f7da9-326">Se as duas seguintes condições forem atendidas, o nó é levantado e o tipo de nó é o tipo que permite valor nulo que corresponde ao tipo de retorno do método de implementação:</span><span class="sxs-lookup"><span data-stu-id="f7da9-326">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="f7da9-327">`left`. Tipo e `right`. Tipo são os dois tipos de valor de que pelo menos um é anulável e os tipos não anuláveis correspondentes são iguais para os tipos de argumento correspondente do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-327">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="f7da9-328">O tipo de retorno do método de implementação é um tipo de valor não anulável.</span><span class="sxs-lookup"><span data-stu-id="f7da9-328">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="f7da9-329">Se o método de implementação é `null`:</span><span class="sxs-lookup"><span data-stu-id="f7da9-329">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="f7da9-330">Se `left`. Tipo e `right`. Tipo são não anuláveis, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-330">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="f7da9-331">O tipo do nó é o tipo de resultado de predefinida bit a bit `AND` operador.</span><span class="sxs-lookup"><span data-stu-id="f7da9-331">The type of the node is the result type of the predefined bitwise `AND` operator.</span></span>  
  
-   <span data-ttu-id="f7da9-332">Se `left`. Tipo e `right`. Tipo são anuláveis, o nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-332">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="f7da9-333">O tipo do nó é o tipo que permite valor nulo que corresponde ao tipo de resultado de predefinida bit a bit `AND` operador.</span><span class="sxs-lookup"><span data-stu-id="f7da9-333">The type of the node is the nullable type that corresponds to the result type of the predefined bitwise `AND` operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f7da9-334">
            <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-334">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f7da9-335">
            <paramref name="method" /> não é <see langword="null" /> e o método que ele representa retorna <see langword="void" />, não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) ou não tem exatamente dois argumentos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-335">
              <paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f7da9-336">
            <paramref name="method" /> é <see langword="null" /> e o operador <see langword="AND" /> bit a bit não é definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-336">
              <paramref name="method" /> is <see langword="null" /> and the bitwise <see langword="AND" /> operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="AndAlso">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f7da9-337">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação <see langword="AND" /> condicional que avalia o segundo operando somente se o primeiro operando é avaliado como <see langword="true" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-337">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a conditional <see langword="AND" /> operation that evaluates the second operand only if the first operand evaluates to <see langword="true" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AndAlso">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AndAlso (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AndAlso(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AndAlso(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AndAlso (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AndAlso(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member AndAlso : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.AndAlso (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="f7da9-338">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-338">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="f7da9-339">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-339">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-340">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação <see langword="AND" /> condicional que avalia o segundo operando somente se o primeiro operando é avaliado como <see langword="true" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-340">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a conditional <see langword="AND" /> operation that evaluates the second operand only if the first operand evaluates to <see langword="true" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-341">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.AndAlso" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-341">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.AndAlso" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-342">Resultante <xref:System.Linq.Expressions.BinaryExpression> tem o <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriedade definida como o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-342">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="f7da9-343">O <xref:System.Linq.Expressions.Expression.Type%2A> estiver definida como o tipo de nó.</span><span class="sxs-lookup"><span data-stu-id="f7da9-343">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="f7da9-344">Se o nó é elevado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> e <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriedades estiverem `true`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-344">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="f7da9-345">Caso contrário, eles são `false`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-345">Otherwise, they are `false`.</span></span> <span data-ttu-id="f7da9-346">A propriedade <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> é `null`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-346">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="f7da9-347">As informações a seguir descrevem o método de implementação, o tipo de nó, e se um nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-347">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="f7da9-348">Implementando método</span><span class="sxs-lookup"><span data-stu-id="f7da9-348">Implementing Method</span></span>  
 <span data-ttu-id="f7da9-349">As regras a seguir determinam o método de implementação para a operação:</span><span class="sxs-lookup"><span data-stu-id="f7da9-349">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="f7da9-350">Se o <xref:System.Linq.Expressions.Expression.Type%2A> propriedade deles `left` ou `right` representa um tipo definido pelo usuário que sobrecarrega o bit a bit `AND` operador, o <xref:System.Reflection.MethodInfo> que representa que o método é o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-350">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the bitwise `AND` operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="f7da9-351">A condicional `AND` operador não pode ser sobrecarregado em c# ou Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="f7da9-351">The conditional `AND` operator cannot be overloaded in C# or Visual Basic.</span></span> <span data-ttu-id="f7da9-352">No entanto, a condicional `AND` operador é avaliado usando o bit a bit `AND` operador.</span><span class="sxs-lookup"><span data-stu-id="f7da9-352">However, the conditional `AND` operator is evaluated by using the bitwise `AND` operator.</span></span> <span data-ttu-id="f7da9-353">Portanto, uma sobrecarga definido pelo usuário de bit a bit `AND` operador pode ser o método de implementação para esse tipo de nó.</span><span class="sxs-lookup"><span data-stu-id="f7da9-353">Thus, a user-defined overload of the bitwise `AND` operator can be the implementing method for this node type.</span></span>  
  
-   <span data-ttu-id="f7da9-354">Caso contrário, se `left`. Tipo e `right`. Tipo são tipos boolianos, o método de implementação é `null`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-354">Otherwise, if `left`.Type and `right`.Type are Boolean types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="f7da9-355">Tipo de nó e versão com comparação de precisão x sem comparação de precisão</span><span class="sxs-lookup"><span data-stu-id="f7da9-355">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="f7da9-356">Se o método de implementação não for `null`:</span><span class="sxs-lookup"><span data-stu-id="f7da9-356">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="f7da9-357">Se `left`. Tipo e `right`. Tipo podem ser atribuídos aos tipos de argumento correspondente do método de implementação, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-357">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="f7da9-358">O tipo do nó é o tipo de retorno do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-358">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="f7da9-359">Se as duas seguintes condições forem atendidas, o nó é levantado e o tipo de nó é o tipo que permite valor nulo que corresponde ao tipo de retorno do método de implementação:</span><span class="sxs-lookup"><span data-stu-id="f7da9-359">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="f7da9-360">`left`. Tipo e `right`. Tipo são os dois tipos de valor de que pelo menos um é anulável, e os tipos não anuláveis correspondentes são iguais para os tipos de argumento correspondente do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-360">`left`.Type and `right`.Type are both value types of which at least one is nullable, and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="f7da9-361">O tipo de retorno do método de implementação é um tipo de valor não anulável.</span><span class="sxs-lookup"><span data-stu-id="f7da9-361">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="f7da9-362">Se o método de implementação é `null`:</span><span class="sxs-lookup"><span data-stu-id="f7da9-362">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="f7da9-363">`left`. Tipo e `right`. Tipo são do mesmo tipo booliano.</span><span class="sxs-lookup"><span data-stu-id="f7da9-363">`left`.Type and `right`.Type are the same Boolean type.</span></span>  
  
-   <span data-ttu-id="f7da9-364">Se `left`. Tipo e `right`. Tipo não anulável, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-364">If `left`.Type and `right`.Type are non-nullable, the node is not lifted.</span></span> <span data-ttu-id="f7da9-365">O tipo do nó é o tipo de resultado da condicional predefinido `AND` operador.</span><span class="sxs-lookup"><span data-stu-id="f7da9-365">The type of the node is the result type of the predefined conditional `AND` operator.</span></span>  
  
-   <span data-ttu-id="f7da9-366">Se `left`. Tipo e `right`. Tipo que permite valor nulo, o nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-366">If `left`.Type and `right`.Type are nullable, the node is lifted.</span></span> <span data-ttu-id="f7da9-367">O tipo de nó é o tipo que permite valor nulo que corresponde ao tipo de resultado da condicional predefinido `AND` operador.</span><span class="sxs-lookup"><span data-stu-id="f7da9-367">The type of the node is the nullable type that corresponds to the result type of the predefined conditional `AND` operator.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f7da9-368">O exemplo de código a seguir mostra como para criar uma expressão que executa uma operação lógica e operação em apenas-se seus dois operandos o primeiro operando é avaliado para `true`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-368">The following code example shows how to create an expression that performs a logical AND operation on its two operands only if the first operand evaluates to `true`.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#19)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f7da9-369">
            <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-369">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f7da9-370">O operador <see langword="AND" /> bit a bit não está definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-370">The bitwise <see langword="AND" /> operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span>
          </span>
          <span data-ttu-id="f7da9-371">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-371">-or-</span>
          </span>
          <span data-ttu-id="f7da9-372">
            <paramref name="left" />.Type e <paramref name="right" />.Type não são do mesmo tipo booliano.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-372">
              <paramref name="left" />.Type and <paramref name="right" />.Type are not the same Boolean type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="AndAlso">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AndAlso (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AndAlso(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AndAlso(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AndAlso (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AndAlso(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member AndAlso : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.AndAlso (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="f7da9-373">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-373">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="f7da9-374">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-374">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="f7da9-375">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-375">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-376">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação <see langword="AND" /> condicional que avalia o segundo operando somente se o primeiro operando é resolvido para verdadeiro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-376">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a conditional <see langword="AND" /> operation that evaluates the second operand only if the first operand is resolved to true.</span>
          </span>
          <span data-ttu-id="f7da9-377">O método de implementação pode ser especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-377">The implementing method can be specified.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-378">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.AndAlso" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-378">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.AndAlso" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-379">Resultante <xref:System.Linq.Expressions.BinaryExpression> tem o <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriedade definida como o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-379">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="f7da9-380">O <xref:System.Linq.Expressions.Expression.Type%2A> estiver definida como o tipo de nó.</span><span class="sxs-lookup"><span data-stu-id="f7da9-380">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="f7da9-381">Se o nó é elevado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> e <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriedades estiverem `true`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-381">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="f7da9-382">Caso contrário, eles são `false`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-382">Otherwise, they are `false`.</span></span> <span data-ttu-id="f7da9-383">A propriedade <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> é `null`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-383">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="f7da9-384">As informações a seguir descrevem o método de implementação, o tipo de nó, e se um nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-384">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="f7da9-385">Implementando método</span><span class="sxs-lookup"><span data-stu-id="f7da9-385">Implementing Method</span></span>  
 <span data-ttu-id="f7da9-386">O método de implementação para a operação é escolhido com base nas seguintes regras:</span><span class="sxs-lookup"><span data-stu-id="f7da9-386">The implementing method for the operation is chosen based on the following rules:</span></span>  
  
-   <span data-ttu-id="f7da9-387">Se `method` não é `null` e representa um não-nulo, `static` (`Shared` no Visual Basic) método que usa dois argumentos, é o método de implementação para o nó.</span><span class="sxs-lookup"><span data-stu-id="f7da9-387">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method for the node.</span></span>  
  
-   <span data-ttu-id="f7da9-388">Caso contrário, se o <xref:System.Linq.Expressions.Expression.Type%2A> propriedade deles `left` ou `right` representa um tipo definido pelo usuário que sobrecarrega o bit a bit `AND` operador, o <xref:System.Reflection.MethodInfo> que representa que o método é o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-388">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the bitwise `AND` operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="f7da9-389">A condicional `AND` operador não pode ser sobrecarregado em c# ou Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="f7da9-389">The conditional `AND` operator cannot be overloaded in C# or Visual Basic.</span></span> <span data-ttu-id="f7da9-390">No entanto, a condicional `AND` operador é avaliado usando o bit a bit `AND` operador.</span><span class="sxs-lookup"><span data-stu-id="f7da9-390">However, the conditional `AND` operator is evaluated by using the bitwise `AND` operator.</span></span> <span data-ttu-id="f7da9-391">Portanto, uma sobrecarga definido pelo usuário de bit a bit `AND` operador pode ser o método de implementação para esse tipo de nó.</span><span class="sxs-lookup"><span data-stu-id="f7da9-391">Thus, a user-defined overload of the bitwise `AND` operator can be the implementing method for this node type.</span></span>  
  
-   <span data-ttu-id="f7da9-392">Caso contrário, se `left`. Tipo e `right`. Tipo são tipos boolianos, o método de implementação é `null`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-392">Otherwise, if `left`.Type and `right`.Type are Boolean types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="f7da9-393">Tipo de nó e versão com comparação de precisão x sem comparação de precisão</span><span class="sxs-lookup"><span data-stu-id="f7da9-393">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="f7da9-394">Se o método de implementação não for `null`:</span><span class="sxs-lookup"><span data-stu-id="f7da9-394">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="f7da9-395">Se `left`. Tipo e `right`. Tipo podem ser atribuídos aos tipos de argumento correspondente do método de implementação, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-395">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="f7da9-396">O tipo do nó é o tipo de retorno do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-396">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="f7da9-397">Se as duas seguintes condições forem atendidas, o nó é levantado e o tipo de nó é o tipo que permite valor nulo que corresponde ao tipo de retorno do método de implementação:</span><span class="sxs-lookup"><span data-stu-id="f7da9-397">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="f7da9-398">`left`. Tipo e `right`. Tipo são os dois tipos de valor de que pelo menos um é anulável, e os tipos não anuláveis correspondentes são iguais para os tipos de argumento correspondente do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-398">`left`.Type and `right`.Type are both value types of which at least one is nullable, and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="f7da9-399">O tipo de retorno do método de implementação é um tipo de valor não anulável.</span><span class="sxs-lookup"><span data-stu-id="f7da9-399">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="f7da9-400">Se o método de implementação é `null`:</span><span class="sxs-lookup"><span data-stu-id="f7da9-400">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="f7da9-401">`left`. Tipo e `right`. Tipo são do mesmo tipo booliano.</span><span class="sxs-lookup"><span data-stu-id="f7da9-401">`left`.Type and `right`.Type are the same Boolean type.</span></span>  
  
-   <span data-ttu-id="f7da9-402">Se `left`. Tipo e `right`. Tipo não anulável, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-402">If `left`.Type and `right`.Type are non-nullable, the node is not lifted.</span></span> <span data-ttu-id="f7da9-403">O tipo do nó é o tipo de resultado da condicional predefinido `AND` operador.</span><span class="sxs-lookup"><span data-stu-id="f7da9-403">The type of the node is the result type of the predefined conditional `AND` operator.</span></span>  
  
-   <span data-ttu-id="f7da9-404">Se `left`. Tipo e `right`. Tipo que permite valor nulo, o nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-404">If `left`.Type and `right`.Type are nullable, the node is lifted.</span></span> <span data-ttu-id="f7da9-405">O tipo de nó é o tipo que permite valor nulo que corresponde ao tipo de resultado da condicional predefinido `AND` operador.</span><span class="sxs-lookup"><span data-stu-id="f7da9-405">The type of the node is the nullable type that corresponds to the result type of the predefined conditional `AND` operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f7da9-406">
            <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-406">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f7da9-407">
            <paramref name="method" /> não é <see langword="null" /> e o método que ele representa retorna <see langword="void" />, não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) ou não tem exatamente dois argumentos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-407">
              <paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f7da9-408">
            <paramref name="method" /> é <see langword="null" /> e o operador <see langword="AND" /> bit a bit não é definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-408">
              <paramref name="method" /> is <see langword="null" /> and the bitwise <see langword="AND" /> operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span>
          </span>
          <span data-ttu-id="f7da9-409">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-409">-or-</span>
          </span>
          <span data-ttu-id="f7da9-410">
            <paramref name="method" /> é <see langword="null" /> e Type.<paramref name="left" /> e Type.<paramref name="right" /> não são do mesmo tipo booliano.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-410">
              <paramref name="method" /> is <see langword="null" /> and <paramref name="left" />.Type and <paramref name="right" />.Type are not the same Boolean type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="AndAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f7da9-411">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição AND bit a bit.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-411">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise AND assignment operation.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AndAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AndAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AndAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AndAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AndAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AndAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member AndAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.AndAssign (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="f7da9-412">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-412">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="f7da9-413">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-413">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-414">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição AND bit a bit.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-414">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise AND assignment operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-415">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.AndAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-415">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.AndAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AndAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AndAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AndAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AndAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AndAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AndAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member AndAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.AndAssign (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="f7da9-416">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-416">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="f7da9-417">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-417">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="f7da9-418">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-418">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-419">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição AND bit a bit.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-419">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise AND assignment operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-420">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.AndAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-420">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.AndAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AndAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AndAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AndAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AndAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AndAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AndAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member AndAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.AndAssign (left, right, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="f7da9-421">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-421">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="f7da9-422">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-422">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="f7da9-423">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-423">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <param name="conversion">
          <span data-ttu-id="f7da9-424">Um <see cref="T:System.Linq.Expressions.LambdaExpression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-424">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-425">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição AND bit a bit.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-425">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise AND assignment operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-426">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.AndAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-426">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.AndAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ArrayAccess">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f7da9-427">Cria uma <see cref="T:System.Linq.Expressions.IndexExpression" /> para acessar uma matriz.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-427">Creates an <see cref="T:System.Linq.Expressions.IndexExpression" /> to access an array.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ArrayAccess">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.IndexExpression ArrayAccess (System.Linq.Expressions.Expression array, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; indexes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.IndexExpression ArrayAccess(class System.Linq.Expressions.Expression array, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; indexes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ArrayAccess(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ArrayAccess (array As Expression, indexes As IEnumerable(Of Expression)) As IndexExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::IndexExpression ^ ArrayAccess(System::Linq::Expressions::Expression ^ array, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ indexes);" />
      <MemberSignature Language="F#" Value="static member ArrayAccess : System.Linq.Expressions.Expression * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.IndexExpression" Usage="System.Linq.Expressions.Expression.ArrayAccess (array, indexes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.IndexExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="indexes" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="array">
          <span data-ttu-id="f7da9-428">Uma expressão que representa a matriz multidimensional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-428">An expression that represents the multidimensional array.</span>
          </span>
        </param>
        <param name="indexes">
          <span data-ttu-id="f7da9-429">Uma <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém as expressões usadas para indexar a matriz.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-429">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> containing expressions used to index the array.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-430">Cria uma <see cref="T:System.Linq.Expressions.IndexExpression" /> para acessar uma matriz multidimensional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-430">Creates an <see cref="T:System.Linq.Expressions.IndexExpression" /> to access a multidimensional array.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-431">O <see cref="T:System.Linq.Expressions.IndexExpression" /> criado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-431">The created <see cref="T:System.Linq.Expressions.IndexExpression" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-432">A expressão que representa a matriz pode ser obtida usando o <xref:System.Linq.Expressions.Expression.MakeMemberAccess%2A> método, ou através dos <xref:System.Linq.Expressions.Expression.NewArrayBounds%2A> ou <xref:System.Linq.Expressions.Expression.NewArrayInit%2A>.</span><span class="sxs-lookup"><span data-stu-id="f7da9-432">The expression that represents the array can be obtained by using the <xref:System.Linq.Expressions.Expression.MakeMemberAccess%2A> method, or through <xref:System.Linq.Expressions.Expression.NewArrayBounds%2A> or <xref:System.Linq.Expressions.Expression.NewArrayInit%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f7da9-433">O exemplo de código a seguir mostra como alterar o valor de um elemento em uma matriz multidimensional usando o `ArrayAccess` método.</span><span class="sxs-lookup"><span data-stu-id="f7da9-433">The following code example shows how to change the value of an element in a multidimensional array by using the `ArrayAccess` method.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#21)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#21)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ArrayAccess">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.IndexExpression ArrayAccess (System.Linq.Expressions.Expression array, params System.Linq.Expressions.Expression[] indexes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.IndexExpression ArrayAccess(class System.Linq.Expressions.Expression array, class System.Linq.Expressions.Expression[] indexes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ArrayAccess(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ArrayAccess (array As Expression, ParamArray indexes As Expression()) As IndexExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::IndexExpression ^ ArrayAccess(System::Linq::Expressions::Expression ^ array, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ indexes);" />
      <MemberSignature Language="F#" Value="static member ArrayAccess : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.IndexExpression" Usage="System.Linq.Expressions.Expression.ArrayAccess (array, indexes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.IndexExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="indexes" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="array">
          <span data-ttu-id="f7da9-434">Uma expressão que representa a matriz a ser indexada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-434">An expression representing the array to index.</span>
          </span>
        </param>
        <param name="indexes">
          <span data-ttu-id="f7da9-435">Uma matriz que contém as expressões usadas para indexar a matriz.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-435">An array that contains expressions used to index the array.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-436">Cria uma <see cref="T:System.Linq.Expressions.IndexExpression" /> para acessar uma matriz.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-436">Creates an <see cref="T:System.Linq.Expressions.IndexExpression" /> to access an array.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-437">O <see cref="T:System.Linq.Expressions.IndexExpression" /> criado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-437">The created <see cref="T:System.Linq.Expressions.IndexExpression" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-438">A expressão que representa a matriz pode ser obtida usando o <xref:System.Linq.Expressions.Expression.MakeMemberAccess%2A> método, ou através dos <xref:System.Linq.Expressions.Expression.NewArrayBounds%2A> ou <xref:System.Linq.Expressions.Expression.NewArrayInit%2A>.</span><span class="sxs-lookup"><span data-stu-id="f7da9-438">The expression that represents the array can be obtained by using the <xref:System.Linq.Expressions.Expression.MakeMemberAccess%2A> method, or through <xref:System.Linq.Expressions.Expression.NewArrayBounds%2A> or <xref:System.Linq.Expressions.Expression.NewArrayInit%2A>.</span></span>  
  
 <span data-ttu-id="f7da9-439">Para matrizes multidimensionais, use o <xref:System.Linq.Expressions.Expression.ArrayAccess%2A> método.</span><span class="sxs-lookup"><span data-stu-id="f7da9-439">For multidimensional arrays, use the <xref:System.Linq.Expressions.Expression.ArrayAccess%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f7da9-440">O exemplo de código a seguir mostra como alterar um valor de um elemento de matriz usando o `ArrayAccess` método.</span><span class="sxs-lookup"><span data-stu-id="f7da9-440">The following code example shows how to change a value of an array element by using the `ArrayAccess` method.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#20)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#20)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ArrayIndex">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f7da9-441">Cria uma <see cref="T:System.Linq.Expressions.Expression" /> que representa a aplicação de um operador de índice.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-441">Creates an <see cref="T:System.Linq.Expressions.Expression" /> that represents applying an array index operator.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ArrayIndex">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression ArrayIndex (System.Linq.Expressions.Expression array, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; indexes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression ArrayIndex(class System.Linq.Expressions.Expression array, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; indexes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ArrayIndex(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ArrayIndex (array As Expression, indexes As IEnumerable(Of Expression)) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ ArrayIndex(System::Linq::Expressions::Expression ^ array, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ indexes);" />
      <MemberSignature Language="F#" Value="static member ArrayIndex : System.Linq.Expressions.Expression * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.ArrayIndex (array, indexes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="indexes" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="array">
          <span data-ttu-id="f7da9-442">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-442">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> property equal to.</span>
          </span>
        </param>
        <param name="indexes">
          <span data-ttu-id="f7da9-443">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.Expression" /> a serem usados para preencher a coleção de <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-443">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-444">Cria uma <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa a aplicação de um operador de índice de matriz a uma matriz de classificação superior a um.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-444">Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents applying an array index operator to an array of rank more than one.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-445">Um <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> e as propriedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> e <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-445">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> and <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-446">Cada elemento da `indexes` deve ter <xref:System.Linq.Expressions.Expression.Type%2A> igual a <xref:System.Int32>.</span><span class="sxs-lookup"><span data-stu-id="f7da9-446">Each element of `indexes` must have <xref:System.Linq.Expressions.Expression.Type%2A> equal to <xref:System.Int32>.</span></span> <span data-ttu-id="f7da9-447">O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade de `array` deve representar um tipo de matriz cuja posição corresponde ao número de elementos em `indexes`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-447">The <xref:System.Linq.Expressions.Expression.Type%2A> property of `array` must represent an array type whose rank matches the number of elements in `indexes`.</span></span>  
  
 <span data-ttu-id="f7da9-448">Se a classificação de `array`. Tipo é 1, esse método retorna um <xref:System.Linq.Expressions.BinaryExpression>.</span><span class="sxs-lookup"><span data-stu-id="f7da9-448">If the rank of `array`.Type is 1, this method returns a <xref:System.Linq.Expressions.BinaryExpression>.</span></span> <span data-ttu-id="f7da9-449">O <xref:System.Linq.Expressions.BinaryExpression.Left%2A> estiver definida como `array` e o <xref:System.Linq.Expressions.BinaryExpression.Right%2A> estiver definida como o único elemento de `indexes`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-449">The <xref:System.Linq.Expressions.BinaryExpression.Left%2A> property is set to `array` and the <xref:System.Linq.Expressions.BinaryExpression.Right%2A> property is set to the single element of `indexes`.</span></span> <span data-ttu-id="f7da9-450">O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade do <xref:System.Linq.Expressions.BinaryExpression> representa o tipo de elemento de `array`. Tipo.</span><span class="sxs-lookup"><span data-stu-id="f7da9-450">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the <xref:System.Linq.Expressions.BinaryExpression> represents the element type of `array`.Type.</span></span>  
  
 <span data-ttu-id="f7da9-451">Se a classificação de `array`. Tipo é a mais de um, esse método retorna um <xref:System.Linq.Expressions.MethodCallExpression>.</span><span class="sxs-lookup"><span data-stu-id="f7da9-451">If the rank of `array`.Type is more than one, this method returns a <xref:System.Linq.Expressions.MethodCallExpression>.</span></span> <span data-ttu-id="f7da9-452">O <xref:System.Linq.Expressions.MethodCallExpression.Method%2A> estiver definida como o <xref:System.Reflection.MethodInfo> que descreve o método de instância pública `Get` no tipo representado pela <xref:System.Linq.Expressions.Expression.Type%2A> propriedade do `array`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-452">The <xref:System.Linq.Expressions.MethodCallExpression.Method%2A> property is set to the <xref:System.Reflection.MethodInfo> that describes the public instance method `Get` on the type represented by the <xref:System.Linq.Expressions.Expression.Type%2A> property of `array`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f7da9-453">O exemplo a seguir demonstra como usar o <xref:System.Linq.Expressions.Expression.ArrayIndex%28System.Linq.Expressions.Expression%2CSystem.Linq.Expressions.Expression%5B%5D%29> método para criar um <xref:System.Linq.Expressions.MethodCallExpression> que representa a indexação em uma matriz bidimensional.</span><span class="sxs-lookup"><span data-stu-id="f7da9-453">The following example demonstrates how to use the <xref:System.Linq.Expressions.Expression.ArrayIndex%28System.Linq.Expressions.Expression%2CSystem.Linq.Expressions.Expression%5B%5D%29> method to create a <xref:System.Linq.Expressions.MethodCallExpression> that represents indexing into a two-dimensional array.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.Expression#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#3)]
 [!code-vb[System.Linq.Expressions.Expression#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f7da9-454">
            <paramref name="array" /> ou <paramref name="indexes" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-454">
              <paramref name="array" /> or <paramref name="indexes" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f7da9-455">
            <paramref name="array" />.Type não representa um tipo de matriz.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-455">
              <paramref name="array" />.Type does not represent an array type.</span>
          </span>
          <span data-ttu-id="f7da9-456">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-456">-or-</span>
          </span>
          <span data-ttu-id="f7da9-457">A classificação de <paramref name="array" />.Type não corresponde ao número de elementos em <paramref name="indexes" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-457">The rank of <paramref name="array" />.Type does not match the number of elements in <paramref name="indexes" />.</span>
          </span>
          <span data-ttu-id="f7da9-458">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-458">-or-</span>
          </span>
          <span data-ttu-id="f7da9-459">A propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> de um ou mais elementos de <paramref name="indexes" /> não representa o tipo <see cref="T:System.Int32" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-459">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of one or more elements of <paramref name="indexes" /> does not represent the <see cref="T:System.Int32" /> type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ArrayIndex">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ArrayIndex (System.Linq.Expressions.Expression array, System.Linq.Expressions.Expression index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ArrayIndex(class System.Linq.Expressions.Expression array, class System.Linq.Expressions.Expression index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ArrayIndex(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ArrayIndex (array As Expression, index As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ArrayIndex(System::Linq::Expressions::Expression ^ array, System::Linq::Expressions::Expression ^ index);" />
      <MemberSignature Language="F#" Value="static member ArrayIndex : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.ArrayIndex (array, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="index" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="array">
          <span data-ttu-id="f7da9-460">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-460">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="index">
          <span data-ttu-id="f7da9-461">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-461">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-462">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa a aplicação de um operador de índice de matriz a uma matriz de classificação um.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-462">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents applying an array index operator to an array of rank one.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-463">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.ArrayIndex" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-463">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ArrayIndex" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-464">`index` deve representar um índice do tipo <xref:System.Int32>.</span><span class="sxs-lookup"><span data-stu-id="f7da9-464">`index` must represent an index of type <xref:System.Int32>.</span></span>  
  
 <span data-ttu-id="f7da9-465">O <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriedade resultantes <xref:System.Linq.Expressions.BinaryExpression> é `null`e ambos <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> e <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> são definidos como `false`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-465">The <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property of the resulting <xref:System.Linq.Expressions.BinaryExpression> is `null`, and both <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> are set to `false`.</span></span> <span data-ttu-id="f7da9-466">O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade é igual ao tipo de elemento de `array`. Tipo.</span><span class="sxs-lookup"><span data-stu-id="f7da9-466">The <xref:System.Linq.Expressions.Expression.Type%2A> property is equal to the element type of `array`.Type.</span></span> <span data-ttu-id="f7da9-467">A propriedade <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> é `null`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-467">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f7da9-468">
            <paramref name="array" /> ou <paramref name="index" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-468">
              <paramref name="array" /> or <paramref name="index" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f7da9-469">
            <paramref name="array" />.Type não representa um tipo de matriz.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-469">
              <paramref name="array" />.Type does not represent an array type.</span>
          </span>
          <span data-ttu-id="f7da9-470">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-470">-or-</span>
          </span>
          <span data-ttu-id="f7da9-471">
            <paramref name="array" />.Type representa um tipo de matriz cuja classificação não é 1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-471">
              <paramref name="array" />.Type represents an array type whose rank is not 1.</span>
          </span>
          <span data-ttu-id="f7da9-472">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-472">-or-</span>
          </span>
          <span data-ttu-id="f7da9-473">
            <paramref name="index" />.Type não representa o tipo <see cref="T:System.Int32" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-473">
              <paramref name="index" />.Type does not represent the <see cref="T:System.Int32" /> type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ArrayIndex">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression ArrayIndex (System.Linq.Expressions.Expression array, params System.Linq.Expressions.Expression[] indexes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression ArrayIndex(class System.Linq.Expressions.Expression array, class System.Linq.Expressions.Expression[] indexes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ArrayIndex(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ArrayIndex (array As Expression, ParamArray indexes As Expression()) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ ArrayIndex(System::Linq::Expressions::Expression ^ array, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ indexes);" />
      <MemberSignature Language="F#" Value="static member ArrayIndex : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.ArrayIndex (array, indexes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="indexes" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="array">
          <span data-ttu-id="f7da9-474">Uma matriz de instâncias <see cref="T:System.Linq.Expressions.Expression" />/índices para a operação de índice da matriz.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-474">An array of <see cref="T:System.Linq.Expressions.Expression" /> instances - indexes for the array index operation.</span>
          </span>
        </param>
        <param name="indexes">
          <span data-ttu-id="f7da9-475">Uma matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> a serem usados para popular a coleção de <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-475">An array of <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-476">Cria um <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa a aplicação de um operador de índice de matriz a uma matriz multidimensional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-476">Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents applying an array index operator to a multidimensional array.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-477">Um <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> e as propriedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> e <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-477">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> and <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-478">Cada elemento da `indexes` deve ter <xref:System.Linq.Expressions.Expression.Type%2A> igual a <xref:System.Int32>.</span><span class="sxs-lookup"><span data-stu-id="f7da9-478">Each element of `indexes` must have <xref:System.Linq.Expressions.Expression.Type%2A> equal to <xref:System.Int32>.</span></span> <span data-ttu-id="f7da9-479">O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade de `array` deve representar um tipo de matriz cuja posição corresponde ao número de elementos em `indexes`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-479">The <xref:System.Linq.Expressions.Expression.Type%2A> property of `array` must represent an array type whose rank matches the number of elements in `indexes`.</span></span>  
  
 <span data-ttu-id="f7da9-480">Se a classificação de `array`. Tipo é 1, esse método retorna um <xref:System.Linq.Expressions.BinaryExpression>.</span><span class="sxs-lookup"><span data-stu-id="f7da9-480">If the rank of `array`.Type is 1, this method returns a <xref:System.Linq.Expressions.BinaryExpression>.</span></span> <span data-ttu-id="f7da9-481">O <xref:System.Linq.Expressions.BinaryExpression.Left%2A> estiver definida como `array` e o <xref:System.Linq.Expressions.BinaryExpression.Right%2A> estiver definida como o único elemento de `indexes`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-481">The <xref:System.Linq.Expressions.BinaryExpression.Left%2A> property is set to `array` and the <xref:System.Linq.Expressions.BinaryExpression.Right%2A> property is set to the single element of `indexes`.</span></span> <span data-ttu-id="f7da9-482">O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade do <xref:System.Linq.Expressions.BinaryExpression> representa o tipo de elemento de `array`. Tipo.</span><span class="sxs-lookup"><span data-stu-id="f7da9-482">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the <xref:System.Linq.Expressions.BinaryExpression> represents the element type of `array`.Type.</span></span>  
  
 <span data-ttu-id="f7da9-483">Se a classificação de `array`. Tipo é a mais de um, esse método retorna um <xref:System.Linq.Expressions.MethodCallExpression>.</span><span class="sxs-lookup"><span data-stu-id="f7da9-483">If the rank of `array`.Type is more than one, this method returns a <xref:System.Linq.Expressions.MethodCallExpression>.</span></span> <span data-ttu-id="f7da9-484">O <xref:System.Linq.Expressions.MethodCallExpression.Method%2A> estiver definida como o <xref:System.Reflection.MethodInfo> que descreve o método de instância pública `Get` no tipo representado pela <xref:System.Linq.Expressions.Expression.Type%2A> propriedade do `array`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-484">The <xref:System.Linq.Expressions.MethodCallExpression.Method%2A> property is set to the <xref:System.Reflection.MethodInfo> that describes the public instance method `Get` on the type represented by the <xref:System.Linq.Expressions.Expression.Type%2A> property of `array`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f7da9-485">O exemplo a seguir demonstra como usar o <xref:System.Linq.Expressions.Expression.ArrayIndex%28System.Linq.Expressions.Expression%2CSystem.Linq.Expressions.Expression%5B%5D%29> método para criar um <xref:System.Linq.Expressions.MethodCallExpression> que representa a indexação em uma matriz bidimensional.</span><span class="sxs-lookup"><span data-stu-id="f7da9-485">The following example demonstrates how to use the <xref:System.Linq.Expressions.Expression.ArrayIndex%28System.Linq.Expressions.Expression%2CSystem.Linq.Expressions.Expression%5B%5D%29> method to create a <xref:System.Linq.Expressions.MethodCallExpression> that represents indexing into a two-dimensional array.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.Expression#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#3)]
 [!code-vb[System.Linq.Expressions.Expression#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f7da9-486">
            <paramref name="array" /> ou <paramref name="indexes" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-486">
              <paramref name="array" /> or <paramref name="indexes" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f7da9-487">
            <paramref name="array" />.Type não representa um tipo de matriz.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-487">
              <paramref name="array" />.Type does not represent an array type.</span>
          </span>
          <span data-ttu-id="f7da9-488">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-488">-or-</span>
          </span>
          <span data-ttu-id="f7da9-489">A classificação de <paramref name="array" />.Type não corresponde ao número de elementos em <paramref name="indexes" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-489">The rank of <paramref name="array" />.Type does not match the number of elements in <paramref name="indexes" />.</span>
          </span>
          <span data-ttu-id="f7da9-490">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-490">-or-</span>
          </span>
          <span data-ttu-id="f7da9-491">A propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> de um ou mais elementos de <paramref name="indexes" /> não representa o tipo <see cref="T:System.Int32" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-491">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of one or more elements of <paramref name="indexes" /> does not represent the <see cref="T:System.Int32" /> type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ArrayLength">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression ArrayLength (System.Linq.Expressions.Expression array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression ArrayLength(class System.Linq.Expressions.Expression array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ArrayLength(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ArrayLength (array As Expression) As UnaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ ArrayLength(System::Linq::Expressions::Expression ^ array);" />
      <MemberSignature Language="F#" Value="static member ArrayLength : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.ArrayLength array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="array">
          <span data-ttu-id="f7da9-492">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-492">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-493">Cria uma <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa uma expressão para obter o comprimento de uma matriz unidimensional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-493">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents an expression for obtaining the length of a one-dimensional array.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-494">Um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.ArrayLength" /> e a propriedade <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> igual a <paramref name="array" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-494">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ArrayLength" /> and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to <paramref name="array" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-495">O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade de `array` deve representar um tipo de matriz.</span><span class="sxs-lookup"><span data-stu-id="f7da9-495">The <xref:System.Linq.Expressions.Expression.Type%2A> property of `array` must represent an array type.</span></span>  
  
 <span data-ttu-id="f7da9-496">O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade resultantes <xref:System.Linq.Expressions.UnaryExpression> é igual a <xref:System.Int32>.</span><span class="sxs-lookup"><span data-stu-id="f7da9-496">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.UnaryExpression> is equal to <xref:System.Int32>.</span></span> <span data-ttu-id="f7da9-497">O <xref:System.Linq.Expressions.UnaryExpression.Method%2A> é de propriedade `null`e ambos <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> e <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> são definidos como `false`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-497">The <xref:System.Linq.Expressions.UnaryExpression.Method%2A> property is `null`, and both <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> are set to `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f7da9-498">
            <paramref name="array" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-498">
              <paramref name="array" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f7da9-499">
            <paramref name="array" />.Type não representa um tipo de matriz.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-499">
              <paramref name="array" />.Type does not represent an array type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Assign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Assign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Assign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Assign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Assign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Assign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member Assign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Assign (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="f7da9-500">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-500">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="f7da9-501">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-501">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-502">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-502">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an assignment operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-503">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Assign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-503">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Assign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-504">O `Assign` expressão copia um valor para tipos de valor e, em seguida, copia uma referência para tipos de referência.</span><span class="sxs-lookup"><span data-stu-id="f7da9-504">The `Assign` expression copies a value for value types, and it copies a reference for reference types.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f7da9-505">O exemplo de código a seguir mostra como criar uma expressão que representa uma operação de atribuição.</span><span class="sxs-lookup"><span data-stu-id="f7da9-505">The following code example shows how to create an expression that represents an assignment operation.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#12)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#12)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Bind">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f7da9-506">Cria uma <see cref="T:System.Linq.Expressions.MemberAssignment" /> que representa a inicialização de um membro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-506">Creates a <see cref="T:System.Linq.Expressions.MemberAssignment" /> that represents the initialization of a member.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Bind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberAssignment Bind (System.Reflection.MemberInfo member, System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberAssignment Bind(class System.Reflection.MemberInfo member, class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Bind(System.Reflection.MemberInfo,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberAssignment ^ Bind(System::Reflection::MemberInfo ^ member, System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member Bind : System.Reflection.MemberInfo * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.MemberAssignment" Usage="System.Linq.Expressions.Expression.Bind (member, expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberAssignment</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="member" Type="System.Reflection.MemberInfo" />
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="member">
          <span data-ttu-id="f7da9-507">Um <see cref="T:System.Reflection.MemberInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-507">A <see cref="T:System.Reflection.MemberInfo" /> to set the <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property equal to.</span>
          </span>
        </param>
        <param name="expression">
          <span data-ttu-id="f7da9-508">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-508">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-509">Cria um <see cref="T:System.Linq.Expressions.MemberAssignment" /> que representa a inicialização de um campo ou propriedade.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-509">Creates a <see cref="T:System.Linq.Expressions.MemberAssignment" /> that represents the initialization of a field or property.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-510">Um <see cref="T:System.Linq.Expressions.MemberAssignment" /> que tem <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> igual a <see cref="F:System.Linq.Expressions.MemberBindingType.Assignment" /> e as propriedades <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> e <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> definidas para os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-510">A <see cref="T:System.Linq.Expressions.MemberAssignment" /> that has <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> equal to <see cref="F:System.Linq.Expressions.MemberBindingType.Assignment" /> and the <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> and <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-511">O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade de `expression` deve ser atribuível ao tipo representado pela <xref:System.Reflection.FieldInfo.FieldType%2A> ou <xref:System.Reflection.PropertyInfo.PropertyType%2A> propriedade do `member`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-511">The <xref:System.Linq.Expressions.Expression.Type%2A> property of `expression` must be assignable to the type represented by the <xref:System.Reflection.FieldInfo.FieldType%2A> or <xref:System.Reflection.PropertyInfo.PropertyType%2A> property of `member`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f7da9-512">
            <paramref name="member" /> ou <paramref name="expression" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-512">
              <paramref name="member" /> or <paramref name="expression" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f7da9-513">
            <paramref name="member" /> não representa um campo ou propriedade.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-513">
              <paramref name="member" /> does not represent a field or property.</span>
          </span>
          <span data-ttu-id="f7da9-514">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-514">-or-</span>
          </span>
          <span data-ttu-id="f7da9-515">A propriedade representada por <paramref name="member" /> não tem um acessador <see langword="set" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-515">The property represented by <paramref name="member" /> does not have a <see langword="set" /> accessor.</span>
          </span>
          <span data-ttu-id="f7da9-516">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-516">-or-</span>
          </span>
          <span data-ttu-id="f7da9-517">
            <paramref name="expression" />.Type não é atribuível ao tipo de campo ou à propriedade que <paramref name="member" /> representa.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-517">
              <paramref name="expression" />.Type is not assignable to the type of the field or property that <paramref name="member" /> represents.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Bind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberAssignment Bind (System.Reflection.MethodInfo propertyAccessor, System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberAssignment Bind(class System.Reflection.MethodInfo propertyAccessor, class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Bind(System.Reflection.MethodInfo,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberAssignment ^ Bind(System::Reflection::MethodInfo ^ propertyAccessor, System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member Bind : System.Reflection.MethodInfo * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.MemberAssignment" Usage="System.Linq.Expressions.Expression.Bind (propertyAccessor, expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberAssignment</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyAccessor" Type="System.Reflection.MethodInfo" />
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="propertyAccessor">
          <span data-ttu-id="f7da9-518">Um <see cref="T:System.Reflection.MethodInfo" /> que representa um método de acessador de propriedade.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-518">A <see cref="T:System.Reflection.MethodInfo" /> that represents a property accessor method.</span>
          </span>
        </param>
        <param name="expression">
          <span data-ttu-id="f7da9-519">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-519">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-520">Cria uma <see cref="T:System.Linq.Expressions.MemberAssignment" /> que representa a inicialização de um membro usando um método de acessador de propriedade.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-520">Creates a <see cref="T:System.Linq.Expressions.MemberAssignment" /> that represents the initialization of a member by using a property accessor method.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-521">Um <see cref="T:System.Linq.Expressions.MemberAssignment" /> que tem a propriedade <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> igual a <see cref="F:System.Linq.Expressions.MemberBindingType.Assignment" />, a propriedade <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> definida para o <see cref="T:System.Reflection.PropertyInfo" /> que representa a propriedade acessada em <paramref name="propertyAccessor" /> e a propriedade <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> definida para <paramref name="expression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-521">A <see cref="T:System.Linq.Expressions.MemberAssignment" /> that has the <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> property equal to <see cref="F:System.Linq.Expressions.MemberBindingType.Assignment" />, the <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property set to the <see cref="T:System.Reflection.PropertyInfo" /> that represents the property accessed in <paramref name="propertyAccessor" />, and the <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> property set to <paramref name="expression" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-522">O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade de `expression` deve ser atribuível ao tipo representado pela <xref:System.Reflection.PropertyInfo.PropertyType%2A> propriedade da propriedade acessada em `propertyAccessor`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-522">The <xref:System.Linq.Expressions.Expression.Type%2A> property of `expression` must be assignable to the type represented by the <xref:System.Reflection.PropertyInfo.PropertyType%2A> property of the property accessed in `propertyAccessor`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f7da9-523">
            <paramref name="propertyAccessor" /> ou <paramref name="expression" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-523">
              <paramref name="propertyAccessor" /> or <paramref name="expression" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f7da9-524">
            <paramref name="propertyAccessor" /> não representa um método de acessador de propriedade.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-524">
              <paramref name="propertyAccessor" /> does not represent a property accessor method.</span>
          </span>
          <span data-ttu-id="f7da9-525">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-525">-or-</span>
          </span>
          <span data-ttu-id="f7da9-526">A propriedade acessada por <paramref name="propertyAccessor" /> não tem um acessador <see langword="set" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-526">The property accessed by <paramref name="propertyAccessor" /> does not have a <see langword="set" /> accessor.</span>
          </span>
          <span data-ttu-id="f7da9-527">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-527">-or-</span>
          </span>
          <span data-ttu-id="f7da9-528">
            <paramref name="expression" />.Type não é atribuível ao tipo de campo ou à propriedade que <paramref name="member" /> representa.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-528">
              <paramref name="expression" />.Type is not assignable to the type of the field or property that <paramref name="member" /> represents.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Block">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f7da9-529">Cria um <see cref="T:System.Linq.Expressions.BlockExpression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-529">Creates a <see cref="T:System.Linq.Expressions.BlockExpression" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; expressions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; expressions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Block (expressions As IEnumerable(Of Expression)) As BlockExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ expressions);" />
      <MemberSignature Language="F#" Value="static member Block : seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.BlockExpression" Usage="System.Linq.Expressions.Expression.Block expressions" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expressions" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="expressions">
          <span data-ttu-id="f7da9-530">As expressões no bloco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-530">The expressions in the block.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-531">Cria um <see cref="T:System.Linq.Expressions.BlockExpression" /> que contém as expressões determinadas e não tem variáveis.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-531">Creates a <see cref="T:System.Linq.Expressions.BlockExpression" /> that contains the given expressions and has no variables.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-532">O <see cref="T:System.Linq.Expressions.BlockExpression" /> criado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-532">The created <see cref="T:System.Linq.Expressions.BlockExpression" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-533">Quando a expressão de bloco é executada, ele retorna o valor da última expressão no bloco.</span><span class="sxs-lookup"><span data-stu-id="f7da9-533">When the block expression is executed, it returns the value of the last expression in the block.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (params System.Linq.Expressions.Expression[] expressions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Linq.Expressions.Expression[] expressions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Block (ParamArray expressions As Expression()) As BlockExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ expressions);" />
      <MemberSignature Language="F#" Value="static member Block : System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.BlockExpression" Usage="System.Linq.Expressions.Expression.Block expressions" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expressions" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="expressions">
          <span data-ttu-id="f7da9-534">As expressões no bloco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-534">The expressions in the block.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-535">Cria um <see cref="T:System.Linq.Expressions.BlockExpression" /> que contém as expressões determinadas e não tem variáveis.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-535">Creates a <see cref="T:System.Linq.Expressions.BlockExpression" /> that contains the given expressions and has no variables.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-536">O <see cref="T:System.Linq.Expressions.BlockExpression" /> criado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-536">The created <see cref="T:System.Linq.Expressions.BlockExpression" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-537">Quando a expressão de bloco é executada, ele retorna o valor da última expressão no bloco.</span><span class="sxs-lookup"><span data-stu-id="f7da9-537">When the block expression is executed, it returns the value of the last expression in the block.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f7da9-538">O exemplo de código a seguir mostra como criar uma expressão de bloco.</span><span class="sxs-lookup"><span data-stu-id="f7da9-538">The following code example shows how to create a block expression.</span></span> <span data-ttu-id="f7da9-539">A expressão de bloco consiste em dois <xref:System.Linq.Expressions.MethodCallExpression> objetos e um <xref:System.Linq.Expressions.ConstantExpression> objeto.</span><span class="sxs-lookup"><span data-stu-id="f7da9-539">The block expression consists of two <xref:System.Linq.Expressions.MethodCallExpression> objects and one <xref:System.Linq.Expressions.ConstantExpression> object.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#13)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#13)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; variables, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; expressions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; variables, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; expressions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Block (variables As IEnumerable(Of ParameterExpression), expressions As IEnumerable(Of Expression)) As BlockExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ variables, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ expressions);" />
      <MemberSignature Language="F#" Value="static member Block : seq&lt;System.Linq.Expressions.ParameterExpression&gt; * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.BlockExpression" Usage="System.Linq.Expressions.Expression.Block (variables, expressions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variables" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
        <Parameter Name="expressions" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="variables">
          <span data-ttu-id="f7da9-540">As variáveis no bloco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-540">The variables in the block.</span>
          </span>
        </param>
        <param name="expressions">
          <span data-ttu-id="f7da9-541">As expressões no bloco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-541">The expressions in the block.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-542">Cria um <see cref="T:System.Linq.Expressions.BlockExpression" /> que contém as expressões e variáveis determinadas.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-542">Creates a <see cref="T:System.Linq.Expressions.BlockExpression" /> that contains the given variables and expressions.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-543">O <see cref="T:System.Linq.Expressions.BlockExpression" /> criado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-543">The created <see cref="T:System.Linq.Expressions.BlockExpression" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-544">Quando a expressão de bloco é executada, ele retorna o valor da última expressão no bloco.</span><span class="sxs-lookup"><span data-stu-id="f7da9-544">When the block expression is executed, it returns the value of the last expression in the block.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f7da9-545">O exemplo de código a seguir mostra como passar um parâmetro para uma expressão de bloco e processa este parâmetro dentro de um bloco.</span><span class="sxs-lookup"><span data-stu-id="f7da9-545">The following code example shows how to pass a parameter to a block expression and process this parameter within a block.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#14)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#14)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; variables, params System.Linq.Expressions.Expression[] expressions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; variables, class System.Linq.Expressions.Expression[] expressions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Block (variables As IEnumerable(Of ParameterExpression), ParamArray expressions As Expression()) As BlockExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ variables, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ expressions);" />
      <MemberSignature Language="F#" Value="static member Block : seq&lt;System.Linq.Expressions.ParameterExpression&gt; * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.BlockExpression" Usage="System.Linq.Expressions.Expression.Block (variables, expressions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variables" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
        <Parameter Name="expressions" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="variables">
          <span data-ttu-id="f7da9-546">As variáveis no bloco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-546">The variables in the block.</span>
          </span>
        </param>
        <param name="expressions">
          <span data-ttu-id="f7da9-547">As expressões no bloco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-547">The expressions in the block.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-548">Cria um <see cref="T:System.Linq.Expressions.BlockExpression" /> que contém as expressões e variáveis determinadas.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-548">Creates a <see cref="T:System.Linq.Expressions.BlockExpression" /> that contains the given variables and expressions.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-549">O <see cref="T:System.Linq.Expressions.BlockExpression" /> criado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-549">The created <see cref="T:System.Linq.Expressions.BlockExpression" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-550">Quando a expressão de bloco é executada, ele retorna o valor da última expressão no bloco.</span><span class="sxs-lookup"><span data-stu-id="f7da9-550">When the block expression is executed, it returns the value of the last expression in the block.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Block (arg0 As Expression, arg1 As Expression) As BlockExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1);" />
      <MemberSignature Language="F#" Value="static member Block : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BlockExpression" Usage="System.Linq.Expressions.Expression.Block (arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="arg0">
          <span data-ttu-id="f7da9-551">A primeira expressão no bloco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-551">The first expression in the block.</span>
          </span>
        </param>
        <param name="arg1">
          <span data-ttu-id="f7da9-552">A segunda expressão no bloco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-552">The second expression in the block.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-553">Cria uma <see cref="T:System.Linq.Expressions.BlockExpression" /> que contém duas expressões e não tem variáveis.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-553">Creates a <see cref="T:System.Linq.Expressions.BlockExpression" /> that contains two expressions and has no variables.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-554">O <see cref="T:System.Linq.Expressions.BlockExpression" /> criado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-554">The created <see cref="T:System.Linq.Expressions.BlockExpression" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-555">Quando a expressão de bloco é executada, ele retorna o valor da última expressão no bloco.</span><span class="sxs-lookup"><span data-stu-id="f7da9-555">When the block expression is executed, it returns the value of the last expression in the block.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (Type type, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; expressions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Type type, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; expressions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(Type ^ type, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ expressions);" />
      <MemberSignature Language="F#" Value="static member Block : Type * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.BlockExpression" Usage="System.Linq.Expressions.Expression.Block (type, expressions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="expressions" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="type">
          <span data-ttu-id="f7da9-556">O tipo de resultado do bloco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-556">The result type of the block.</span>
          </span>
        </param>
        <param name="expressions">
          <span data-ttu-id="f7da9-557">As expressões no bloco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-557">The expressions in the block.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-558">Cria uma <see cref="T:System.Linq.Expressions.BlockExpression" /> que contém as expressões fornecidas, não tem variáveis e tem um tipo de resultado específico.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-558">Creates a <see cref="T:System.Linq.Expressions.BlockExpression" /> that contains the given expressions, has no variables and has specific result type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-559">O <see cref="T:System.Linq.Expressions.BlockExpression" /> criado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-559">The created <see cref="T:System.Linq.Expressions.BlockExpression" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (Type type, params System.Linq.Expressions.Expression[] expressions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Type type, class System.Linq.Expressions.Expression[] expressions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Type,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(Type ^ type, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ expressions);" />
      <MemberSignature Language="F#" Value="static member Block : Type * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.BlockExpression" Usage="System.Linq.Expressions.Expression.Block (type, expressions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="expressions" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="type">
          <span data-ttu-id="f7da9-560">O tipo de resultado do bloco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-560">The result type of the block.</span>
          </span>
        </param>
        <param name="expressions">
          <span data-ttu-id="f7da9-561">As expressões no bloco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-561">The expressions in the block.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-562">Cria uma <see cref="T:System.Linq.Expressions.BlockExpression" /> que contém as expressões fornecidas, não tem variáveis e tem um tipo de resultado específico.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-562">Creates a <see cref="T:System.Linq.Expressions.BlockExpression" /> that contains the given expressions, has no variables and has specific result type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-563">O <see cref="T:System.Linq.Expressions.BlockExpression" /> criado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-563">The created <see cref="T:System.Linq.Expressions.BlockExpression" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Block (arg0 As Expression, arg1 As Expression, arg2 As Expression) As BlockExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2);" />
      <MemberSignature Language="F#" Value="static member Block : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BlockExpression" Usage="System.Linq.Expressions.Expression.Block (arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="arg0">
          <span data-ttu-id="f7da9-564">A primeira expressão no bloco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-564">The first expression in the block.</span>
          </span>
        </param>
        <param name="arg1">
          <span data-ttu-id="f7da9-565">A segunda expressão no bloco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-565">The second expression in the block.</span>
          </span>
        </param>
        <param name="arg2">
          <span data-ttu-id="f7da9-566">A terceira expressão no bloco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-566">The third expression in the block.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-567">Cria uma <see cref="T:System.Linq.Expressions.BlockExpression" /> que contém três expressões e não tem variáveis.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-567">Creates a <see cref="T:System.Linq.Expressions.BlockExpression" /> that contains three expressions and has no variables.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-568">O <see cref="T:System.Linq.Expressions.BlockExpression" /> criado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-568">The created <see cref="T:System.Linq.Expressions.BlockExpression" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-569">Quando a expressão de bloco é executada, ele retorna o valor da última expressão no bloco.</span><span class="sxs-lookup"><span data-stu-id="f7da9-569">When the block expression is executed, it returns the value of the last expression in the block.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (Type type, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; variables, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; expressions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Type type, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; variables, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; expressions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(Type ^ type, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ variables, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ expressions);" />
      <MemberSignature Language="F#" Value="static member Block : Type * seq&lt;System.Linq.Expressions.ParameterExpression&gt; * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.BlockExpression" Usage="System.Linq.Expressions.Expression.Block (type, variables, expressions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="variables" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
        <Parameter Name="expressions" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="type">
          <span data-ttu-id="f7da9-570">O tipo de resultado do bloco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-570">The result type of the block.</span>
          </span>
        </param>
        <param name="variables">
          <span data-ttu-id="f7da9-571">As variáveis no bloco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-571">The variables in the block.</span>
          </span>
        </param>
        <param name="expressions">
          <span data-ttu-id="f7da9-572">As expressões no bloco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-572">The expressions in the block.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-573">Cria um <see cref="T:System.Linq.Expressions.BlockExpression" /> que contém as expressões e variáveis determinadas.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-573">Creates a <see cref="T:System.Linq.Expressions.BlockExpression" /> that contains the given variables and expressions.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-574">O <see cref="T:System.Linq.Expressions.BlockExpression" /> criado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-574">The created <see cref="T:System.Linq.Expressions.BlockExpression" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (Type type, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; variables, params System.Linq.Expressions.Expression[] expressions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Type type, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; variables, class System.Linq.Expressions.Expression[] expressions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(Type ^ type, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ variables, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ expressions);" />
      <MemberSignature Language="F#" Value="static member Block : Type * seq&lt;System.Linq.Expressions.ParameterExpression&gt; * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.BlockExpression" Usage="System.Linq.Expressions.Expression.Block (type, variables, expressions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="variables" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
        <Parameter Name="expressions" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="type">
          <span data-ttu-id="f7da9-575">O tipo de resultado do bloco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-575">The result type of the block.</span>
          </span>
        </param>
        <param name="variables">
          <span data-ttu-id="f7da9-576">As variáveis no bloco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-576">The variables in the block.</span>
          </span>
        </param>
        <param name="expressions">
          <span data-ttu-id="f7da9-577">As expressões no bloco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-577">The expressions in the block.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-578">Cria um <see cref="T:System.Linq.Expressions.BlockExpression" /> que contém as expressões e variáveis determinadas.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-578">Creates a <see cref="T:System.Linq.Expressions.BlockExpression" /> that contains the given variables and expressions.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-579">O <see cref="T:System.Linq.Expressions.BlockExpression" /> criado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-579">The created <see cref="T:System.Linq.Expressions.BlockExpression" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2, System.Linq.Expressions.Expression arg3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2, class System.Linq.Expressions.Expression arg3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Block (arg0 As Expression, arg1 As Expression, arg2 As Expression, arg3 As Expression) As BlockExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2, System::Linq::Expressions::Expression ^ arg3);" />
      <MemberSignature Language="F#" Value="static member Block : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BlockExpression" Usage="System.Linq.Expressions.Expression.Block (arg0, arg1, arg2, arg3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg3" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="arg0">
          <span data-ttu-id="f7da9-580">A primeira expressão no bloco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-580">The first expression in the block.</span>
          </span>
        </param>
        <param name="arg1">
          <span data-ttu-id="f7da9-581">A segunda expressão no bloco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-581">The second expression in the block.</span>
          </span>
        </param>
        <param name="arg2">
          <span data-ttu-id="f7da9-582">A terceira expressão no bloco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-582">The third expression in the block.</span>
          </span>
        </param>
        <param name="arg3">
          <span data-ttu-id="f7da9-583">A quarta expressão no bloco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-583">The fourth expression in the block.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-584">Cria uma <see cref="T:System.Linq.Expressions.BlockExpression" /> que contém quatro expressões e não tem variáveis.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-584">Creates a <see cref="T:System.Linq.Expressions.BlockExpression" /> that contains four expressions and has no variables.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-585">O <see cref="T:System.Linq.Expressions.BlockExpression" /> criado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-585">The created <see cref="T:System.Linq.Expressions.BlockExpression" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-586">Quando a expressão de bloco é executada, ele retorna o valor da última expressão no bloco.</span><span class="sxs-lookup"><span data-stu-id="f7da9-586">When the block expression is executed, it returns the value of the last expression in the block.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2, System.Linq.Expressions.Expression arg3, System.Linq.Expressions.Expression arg4);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2, class System.Linq.Expressions.Expression arg3, class System.Linq.Expressions.Expression arg4) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Block (arg0 As Expression, arg1 As Expression, arg2 As Expression, arg3 As Expression, arg4 As Expression) As BlockExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2, System::Linq::Expressions::Expression ^ arg3, System::Linq::Expressions::Expression ^ arg4);" />
      <MemberSignature Language="F#" Value="static member Block : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BlockExpression" Usage="System.Linq.Expressions.Expression.Block (arg0, arg1, arg2, arg3, arg4)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg3" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg4" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="arg0">
          <span data-ttu-id="f7da9-587">A primeira expressão no bloco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-587">The first expression in the block.</span>
          </span>
        </param>
        <param name="arg1">
          <span data-ttu-id="f7da9-588">A segunda expressão no bloco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-588">The second expression in the block.</span>
          </span>
        </param>
        <param name="arg2">
          <span data-ttu-id="f7da9-589">A terceira expressão no bloco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-589">The third expression in the block.</span>
          </span>
        </param>
        <param name="arg3">
          <span data-ttu-id="f7da9-590">A quarta expressão no bloco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-590">The fourth expression in the block.</span>
          </span>
        </param>
        <param name="arg4">
          <span data-ttu-id="f7da9-591">A quinta expressão no bloco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-591">The fifth expression in the block.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-592">Cria uma <see cref="T:System.Linq.Expressions.BlockExpression" /> que contém cinco expressões e não tem variáveis.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-592">Creates a <see cref="T:System.Linq.Expressions.BlockExpression" /> that contains five expressions and has no variables.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-593">O <see cref="T:System.Linq.Expressions.BlockExpression" /> criado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-593">The created <see cref="T:System.Linq.Expressions.BlockExpression" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-594">Quando a expressão de bloco é executada, ele retorna o valor da última expressão no bloco.</span><span class="sxs-lookup"><span data-stu-id="f7da9-594">When the block expression is executed, it returns the value of the last expression in the block.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Break">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f7da9-595">Cria uma <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa uma instrução break.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-595">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a break statement.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Break">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Break (System.Linq.Expressions.LabelTarget target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Break(class System.Linq.Expressions.LabelTarget target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Break (target As LabelTarget) As GotoExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Break(System::Linq::Expressions::LabelTarget ^ target);" />
      <MemberSignature Language="F#" Value="static member Break : System.Linq.Expressions.LabelTarget -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.Break target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
      </Parameters>
      <Docs>
        <param name="target">
          <span data-ttu-id="f7da9-596">O <see cref="T:System.Linq.Expressions.LabelTarget" /> para o qual o <see cref="T:System.Linq.Expressions.GotoExpression" /> irá.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-596">The <see cref="T:System.Linq.Expressions.LabelTarget" /> that the <see cref="T:System.Linq.Expressions.GotoExpression" /> will jump to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-597">Cria uma <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa uma instrução break.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-597">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a break statement.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-598">Um <see cref="T:System.Linq.Expressions.GotoExpression" /> com <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Break, a propriedade <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> definida para <paramref name="target" /> e um valor nulo a ser passado para o rótulo de destino ao saltar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-598">A <see cref="T:System.Linq.Expressions.GotoExpression" /> with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> equal to Break, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> property set to <paramref name="target" />, and a null value to be passed to the target label upon jumping.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="f7da9-599">O exemplo a seguir demonstra como criar uma expressão que contém um <xref:System.Linq.Expressions.LoopExpression> objeto que usa o <xref:System.Linq.Expressions.Expression.Break%2A> método.</span><span class="sxs-lookup"><span data-stu-id="f7da9-599">The following example demonstrates how to create an expression that contains a <xref:System.Linq.Expressions.LoopExpression> object that uses the <xref:System.Linq.Expressions.Expression.Break%2A> method.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#44](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#44)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#44](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#44)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Break">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Break (System.Linq.Expressions.LabelTarget target, System.Linq.Expressions.Expression value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Break(class System.Linq.Expressions.LabelTarget target, class System.Linq.Expressions.Expression value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Break (target As LabelTarget, value As Expression) As GotoExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Break(System::Linq::Expressions::LabelTarget ^ target, System::Linq::Expressions::Expression ^ value);" />
      <MemberSignature Language="F#" Value="static member Break : System.Linq.Expressions.LabelTarget * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.Break (target, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="target">
          <span data-ttu-id="f7da9-600">O <see cref="T:System.Linq.Expressions.LabelTarget" /> para o qual o <see cref="T:System.Linq.Expressions.GotoExpression" /> irá.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-600">The <see cref="T:System.Linq.Expressions.LabelTarget" /> that the <see cref="T:System.Linq.Expressions.GotoExpression" /> will jump to.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="f7da9-601">O valor que será passado para o rótulo associado ao saltar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-601">The value that will be passed to the associated label upon jumping.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-602">Cria uma <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa uma instrução break.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-602">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a break statement.</span>
          </span>
          <span data-ttu-id="f7da9-603">O valor passado para o rótulo no salto pode ser especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-603">The value passed to the label upon jumping can be specified.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-604">Um <see cref="T:System.Linq.Expressions.GotoExpression" /> com <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Break, a propriedade <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> definida para <paramref name="target" /> e <paramref name="value" /> a ser passado para o rótulo de destino ao saltar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-604">A <see cref="T:System.Linq.Expressions.GotoExpression" /> with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> equal to Break, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> property set to <paramref name="target" />, and <paramref name="value" /> to be passed to the target label upon jumping.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Break">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Break (System.Linq.Expressions.LabelTarget target, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Break(class System.Linq.Expressions.LabelTarget target, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Break(System::Linq::Expressions::LabelTarget ^ target, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Break : System.Linq.Expressions.LabelTarget * Type -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.Break (target, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="target">
          <span data-ttu-id="f7da9-605">O <see cref="T:System.Linq.Expressions.LabelTarget" /> para o qual o <see cref="T:System.Linq.Expressions.GotoExpression" /> irá.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-605">The <see cref="T:System.Linq.Expressions.LabelTarget" /> that the <see cref="T:System.Linq.Expressions.GotoExpression" /> will jump to.</span>
          </span>
        </param>
        <param name="type">
          <span data-ttu-id="f7da9-606">Um <see cref="T:System.Type" /> para definir a propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-606">An <see cref="T:System.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-607">Cria uma <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa uma instrução break com o tipo especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-607">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a break statement with the specified type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-608">Um <see cref="T:System.Linq.Expressions.GotoExpression" /> com <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Break, a propriedade <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> definida para <paramref name="target" /> e a propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> definida para <paramref name="type" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-608">A <see cref="T:System.Linq.Expressions.GotoExpression" /> with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> equal to Break, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> property set to <paramref name="target" />, and the <see cref="P:System.Linq.Expressions.Expression.Type" /> property set to <paramref name="type" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Break">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Break (System.Linq.Expressions.LabelTarget target, System.Linq.Expressions.Expression value, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Break(class System.Linq.Expressions.LabelTarget target, class System.Linq.Expressions.Expression value, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Break(System::Linq::Expressions::LabelTarget ^ target, System::Linq::Expressions::Expression ^ value, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Break : System.Linq.Expressions.LabelTarget * System.Linq.Expressions.Expression * Type -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.Break (target, value, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="target">
          <span data-ttu-id="f7da9-609">O <see cref="T:System.Linq.Expressions.LabelTarget" /> para o qual o <see cref="T:System.Linq.Expressions.GotoExpression" /> irá.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-609">The <see cref="T:System.Linq.Expressions.LabelTarget" /> that the <see cref="T:System.Linq.Expressions.GotoExpression" /> will jump to.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="f7da9-610">O valor que será passado para o rótulo associado ao saltar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-610">The value that will be passed to the associated label upon jumping.</span>
          </span>
        </param>
        <param name="type">
          <span data-ttu-id="f7da9-611">Um <see cref="T:System.Type" /> para definir a propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-611">An <see cref="T:System.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-612">Cria uma <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa uma instrução break com o tipo especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-612">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a break statement with the specified type.</span>
          </span>
          <span data-ttu-id="f7da9-613">O valor passado para o rótulo no salto pode ser especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-613">The value passed to the label upon jumping can be specified.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-614">Um <see cref="T:System.Linq.Expressions.GotoExpression" /> com <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Break, a propriedade <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> definida para <paramref name="target" />, a propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> definida para <paramref name="type" /> e <paramref name="value" /> a serem passados para o rótulo de destino após saltar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-614">A <see cref="T:System.Linq.Expressions.GotoExpression" /> with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> equal to Break, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> property set to <paramref name="target" />, the <see cref="P:System.Linq.Expressions.Expression.Type" /> property set to <paramref name="type" />, and <paramref name="value" /> to be passed to the target label upon jumping.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Call">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f7da9-615">Cria um <see cref="T:System.Linq.Expressions.MethodCallExpression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-615">Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Linq.Expressions.Expression instance, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Linq.Expressions.Expression instance, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (instance As Expression, method As MethodInfo) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Linq::Expressions::Expression ^ instance, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member Call : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.Call (instance, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="instance">
          <span data-ttu-id="f7da9-616">Um <see cref="T:System.Linq.Expressions.Expression" /> que especifica a instância de uma chamada de método de instância (passa <see langword="null" /> para um método <see langword="static" /> (<see langword="Shared" /> no Visual Basic)).</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-616">An <see cref="T:System.Linq.Expressions.Expression" /> that specifies the instance for an instance method call (pass <see langword="null" /> for a <see langword="static" /> (<see langword="Shared" /> in Visual Basic) method).</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="f7da9-617">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-617">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-618">Cria um <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa uma chamada para um método que não aceita argumentos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-618">Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents a call to a method that takes no arguments.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-619">Um <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> e as propriedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> e <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-619">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> and <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-620">Para representar uma chamada para um `static` (`Shared` no Visual Basic) método, passe `null` para o `instance` parâmetro ao chamar esse método.</span><span class="sxs-lookup"><span data-stu-id="f7da9-620">To represent a call to a `static` (`Shared` in Visual Basic) method, pass in `null` for the `instance` parameter when you call this method.</span></span>  
  
 <span data-ttu-id="f7da9-621">Se `method` representa um método de instância, o <xref:System.Linq.Expressions.Expression.Type%2A> propriedade de `instance` deve ser atribuível ao tipo de declaração do método representado por `method`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-621">If `method` represents an instance method, the <xref:System.Linq.Expressions.Expression.Type%2A> property of `instance` must be assignable to the declaring type of the method represented by `method`.</span></span>  
  
 <span data-ttu-id="f7da9-622">O <xref:System.Linq.Expressions.MethodCallExpression.Arguments%2A> propriedade resultantes <xref:System.Linq.Expressions.MethodCallExpression> está vazio.</span><span class="sxs-lookup"><span data-stu-id="f7da9-622">The <xref:System.Linq.Expressions.MethodCallExpression.Arguments%2A> property of the resulting <xref:System.Linq.Expressions.MethodCallExpression> is empty.</span></span> <span data-ttu-id="f7da9-623">O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade é igual ao tipo de retorno do método representado por `method`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-623">The <xref:System.Linq.Expressions.Expression.Type%2A> property is equal to the return type of the method represented by `method`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f7da9-624">O exemplo de código a seguir mostra como criar uma expressão que chama um método sem argumentos.</span><span class="sxs-lookup"><span data-stu-id="f7da9-624">The following code example shows how to create an expression that calls a method without arguments.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#15)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f7da9-625">
            <paramref name="method" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-625">
              <paramref name="method" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="f7da9-626">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-626">-or-</span>
          </span>
          <span data-ttu-id="f7da9-627">
            <paramref name="instance" /> é <see langword="null" /> e <paramref name="method" /> representa um método de instância.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-627">
              <paramref name="instance" /> is <see langword="null" /> and <paramref name="method" /> represents an instance method.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f7da9-628">
            <paramref name="instance" />. O tipo não é atribuível ao tipo de declaração de método representada pelo <paramref name="method" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-628">
              <paramref name="instance" />.Type is not assignable to the declaring type of the method represented by <paramref name="method" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Reflection.MethodInfo method, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Reflection.MethodInfo method, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (method As MethodInfo, arguments As IEnumerable(Of Expression)) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Reflection::MethodInfo ^ method, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Call : System.Reflection.MethodInfo * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.Call (method, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="method">
          <span data-ttu-id="f7da9-629">O <see cref="T:System.Reflection.MethodInfo" /> que representa o método de destino.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-629">The <see cref="T:System.Reflection.MethodInfo" /> that represents the target method.</span>
          </span>
        </param>
        <param name="arguments">
          <span data-ttu-id="f7da9-630">Uma coleção de <see cref="T:System.Linq.Expressions.Expression" /> que representa os argumentos de chamada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-630">A collection of <see cref="T:System.Linq.Expressions.Expression" /> that represents the call arguments.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-631">Cria uma <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa uma chamada para um método estático (compartilhado no Visual Basic).</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-631">Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents a call to a static (Shared in Visual Basic) method.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-632">Um <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> e as propriedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> e <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-632">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> and <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Reflection.MethodInfo method, System.Linq.Expressions.Expression arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (method As MethodInfo, arg0 As Expression) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Reflection::MethodInfo ^ method, System::Linq::Expressions::Expression ^ arg0);" />
      <MemberSignature Language="F#" Value="static member Call : System.Reflection.MethodInfo * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.Call (method, arg0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="method">
          <span data-ttu-id="f7da9-633">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-633">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <param name="arg0">
          <span data-ttu-id="f7da9-634">O <see cref="T:System.Linq.Expressions.Expression" /> que representa o primeiro argumento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-634">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the first argument.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-635">Cria um <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa uma chamada para um método <see langword="static" /> (<see langword="Shared" /> no Visual Basic) que aceita um argumento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-635">Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents a call to a <see langword="static" /> (<see langword="Shared" /> in Visual Basic) method that takes one argument.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-636">Um <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> e as propriedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> e <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-636">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> and <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="f7da9-637">O exemplo a seguir demonstra como criar uma expressão que chama um `static` (`Shared` no Visual Basic) método que aceita um argumento.</span><span class="sxs-lookup"><span data-stu-id="f7da9-637">The following example demonstrates how to create an expression that calls a `static` (`Shared` in Visual Basic) method that takes one argument.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#16)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f7da9-638">
            <paramref name="method" /> é nulo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-638">
              <paramref name="method" /> is null.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Reflection.MethodInfo method, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (method As MethodInfo, ParamArray arguments As Expression()) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Reflection::MethodInfo ^ method, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Call : System.Reflection.MethodInfo * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.Call (method, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="method">
          <span data-ttu-id="f7da9-639">Um <see cref="T:System.Reflection.MethodInfo" /> que representa um método <see langword="static" /> (<see langword="Shared" /> no Visual Basic) igual ao qual definir a propriedade <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-639">A <see cref="T:System.Reflection.MethodInfo" /> that represents a <see langword="static" /> (<see langword="Shared" /> in Visual Basic) method to set the <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <param name="arguments">
          <span data-ttu-id="f7da9-640">Uma matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> a serem usados para popular a coleção de <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-640">An array of <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-641">Cria um <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa uma chamada para um método <see langword="static" /> (<see langword="Shared" /> no Visual Basic) que tem argumentos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-641">Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents a call to a <see langword="static" /> (<see langword="Shared" /> in Visual Basic) method that has arguments.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-642">Um <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> e as propriedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> e <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-642">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> and <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-643">Se `arguments` não é `null`, ele deve ter o mesmo número de elementos que o número de parâmetros para o método representado por `method`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-643">If `arguments` is not `null`, it must have the same number of elements as the number of parameters for the method represented by `method`.</span></span> <span data-ttu-id="f7da9-644">Cada elemento na `arguments` não deve ser `null` e deve ser atribuível ao parâmetro correspondente do `method`, possivelmente após *citando*.</span><span class="sxs-lookup"><span data-stu-id="f7da9-644">Each element in `arguments` must not be `null` and must be assignable to the corresponding parameter of `method`, possibly after *quoting*.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f7da9-645">Um elemento será ser colocado entre aspas somente se o parâmetro do método correspondente é do tipo <xref:System.Linq.Expressions.Expression>.</span><span class="sxs-lookup"><span data-stu-id="f7da9-645">An element will be quoted only if the corresponding method parameter is of type <xref:System.Linq.Expressions.Expression>.</span></span> <span data-ttu-id="f7da9-646">Delimitação significa que o elemento é encapsulado em um <xref:System.Linq.Expressions.ExpressionType.Quote> nó.</span><span class="sxs-lookup"><span data-stu-id="f7da9-646">Quoting means the element is wrapped in a <xref:System.Linq.Expressions.ExpressionType.Quote> node.</span></span> <span data-ttu-id="f7da9-647">O nó resultante é um <xref:System.Linq.Expressions.UnaryExpression> cujos <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> propriedade é o elemento de `arguments`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-647">The resulting node is a <xref:System.Linq.Expressions.UnaryExpression> whose <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> property is the element of `arguments`.</span></span>  
  
 <span data-ttu-id="f7da9-648">O <xref:System.Linq.Expressions.MethodCallExpression.Arguments%2A> propriedade resultantes <xref:System.Linq.Expressions.MethodCallExpression> está vazia se `arguments` é `null`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-648">The <xref:System.Linq.Expressions.MethodCallExpression.Arguments%2A> property of the resulting <xref:System.Linq.Expressions.MethodCallExpression> is empty if `arguments` is `null`.</span></span> <span data-ttu-id="f7da9-649">Caso contrário, ele contém os mesmos elementos que `arguments`, algumas das quais podem ser colocado entre aspas.</span><span class="sxs-lookup"><span data-stu-id="f7da9-649">Otherwise, it contains the same elements as `arguments`, some of which may be quoted.</span></span>  
  
 <span data-ttu-id="f7da9-650">O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade resultantes <xref:System.Linq.Expressions.MethodCallExpression> é igual ao tipo de retorno do método representado por `method`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-650">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.MethodCallExpression> is equal to the return type of the method represented by `method`.</span></span> <span data-ttu-id="f7da9-651">A propriedade <xref:System.Linq.Expressions.MethodCallExpression.Object%2A> é `null`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-651">The <xref:System.Linq.Expressions.MethodCallExpression.Object%2A> property is `null`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f7da9-652">
            <paramref name="method" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-652">
              <paramref name="method" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f7da9-653">O número de elementos em <paramref name="arguments" /> não é igual ao número de parâmetros para o método representado por <paramref name="method" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-653">The number of elements in <paramref name="arguments" /> does not equal the number of parameters for the method represented by <paramref name="method" />.</span>
          </span>
          <span data-ttu-id="f7da9-654">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-654">-or-</span>
          </span>
          <span data-ttu-id="f7da9-655">Um ou mais dos elementos de <paramref name="arguments" /> não é atribuível ao parâmetro correspondente para o método representado por <paramref name="method" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-655">One or more of the elements of <paramref name="arguments" /> is not assignable to the corresponding parameter for the method represented by <paramref name="method" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Linq.Expressions.Expression instance, System.Reflection.MethodInfo method, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Linq.Expressions.Expression instance, class System.Reflection.MethodInfo method, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (instance As Expression, method As MethodInfo, arguments As IEnumerable(Of Expression)) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Linq::Expressions::Expression ^ instance, System::Reflection::MethodInfo ^ method, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Call : System.Linq.Expressions.Expression * System.Reflection.MethodInfo * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.Call (instance, method, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="instance">
          <span data-ttu-id="f7da9-656">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> igual a (passar <see langword="null" /> para um método <see langword="static" /> [<see langword="Shared" /> no Visual Basic]).</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-656">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> property equal to (pass <see langword="null" /> for a <see langword="static" /> (<see langword="Shared" /> in Visual Basic) method).</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="f7da9-657">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-657">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <param name="arguments">
          <span data-ttu-id="f7da9-658">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.Expression" /> a serem usados para preencher a coleção de <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-658">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-659">Cria um <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa uma chamada para um método que aceita argumentos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-659">Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents a call to a method that takes arguments.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-660">Um <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> e as propriedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />, <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> e <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-660">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />, <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />, and <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-661">Para representar uma chamada para um `static` (`Shared` no Visual Basic) método, passe `null` para o `instance` parâmetro ao chamar esse método, ou chamar <xref:System.Linq.Expressions.Expression.Call%2A> em vez disso.</span><span class="sxs-lookup"><span data-stu-id="f7da9-661">To represent a call to a `static` (`Shared` in Visual Basic) method, pass in `null` for the `instance` parameter when you call this method, or call <xref:System.Linq.Expressions.Expression.Call%2A> instead.</span></span>  
  
 <span data-ttu-id="f7da9-662">Se `method` representa um método de instância, o <xref:System.Linq.Expressions.Expression.Type%2A> propriedade de `instance` deve ser atribuível ao tipo de declaração do método representado por `method`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-662">If `method` represents an instance method, the <xref:System.Linq.Expressions.Expression.Type%2A> property of `instance` must be assignable to the declaring type of the method represented by `method`.</span></span>  
  
 <span data-ttu-id="f7da9-663">Se `arguments` não é `null`, ele deve ter o mesmo número de elementos que o número de parâmetros para o método representado por `method`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-663">If `arguments` is not `null`, it must have the same number of elements as the number of parameters for the method represented by `method`.</span></span> <span data-ttu-id="f7da9-664">Cada elemento na `arguments` não deve ser `null` e deve ser atribuível ao parâmetro correspondente do `method`, possivelmente após *citando*.</span><span class="sxs-lookup"><span data-stu-id="f7da9-664">Each element in `arguments` must not be `null` and must be assignable to the corresponding parameter of `method`, possibly after *quoting*.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f7da9-665">Um elemento será ser colocado entre aspas somente se o parâmetro do método correspondente é do tipo <xref:System.Linq.Expressions.Expression>.</span><span class="sxs-lookup"><span data-stu-id="f7da9-665">An element will be quoted only if the corresponding method parameter is of type <xref:System.Linq.Expressions.Expression>.</span></span> <span data-ttu-id="f7da9-666">Delimitação significa que o elemento é encapsulado em um <xref:System.Linq.Expressions.ExpressionType.Quote> nó.</span><span class="sxs-lookup"><span data-stu-id="f7da9-666">Quoting means the element is wrapped in a <xref:System.Linq.Expressions.ExpressionType.Quote> node.</span></span> <span data-ttu-id="f7da9-667">O nó resultante é um <xref:System.Linq.Expressions.UnaryExpression> cujos <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> propriedade é o elemento de `arguments`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-667">The resulting node is a <xref:System.Linq.Expressions.UnaryExpression> whose <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> property is the element of `arguments`.</span></span>  
  
 <span data-ttu-id="f7da9-668">O <xref:System.Linq.Expressions.MethodCallExpression.Arguments%2A> propriedade resultantes <xref:System.Linq.Expressions.MethodCallExpression> está vazia se `arguments` é `null`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-668">The <xref:System.Linq.Expressions.MethodCallExpression.Arguments%2A> property of the resulting <xref:System.Linq.Expressions.MethodCallExpression> is empty if `arguments` is `null`.</span></span> <span data-ttu-id="f7da9-669">Caso contrário, ele contém os mesmos elementos que `arguments`, algumas das quais podem ser colocado entre aspas.</span><span class="sxs-lookup"><span data-stu-id="f7da9-669">Otherwise, it contains the same elements as `arguments`, some of which may be quoted.</span></span>  
  
 <span data-ttu-id="f7da9-670">O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade resultantes <xref:System.Linq.Expressions.MethodCallExpression> é igual ao tipo de retorno do método representado por `method`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-670">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.MethodCallExpression> is equal to the return type of the method represented by `method`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f7da9-671">
            <paramref name="method" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-671">
              <paramref name="method" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="f7da9-672">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-672">-or-</span>
          </span>
          <span data-ttu-id="f7da9-673">
            <paramref name="instance" /> é <see langword="null" /> e <paramref name="method" /> representa um método de instância.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-673">
              <paramref name="instance" /> is <see langword="null" /> and <paramref name="method" /> represents an instance method.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f7da9-674">
            <paramref name="instance" />. O tipo não é atribuível ao tipo de declaração de método representada pelo <paramref name="method" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-674">
              <paramref name="instance" />.Type is not assignable to the declaring type of the method represented by <paramref name="method" />.</span>
          </span>
          <span data-ttu-id="f7da9-675">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-675">-or-</span>
          </span>
          <span data-ttu-id="f7da9-676">O número de elementos em <paramref name="arguments" /> não é igual ao número de parâmetros para o método representado por <paramref name="method" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-676">The number of elements in <paramref name="arguments" /> does not equal the number of parameters for the method represented by <paramref name="method" />.</span>
          </span>
          <span data-ttu-id="f7da9-677">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-677">-or-</span>
          </span>
          <span data-ttu-id="f7da9-678">Um ou mais dos elementos de <paramref name="arguments" /> não é atribuível ao parâmetro correspondente para o método representado por <paramref name="method" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-678">One or more of the elements of <paramref name="arguments" /> is not assignable to the corresponding parameter for the method represented by <paramref name="method" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Linq.Expressions.Expression instance, System.Reflection.MethodInfo method, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Linq.Expressions.Expression instance, class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (instance As Expression, method As MethodInfo, ParamArray arguments As Expression()) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Linq::Expressions::Expression ^ instance, System::Reflection::MethodInfo ^ method, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Call : System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.Call (instance, method, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="instance">
          <span data-ttu-id="f7da9-679">Um <see cref="T:System.Linq.Expressions.Expression" /> que especifica a instância de uma chamada de método de instância (passa <see langword="null" /> para um método <see langword="static" /> (<see langword="Shared" /> no Visual Basic)).</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-679">An <see cref="T:System.Linq.Expressions.Expression" /> that specifies the instance for an instance method call (pass <see langword="null" /> for a <see langword="static" /> (<see langword="Shared" /> in Visual Basic) method).</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="f7da9-680">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-680">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <param name="arguments">
          <span data-ttu-id="f7da9-681">Uma matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> a serem usados para popular a coleção de <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-681">An array of <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-682">Cria um <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa uma chamada para um método que aceita argumentos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-682">Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents a call to a method that takes arguments.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-683">Um <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> e as propriedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />, <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> e <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-683">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />, <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />, and <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-684">Para representar uma chamada para um `static` (`Shared` no Visual Basic) método, passe `null` para o `instance` parâmetro ao chamar esse método, ou chamar <xref:System.Linq.Expressions.Expression.Call%2A> em vez disso.</span><span class="sxs-lookup"><span data-stu-id="f7da9-684">To represent a call to a `static` (`Shared` in Visual Basic) method, pass in `null` for the `instance` parameter when you call this method, or call <xref:System.Linq.Expressions.Expression.Call%2A> instead.</span></span>  
  
 <span data-ttu-id="f7da9-685">Se `method` representa um método de instância, o <xref:System.Linq.Expressions.Expression.Type%2A> propriedade de `instance` deve ser atribuível ao tipo de declaração do método representado por `method`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-685">If `method` represents an instance method, the <xref:System.Linq.Expressions.Expression.Type%2A> property of `instance` must be assignable to the declaring type of the method represented by `method`.</span></span>  
  
 <span data-ttu-id="f7da9-686">Se `arguments` não é `null`, ele deve ter o mesmo número de elementos que o número de parâmetros para o método representado por `method`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-686">If `arguments` is not `null`, it must have the same number of elements as the number of parameters for the method represented by `method`.</span></span> <span data-ttu-id="f7da9-687">Cada elemento na `arguments` não deve ser `null` e deve ser atribuível ao parâmetro correspondente do `method`, possivelmente após *citando*.</span><span class="sxs-lookup"><span data-stu-id="f7da9-687">Each element in `arguments` must not be `null` and must be assignable to the corresponding parameter of `method`, possibly after *quoting*.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f7da9-688">Um elemento será ser colocado entre aspas somente se o parâmetro do método correspondente é do tipo <xref:System.Linq.Expressions.Expression>.</span><span class="sxs-lookup"><span data-stu-id="f7da9-688">An element will be quoted only if the corresponding method parameter is of type <xref:System.Linq.Expressions.Expression>.</span></span> <span data-ttu-id="f7da9-689">Delimitação significa que o elemento é encapsulado em um <xref:System.Linq.Expressions.ExpressionType.Quote> nó.</span><span class="sxs-lookup"><span data-stu-id="f7da9-689">Quoting means the element is wrapped in a <xref:System.Linq.Expressions.ExpressionType.Quote> node.</span></span> <span data-ttu-id="f7da9-690">O nó resultante é um <xref:System.Linq.Expressions.UnaryExpression> cujos <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> propriedade é o elemento de `arguments`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-690">The resulting node is a <xref:System.Linq.Expressions.UnaryExpression> whose <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> property is the element of `arguments`.</span></span>  
  
 <span data-ttu-id="f7da9-691">O <xref:System.Linq.Expressions.MethodCallExpression.Arguments%2A> propriedade resultantes <xref:System.Linq.Expressions.MethodCallExpression> está vazia se `arguments` é `null`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-691">The <xref:System.Linq.Expressions.MethodCallExpression.Arguments%2A> property of the resulting <xref:System.Linq.Expressions.MethodCallExpression> is empty if `arguments` is `null`.</span></span> <span data-ttu-id="f7da9-692">Caso contrário, ele contém os mesmos elementos que `arguments`, algumas das quais podem ser colocado entre aspas.</span><span class="sxs-lookup"><span data-stu-id="f7da9-692">Otherwise, it contains the same elements as `arguments`, some of which may be quoted.</span></span>  
  
 <span data-ttu-id="f7da9-693">O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade resultantes <xref:System.Linq.Expressions.MethodCallExpression> é igual ao tipo de retorno do método representado por `method`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-693">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.MethodCallExpression> is equal to the return type of the method represented by `method`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f7da9-694">
            <paramref name="method" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-694">
              <paramref name="method" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="f7da9-695">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-695">-or-</span>
          </span>
          <span data-ttu-id="f7da9-696">
            <paramref name="instance" /> é <see langword="null" /> e <paramref name="method" /> representa um método de instância.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-696">
              <paramref name="instance" /> is <see langword="null" /> and <paramref name="method" /> represents an instance method.</span>
          </span>
          <span data-ttu-id="f7da9-697">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-697">-or-</span>
          </span>
          <span data-ttu-id="f7da9-698">
            <paramref name="arguments" /> não é <see langword="null" /> e um ou mais dos seus elementos é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-698">
              <paramref name="arguments" /> is not <see langword="null" /> and one or more of its elements is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f7da9-699">
            <paramref name="instance" />. O tipo não é atribuível ao tipo de declaração de método representada pelo <paramref name="method" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-699">
              <paramref name="instance" />.Type is not assignable to the declaring type of the method represented by <paramref name="method" />.</span>
          </span>
          <span data-ttu-id="f7da9-700">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-700">-or-</span>
          </span>
          <span data-ttu-id="f7da9-701">O número de elementos em <paramref name="arguments" /> não é igual ao número de parâmetros para o método representado por <paramref name="method" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-701">The number of elements in <paramref name="arguments" /> does not equal the number of parameters for the method represented by <paramref name="method" />.</span>
          </span>
          <span data-ttu-id="f7da9-702">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-702">-or-</span>
          </span>
          <span data-ttu-id="f7da9-703">Um ou mais dos elementos de <paramref name="arguments" /> não é atribuível ao parâmetro correspondente para o método representado por <paramref name="method" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-703">One or more of the elements of <paramref name="arguments" /> is not assignable to the corresponding parameter for the method represented by <paramref name="method" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Reflection.MethodInfo method, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (method As MethodInfo, arg0 As Expression, arg1 As Expression) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Reflection::MethodInfo ^ method, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1);" />
      <MemberSignature Language="F#" Value="static member Call : System.Reflection.MethodInfo * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.Call (method, arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="method">
          <span data-ttu-id="f7da9-704">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-704">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <param name="arg0">
          <span data-ttu-id="f7da9-705">O <see cref="T:System.Linq.Expressions.Expression" /> que representa o primeiro argumento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-705">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the first argument.</span>
          </span>
        </param>
        <param name="arg1">
          <span data-ttu-id="f7da9-706">O <see cref="T:System.Linq.Expressions.Expression" /> que representa o segundo argumento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-706">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the second argument.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-707">Cria um <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa uma chamada para um método estático que aceita dois argumentos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-707">Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents a call to a static method that takes two arguments.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-708">Um <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> e as propriedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> e <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-708">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> and <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f7da9-709">
            <paramref name="method" /> é nulo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-709">
              <paramref name="method" /> is null.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Linq.Expressions.Expression instance, System.Reflection.MethodInfo method, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Linq.Expressions.Expression instance, class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (instance As Expression, method As MethodInfo, arg0 As Expression, arg1 As Expression) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Linq::Expressions::Expression ^ instance, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1);" />
      <MemberSignature Language="F#" Value="static member Call : System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.Call (instance, method, arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="instance">
          <span data-ttu-id="f7da9-710">Um <see cref="T:System.Linq.Expressions.Expression" /> que especifica a instância de uma chamada de instância.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-710">An <see cref="T:System.Linq.Expressions.Expression" /> that specifies the instance for an instance call.</span>
          </span>
          <span data-ttu-id="f7da9-711">(passar nulo para um método estático [compartilhado no Visual Basic]).</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-711">(pass null for a static (Shared in Visual Basic) method).</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="f7da9-712">O <see cref="T:System.Reflection.MethodInfo" /> que representa o método de destino.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-712">The <see cref="T:System.Reflection.MethodInfo" /> that represents the target method.</span>
          </span>
        </param>
        <param name="arg0">
          <span data-ttu-id="f7da9-713">O <see cref="T:System.Linq.Expressions.Expression" /> que representa o primeiro argumento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-713">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the first argument.</span>
          </span>
        </param>
        <param name="arg1">
          <span data-ttu-id="f7da9-714">O <see cref="T:System.Linq.Expressions.Expression" /> que representa o segundo argumento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-714">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the second argument.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-715">Cria um <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa uma chamada para um método que aceita dois argumentos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-715">Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents a call to a method that takes two arguments.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-716">Um <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> e as propriedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> e <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-716">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> and <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="f7da9-717">O exemplo de código a seguir mostra como criar uma expressão que chama um método de instância que tem dois argumentos.</span><span class="sxs-lookup"><span data-stu-id="f7da9-717">The following code example shows how to create an expression that calls an instance method that has two arguments.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#17)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#17)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Linq.Expressions.Expression instance, string methodName, Type[] typeArguments, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Linq.Expressions.Expression instance, string methodName, class System.Type[] typeArguments, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.String,System.Type[],System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (instance As Expression, methodName As String, typeArguments As Type(), ParamArray arguments As Expression()) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Linq::Expressions::Expression ^ instance, System::String ^ methodName, cli::array &lt;Type ^&gt; ^ typeArguments, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Call : System.Linq.Expressions.Expression * string * Type[] * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.Call (instance, methodName, typeArguments, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="methodName" Type="System.String" />
        <Parameter Name="typeArguments" Type="System.Type[]" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="instance">
          <span data-ttu-id="f7da9-718">Um <see cref="T:System.Linq.Expressions.Expression" /> cujo valor da propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> será pesquisado quanto a um método específico.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-718">An <see cref="T:System.Linq.Expressions.Expression" /> whose <see cref="P:System.Linq.Expressions.Expression.Type" /> property value will be searched for a specific method.</span>
          </span>
        </param>
        <param name="methodName">
          <span data-ttu-id="f7da9-719">O nome do método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-719">The name of the method.</span>
          </span>
        </param>
        <param name="typeArguments">
          <span data-ttu-id="f7da9-720">Uma matriz de objetos <see cref="T:System.Type" /> que especificam os parâmetros de tipo do método genérico.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-720">An array of <see cref="T:System.Type" /> objects that specify the type parameters of the generic method.</span>
          </span>
          <span data-ttu-id="f7da9-721">Esse argumento deve ser nulo quando methodName especifica um método não genérico.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-721">This argument should be null when methodName specifies a non-generic method.</span>
          </span>
        </param>
        <param name="arguments">
          <span data-ttu-id="f7da9-722">Uma matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> que representa os argumentos para o método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-722">An array of <see cref="T:System.Linq.Expressions.Expression" /> objects that represents the arguments to the method.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-723">Cria um <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa uma chamada para um método chamando o método de fábrica apropriado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-723">Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents a call to a method by calling the appropriate factory method.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-724">Um <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Call" />, a propriedade <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> igual a <paramref name="instance" />, <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> definido como o <see cref="T:System.Reflection.MethodInfo" /> que representa o método de instância especificado e <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> definido como os argumentos especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-724">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" />, the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> property equal to <paramref name="instance" />, <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> set to the <see cref="T:System.Reflection.MethodInfo" /> that represents the specified instance method, and <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> set to the specified arguments.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-725">O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade resultantes <xref:System.Linq.Expressions.MethodCallExpression> é igual ao tipo de retorno do método indicado pelo `methodName`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-725">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.MethodCallExpression> is equal to the return type of the method denoted by `methodName`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f7da9-726">
            <paramref name="instance" /> ou <paramref name="methodName" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-726">
              <paramref name="instance" /> or <paramref name="methodName" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f7da9-727">Nenhum método cujo nome é <paramref name="methodName" />, cujos parâmetros de tipo correspondem a <paramref name="typeArguments" /> e cujos tipos de parâmetro correspondem a <paramref name="arguments" /> foi encontrado em <paramref name="instance" />.Type ou em seus tipos base.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-727">No method whose name is <paramref name="methodName" />, whose type parameters match <paramref name="typeArguments" />, and whose parameter types match <paramref name="arguments" /> is found in <paramref name="instance" />.Type or its base types.</span>
          </span>
          <span data-ttu-id="f7da9-728">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-728">-or-</span>
          </span>
          <span data-ttu-id="f7da9-729">Mais de um método cujo nome é <paramref name="methodName" />, cujos parâmetros de tipo correspondem a <paramref name="typeArguments" /> e cujos tipos de parâmetro correspondem a <paramref name="arguments" /> foi encontrado em <paramref name="instance" />.Type ou em seus tipos base.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-729">More than one method whose name is <paramref name="methodName" />, whose type parameters match <paramref name="typeArguments" />, and whose parameter types match <paramref name="arguments" /> is found in <paramref name="instance" />.Type or its base types.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Reflection.MethodInfo method, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (method As MethodInfo, arg0 As Expression, arg1 As Expression, arg2 As Expression) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Reflection::MethodInfo ^ method, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2);" />
      <MemberSignature Language="F#" Value="static member Call : System.Reflection.MethodInfo * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.Call (method, arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="method">
          <span data-ttu-id="f7da9-730">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-730">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <param name="arg0">
          <span data-ttu-id="f7da9-731">O <see cref="T:System.Linq.Expressions.Expression" /> que representa o primeiro argumento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-731">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the first argument.</span>
          </span>
        </param>
        <param name="arg1">
          <span data-ttu-id="f7da9-732">O <see cref="T:System.Linq.Expressions.Expression" /> que representa o segundo argumento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-732">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the second argument.</span>
          </span>
        </param>
        <param name="arg2">
          <span data-ttu-id="f7da9-733">O <see cref="T:System.Linq.Expressions.Expression" /> que representa o terceiro argumento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-733">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the third argument.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-734">Cria uma <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa uma chamada para um método estático que usa três argumentos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-734">Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents a call to a static method that takes three arguments.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-735">Um <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> e as propriedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> e <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-735">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> and <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f7da9-736">
            <paramref name="method" /> é nulo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-736">
              <paramref name="method" /> is null.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (Type type, string methodName, Type[] typeArguments, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Type type, string methodName, class System.Type[] typeArguments, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Type,System.String,System.Type[],System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(Type ^ type, System::String ^ methodName, cli::array &lt;Type ^&gt; ^ typeArguments, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Call : Type * string * Type[] * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.Call (type, methodName, typeArguments, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="methodName" Type="System.String" />
        <Parameter Name="typeArguments" Type="System.Type[]" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="type">
          <span data-ttu-id="f7da9-737">O <see cref="T:System.Type" /> que especifica o tipo que contém o método <see langword="static" /> especificado (<see langword="Shared" /> no Visual Basic).</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-737">The <see cref="T:System.Type" /> that specifies the type that contains the specified <see langword="static" /> (<see langword="Shared" /> in Visual Basic) method.</span>
          </span>
        </param>
        <param name="methodName">
          <span data-ttu-id="f7da9-738">O nome do método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-738">The name of the method.</span>
          </span>
        </param>
        <param name="typeArguments">
          <span data-ttu-id="f7da9-739">Uma matriz de objetos <see cref="T:System.Type" /> que especificam os parâmetros de tipo do método genérico.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-739">An array of <see cref="T:System.Type" /> objects that specify the type parameters of the generic method.</span>
          </span>
          <span data-ttu-id="f7da9-740">Esse argumento deve ser nulo quando methodName especifica um método não genérico.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-740">This argument should be null when methodName specifies a non-generic method.</span>
          </span>
        </param>
        <param name="arguments">
          <span data-ttu-id="f7da9-741">Uma matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> que representam os argumentos para o método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-741">An array of <see cref="T:System.Linq.Expressions.Expression" /> objects that represent the arguments to the method.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-742">Cria um <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa uma chamada para um método <see langword="static" /> (<see langword="Shared" /> no Visual Basic) chamando o método de fábrica apropriado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-742">Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents a call to a <see langword="static" /> (<see langword="Shared" /> in Visual Basic) method by calling the appropriate factory method.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-743">Um <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Call" />, a propriedade <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> definida como o <see cref="T:System.Reflection.MethodInfo" /> que representa o método <see langword="static" /> especificado (<see langword="Shared" /> no Visual Basic) e a propriedade <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> definida como os argumentos especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-743">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" />, the <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> property set to the <see cref="T:System.Reflection.MethodInfo" /> that represents the specified <see langword="static" /> (<see langword="Shared" /> in Visual Basic) method, and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> property set to the specified arguments.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-744">O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade resultantes <xref:System.Linq.Expressions.MethodCallExpression> é igual ao tipo de retorno do método indicado pelo `methodName`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-744">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.MethodCallExpression> is equal to the return type of the method denoted by `methodName`.</span></span> <span data-ttu-id="f7da9-745">A propriedade <xref:System.Linq.Expressions.MethodCallExpression.Object%2A> é `null`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-745">The <xref:System.Linq.Expressions.MethodCallExpression.Object%2A> property is `null`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f7da9-746">
            <paramref name="type" /> ou <paramref name="methodName" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-746">
              <paramref name="type" /> or <paramref name="methodName" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f7da9-747">Nenhum método cujo nome é <paramref name="methodName" />, cujos parâmetros de tipo correspondem a <paramref name="typeArguments" /> e cujos tipos de parâmetro correspondem a <paramref name="arguments" /> foi encontrado em <paramref name="type" /> ou em seus tipos base.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-747">No method whose name is <paramref name="methodName" />, whose type parameters match <paramref name="typeArguments" />, and whose parameter types match <paramref name="arguments" /> is found in <paramref name="type" /> or its base types.</span>
          </span>
          <span data-ttu-id="f7da9-748">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-748">-or-</span>
          </span>
          <span data-ttu-id="f7da9-749">Mais de um método cujo nome é <paramref name="methodName" />, cujos parâmetros de tipo correspondem a <paramref name="typeArguments" /> e cujos tipos de parâmetro correspondem a <paramref name="arguments" /> foi encontrado em <paramref name="type" /> ou em seus tipos base.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-749">More than one method whose name is <paramref name="methodName" />, whose type parameters match <paramref name="typeArguments" />, and whose parameter types match <paramref name="arguments" /> is found in <paramref name="type" /> or its base types.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Linq.Expressions.Expression instance, System.Reflection.MethodInfo method, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Linq.Expressions.Expression instance, class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (instance As Expression, method As MethodInfo, arg0 As Expression, arg1 As Expression, arg2 As Expression) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Linq::Expressions::Expression ^ instance, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2);" />
      <MemberSignature Language="F#" Value="static member Call : System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.Call (instance, method, arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="instance">
          <span data-ttu-id="f7da9-750">Um <see cref="T:System.Linq.Expressions.Expression" /> que especifica a instância de uma chamada de instância.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-750">An <see cref="T:System.Linq.Expressions.Expression" /> that specifies the instance for an instance call.</span>
          </span>
          <span data-ttu-id="f7da9-751">(passar nulo para um método estático [compartilhado no Visual Basic]).</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-751">(pass null for a static (Shared in Visual Basic) method).</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="f7da9-752">O <see cref="T:System.Reflection.MethodInfo" /> que representa o método de destino.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-752">The <see cref="T:System.Reflection.MethodInfo" /> that represents the target method.</span>
          </span>
        </param>
        <param name="arg0">
          <span data-ttu-id="f7da9-753">O <see cref="T:System.Linq.Expressions.Expression" /> que representa o primeiro argumento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-753">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the first argument.</span>
          </span>
        </param>
        <param name="arg1">
          <span data-ttu-id="f7da9-754">O <see cref="T:System.Linq.Expressions.Expression" /> que representa o segundo argumento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-754">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the second argument.</span>
          </span>
        </param>
        <param name="arg2">
          <span data-ttu-id="f7da9-755">O <see cref="T:System.Linq.Expressions.Expression" /> que representa o terceiro argumento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-755">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the third argument.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-756">Cria uma <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa uma chamada para um método que usa três argumentos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-756">Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents a call to a method that takes three arguments.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-757">Um <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> e as propriedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> e <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-757">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> and <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Reflection.MethodInfo method, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2, System.Linq.Expressions.Expression arg3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2, class System.Linq.Expressions.Expression arg3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (method As MethodInfo, arg0 As Expression, arg1 As Expression, arg2 As Expression, arg3 As Expression) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Reflection::MethodInfo ^ method, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2, System::Linq::Expressions::Expression ^ arg3);" />
      <MemberSignature Language="F#" Value="static member Call : System.Reflection.MethodInfo * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.Call (method, arg0, arg1, arg2, arg3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg3" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="method">
          <span data-ttu-id="f7da9-758">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-758">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <param name="arg0">
          <span data-ttu-id="f7da9-759">O <see cref="T:System.Linq.Expressions.Expression" /> que representa o primeiro argumento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-759">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the first argument.</span>
          </span>
        </param>
        <param name="arg1">
          <span data-ttu-id="f7da9-760">O <see cref="T:System.Linq.Expressions.Expression" /> que representa o segundo argumento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-760">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the second argument.</span>
          </span>
        </param>
        <param name="arg2">
          <span data-ttu-id="f7da9-761">O <see cref="T:System.Linq.Expressions.Expression" /> que representa o terceiro argumento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-761">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the third argument.</span>
          </span>
        </param>
        <param name="arg3">
          <span data-ttu-id="f7da9-762">O <see cref="T:System.Linq.Expressions.Expression" /> que representa o quarto argumento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-762">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the fourth argument.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-763">Cria uma <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa uma chamada para um método estático que aceita quatro argumentos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-763">Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents a call to a static method that takes four arguments.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-764">Um <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> e as propriedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> e <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-764">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> and <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f7da9-765">
            <paramref name="method" /> é nulo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-765">
              <paramref name="method" /> is null.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Reflection.MethodInfo method, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2, System.Linq.Expressions.Expression arg3, System.Linq.Expressions.Expression arg4);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2, class System.Linq.Expressions.Expression arg3, class System.Linq.Expressions.Expression arg4) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (method As MethodInfo, arg0 As Expression, arg1 As Expression, arg2 As Expression, arg3 As Expression, arg4 As Expression) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Reflection::MethodInfo ^ method, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2, System::Linq::Expressions::Expression ^ arg3, System::Linq::Expressions::Expression ^ arg4);" />
      <MemberSignature Language="F#" Value="static member Call : System.Reflection.MethodInfo * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.Call (method, arg0, arg1, arg2, arg3, arg4)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg3" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg4" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="method">
          <span data-ttu-id="f7da9-766">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-766">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <param name="arg0">
          <span data-ttu-id="f7da9-767">O <see cref="T:System.Linq.Expressions.Expression" /> que representa o primeiro argumento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-767">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the first argument.</span>
          </span>
        </param>
        <param name="arg1">
          <span data-ttu-id="f7da9-768">O <see cref="T:System.Linq.Expressions.Expression" /> que representa o segundo argumento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-768">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the second argument.</span>
          </span>
        </param>
        <param name="arg2">
          <span data-ttu-id="f7da9-769">O <see cref="T:System.Linq.Expressions.Expression" /> que representa o terceiro argumento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-769">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the third argument.</span>
          </span>
        </param>
        <param name="arg3">
          <span data-ttu-id="f7da9-770">O <see cref="T:System.Linq.Expressions.Expression" /> que representa o quarto argumento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-770">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the fourth argument.</span>
          </span>
        </param>
        <param name="arg4">
          <span data-ttu-id="f7da9-771">O <see cref="T:System.Linq.Expressions.Expression" /> que representa o quinto argumento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-771">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the fifth argument.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-772">Cria uma <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa uma chamada para um método estático que aceita cinco argumentos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-772">Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents a call to a static method that takes five arguments.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-773">Um <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> e as propriedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> e <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-773">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> and <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f7da9-774">
            <paramref name="method" /> é nulo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-774">
              <paramref name="method" /> is null.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="CanReduce">
      <MemberSignature Language="C#" Value="public virtual bool CanReduce { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanReduce" />
      <MemberSignature Language="DocId" Value="P:System.Linq.Expressions.Expression.CanReduce" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CanReduce As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanReduce { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanReduce : bool" Usage="System.Linq.Expressions.Expression.CanReduce" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f7da9-775">Indica que o nó pode ser reduzido a um nó mais simples.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-775">Indicates that the node can be reduced to a simpler node.</span>
          </span>
          <span data-ttu-id="f7da9-776">Se isso retornar verdadeiro, Reduce() poderá ser chamado para produzir a forma reduzida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-776">If this returns true, Reduce() can be called to produce the reduced form.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="f7da9-777">True se o nó puder ser reduzido; caso contrário, false.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-777">True if the node can be reduced, otherwise false.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Catch">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f7da9-778">Cria uma <see cref="T:System.Linq.Expressions.CatchBlock" /> que representa uma instrução catch.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-778">Creates a <see cref="T:System.Linq.Expressions.CatchBlock" /> representing a catch statement.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Catch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.CatchBlock Catch (System.Linq.Expressions.ParameterExpression variable, System.Linq.Expressions.Expression body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.CatchBlock Catch(class System.Linq.Expressions.ParameterExpression variable, class System.Linq.Expressions.Expression body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Catch(System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Catch (variable As ParameterExpression, body As Expression) As CatchBlock" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::CatchBlock ^ Catch(System::Linq::Expressions::ParameterExpression ^ variable, System::Linq::Expressions::Expression ^ body);" />
      <MemberSignature Language="F#" Value="static member Catch : System.Linq.Expressions.ParameterExpression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.CatchBlock" Usage="System.Linq.Expressions.Expression.Catch (variable, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.CatchBlock</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variable" Type="System.Linq.Expressions.ParameterExpression" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="variable">
          <span data-ttu-id="f7da9-779">Uma <see cref="T:System.Linq.Expressions.ParameterExpression" /> que representa uma referência para o objeto <see cref="T:System.Exception" /> capturado por este manipulador.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-779">A <see cref="T:System.Linq.Expressions.ParameterExpression" /> representing a reference to the <see cref="T:System.Exception" /> object caught by this handler.</span>
          </span>
        </param>
        <param name="body">
          <span data-ttu-id="f7da9-780">O corpo da instrução catch.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-780">The body of the catch statement.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-781">Cria uma <see cref="T:System.Linq.Expressions.CatchBlock" /> que representa uma instrução catch com uma referência para o objeto <see cref="T:System.Exception" /> capturado para uso no corpo do manipulador.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-781">Creates a <see cref="T:System.Linq.Expressions.CatchBlock" /> representing a catch statement with a reference to the caught <see cref="T:System.Exception" /> object for use in the handler body.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-782">O <see cref="T:System.Linq.Expressions.CatchBlock" /> criado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-782">The created <see cref="T:System.Linq.Expressions.CatchBlock" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Catch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.CatchBlock Catch (Type type, System.Linq.Expressions.Expression body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.CatchBlock Catch(class System.Type type, class System.Linq.Expressions.Expression body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Catch(System.Type,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::CatchBlock ^ Catch(Type ^ type, System::Linq::Expressions::Expression ^ body);" />
      <MemberSignature Language="F#" Value="static member Catch : Type * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.CatchBlock" Usage="System.Linq.Expressions.Expression.Catch (type, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.CatchBlock</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="type">
          <span data-ttu-id="f7da9-783">O <see cref="P:System.Linq.Expressions.Expression.Type" /> de <see cref="T:System.Exception" /> que esse <see cref="T:System.Linq.Expressions.CatchBlock" /> tratará.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-783">The <see cref="P:System.Linq.Expressions.Expression.Type" /> of <see cref="T:System.Exception" /> this <see cref="T:System.Linq.Expressions.CatchBlock" /> will handle.</span>
          </span>
        </param>
        <param name="body">
          <span data-ttu-id="f7da9-784">O corpo da instrução catch.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-784">The body of the catch statement.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-785">Cria uma <see cref="T:System.Linq.Expressions.CatchBlock" /> que representa uma instrução catch.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-785">Creates a <see cref="T:System.Linq.Expressions.CatchBlock" /> representing a catch statement.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-786">O <see cref="T:System.Linq.Expressions.CatchBlock" /> criado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-786">The created <see cref="T:System.Linq.Expressions.CatchBlock" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-787">O <xref:System.Linq.Expressions.Expression.Type%2A> de <xref:System.Exception> ser capturada pode ser especificada, mas nenhuma referência para o <xref:System.Exception> objeto estará disponível para uso no <xref:System.Linq.Expressions.CatchBlock>.</span><span class="sxs-lookup"><span data-stu-id="f7da9-787">The <xref:System.Linq.Expressions.Expression.Type%2A> of <xref:System.Exception> to be caught can be specified but no reference to the <xref:System.Exception> object will be available for use in the <xref:System.Linq.Expressions.CatchBlock>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Catch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.CatchBlock Catch (System.Linq.Expressions.ParameterExpression variable, System.Linq.Expressions.Expression body, System.Linq.Expressions.Expression filter);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.CatchBlock Catch(class System.Linq.Expressions.ParameterExpression variable, class System.Linq.Expressions.Expression body, class System.Linq.Expressions.Expression filter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Catch(System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Catch (variable As ParameterExpression, body As Expression, filter As Expression) As CatchBlock" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::CatchBlock ^ Catch(System::Linq::Expressions::ParameterExpression ^ variable, System::Linq::Expressions::Expression ^ body, System::Linq::Expressions::Expression ^ filter);" />
      <MemberSignature Language="F#" Value="static member Catch : System.Linq.Expressions.ParameterExpression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.CatchBlock" Usage="System.Linq.Expressions.Expression.Catch (variable, body, filter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.CatchBlock</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variable" Type="System.Linq.Expressions.ParameterExpression" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="filter" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="variable">
          <span data-ttu-id="f7da9-788">Uma <see cref="T:System.Linq.Expressions.ParameterExpression" /> que representa uma referência para o objeto <see cref="T:System.Exception" /> capturado por este manipulador.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-788">A <see cref="T:System.Linq.Expressions.ParameterExpression" /> representing a reference to the <see cref="T:System.Exception" /> object caught by this handler.</span>
          </span>
        </param>
        <param name="body">
          <span data-ttu-id="f7da9-789">O corpo da instrução catch.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-789">The body of the catch statement.</span>
          </span>
        </param>
        <param name="filter">
          <span data-ttu-id="f7da9-790">O corpo do filtro <see cref="T:System.Exception" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-790">The body of the <see cref="T:System.Exception" /> filter.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-791">Cria uma <see cref="T:System.Linq.Expressions.CatchBlock" /> que representa uma instrução catch com um filtro <see cref="T:System.Exception" /> e uma referência para o objeto <see cref="T:System.Exception" /> capturado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-791">Creates a <see cref="T:System.Linq.Expressions.CatchBlock" /> representing a catch statement with an <see cref="T:System.Exception" /> filter and a reference to the caught <see cref="T:System.Exception" /> object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-792">O <see cref="T:System.Linq.Expressions.CatchBlock" /> criado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-792">The created <see cref="T:System.Linq.Expressions.CatchBlock" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Catch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.CatchBlock Catch (Type type, System.Linq.Expressions.Expression body, System.Linq.Expressions.Expression filter);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.CatchBlock Catch(class System.Type type, class System.Linq.Expressions.Expression body, class System.Linq.Expressions.Expression filter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Catch(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::CatchBlock ^ Catch(Type ^ type, System::Linq::Expressions::Expression ^ body, System::Linq::Expressions::Expression ^ filter);" />
      <MemberSignature Language="F#" Value="static member Catch : Type * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.CatchBlock" Usage="System.Linq.Expressions.Expression.Catch (type, body, filter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.CatchBlock</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="filter" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="type">
          <span data-ttu-id="f7da9-793">O <see cref="P:System.Linq.Expressions.Expression.Type" /> de <see cref="T:System.Exception" /> que esse <see cref="T:System.Linq.Expressions.CatchBlock" /> tratará.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-793">The <see cref="P:System.Linq.Expressions.Expression.Type" /> of <see cref="T:System.Exception" /> this <see cref="T:System.Linq.Expressions.CatchBlock" /> will handle.</span>
          </span>
        </param>
        <param name="body">
          <span data-ttu-id="f7da9-794">O corpo da instrução catch.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-794">The body of the catch statement.</span>
          </span>
        </param>
        <param name="filter">
          <span data-ttu-id="f7da9-795">O corpo do filtro <see cref="T:System.Exception" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-795">The body of the <see cref="T:System.Exception" /> filter.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-796">Cria uma <see cref="T:System.Linq.Expressions.CatchBlock" /> que representa uma instrução catch com um filtro <see cref="T:System.Exception" />, mas nenhuma referência ao objeto <see cref="T:System.Exception" /> capturado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-796">Creates a <see cref="T:System.Linq.Expressions.CatchBlock" /> representing a catch statement with an <see cref="T:System.Exception" /> filter but no reference to the caught <see cref="T:System.Exception" /> object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-797">O <see cref="T:System.Linq.Expressions.CatchBlock" /> criado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-797">The created <see cref="T:System.Linq.Expressions.CatchBlock" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ClearDebugInfo">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DebugInfoExpression ClearDebugInfo (System.Linq.Expressions.SymbolDocumentInfo document);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DebugInfoExpression ClearDebugInfo(class System.Linq.Expressions.SymbolDocumentInfo document) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ClearDebugInfo(System.Linq.Expressions.SymbolDocumentInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ClearDebugInfo (document As SymbolDocumentInfo) As DebugInfoExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DebugInfoExpression ^ ClearDebugInfo(System::Linq::Expressions::SymbolDocumentInfo ^ document);" />
      <MemberSignature Language="F#" Value="static member ClearDebugInfo : System.Linq.Expressions.SymbolDocumentInfo -&gt; System.Linq.Expressions.DebugInfoExpression" Usage="System.Linq.Expressions.Expression.ClearDebugInfo document" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DebugInfoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="document" Type="System.Linq.Expressions.SymbolDocumentInfo" />
      </Parameters>
      <Docs>
        <param name="document">
          <span data-ttu-id="f7da9-798">O <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> que representa o arquivo de origem.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-798">The <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> that represents the source file.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-799">Cria uma <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> para limpar um ponto de sequência.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-799">Creates a <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> for clearing a sequence point.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-800">Uma instância de <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> para limpar um ponto de sequência.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-800">An instance of <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> for clearning a sequence point.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Coalesce">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f7da9-801">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de união.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-801">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a coalescing operation.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Coalesce">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Coalesce (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Coalesce(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Coalesce(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Coalesce (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Coalesce(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member Coalesce : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Coalesce (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="f7da9-802">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-802">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="f7da9-803">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-803">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-804">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de união.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-804">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a coalescing operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-805">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Coalesce" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-805">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Coalesce" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-806">O <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriedade resultantes <xref:System.Linq.Expressions.BinaryExpression> é `null` e ambas <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> e <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> são definidos como `false`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-806">The <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property of the resulting <xref:System.Linq.Expressions.BinaryExpression> is `null` and both <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> are set to `false`.</span></span> <span data-ttu-id="f7da9-807">O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade é igual ao tipo de resultado da operação de união.</span><span class="sxs-lookup"><span data-stu-id="f7da9-807">The <xref:System.Linq.Expressions.Expression.Type%2A> property is equal to the result type of the coalescing operation.</span></span> <span data-ttu-id="f7da9-808">A propriedade <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> é `null`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-808">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
#### <a name="result-type"></a><span data-ttu-id="f7da9-809">Tipo de resultado</span><span class="sxs-lookup"><span data-stu-id="f7da9-809">Result Type</span></span>  
 <span data-ttu-id="f7da9-810">As regras a seguir determinam o tipo de resultado:</span><span class="sxs-lookup"><span data-stu-id="f7da9-810">The following rules determine the result type:</span></span>  
  
-   <span data-ttu-id="f7da9-811">Se `left`. Tipo representa um tipo anulável e `right`. Tipo é implicitamente conversível para o tipo não anulável correspondente, o tipo de resultado é o equivalente não anulável de `left`. Tipo.</span><span class="sxs-lookup"><span data-stu-id="f7da9-811">If `left`.Type represents a nullable type and `right`.Type is implicitly convertible to the corresponding non-nullable type, the result type is the non-nullable equivalent of `left`.Type.</span></span>  
  
-   <span data-ttu-id="f7da9-812">Caso contrário, se `right`. Tipo é implicitamente conversível para `left`. Tipo, o tipo de resultado é `left`. Tipo.</span><span class="sxs-lookup"><span data-stu-id="f7da9-812">Otherwise, if `right`.Type is implicitly convertible to `left`.Type, the result type is `left`.Type.</span></span>  
  
-   <span data-ttu-id="f7da9-813">Caso contrário, se o equivalente não anulável de `left`. Tipo é implicitamente conversível para `right`. Tipo, o tipo de resultado é `right`. Tipo.</span><span class="sxs-lookup"><span data-stu-id="f7da9-813">Otherwise, if the non-nullable equivalent of `left`.Type is implicitly convertible to `right`.Type, the result type is `right`.Type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f7da9-814">
            <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-814">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f7da9-815">A propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> do <paramref name="left" /> não representa um tipo de referência nem um tipo de valor que permite um valor null.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-815">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of <paramref name="left" /> does not represent a reference type or a nullable value type.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f7da9-816">
            <paramref name="left" />.Type e <paramref name="right" />.Type não são conversíveis entre si.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-816">
              <paramref name="left" />.Type and <paramref name="right" />.Type are not convertible to each other.</span>
          </span>
        </exception>
        <related type="Article" href="https://msdn.microsoft.com/library/088b1f0d-c1af-4fe1-b4b8-196fd5ea9132">
          <span data-ttu-id="f7da9-817">??</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-817">??</span>
          </span>
          <span data-ttu-id="f7da9-818">Operador (Referência de C#)</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-818">Operator (C# Reference)</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="Coalesce">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Coalesce (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Coalesce(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Coalesce(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Coalesce (left As Expression, right As Expression, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Coalesce(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member Coalesce : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Coalesce (left, right, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="f7da9-819">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-819">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="f7da9-820">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-820">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="conversion">
          <span data-ttu-id="f7da9-821">Um <see cref="T:System.Linq.Expressions.LambdaExpression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-821">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-822">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de união, dada uma função de conversão.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-822">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a coalescing operation, given a conversion function.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-823">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Coalesce" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> definidas para os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-823">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Coalesce" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-824">O <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriedade resultantes <xref:System.Linq.Expressions.BinaryExpression> é `null` e ambas <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> e <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> são definidos como `false`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-824">The <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property of the resulting <xref:System.Linq.Expressions.BinaryExpression> is `null` and both <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> are set to `false`.</span></span>  
  
 <span data-ttu-id="f7da9-825">O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade resultantes <xref:System.Linq.Expressions.BinaryExpression> é igual ao tipo de resultado da operação de união.</span><span class="sxs-lookup"><span data-stu-id="f7da9-825">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.BinaryExpression> is equal to the result type of the coalescing operation.</span></span>  
  
 <span data-ttu-id="f7da9-826">As regras a seguir determinam o tipo de resultado:</span><span class="sxs-lookup"><span data-stu-id="f7da9-826">The following rules determine the result type:</span></span>  
  
-   <span data-ttu-id="f7da9-827">Se `left`. Tipo representa um tipo anulável e `right`. Tipo é implicitamente conversível para o tipo não anulável correspondente, o tipo de resultado é o equivalente não anulável de `left`. Tipo.</span><span class="sxs-lookup"><span data-stu-id="f7da9-827">If `left`.Type represents a nullable type and `right`.Type is implicitly convertible to the corresponding non-nullable type, the result type is the non-nullable equivalent of `left`.Type.</span></span>  
  
-   <span data-ttu-id="f7da9-828">Caso contrário, se `right`. Tipo é implicitamente conversível para `left`. Tipo, o tipo de resultado é `left`. Tipo.</span><span class="sxs-lookup"><span data-stu-id="f7da9-828">Otherwise, if `right`.Type is implicitly convertible to `left`.Type, the result type is `left`.Type.</span></span>  
  
-   <span data-ttu-id="f7da9-829">Caso contrário, se o equivalente não anulável de `left`. Tipo é implicitamente conversível para `right`. Tipo, o tipo de resultado é `right`. Tipo.</span><span class="sxs-lookup"><span data-stu-id="f7da9-829">Otherwise, if the non-nullable equivalent of `left`.Type is implicitly convertible to `right`.Type, the result type is `right`.Type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f7da9-830">
            <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-830">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f7da9-831">
            <paramref name="left" />.Type e <paramref name="right" />.Type não são conversíveis entre si.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-831">
              <paramref name="left" />.Type and <paramref name="right" />.Type are not convertible to each other.</span>
          </span>
          <span data-ttu-id="f7da9-832">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-832">-or-</span>
          </span>
          <span data-ttu-id="f7da9-833">
            <paramref name="conversion" /> não é <see langword="null" /> e <paramref name="conversion" />. O tipo é um tipo delegado que não aceita exatamente um argumento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-833">
              <paramref name="conversion" /> is not <see langword="null" /> and <paramref name="conversion" />.Type is a delegate type that does not take exactly one argument.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f7da9-834">A propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> do <paramref name="left" /> não representa um tipo de referência nem um tipo de valor que permite um valor null.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-834">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of <paramref name="left" /> does not represent a reference type or a nullable value type.</span>
          </span>
          <span data-ttu-id="f7da9-835">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-835">-or-</span>
          </span>
          <span data-ttu-id="f7da9-836">A propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> de <paramref name="left" /> representa um tipo que não é atribuível ao tipo de parâmetro do tipo delegado <paramref name="conversion" />.Type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-836">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of <paramref name="left" /> represents a type that is not assignable to the parameter type of the delegate type <paramref name="conversion" />.Type.</span>
          </span>
          <span data-ttu-id="f7da9-837">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-837">-or-</span>
          </span>
          <span data-ttu-id="f7da9-838">A propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> de <paramref name="right" /> não é igual ao tipo de retorno do tipo delegado <paramref name="conversion" />.Type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-838">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of <paramref name="right" /> is not equal to the return type of the delegate type <paramref name="conversion" />.Type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Condition">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f7da9-839">Cria um <see cref="T:System.Linq.Expressions.ConditionalExpression" /> que representa uma instrução condicional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-839">Creates a <see cref="T:System.Linq.Expressions.ConditionalExpression" /> that represents a conditional statement.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Condition">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ConditionalExpression Condition (System.Linq.Expressions.Expression test, System.Linq.Expressions.Expression ifTrue, System.Linq.Expressions.Expression ifFalse);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ConditionalExpression Condition(class System.Linq.Expressions.Expression test, class System.Linq.Expressions.Expression ifTrue, class System.Linq.Expressions.Expression ifFalse) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Condition(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Condition (test As Expression, ifTrue As Expression, ifFalse As Expression) As ConditionalExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ConditionalExpression ^ Condition(System::Linq::Expressions::Expression ^ test, System::Linq::Expressions::Expression ^ ifTrue, System::Linq::Expressions::Expression ^ ifFalse);" />
      <MemberSignature Language="F#" Value="static member Condition : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.ConditionalExpression" Usage="System.Linq.Expressions.Expression.Condition (test, ifTrue, ifFalse)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ConditionalExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="test" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="ifTrue" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="ifFalse" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="test">
          <span data-ttu-id="f7da9-840">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-840">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> property equal to.</span>
          </span>
        </param>
        <param name="ifTrue">
          <span data-ttu-id="f7da9-841">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-841">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> property equal to.</span>
          </span>
        </param>
        <param name="ifFalse">
          <span data-ttu-id="f7da9-842">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-842">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-843">Cria um <see cref="T:System.Linq.Expressions.ConditionalExpression" /> que representa uma instrução condicional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-843">Creates a <see cref="T:System.Linq.Expressions.ConditionalExpression" /> that represents a conditional statement.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-844">Um <see cref="T:System.Linq.Expressions.ConditionalExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> e as propriedades <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> e <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-844">A <see cref="T:System.Linq.Expressions.ConditionalExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> and the <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />, and <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-845">O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade resultantes <xref:System.Linq.Expressions.ConditionalExpression> é igual ao <xref:System.Linq.Expressions.Expression.Type%2A> propriedade `ifTrue`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-845">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.ConditionalExpression> is equal to the <xref:System.Linq.Expressions.Expression.Type%2A> property of `ifTrue`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f7da9-846">O exemplo de código a seguir mostra como criar uma expressão que representa uma instrução condicional.</span><span class="sxs-lookup"><span data-stu-id="f7da9-846">The following code example shows how to create an expression that represents a conditional statement.</span></span> <span data-ttu-id="f7da9-847">Se o primeiro argumento é avaliado como `true`, o segundo argumento é executado; caso contrário, o terceiro argumento é executado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-847">If the first argument evaluates to `true`, the second argument is executed; otherwise, the third argument is executed.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#3)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f7da9-848">
            <paramref name="test" />, <paramref name="ifTrue" /> ou <paramref name="ifFalse" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-848">
              <paramref name="test" /> or <paramref name="ifTrue" /> or <paramref name="ifFalse" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f7da9-849">
            <paramref name="test" />.Type não é <see cref="T:System.Boolean" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-849">
              <paramref name="test" />.Type is not <see cref="T:System.Boolean" />.</span>
          </span>
          <span data-ttu-id="f7da9-850">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-850">-or-</span>
          </span>
          <span data-ttu-id="f7da9-851">
            <paramref name="ifTrue" />.Type não é igual a <paramref name="ifFalse" />.Type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-851">
              <paramref name="ifTrue" />.Type is not equal to <paramref name="ifFalse" />.Type.</span>
          </span>
        </exception>
        <altmember cref="M:System.Linq.Expressions.Expression.IfThen(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
        <altmember cref="M:System.Linq.Expressions.Expression.IfThenElse(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      </Docs>
    </Member>
    <Member MemberName="Condition">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ConditionalExpression Condition (System.Linq.Expressions.Expression test, System.Linq.Expressions.Expression ifTrue, System.Linq.Expressions.Expression ifFalse, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ConditionalExpression Condition(class System.Linq.Expressions.Expression test, class System.Linq.Expressions.Expression ifTrue, class System.Linq.Expressions.Expression ifFalse, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Condition(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ConditionalExpression ^ Condition(System::Linq::Expressions::Expression ^ test, System::Linq::Expressions::Expression ^ ifTrue, System::Linq::Expressions::Expression ^ ifFalse, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Condition : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * Type -&gt; System.Linq.Expressions.ConditionalExpression" Usage="System.Linq.Expressions.Expression.Condition (test, ifTrue, ifFalse, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ConditionalExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="test" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="ifTrue" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="ifFalse" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="test">
          <span data-ttu-id="f7da9-852">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-852">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> property equal to.</span>
          </span>
        </param>
        <param name="ifTrue">
          <span data-ttu-id="f7da9-853">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-853">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> property equal to.</span>
          </span>
        </param>
        <param name="ifFalse">
          <span data-ttu-id="f7da9-854">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-854">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> property equal to.</span>
          </span>
        </param>
        <param name="type">
          <span data-ttu-id="f7da9-855">Um <see cref="P:System.Linq.Expressions.Expression.Type" /> para definir a propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-855">A <see cref="P:System.Linq.Expressions.Expression.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-856">Cria um <see cref="T:System.Linq.Expressions.ConditionalExpression" /> que representa uma instrução condicional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-856">Creates a <see cref="T:System.Linq.Expressions.ConditionalExpression" /> that represents a conditional statement.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-857">Um <see cref="T:System.Linq.Expressions.ConditionalExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> e as propriedades <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> e <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-857">A <see cref="T:System.Linq.Expressions.ConditionalExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> and the <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />, and <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-858">Esse método permite unificando explicitamente o tipo de resultado da expressão condicional em casos em que os tipos de `ifTrue` e `ifFalse` expressões não são iguais.</span><span class="sxs-lookup"><span data-stu-id="f7da9-858">This method allows explicitly unifying the result type of the conditional expression in cases where the types of `ifTrue` and `ifFalse` expressions are not equal.</span></span> <span data-ttu-id="f7da9-859">Tipos de ambos `ifTrue` e `ifFalse` deve ser implicitamente referência atribuível ao tipo de resultado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-859">Types of both `ifTrue` and `ifFalse` must be implicitly reference assignable to the result type.</span></span> <span data-ttu-id="f7da9-860">O `type` tem permissão para ser <xref:System.Void>.</span><span class="sxs-lookup"><span data-stu-id="f7da9-860">The `type` is allowed to be <xref:System.Void>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Constant">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f7da9-861">Cria um <see cref="T:System.Linq.Expressions.ConstantExpression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-861">Creates a <see cref="T:System.Linq.Expressions.ConstantExpression" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Constant">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ConstantExpression Constant (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ConstantExpression Constant(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Constant(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Constant (value As Object) As ConstantExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ConstantExpression ^ Constant(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member Constant : obj -&gt; System.Linq.Expressions.ConstantExpression" Usage="System.Linq.Expressions.Expression.Constant value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ConstantExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="f7da9-862">Um <see cref="T:System.Object" /> para definir a propriedade <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-862">An <see cref="T:System.Object" /> to set the <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-863">Cria uma <see cref="T:System.Linq.Expressions.ConstantExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> definida para o valor especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-863">Creates a <see cref="T:System.Linq.Expressions.ConstantExpression" /> that has the <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> property set to the specified value.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-864">Uma <see cref="T:System.Linq.Expressions.ConstantExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Constant" /> e a propriedade <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> definida para o valor especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-864">A <see cref="T:System.Linq.Expressions.ConstantExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Constant" /> and the <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> property set to the specified value.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-865">O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade resultantes <xref:System.Linq.Expressions.ConstantExpression> é igual ao tipo de `value`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-865">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.ConstantExpression> is equal to the type of `value`.</span></span> <span data-ttu-id="f7da9-866">Se `value` está `null`, <xref:System.Linq.Expressions.Expression.Type%2A> é igual a <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="f7da9-866">If `value` is `null`, <xref:System.Linq.Expressions.Expression.Type%2A> is equal to <xref:System.Object>.</span></span>  
  
 <span data-ttu-id="f7da9-867">Para representar `null`, você também pode usar o <xref:System.Linq.Expressions.Expression.Constant%28System.Object%2CSystem.Type%29> método, com a qual você pode especificar explicitamente o tipo.</span><span class="sxs-lookup"><span data-stu-id="f7da9-867">To represent `null`, you can also use the <xref:System.Linq.Expressions.Expression.Constant%28System.Object%2CSystem.Type%29> method, with which you can explicitly specify the type.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f7da9-868">O exemplo de código a seguir mostra como criar uma expressão que representa um valor constante.</span><span class="sxs-lookup"><span data-stu-id="f7da9-868">The following code example shows how to create an expression that represents a constant value.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#4)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Constant">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ConstantExpression Constant (object value, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ConstantExpression Constant(object value, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Constant(System.Object,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ConstantExpression ^ Constant(System::Object ^ value, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Constant : obj * Type -&gt; System.Linq.Expressions.ConstantExpression" Usage="System.Linq.Expressions.Expression.Constant (value, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ConstantExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="f7da9-869">Um <see cref="T:System.Object" /> para definir a propriedade <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-869">An <see cref="T:System.Object" /> to set the <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> property equal to.</span>
          </span>
        </param>
        <param name="type">
          <span data-ttu-id="f7da9-870">Um <see cref="T:System.Type" /> para definir a propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-870">A <see cref="T:System.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-871">Cria uma <see cref="T:System.Linq.Expressions.ConstantExpression" /> que tem as propriedades <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> e <see cref="P:System.Linq.Expressions.Expression.Type" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-871">Creates a <see cref="T:System.Linq.Expressions.ConstantExpression" /> that has the <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> and <see cref="P:System.Linq.Expressions.Expression.Type" /> properties set to the specified values.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-872">Um <see cref="T:System.Linq.Expressions.ConstantExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Constant" /> e as propriedades <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> e <see cref="P:System.Linq.Expressions.Expression.Type" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-872">A <see cref="T:System.Linq.Expressions.ConstantExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Constant" /> and the <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> and <see cref="P:System.Linq.Expressions.Expression.Type" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-873">Esse método pode ser útil para representar valores de tipos que permitem valor nulos.</span><span class="sxs-lookup"><span data-stu-id="f7da9-873">This method can be useful for representing values of nullable types.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f7da9-874">O exemplo de código a seguir mostra como criar uma expressão que representa uma constante do tipo que permite valor nulo e defina seu valor como `null`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-874">The following code example shows how to create an expression that represents a constant of the nullable type and set its value to `null`.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#22)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#22)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f7da9-875">
            <paramref name="type" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-875">
              <paramref name="type" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f7da9-876">
            <paramref name="value" /> não é <see langword="null" /> e <paramref name="type" /> não pode ser atribuído do tipo dinâmico de <paramref name="value" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-876">
              <paramref name="value" /> is not <see langword="null" /> and <paramref name="type" /> is not assignable from the dynamic type of <paramref name="value" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Continue">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f7da9-877">Cria uma <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa uma instrução continue.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-877">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a continue statement.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Continue">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Continue (System.Linq.Expressions.LabelTarget target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Continue(class System.Linq.Expressions.LabelTarget target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Continue(System.Linq.Expressions.LabelTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Continue (target As LabelTarget) As GotoExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Continue(System::Linq::Expressions::LabelTarget ^ target);" />
      <MemberSignature Language="F#" Value="static member Continue : System.Linq.Expressions.LabelTarget -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.Continue target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
      </Parameters>
      <Docs>
        <param name="target">
          <span data-ttu-id="f7da9-878">O <see cref="T:System.Linq.Expressions.LabelTarget" /> para o qual o <see cref="T:System.Linq.Expressions.GotoExpression" /> irá.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-878">The <see cref="T:System.Linq.Expressions.LabelTarget" /> that the <see cref="T:System.Linq.Expressions.GotoExpression" /> will jump to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-879">Cria uma <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa uma instrução continue.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-879">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a continue statement.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-880">Um <see cref="T:System.Linq.Expressions.GotoExpression" /> com <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Continue, a propriedade <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> definida para <paramref name="target" /> e um valor nulo a ser passado para o rótulo de destino ao saltar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-880">A <see cref="T:System.Linq.Expressions.GotoExpression" /> with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> equal to Continue, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> property set to <paramref name="target" />, and a null value to be passed to the target label upon jumping.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="f7da9-881">O exemplo a seguir demonstra como criar uma expressão de loop que usa o <xref:System.Linq.Expressions.Expression.Continue%2A> método.</span><span class="sxs-lookup"><span data-stu-id="f7da9-881">The following example demonstrates how to create a loop expression that uses the <xref:System.Linq.Expressions.Expression.Continue%2A> method.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#46](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#46)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#46](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#46)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Continue">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Continue (System.Linq.Expressions.LabelTarget target, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Continue(class System.Linq.Expressions.LabelTarget target, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Continue(System.Linq.Expressions.LabelTarget,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Continue(System::Linq::Expressions::LabelTarget ^ target, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Continue : System.Linq.Expressions.LabelTarget * Type -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.Continue (target, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="target">
          <span data-ttu-id="f7da9-882">O <see cref="T:System.Linq.Expressions.LabelTarget" /> para o qual o <see cref="T:System.Linq.Expressions.GotoExpression" /> irá.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-882">The <see cref="T:System.Linq.Expressions.LabelTarget" /> that the <see cref="T:System.Linq.Expressions.GotoExpression" /> will jump to.</span>
          </span>
        </param>
        <param name="type">
          <span data-ttu-id="f7da9-883">Um <see cref="T:System.Type" /> para definir a propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-883">An <see cref="T:System.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-884">Cria uma <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa uma instrução continue com o tipo especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-884">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a continue statement with the specified type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-885">Um <see cref="T:System.Linq.Expressions.GotoExpression" /> com <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Continue, a propriedade <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> definida para <paramref name="target" />, a propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> definida para <paramref name="type" /> e um valor nulo a ser passado para o rótulo de destino ao saltar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-885">A <see cref="T:System.Linq.Expressions.GotoExpression" /> with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> equal to Continue, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> property set to <paramref name="target" />, the <see cref="P:System.Linq.Expressions.Expression.Type" /> property set to <paramref name="type" />, and a null value to be passed to the target label upon jumping.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Convert">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f7da9-886">Cria um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa uma operação de conversão de tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-886">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a type conversion operation.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Convert">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Convert (System.Linq.Expressions.Expression expression, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Convert(class System.Linq.Expressions.Expression expression, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Convert(System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Convert(System::Linq::Expressions::Expression ^ expression, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Convert : System.Linq.Expressions.Expression * Type -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Convert (expression, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="expression">
          <span data-ttu-id="f7da9-887">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-887">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to.</span>
          </span>
        </param>
        <param name="type">
          <span data-ttu-id="f7da9-888">Um <see cref="T:System.Type" /> para definir a propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-888">A <see cref="T:System.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-889">Cria um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa uma operação de conversão de tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-889">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a type conversion operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-890">Um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Convert" /> e as propriedades <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> e <see cref="P:System.Linq.Expressions.Expression.Type" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-890">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Convert" /> and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> and <see cref="P:System.Linq.Expressions.Expression.Type" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-891">O <xref:System.Linq.Expressions.UnaryExpression.Method%2A> propriedade resultantes <xref:System.Linq.Expressions.UnaryExpression> é definido como o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-891">The <xref:System.Linq.Expressions.UnaryExpression.Method%2A> property of the resulting <xref:System.Linq.Expressions.UnaryExpression> is set to the implementing method.</span></span> <span data-ttu-id="f7da9-892">A propriedade <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> é `false`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-892">The <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> property is `false`.</span></span> <span data-ttu-id="f7da9-893">Se o nó é eliminado, <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> é `true`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-893">If the node is lifted, <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> is `true`.</span></span> <span data-ttu-id="f7da9-894">Caso contrário, será `false`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-894">Otherwise, it is `false`.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="f7da9-895">Implementando método</span><span class="sxs-lookup"><span data-stu-id="f7da9-895">Implementing Method</span></span>  
 <span data-ttu-id="f7da9-896">As regras a seguir determinam o método de implementação para a operação:</span><span class="sxs-lookup"><span data-stu-id="f7da9-896">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="f7da9-897">Se qualquer um dos `expression`. Tipo ou `type` é um tipo definido pelo usuário que define um operador de conversão implícita ou explícita, o <xref:System.Reflection.MethodInfo> que representa que o método de implementação do operador é.</span><span class="sxs-lookup"><span data-stu-id="f7da9-897">If either `expression`.Type or `type` is a user-defined type that defines an implicit or explicit conversion operator, the <xref:System.Reflection.MethodInfo> that represents that operator is the implementing method.</span></span>  
  
-   <span data-ttu-id="f7da9-898">Caso contrário:</span><span class="sxs-lookup"><span data-stu-id="f7da9-898">Otherwise:</span></span>  
  
    -   <span data-ttu-id="f7da9-899">Se ambos os `expression`. Tipo e `type` representam os tipos numéricos ou booleanos ou tipos de enumeração que permite valor nulo ou não anulável, o método de implementação é `null`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-899">If both `expression`.Type and `type` represent numeric or Boolean types, or nullable or non-nullable enumeration types, the implementing method is `null`.</span></span>  
  
    -   <span data-ttu-id="f7da9-900">Se qualquer um dos `expression`. Tipo ou `type` é um tipo de referência e uma conversão boxing explícita, conversão unboxing ou conversão de referência existe de `expression`. Digite para `type`, o método de implementação é `null`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-900">If either `expression`.Type or `type` is a reference type and an explicit boxing, unboxing, or reference conversion exists from `expression`.Type to `type`, the implementing method is `null`.</span></span>  
  
#### <a name="lifted-versus-non-lifted"></a><span data-ttu-id="f7da9-901">Com comparação de precisão x sem comparação de precisão</span><span class="sxs-lookup"><span data-stu-id="f7da9-901">Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="f7da9-902">Se o método de implementação não for `null`:</span><span class="sxs-lookup"><span data-stu-id="f7da9-902">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="f7da9-903">Se `expression`. O tipo é atribuível ao tipo de argumento do método de implementação e o tipo de retorno do método de implementação é atribuível ao `type`, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-903">If `expression`.Type is assignable to the argument type of the implementing method and the return type of the implementing method is assignable to `type`, the node is not lifted.</span></span>  
  
-   <span data-ttu-id="f7da9-904">Se uma ou ambas as de `expression`. Tipo ou `type` é um tipo de valor anulável e os tipos de valor não anulável correspondentes são iguais para o tipo de argumento e o tipo de retorno do método de implementação, respectivamente, o nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-904">If one or both of `expression`.Type or `type` is a nullable value type and the corresponding non-nullable value types are equal to the argument type and the return type of the implementing method respectively, the node is lifted.</span></span>  
  
 <span data-ttu-id="f7da9-905">Se o método de implementação é `null`:</span><span class="sxs-lookup"><span data-stu-id="f7da9-905">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="f7da9-906">Se ambos os `expression`. Tipo e `type` são não anuláveis, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-906">If both `expression`.Type and `type` are non-nullable, the node is not lifted.</span></span>  
  
-   <span data-ttu-id="f7da9-907">Caso contrário, o nó é eliminado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-907">Otherwise the node is lifted.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f7da9-908">O exemplo de código a seguir mostra como criar uma expressão que representa uma operação de conversão de tipo.</span><span class="sxs-lookup"><span data-stu-id="f7da9-908">The following code example shows how to create an expression that represents a type convertion operation.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#23)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#23)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f7da9-909">
            <paramref name="expression" /> ou <paramref name="type" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-909">
              <paramref name="expression" /> or <paramref name="type" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f7da9-910">Não há nenhum operador de conversão definido entre <paramref name="expression" />.Type e <paramref name="type" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-910">No conversion operator is defined between <paramref name="expression" />.Type and <paramref name="type" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Convert">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Convert (System.Linq.Expressions.Expression expression, Type type, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Convert(class System.Linq.Expressions.Expression expression, class System.Type type, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Convert(System.Linq.Expressions.Expression,System.Type,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Convert(System::Linq::Expressions::Expression ^ expression, Type ^ type, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member Convert : System.Linq.Expressions.Expression * Type * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Convert (expression, type, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">
          <span data-ttu-id="f7da9-911">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-911">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to.</span>
          </span>
        </param>
        <param name="type">
          <span data-ttu-id="f7da9-912">Um <see cref="T:System.Type" /> para definir a propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-912">A <see cref="T:System.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="f7da9-913">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-913">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-914">Cria um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa uma operação de conversão para a qual o método de implementação é especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-914">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a conversion operation for which the implementing method is specified.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-915">Um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Convert" /> e as propriedades <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />, <see cref="P:System.Linq.Expressions.Expression.Type" /> e <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-915">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Convert" /> and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />, <see cref="P:System.Linq.Expressions.Expression.Type" />, and <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-916">O <xref:System.Linq.Expressions.UnaryExpression.Method%2A> propriedade resultantes <xref:System.Linq.Expressions.UnaryExpression> é definido como o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-916">The <xref:System.Linq.Expressions.UnaryExpression.Method%2A> property of the resulting <xref:System.Linq.Expressions.UnaryExpression> is set to the implementing method.</span></span> <span data-ttu-id="f7da9-917">A propriedade <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> é `false`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-917">The <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> property is `false`.</span></span> <span data-ttu-id="f7da9-918">Se o nó é eliminado, <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> é `true`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-918">If the node is lifted, <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> is `true`.</span></span> <span data-ttu-id="f7da9-919">Caso contrário, será `false`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-919">Otherwise, it is `false`.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="f7da9-920">Implementando método</span><span class="sxs-lookup"><span data-stu-id="f7da9-920">Implementing Method</span></span>  
 <span data-ttu-id="f7da9-921">As regras a seguir determinam o método de implementação para a operação:</span><span class="sxs-lookup"><span data-stu-id="f7da9-921">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="f7da9-922">Se o método não é `null`, é o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-922">If method is not `null`, it is the implementing method.</span></span> <span data-ttu-id="f7da9-923">Ele deve representar um não-nulo, `static` (`Shared` no Visual Basic) método que aceita um argumento.</span><span class="sxs-lookup"><span data-stu-id="f7da9-923">It must represent a non-void, `static` (`Shared` in Visual Basic) method that takes one argument.</span></span>  
  
-   <span data-ttu-id="f7da9-924">Caso contrário, se qualquer um dos `expression`. Tipo ou `type` é um tipo definido pelo usuário que define um operador de conversão implícita ou explícita, o <xref:System.Reflection.MethodInfo> que representa que o método de implementação do operador é.</span><span class="sxs-lookup"><span data-stu-id="f7da9-924">Otherwise, if either `expression`.Type or `type` is a user-defined type that defines an implicit or explicit conversion operator, the <xref:System.Reflection.MethodInfo> that represents that operator is the implementing method.</span></span>  
  
-   <span data-ttu-id="f7da9-925">Caso contrário:</span><span class="sxs-lookup"><span data-stu-id="f7da9-925">Otherwise:</span></span>  
  
    -   <span data-ttu-id="f7da9-926">Se ambos os `expression`. Tipo e `type` representam os tipos numéricos ou booleanos ou tipos de enumeração que permite valor nulo ou não anulável, o método de implementação é `null`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-926">If both `expression`.Type and `type` represent numeric or Boolean types, or nullable or non-nullable enumeration types, the implementing method is `null`.</span></span>  
  
    -   <span data-ttu-id="f7da9-927">Se qualquer um dos `expression`. Tipo ou `type` é um tipo de referência e uma conversão boxing explícita, conversão unboxing ou conversão de referência existe de `expression`. Digite para `type`, o método de implementação é `null`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-927">If either `expression`.Type or `type` is a reference type and an explicit boxing, unboxing, or reference conversion exists from `expression`.Type to `type`, the implementing method is `null`.</span></span>  
  
#### <a name="lifted-versus-non-lifted"></a><span data-ttu-id="f7da9-928">Com comparação de precisão x sem comparação de precisão</span><span class="sxs-lookup"><span data-stu-id="f7da9-928">Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="f7da9-929">Se o método de implementação não for `null`:</span><span class="sxs-lookup"><span data-stu-id="f7da9-929">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="f7da9-930">Se `expression`. O tipo é atribuível ao tipo de argumento do método de implementação e o tipo de retorno do método de implementação é atribuível ao `type`, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-930">If `expression`.Type is assignable to the argument type of the implementing method and the return type of the implementing method is assignable to `type`, the node is not lifted.</span></span>  
  
-   <span data-ttu-id="f7da9-931">Se um ou ambos os de `expression`. Tipo ou `type` são um tipo de valor anulável e os tipos de valor não anulável correspondentes são iguais para o tipo de argumento e o tipo de retorno do método de implementação, respectivamente, o nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-931">If either or both of `expression`.Type or `type` are a nullable value type and the corresponding non-nullable value types are equal to the argument type and the return type of the implementing method respectively, the node is lifted.</span></span>  
  
 <span data-ttu-id="f7da9-932">Se o método de implementação é `null`:</span><span class="sxs-lookup"><span data-stu-id="f7da9-932">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="f7da9-933">Se ambos os `expression`. Tipo e `type` são não anuláveis, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-933">If both `expression`.Type and `type` are non-nullable, the node is not lifted.</span></span>  
  
-   <span data-ttu-id="f7da9-934">Caso contrário, o nó é eliminado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-934">Otherwise the node is lifted.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f7da9-935">
            <paramref name="expression" /> ou <paramref name="type" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-935">
              <paramref name="expression" /> or <paramref name="type" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f7da9-936">
            <paramref name="method" /> não é <see langword="null" /> e o método que ele representa retorna <see langword="void" />, não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) ou não tem exatamente um argumento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-936">
              <paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly one argument.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f7da9-937">Não há nenhum operador de conversão definido entre <paramref name="expression" />.Type e <paramref name="type" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-937">No conversion operator is defined between <paramref name="expression" />.Type and <paramref name="type" />.</span>
          </span>
          <span data-ttu-id="f7da9-938">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-938">-or-</span>
          </span>
          <span data-ttu-id="f7da9-939">
            <paramref name="expression" />.Type não é atribuível ao tipo de argumento do método representado pelo <paramref name="method" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-939">
              <paramref name="expression" />.Type is not assignable to the argument type of the method represented by <paramref name="method" />.</span>
          </span>
          <span data-ttu-id="f7da9-940">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-940">-or-</span>
          </span>
          <span data-ttu-id="f7da9-941">O tipo de retorno do método representado por <paramref name="method" /> não é atribuível ao <paramref name="type" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-941">The return type of the method represented by <paramref name="method" /> is not assignable to <paramref name="type" />.</span>
          </span>
          <span data-ttu-id="f7da9-942">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-942">-or-</span>
          </span>
          <span data-ttu-id="f7da9-943">
            <paramref name="expression" />.Type ou <paramref name="type" /> é um tipo de valor que permite valor nulo e o tipo de valor que não permite valor nulo correspondente não é igual ao tipo de argumento ou ao tipo de retorno, respectivamente, do método representado por <paramref name="method" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-943">
              <paramref name="expression" />.Type or <paramref name="type" /> is a nullable value type and the corresponding non-nullable value type does not equal the argument type or the return type, respectively, of the method represented by <paramref name="method" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">
          <span data-ttu-id="f7da9-944">Foi encontrado mais de um método que corresponde à descrição de <paramref name="method" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-944">More than one method that matches the <paramref name="method" /> description was found.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ConvertChecked">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f7da9-945">Cria uma <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa uma operação de conversão que lança uma exceção se o tipo de destino está estourado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-945">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a conversion operation that throws an exception if the target type is overflowed.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ConvertChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression ConvertChecked (System.Linq.Expressions.Expression expression, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression ConvertChecked(class System.Linq.Expressions.Expression expression, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ConvertChecked(System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ ConvertChecked(System::Linq::Expressions::Expression ^ expression, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member ConvertChecked : System.Linq.Expressions.Expression * Type -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.ConvertChecked (expression, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="expression">
          <span data-ttu-id="f7da9-946">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-946">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to.</span>
          </span>
        </param>
        <param name="type">
          <span data-ttu-id="f7da9-947">Um <see cref="T:System.Type" /> para definir a propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-947">A <see cref="T:System.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-948">Cria uma <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa uma operação de conversão que lança uma exceção se o tipo de destino está estourado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-948">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a conversion operation that throws an exception if the target type is overflowed.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-949">Um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.ConvertChecked" /> e as propriedades <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> e <see cref="P:System.Linq.Expressions.Expression.Type" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-949">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ConvertChecked" /> and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> and <see cref="P:System.Linq.Expressions.Expression.Type" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-950">O <xref:System.Linq.Expressions.UnaryExpression.Method%2A> propriedade resultantes <xref:System.Linq.Expressions.UnaryExpression> é definido como o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-950">The <xref:System.Linq.Expressions.UnaryExpression.Method%2A> property of the resulting <xref:System.Linq.Expressions.UnaryExpression> is set to the implementing method.</span></span> <span data-ttu-id="f7da9-951">A propriedade <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> é `false`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-951">The <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> property is `false`.</span></span> <span data-ttu-id="f7da9-952">Se o nó é eliminado, <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> é `true`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-952">If the node is lifted, <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> is `true`.</span></span> <span data-ttu-id="f7da9-953">Caso contrário, será `false`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-953">Otherwise, it is `false`.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="f7da9-954">Implementando método</span><span class="sxs-lookup"><span data-stu-id="f7da9-954">Implementing Method</span></span>  
 <span data-ttu-id="f7da9-955">As regras a seguir determinam o método de implementação para a operação:</span><span class="sxs-lookup"><span data-stu-id="f7da9-955">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="f7da9-956">Se qualquer um dos `expression`. Tipo ou `type` é um tipo definido pelo usuário que define um operador de conversão implícita ou explícita, o <xref:System.Reflection.MethodInfo> que representa que o método de implementação do operador é.</span><span class="sxs-lookup"><span data-stu-id="f7da9-956">If either `expression`.Type or `type` is a user-defined type that defines an implicit or explicit conversion operator, the <xref:System.Reflection.MethodInfo> that represents that operator is the implementing method.</span></span>  
  
-   <span data-ttu-id="f7da9-957">Caso contrário:</span><span class="sxs-lookup"><span data-stu-id="f7da9-957">Otherwise:</span></span>  
  
    -   <span data-ttu-id="f7da9-958">Se ambos os `expression`. Tipo e `type` representam os tipos numéricos ou booleanos ou tipos de enumeração que permite valor nulo ou não anulável, o método de implementação é `null`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-958">If both `expression`.Type and `type` represent numeric or Boolean types, or nullable or non-nullable enumeration types, the implementing method is `null`.</span></span>  
  
    -   <span data-ttu-id="f7da9-959">Se qualquer um dos `expression`. Tipo ou `type` é um tipo de referência e uma conversão boxing explícita, conversão unboxing ou conversão de referência existe de `expression`. Digite para `type`, o método de implementação é `null`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-959">If either `expression`.Type or `type` is a reference type and an explicit boxing, unboxing, or reference conversion exists from `expression`.Type to `type`, the implementing method is `null`.</span></span>  
  
#### <a name="lifted-versus-non-lifted"></a><span data-ttu-id="f7da9-960">Com comparação de precisão x sem comparação de precisão</span><span class="sxs-lookup"><span data-stu-id="f7da9-960">Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="f7da9-961">Se o método de implementação não for `null`:</span><span class="sxs-lookup"><span data-stu-id="f7da9-961">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="f7da9-962">Se `expression`. O tipo é atribuível ao tipo de argumento do método de implementação e o tipo de retorno do método de implementação é atribuível ao `type`, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-962">If `expression`.Type is assignable to the argument type of the implementing method and the return type of the implementing method is assignable to `type`, the node is not lifted.</span></span>  
  
-   <span data-ttu-id="f7da9-963">Se um ou ambos os de `expression`. Tipo ou `type` são um tipo de valor anulável e os tipos de valor não anulável correspondentes são iguais para o tipo de argumento e o tipo de retorno do método de implementação, respectivamente, o nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-963">If either or both of `expression`.Type or `type` are a nullable value type and the corresponding non-nullable value types are equal to the argument type and the return type of the implementing method respectively, the node is lifted.</span></span>  
  
 <span data-ttu-id="f7da9-964">Se o método de implementação é `null`:</span><span class="sxs-lookup"><span data-stu-id="f7da9-964">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="f7da9-965">Se ambos os `expression`. Tipo e `type` são não anuláveis, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-965">If both `expression`.Type and `type` are non-nullable, the node is not lifted.</span></span>  
  
-   <span data-ttu-id="f7da9-966">Caso contrário, o nó é eliminado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-966">Otherwise the node is lifted.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f7da9-967">
            <paramref name="expression" /> ou <paramref name="type" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-967">
              <paramref name="expression" /> or <paramref name="type" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f7da9-968">Não há nenhum operador de conversão definido entre <paramref name="expression" />.Type e <paramref name="type" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-968">No conversion operator is defined between <paramref name="expression" />.Type and <paramref name="type" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ConvertChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression ConvertChecked (System.Linq.Expressions.Expression expression, Type type, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression ConvertChecked(class System.Linq.Expressions.Expression expression, class System.Type type, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ConvertChecked(System.Linq.Expressions.Expression,System.Type,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ ConvertChecked(System::Linq::Expressions::Expression ^ expression, Type ^ type, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member ConvertChecked : System.Linq.Expressions.Expression * Type * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.ConvertChecked (expression, type, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">
          <span data-ttu-id="f7da9-969">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-969">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to.</span>
          </span>
        </param>
        <param name="type">
          <span data-ttu-id="f7da9-970">Um <see cref="T:System.Type" /> para definir a propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-970">A <see cref="T:System.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="f7da9-971">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-971">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-972">Cria uma <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa uma operação de conversão que lança uma exceção se o tipo de destino está estourado e para o qual o método de implementação é especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-972">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a conversion operation that throws an exception if the target type is overflowed and for which the implementing method is specified.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-973">Um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.ConvertChecked" /> e as propriedades <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />, <see cref="P:System.Linq.Expressions.Expression.Type" /> e <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-973">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ConvertChecked" /> and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />, <see cref="P:System.Linq.Expressions.Expression.Type" />, and <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-974">O <xref:System.Linq.Expressions.UnaryExpression.Method%2A> propriedade resultantes <xref:System.Linq.Expressions.UnaryExpression> é definido como o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-974">The <xref:System.Linq.Expressions.UnaryExpression.Method%2A> property of the resulting <xref:System.Linq.Expressions.UnaryExpression> is set to the implementing method.</span></span> <span data-ttu-id="f7da9-975">A propriedade <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> é `false`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-975">The <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> property is `false`.</span></span> <span data-ttu-id="f7da9-976">Se o nó é eliminado, <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> é `true`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-976">If the node is lifted, <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> is `true`.</span></span> <span data-ttu-id="f7da9-977">Caso contrário, será `false`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-977">Otherwise, it is `false`.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="f7da9-978">Implementando método</span><span class="sxs-lookup"><span data-stu-id="f7da9-978">Implementing Method</span></span>  
 <span data-ttu-id="f7da9-979">As regras a seguir determinam o método de implementação para a operação:</span><span class="sxs-lookup"><span data-stu-id="f7da9-979">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="f7da9-980">Se o método não é `null`, é o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-980">If method is not `null`, it is the implementing method.</span></span> <span data-ttu-id="f7da9-981">Ele deve representar um não-nulo, `static` (`Shared` no Visual Basic) método que aceita um argumento.</span><span class="sxs-lookup"><span data-stu-id="f7da9-981">It must represent a non-void, `static` (`Shared` in Visual Basic) method that takes one argument.</span></span>  
  
-   <span data-ttu-id="f7da9-982">Caso contrário, se qualquer um dos `expression`. Tipo ou `type` é um tipo definido pelo usuário que define um operador de conversão implícita ou explícita, o <xref:System.Reflection.MethodInfo> que representa que o método de implementação do operador é.</span><span class="sxs-lookup"><span data-stu-id="f7da9-982">Otherwise, if either `expression`.Type or `type` is a user-defined type that defines an implicit or explicit conversion operator, the <xref:System.Reflection.MethodInfo> that represents that operator is the implementing method.</span></span>  
  
-   <span data-ttu-id="f7da9-983">Caso contrário:</span><span class="sxs-lookup"><span data-stu-id="f7da9-983">Otherwise:</span></span>  
  
    -   <span data-ttu-id="f7da9-984">Se ambos os `expression`. Tipo e `type` representam os tipos numéricos ou booleanos ou tipos de enumeração que permite valor nulo ou não anulável, o método de implementação é `null`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-984">If both `expression`.Type and `type` represent numeric or Boolean types, or nullable or non-nullable enumeration types, the implementing method is `null`.</span></span>  
  
    -   <span data-ttu-id="f7da9-985">Se qualquer um dos `expression`. Tipo ou `type` é um tipo de referência e uma conversão boxing explícita, conversão unboxing ou conversão de referência existe de `expression`. Digite para `type`, o método de implementação é `null`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-985">If either `expression`.Type or `type` is a reference type and an explicit boxing, unboxing, or reference conversion exists from `expression`.Type to `type`, the implementing method is `null`.</span></span>  
  
#### <a name="lifted-versus-non-lifted"></a><span data-ttu-id="f7da9-986">Com comparação de precisão x sem comparação de precisão</span><span class="sxs-lookup"><span data-stu-id="f7da9-986">Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="f7da9-987">Se o método de implementação não for `null`:</span><span class="sxs-lookup"><span data-stu-id="f7da9-987">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="f7da9-988">Se `expression`. O tipo é atribuível ao tipo de argumento do método de implementação e o tipo de retorno do método de implementação é atribuível ao `type`, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-988">If `expression`.Type is assignable to the argument type of the implementing method and the return type of the implementing method is assignable to `type`, the node is not lifted.</span></span>  
  
-   <span data-ttu-id="f7da9-989">Se um ou ambos os de `expression`. Tipo ou `type` são um tipo de valor anulável e os tipos de valor não anulável correspondentes são iguais para o tipo de argumento e o tipo de retorno do método de implementação, respectivamente, o nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-989">If either or both of `expression`.Type or `type` are a nullable value type and the corresponding non-nullable value types are equal to the argument type and the return type of the implementing method respectively, the node is lifted.</span></span>  
  
 <span data-ttu-id="f7da9-990">Se o método de implementação é `null`:</span><span class="sxs-lookup"><span data-stu-id="f7da9-990">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="f7da9-991">Se ambos os `expression`. Tipo e `type` são não anuláveis, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-991">If both `expression`.Type and `type` are non-nullable, the node is not lifted.</span></span>  
  
-   <span data-ttu-id="f7da9-992">Caso contrário, o nó é eliminado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-992">Otherwise the node is lifted.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f7da9-993">
            <paramref name="expression" /> ou <paramref name="type" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-993">
              <paramref name="expression" /> or <paramref name="type" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f7da9-994">
            <paramref name="method" /> não é <see langword="null" /> e o método que ele representa retorna <see langword="void" />, não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) ou não tem exatamente um argumento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-994">
              <paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly one argument.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f7da9-995">Não há nenhum operador de conversão definido entre <paramref name="expression" />.Type e <paramref name="type" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-995">No conversion operator is defined between <paramref name="expression" />.Type and <paramref name="type" />.</span>
          </span>
          <span data-ttu-id="f7da9-996">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-996">-or-</span>
          </span>
          <span data-ttu-id="f7da9-997">
            <paramref name="expression" />.Type não é atribuível ao tipo de argumento do método representado pelo <paramref name="method" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-997">
              <paramref name="expression" />.Type is not assignable to the argument type of the method represented by <paramref name="method" />.</span>
          </span>
          <span data-ttu-id="f7da9-998">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-998">-or-</span>
          </span>
          <span data-ttu-id="f7da9-999">O tipo de retorno do método representado por <paramref name="method" /> não é atribuível ao <paramref name="type" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-999">The return type of the method represented by <paramref name="method" /> is not assignable to <paramref name="type" />.</span>
          </span>
          <span data-ttu-id="f7da9-1000">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1000">-or-</span>
          </span>
          <span data-ttu-id="f7da9-1001">
            <paramref name="expression" />.Type ou <paramref name="type" /> é um tipo de valor que permite valor nulo e o tipo de valor que não permite valor nulo correspondente não é igual ao tipo de argumento ou ao tipo de retorno, respectivamente, do método representado por <paramref name="method" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1001">
              <paramref name="expression" />.Type or <paramref name="type" /> is a nullable value type and the corresponding non-nullable value type does not equal the argument type or the return type, respectively, of the method represented by <paramref name="method" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">
          <span data-ttu-id="f7da9-1002">Foi encontrado mais de um método que corresponde à descrição de <paramref name="method" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1002">More than one method that matches the <paramref name="method" /> description was found.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="DebugInfo">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DebugInfoExpression DebugInfo (System.Linq.Expressions.SymbolDocumentInfo document, int startLine, int startColumn, int endLine, int endColumn);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DebugInfoExpression DebugInfo(class System.Linq.Expressions.SymbolDocumentInfo document, int32 startLine, int32 startColumn, int32 endLine, int32 endColumn) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.DebugInfo(System.Linq.Expressions.SymbolDocumentInfo,System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DebugInfo (document As SymbolDocumentInfo, startLine As Integer, startColumn As Integer, endLine As Integer, endColumn As Integer) As DebugInfoExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DebugInfoExpression ^ DebugInfo(System::Linq::Expressions::SymbolDocumentInfo ^ document, int startLine, int startColumn, int endLine, int endColumn);" />
      <MemberSignature Language="F#" Value="static member DebugInfo : System.Linq.Expressions.SymbolDocumentInfo * int * int * int * int -&gt; System.Linq.Expressions.DebugInfoExpression" Usage="System.Linq.Expressions.Expression.DebugInfo (document, startLine, startColumn, endLine, endColumn)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DebugInfoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="document" Type="System.Linq.Expressions.SymbolDocumentInfo" />
        <Parameter Name="startLine" Type="System.Int32" />
        <Parameter Name="startColumn" Type="System.Int32" />
        <Parameter Name="endLine" Type="System.Int32" />
        <Parameter Name="endColumn" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="document">
          <span data-ttu-id="f7da9-1003">O <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> que representa o arquivo de origem.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1003">The <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> that represents the source file.</span>
          </span>
        </param>
        <param name="startLine">
          <span data-ttu-id="f7da9-1004">A linha inicial deste <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1004">The start line of this <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</span>
          </span>
          <span data-ttu-id="f7da9-1005">Deve ser maior que 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1005">Must be greater than 0.</span>
          </span>
        </param>
        <param name="startColumn">
          <span data-ttu-id="f7da9-1006">A coluna inicial deste <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1006">The start column of this <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</span>
          </span>
          <span data-ttu-id="f7da9-1007">Deve ser maior que 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1007">Must be greater than 0.</span>
          </span>
        </param>
        <param name="endLine">
          <span data-ttu-id="f7da9-1008">A linha final deste <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1008">The end line of this <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</span>
          </span>
          <span data-ttu-id="f7da9-1009">Deve ser maior ou igual à linha inicial.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1009">Must be greater or equal than the start line.</span>
          </span>
        </param>
        <param name="endColumn">
          <span data-ttu-id="f7da9-1010">A coluna final deste <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1010">The end column of this <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</span>
          </span>
          <span data-ttu-id="f7da9-1011">Se a linha final é a mesma que a linha inicial, ela deve ser maior ou igual à coluna inicial.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1011">If the end line is the same as the start line, it must be greater or equal than the start column.</span>
          </span>
          <span data-ttu-id="f7da9-1012">Em qualquer caso, ela deve ser maior que 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1012">In any case, must be greater than 0.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-1013">Cria uma <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> com o intervalo especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1013">Creates a <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> with the specified span.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-1014">Uma instância de <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1014">An instance of <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Decrement">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f7da9-1015">Cria uma <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa o decremento da expressão em 1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1015">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the decrementing of the expression by 1.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Decrement">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Decrement (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Decrement(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Decrement(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Decrement(System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member Decrement : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Decrement expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression">
          <span data-ttu-id="f7da9-1016">Um <see cref="T:System.Linq.Expressions.Expression" /> para diminuir.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1016">An <see cref="T:System.Linq.Expressions.Expression" /> to decrement.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-1017">Cria uma <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa o decremento da expressão em 1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1017">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the decrementing of the expression by 1.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-1018">Um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa a expressão decrementada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1018">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the decremented expression.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-1019">Esta expressão é funcional e não altera o valor do objeto passado a ele.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1019">This expression is functional and does not change the value of the object passed to it.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f7da9-1020">O exemplo de código a seguir mostra como criar uma expressão que substracts 1 de um determinado valor.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1020">The following code example shows how to create an expression that substracts 1 from a given value.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#5)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Decrement">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Decrement (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Decrement(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Decrement(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Decrement(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member Decrement : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Decrement (expression, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">
          <span data-ttu-id="f7da9-1021">Um <see cref="T:System.Linq.Expressions.Expression" /> para diminuir.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1021">An <see cref="T:System.Linq.Expressions.Expression" /> to decrement.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="f7da9-1022">Um <see cref="T:System.Reflection.MethodInfo" /> que representa o método de implementação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1022">A <see cref="T:System.Reflection.MethodInfo" /> that represents the implementing method.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-1023">Cria uma <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa o decremento da expressão em 1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1023">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the decrementing of the expression by 1.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-1024">Um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa a expressão decrementada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1024">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the decremented expression.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-1025">Esta expressão é funcional e não altera o valor do objeto passado a ele.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1025">This expression is functional and does not change the value of the object passed to it.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Default">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DefaultExpression Default (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DefaultExpression Default(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Default(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DefaultExpression ^ Default(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Default : Type -&gt; System.Linq.Expressions.DefaultExpression" Usage="System.Linq.Expressions.Expression.Default type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DefaultExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">
          <span data-ttu-id="f7da9-1026">Um <see cref="T:System.Type" /> para definir a propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1026">A <see cref="T:System.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-1027">Cria um <see cref="T:System.Linq.Expressions.DefaultExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> definida para o tipo especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1027">Creates a <see cref="T:System.Linq.Expressions.DefaultExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.Type" /> property set to the specified type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-1028">Um <see cref="T:System.Linq.Expressions.DefaultExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Default" /> e a propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> definida para o tipo especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1028">A <see cref="T:System.Linq.Expressions.DefaultExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Default" /> and the <see cref="P:System.Linq.Expressions.Expression.Type" /> property set to the specified type.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="f7da9-1029">O exemplo de código a seguir mostra como criar uma expressão que representa um valor padrão para um determinado tipo.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1029">The following code example shows how to create an expression that represents a default vaule for a given type.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#6)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Divide">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f7da9-1030">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação aritmética de divisão.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1030">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic division operation.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Divide">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Divide (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Divide(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Divide(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Divide (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Divide(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member Divide : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Divide (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="f7da9-1031">Um <see cref="T:System.Linq.Expressions.Expression" /> para o qual definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1031">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="f7da9-1032">Um <see cref="T:System.Linq.Expressions.Expression" /> para o qual definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1032">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-1033">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação aritmética de divisão.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1033">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic division operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-1034">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Divide" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1034">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Divide" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-1035">Resultante <xref:System.Linq.Expressions.BinaryExpression> tem o <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriedade definida como o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1035">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="f7da9-1036">O <xref:System.Linq.Expressions.Expression.Type%2A> estiver definida como o tipo de nó.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1036">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="f7da9-1037">Se o nó é elevado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> e <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriedades estiverem `true`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1037">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="f7da9-1038">Caso contrário, eles são `false`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1038">Otherwise, they are `false`.</span></span> <span data-ttu-id="f7da9-1039">A propriedade <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> é `null`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1039">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="f7da9-1040">As informações a seguir descrevem o método de implementação, o tipo de nó, e se um nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1040">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="f7da9-1041">Implementando método</span><span class="sxs-lookup"><span data-stu-id="f7da9-1041">Implementing Method</span></span>  
 <span data-ttu-id="f7da9-1042">As regras a seguir determinam o método de implementação para a operação:</span><span class="sxs-lookup"><span data-stu-id="f7da9-1042">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="f7da9-1043">Se o <xref:System.Linq.Expressions.Expression.Type%2A> propriedade deles `left` ou `right` representa um tipo definido pelo usuário que sobrecarrega o operador de divisão, o <xref:System.Reflection.MethodInfo> que representa que o método é o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1043">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the division operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="f7da9-1044">Caso contrário, se `left`. Tipo e `right`. Tipo de tipos numéricos, o método de implementação está `null`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1044">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="f7da9-1045">Tipo de nó e versão com comparação de precisão x sem comparação de precisão</span><span class="sxs-lookup"><span data-stu-id="f7da9-1045">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="f7da9-1046">Se o método de implementação não for `null`:</span><span class="sxs-lookup"><span data-stu-id="f7da9-1046">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="f7da9-1047">Se `left`. Tipo e `right`. Tipo podem ser atribuídos aos tipos de argumento correspondente do método de implementação, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1047">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="f7da9-1048">O tipo do nó é o tipo de retorno do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1048">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="f7da9-1049">Se as duas seguintes condições forem atendidas, o nó é levantado e o tipo de nó é o tipo que permite valor nulo que corresponde ao tipo de retorno do método de implementação:</span><span class="sxs-lookup"><span data-stu-id="f7da9-1049">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="f7da9-1050">`left`. Tipo e `right`. Tipo são os dois tipos de valor de que pelo menos um é anulável e os tipos não anuláveis correspondentes são iguais para os tipos de argumento correspondente do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1050">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="f7da9-1051">O tipo de retorno do método de implementação é um tipo de valor não anulável.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1051">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="f7da9-1052">Se o método de implementação é `null`:</span><span class="sxs-lookup"><span data-stu-id="f7da9-1052">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="f7da9-1053">Se `left`. Tipo e `right`. Tipo são não anuláveis, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1053">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="f7da9-1054">O tipo do nó é o tipo de resultado do operador de divisão predefinidos.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1054">The type of the node is the result type of the predefined division operator.</span></span>  
  
-   <span data-ttu-id="f7da9-1055">Se `left`. Tipo e `right`. Tipo são anuláveis, o nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1055">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="f7da9-1056">O tipo de nó é o tipo que permite valor nulo que corresponde ao tipo de resultado do operador de divisão predefinidos.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1056">The type of the node is the nullable type that corresponds to the result type of the predefined division operator.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f7da9-1057">O exemplo de código a seguir mostra como criar uma expressão que divide divide seu primeiro argumento pelo seu segundo argumento.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1057">The following code example shows how to create an expression that divides divides its first argument by its second argument.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#7)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f7da9-1058">
            <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1058">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f7da9-1059">O operador de divisão não foi definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1059">The division operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Divide">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Divide (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Divide(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Divide(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Divide (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Divide(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member Divide : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Divide (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="f7da9-1060">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1060">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="f7da9-1061">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1061">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="f7da9-1062">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1062">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-1063">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação aritmética de divisão.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1063">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic division operation.</span>
          </span>
          <span data-ttu-id="f7da9-1064">O método de implementação pode ser especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1064">The implementing method can be specified.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-1065">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Divide" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1065">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Divide" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-1066">Resultante <xref:System.Linq.Expressions.BinaryExpression> tem o <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriedade definida como o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1066">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="f7da9-1067">O <xref:System.Linq.Expressions.Expression.Type%2A> estiver definida como o tipo de nó.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1067">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="f7da9-1068">Se o nó é elevado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> e <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriedades estiverem `true`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1068">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="f7da9-1069">Caso contrário, eles são `false`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1069">Otherwise, they are `false`.</span></span> <span data-ttu-id="f7da9-1070">A propriedade <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> é `null`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1070">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="f7da9-1071">As informações a seguir descrevem o método de implementação, o tipo de nó, e se um nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1071">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="f7da9-1072">Implementando método</span><span class="sxs-lookup"><span data-stu-id="f7da9-1072">Implementing Method</span></span>  
 <span data-ttu-id="f7da9-1073">As regras a seguir determinam o método de implementação para a operação:</span><span class="sxs-lookup"><span data-stu-id="f7da9-1073">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="f7da9-1074">Se `method` não é `null` e representa um não-nulo, `static` (`Shared` no Visual Basic) método que usa dois argumentos, é o método de implementação para o nó.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1074">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method for the node.</span></span>  
  
-   <span data-ttu-id="f7da9-1075">Caso contrário, se o <xref:System.Linq.Expressions.Expression.Type%2A> propriedade deles `left` ou `right` representa um tipo definido pelo usuário que sobrecarrega o operador de divisão, o <xref:System.Reflection.MethodInfo> que representa que o método é o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1075">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the division operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="f7da9-1076">Caso contrário, se `left`. Tipo e `right`. Tipo de tipos numéricos, o método de implementação está `null`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1076">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="f7da9-1077">Tipo de nó e versão com comparação de precisão x sem comparação de precisão</span><span class="sxs-lookup"><span data-stu-id="f7da9-1077">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="f7da9-1078">Se o método de implementação não for `null`:</span><span class="sxs-lookup"><span data-stu-id="f7da9-1078">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="f7da9-1079">Se `left`. Tipo e `right`. Tipo podem ser atribuídos aos tipos de argumento correspondente do método de implementação, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1079">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="f7da9-1080">O tipo do nó é o tipo de retorno do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1080">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="f7da9-1081">Se as duas seguintes condições forem atendidas, o nó é levantado e o tipo de nó é o tipo que permite valor nulo que corresponde ao tipo de retorno do método de implementação:</span><span class="sxs-lookup"><span data-stu-id="f7da9-1081">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="f7da9-1082">`left`. Tipo e `right`. Tipo são os dois tipos de valor de que pelo menos um é anulável e os tipos não anuláveis correspondentes são iguais para os tipos de argumento correspondente do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1082">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="f7da9-1083">O tipo de retorno do método de implementação é um tipo de valor não anulável.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1083">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="f7da9-1084">Se o método de implementação é `null`:</span><span class="sxs-lookup"><span data-stu-id="f7da9-1084">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="f7da9-1085">Se `left`. Tipo e `right`. Tipo são não anuláveis, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1085">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="f7da9-1086">O tipo do nó é o tipo de resultado do operador de divisão predefinidos.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1086">The type of the node is the result type of the predefined division operator.</span></span>  
  
-   <span data-ttu-id="f7da9-1087">Se `left`. Tipo e `right`. Tipo são anuláveis, o nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1087">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="f7da9-1088">O tipo de nó é o tipo que permite valor nulo que corresponde ao tipo de resultado do operador de divisão predefinidos.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1088">The type of the node is the nullable type that corresponds to the result type of the predefined division operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f7da9-1089">
            <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1089">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f7da9-1090">
            <paramref name="method" /> não é <see langword="null" /> e o método que ele representa retorna <see langword="void" />, não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) ou não tem exatamente dois argumentos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1090">
              <paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f7da9-1091">
            <paramref name="method" /> é <see langword="null" /> e o operador de divisão não foi definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1091">
              <paramref name="method" /> is <see langword="null" /> and the division operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DivideAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f7da9-1092">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de divisão de adição que não tem verificação de estouro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1092">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a division assignment operation that does not have overflow checking.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DivideAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression DivideAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression DivideAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.DivideAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DivideAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ DivideAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member DivideAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.DivideAssign (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="f7da9-1093">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1093">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="f7da9-1094">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1094">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-1095">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de divisão de adição que não tem verificação de estouro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1095">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a division assignment operation that does not have overflow checking.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-1096">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.DivideAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1096">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.DivideAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DivideAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression DivideAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression DivideAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.DivideAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DivideAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ DivideAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member DivideAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.DivideAssign (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="f7da9-1097">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1097">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="f7da9-1098">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1098">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="f7da9-1099">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1099">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-1100">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de divisão de adição que não tem verificação de estouro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1100">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a division assignment operation that does not have overflow checking.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-1101">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.DivideAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1101">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.DivideAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DivideAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression DivideAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression DivideAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.DivideAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DivideAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ DivideAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member DivideAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.DivideAssign (left, right, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="f7da9-1102">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1102">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="f7da9-1103">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1103">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="f7da9-1104">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1104">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <param name="conversion">
          <span data-ttu-id="f7da9-1105">Um <see cref="T:System.Linq.Expressions.LambdaExpression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1105">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-1106">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de divisão de adição que não tem verificação de estouro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1106">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a division assignment operation that does not have overflow checking.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-1107">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.DivideAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1107">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.DivideAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dynamic">
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f7da9-1108">Cria uma <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa uma operação dinâmica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1108">Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" /> that represents a dynamic operation.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression Dynamic (System.Runtime.CompilerServices.CallSiteBinder binder, Type returnType, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression Dynamic(class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Type returnType, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Dynamic (binder As CallSiteBinder, returnType As Type, arguments As IEnumerable(Of Expression)) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ Dynamic(System::Runtime::CompilerServices::CallSiteBinder ^ binder, Type ^ returnType, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Dynamic : System.Runtime.CompilerServices.CallSiteBinder * Type * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.DynamicExpression" Usage="System.Linq.Expressions.Expression.Dynamic (binder, returnType, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="binder">
          <span data-ttu-id="f7da9-1109">O associador de tempo de execução para a operação dinâmica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1109">The runtime binder for the dynamic operation.</span>
          </span>
        </param>
        <param name="returnType">
          <span data-ttu-id="f7da9-1110">O tipo de resultado da expressão dinâmica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1110">The result type of the dynamic expression.</span>
          </span>
        </param>
        <param name="arguments">
          <span data-ttu-id="f7da9-1111">Os argumentos para a operação dinâmica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1111">The arguments to the dynamic operation.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-1112">Cria uma <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa uma operação dinâmica associada pelo <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fornecido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1112">Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" /> that represents a dynamic operation bound by the provided <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-1113">Um <see cref="T:System.Linq.Expressions.DynamicExpression" /> que tem <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> e tem a <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> e <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> definidas para os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1113">A <see cref="T:System.Linq.Expressions.DynamicExpression" /> that has <see cref="P:System.Linq.Expressions.Expression.NodeType" /> equal to <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> and has the <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> and <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-1114">O <xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A> propriedade do resultado será inferida dos tipos dos argumentos e o tipo de retorno especificado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1114">The <xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A> property of the result will be inferred from the types of the arguments and the specified return type.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression Dynamic (System.Runtime.CompilerServices.CallSiteBinder binder, Type returnType, System.Linq.Expressions.Expression arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression Dynamic(class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Type returnType, class System.Linq.Expressions.Expression arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Dynamic (binder As CallSiteBinder, returnType As Type, arg0 As Expression) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ Dynamic(System::Runtime::CompilerServices::CallSiteBinder ^ binder, Type ^ returnType, System::Linq::Expressions::Expression ^ arg0);" />
      <MemberSignature Language="F#" Value="static member Dynamic : System.Runtime.CompilerServices.CallSiteBinder * Type * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.DynamicExpression" Usage="System.Linq.Expressions.Expression.Dynamic (binder, returnType, arg0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="binder">
          <span data-ttu-id="f7da9-1115">O associador de tempo de execução para a operação dinâmica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1115">The runtime binder for the dynamic operation.</span>
          </span>
        </param>
        <param name="returnType">
          <span data-ttu-id="f7da9-1116">O tipo de resultado da expressão dinâmica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1116">The result type of the dynamic expression.</span>
          </span>
        </param>
        <param name="arg0">
          <span data-ttu-id="f7da9-1117">O primeiro argumento para a operação dinâmica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1117">The first argument to the dynamic operation.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-1118">Cria uma <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa uma operação dinâmica associada pelo <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fornecido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1118">Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" /> that represents a dynamic operation bound by the provided <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-1119">Um <see cref="T:System.Linq.Expressions.DynamicExpression" /> que tem <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> e tem a <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> e <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> definidas para os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1119">A <see cref="T:System.Linq.Expressions.DynamicExpression" /> that has <see cref="P:System.Linq.Expressions.Expression.NodeType" /> equal to <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> and has the <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> and <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-1120">O <xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A> propriedade do resultado será inferida dos tipos dos argumentos e o tipo de retorno especificado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1120">The <xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A> property of the result will be inferred from the types of the arguments and the specified return type.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression Dynamic (System.Runtime.CompilerServices.CallSiteBinder binder, Type returnType, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression Dynamic(class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Type returnType, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Dynamic (binder As CallSiteBinder, returnType As Type, ParamArray arguments As Expression()) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ Dynamic(System::Runtime::CompilerServices::CallSiteBinder ^ binder, Type ^ returnType, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Dynamic : System.Runtime.CompilerServices.CallSiteBinder * Type * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.DynamicExpression" Usage="System.Linq.Expressions.Expression.Dynamic (binder, returnType, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="binder">
          <span data-ttu-id="f7da9-1121">O associador de tempo de execução para a operação dinâmica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1121">The runtime binder for the dynamic operation.</span>
          </span>
        </param>
        <param name="returnType">
          <span data-ttu-id="f7da9-1122">O tipo de resultado da expressão dinâmica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1122">The result type of the dynamic expression.</span>
          </span>
        </param>
        <param name="arguments">
          <span data-ttu-id="f7da9-1123">Os argumentos para a operação dinâmica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1123">The arguments to the dynamic operation.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-1124">Cria uma <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa uma operação dinâmica associada pelo <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fornecido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1124">Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" /> that represents a dynamic operation bound by the provided <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-1125">Um <see cref="T:System.Linq.Expressions.DynamicExpression" /> que tem <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> e tem a <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> e <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> definidas para os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1125">A <see cref="T:System.Linq.Expressions.DynamicExpression" /> that has <see cref="P:System.Linq.Expressions.Expression.NodeType" /> equal to <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> and has the <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> and <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-1126">O <xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A> propriedade do resultado será inferida dos tipos dos argumentos e o tipo de retorno especificado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1126">The <xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A> property of the result will be inferred from the types of the arguments and the specified return type.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression Dynamic (System.Runtime.CompilerServices.CallSiteBinder binder, Type returnType, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression Dynamic(class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Type returnType, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Dynamic (binder As CallSiteBinder, returnType As Type, arg0 As Expression, arg1 As Expression) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ Dynamic(System::Runtime::CompilerServices::CallSiteBinder ^ binder, Type ^ returnType, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1);" />
      <MemberSignature Language="F#" Value="static member Dynamic : System.Runtime.CompilerServices.CallSiteBinder * Type * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.DynamicExpression" Usage="System.Linq.Expressions.Expression.Dynamic (binder, returnType, arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="binder">
          <span data-ttu-id="f7da9-1127">O associador de tempo de execução para a operação dinâmica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1127">The runtime binder for the dynamic operation.</span>
          </span>
        </param>
        <param name="returnType">
          <span data-ttu-id="f7da9-1128">O tipo de resultado da expressão dinâmica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1128">The result type of the dynamic expression.</span>
          </span>
        </param>
        <param name="arg0">
          <span data-ttu-id="f7da9-1129">O primeiro argumento para a operação dinâmica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1129">The first argument to the dynamic operation.</span>
          </span>
        </param>
        <param name="arg1">
          <span data-ttu-id="f7da9-1130">O segundo argumento para a operação dinâmica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1130">The second argument to the dynamic operation.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-1131">Cria uma <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa uma operação dinâmica associada pelo <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fornecido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1131">Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" /> that represents a dynamic operation bound by the provided <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-1132">Um <see cref="T:System.Linq.Expressions.DynamicExpression" /> que tem <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> e tem a <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> e <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> definidas para os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1132">A <see cref="T:System.Linq.Expressions.DynamicExpression" /> that has <see cref="P:System.Linq.Expressions.Expression.NodeType" /> equal to <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> and has the <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> and <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-1133">O <xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A> propriedade do resultado será inferida dos tipos dos argumentos e o tipo de retorno especificado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1133">The <xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A> property of the result will be inferred from the types of the arguments and the specified return type.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression Dynamic (System.Runtime.CompilerServices.CallSiteBinder binder, Type returnType, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression Dynamic(class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Type returnType, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Dynamic (binder As CallSiteBinder, returnType As Type, arg0 As Expression, arg1 As Expression, arg2 As Expression) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ Dynamic(System::Runtime::CompilerServices::CallSiteBinder ^ binder, Type ^ returnType, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2);" />
      <MemberSignature Language="F#" Value="static member Dynamic : System.Runtime.CompilerServices.CallSiteBinder * Type * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.DynamicExpression" Usage="System.Linq.Expressions.Expression.Dynamic (binder, returnType, arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="binder">
          <span data-ttu-id="f7da9-1134">O associador de tempo de execução para a operação dinâmica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1134">The runtime binder for the dynamic operation.</span>
          </span>
        </param>
        <param name="returnType">
          <span data-ttu-id="f7da9-1135">O tipo de resultado da expressão dinâmica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1135">The result type of the dynamic expression.</span>
          </span>
        </param>
        <param name="arg0">
          <span data-ttu-id="f7da9-1136">O primeiro argumento para a operação dinâmica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1136">The first argument to the dynamic operation.</span>
          </span>
        </param>
        <param name="arg1">
          <span data-ttu-id="f7da9-1137">O segundo argumento para a operação dinâmica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1137">The second argument to the dynamic operation.</span>
          </span>
        </param>
        <param name="arg2">
          <span data-ttu-id="f7da9-1138">O terceiro argumento para a operação dinâmica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1138">The third argument to the dynamic operation.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-1139">Cria uma <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa uma operação dinâmica associada pelo <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fornecido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1139">Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" /> that represents a dynamic operation bound by the provided <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-1140">Um <see cref="T:System.Linq.Expressions.DynamicExpression" /> que tem <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> e tem a <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> e <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> definidas para os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1140">A <see cref="T:System.Linq.Expressions.DynamicExpression" /> that has <see cref="P:System.Linq.Expressions.Expression.NodeType" /> equal to <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> and has the <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> and <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-1141">O <xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A> propriedade do resultado será inferida dos tipos dos argumentos e o tipo de retorno especificado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1141">The <xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A> property of the result will be inferred from the types of the arguments and the specified return type.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression Dynamic (System.Runtime.CompilerServices.CallSiteBinder binder, Type returnType, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2, System.Linq.Expressions.Expression arg3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression Dynamic(class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Type returnType, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2, class System.Linq.Expressions.Expression arg3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Dynamic (binder As CallSiteBinder, returnType As Type, arg0 As Expression, arg1 As Expression, arg2 As Expression, arg3 As Expression) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ Dynamic(System::Runtime::CompilerServices::CallSiteBinder ^ binder, Type ^ returnType, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2, System::Linq::Expressions::Expression ^ arg3);" />
      <MemberSignature Language="F#" Value="static member Dynamic : System.Runtime.CompilerServices.CallSiteBinder * Type * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.DynamicExpression" Usage="System.Linq.Expressions.Expression.Dynamic (binder, returnType, arg0, arg1, arg2, arg3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg3" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="binder">
          <span data-ttu-id="f7da9-1142">O associador de tempo de execução para a operação dinâmica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1142">The runtime binder for the dynamic operation.</span>
          </span>
        </param>
        <param name="returnType">
          <span data-ttu-id="f7da9-1143">O tipo de resultado da expressão dinâmica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1143">The result type of the dynamic expression.</span>
          </span>
        </param>
        <param name="arg0">
          <span data-ttu-id="f7da9-1144">O primeiro argumento para a operação dinâmica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1144">The first argument to the dynamic operation.</span>
          </span>
        </param>
        <param name="arg1">
          <span data-ttu-id="f7da9-1145">O segundo argumento para a operação dinâmica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1145">The second argument to the dynamic operation.</span>
          </span>
        </param>
        <param name="arg2">
          <span data-ttu-id="f7da9-1146">O terceiro argumento para a operação dinâmica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1146">The third argument to the dynamic operation.</span>
          </span>
        </param>
        <param name="arg3">
          <span data-ttu-id="f7da9-1147">O quarto argumento para a operação dinâmica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1147">The fourth argument to the dynamic operation.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-1148">Cria uma <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa uma operação dinâmica associada pelo <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fornecido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1148">Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" /> that represents a dynamic operation bound by the provided <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-1149">Um <see cref="T:System.Linq.Expressions.DynamicExpression" /> que tem <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> e tem a <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> e <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> definidas para os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1149">A <see cref="T:System.Linq.Expressions.DynamicExpression" /> that has <see cref="P:System.Linq.Expressions.Expression.NodeType" /> equal to <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> and has the <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> and <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-1150">O <xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A> propriedade do resultado será inferida dos tipos dos argumentos e o tipo de retorno especificado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1150">The <xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A> property of the result will be inferred from the types of the arguments and the specified return type.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ElementInit">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f7da9-1151">Cria um <see cref="T:System.Linq.Expressions.ElementInit" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1151">Creates an <see cref="T:System.Linq.Expressions.ElementInit" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ElementInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ElementInit ElementInit (System.Reflection.MethodInfo addMethod, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ElementInit ElementInit(class System.Reflection.MethodInfo addMethod, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ElementInit(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ElementInit (addMethod As MethodInfo, arguments As IEnumerable(Of Expression)) As ElementInit" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ElementInit ^ ElementInit(System::Reflection::MethodInfo ^ addMethod, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member ElementInit : System.Reflection.MethodInfo * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.ElementInit" Usage="System.Linq.Expressions.Expression.ElementInit (addMethod, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ElementInit</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="addMethod" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="addMethod">
          <span data-ttu-id="f7da9-1152">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1152">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" /> property equal to.</span>
          </span>
        </param>
        <param name="arguments">
          <span data-ttu-id="f7da9-1153">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.Expression" /> igual aos quais definir a propriedade <see cref="P:System.Linq.Expressions.ElementInit.Arguments" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1153">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.Expression" /> objects to set the <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-1154">Cria uma <see cref="T:System.Linq.Expressions.ElementInit" />, dado um <see cref="T:System.Collections.Generic.IEnumerable`1" /> como o segundo argumento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1154">Creates an <see cref="T:System.Linq.Expressions.ElementInit" />, given an <see cref="T:System.Collections.Generic.IEnumerable`1" /> as the second argument.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-1155">Um <see cref="T:System.Linq.Expressions.ElementInit" /> que tem as propriedades <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" /> e <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> definidas para os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1155">An <see cref="T:System.Linq.Expressions.ElementInit" /> that has the <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" /> and <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-1156">O `addMethod` parâmetro deve representar um método de instância nomeado "Add" (diferencia maiusculas de minúsculas).</span><span class="sxs-lookup"><span data-stu-id="f7da9-1156">The `addMethod` parameter must represent an instance method named "Add" (case insensitive).</span></span> <span data-ttu-id="f7da9-1157">O método add deve ter o mesmo número de parâmetros que o número de elementos em `arguments`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1157">The add method must have the same number of parameters as the number of elements in `arguments`.</span></span> <span data-ttu-id="f7da9-1158">O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade de cada elemento na `arguments` deve ser atribuível ao tipo do parâmetro correspondente do método add, possivelmente após *citando*.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1158">The <xref:System.Linq.Expressions.Expression.Type%2A> property of each element in `arguments` must be assignable to the type of the corresponding parameter of the add method, possibly after *quoting*.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f7da9-1159">Um elemento será ser colocado entre aspas somente se o parâmetro do método correspondente é do tipo <xref:System.Linq.Expressions.Expression>.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1159">An element will be quoted only if the corresponding method parameter is of type <xref:System.Linq.Expressions.Expression>.</span></span> <span data-ttu-id="f7da9-1160">Delimitação significa que o elemento é encapsulado em um <xref:System.Linq.Expressions.ExpressionType.Quote> nó.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1160">Quoting means the element is wrapped in a <xref:System.Linq.Expressions.ExpressionType.Quote> node.</span></span> <span data-ttu-id="f7da9-1161">O nó resultante é um <xref:System.Linq.Expressions.UnaryExpression> cujos <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> propriedade é o elemento de `arguments`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1161">The resulting node is a <xref:System.Linq.Expressions.UnaryExpression> whose <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> property is the element of `arguments`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f7da9-1162">O exemplo a seguir demonstra como usar o <xref:System.Linq.Expressions.Expression.ElementInit%28System.Reflection.MethodInfo%2CSystem.Linq.Expressions.Expression%5B%5D%29> método para criar um <xref:System.Linq.Expressions.ElementInit> que representa a chamada a <xref:System.Collections.Generic.Dictionary%602.Add%2A> método para inicializar um elemento de uma coleção de dicionário.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1162">The following example demonstrates how to use the <xref:System.Linq.Expressions.Expression.ElementInit%28System.Reflection.MethodInfo%2CSystem.Linq.Expressions.Expression%5B%5D%29> method to create an <xref:System.Linq.Expressions.ElementInit> that represents calling the <xref:System.Collections.Generic.Dictionary%602.Add%2A> method to initialize an element of a dictionary collection.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.Expression#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#4)]
 [!code-vb[System.Linq.Expressions.Expression#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f7da9-1163">
            <paramref name="addMethod" /> ou <paramref name="arguments" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1163">
              <paramref name="addMethod" /> or <paramref name="arguments" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f7da9-1164">O método representado por <paramref name="addMethod" /> não é nomeado "Add" (não diferencia maiúsculas de minúsculas).</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1164">The method that <paramref name="addMethod" /> represents is not named "Add" (case insensitive).</span>
          </span>
          <span data-ttu-id="f7da9-1165">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1165">-or-</span>
          </span>
          <span data-ttu-id="f7da9-1166">O método representado por <paramref name="addMethod" /> não é um método de instância.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1166">The method that <paramref name="addMethod" /> represents is not an instance method.</span>
          </span>
          <span data-ttu-id="f7da9-1167">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1167">-or-</span>
          </span>
          <span data-ttu-id="f7da9-1168">
            <paramref name="arguments" /> não contém o mesmo número de elementos que o número de parâmetros para o método representado por <paramref name="addMethod" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1168">
              <paramref name="arguments" /> does not contain the same number of elements as the number of parameters for the method that <paramref name="addMethod" /> represents.</span>
          </span>
          <span data-ttu-id="f7da9-1169">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1169">-or-</span>
          </span>
          <span data-ttu-id="f7da9-1170">A propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> de um ou mais elementos de <paramref name="arguments" /> não pode ser atribuída ao tipo do parâmetro correspondente do método representado por <paramref name="addMethod" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1170">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of one or more elements of <paramref name="arguments" /> is not assignable to the type of the corresponding parameter of the method that <paramref name="addMethod" /> represents.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ElementInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ElementInit ElementInit (System.Reflection.MethodInfo addMethod, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ElementInit ElementInit(class System.Reflection.MethodInfo addMethod, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ElementInit(System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ElementInit (addMethod As MethodInfo, ParamArray arguments As Expression()) As ElementInit" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ElementInit ^ ElementInit(System::Reflection::MethodInfo ^ addMethod, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member ElementInit : System.Reflection.MethodInfo * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.ElementInit" Usage="System.Linq.Expressions.Expression.ElementInit (addMethod, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ElementInit</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="addMethod" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="addMethod">
          <span data-ttu-id="f7da9-1171">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1171">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" /> property equal to.</span>
          </span>
        </param>
        <param name="arguments">
          <span data-ttu-id="f7da9-1172">Uma matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> igual aos quais definir a propriedade <see cref="P:System.Linq.Expressions.ElementInit.Arguments" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1172">An array of <see cref="T:System.Linq.Expressions.Expression" /> objects to set the <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-1173">Cria uma <see cref="T:System.Linq.Expressions.ElementInit" />, dada uma matriz de valores como o segundo argumento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1173">Creates an <see cref="T:System.Linq.Expressions.ElementInit" />, given an array of values as the second argument.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-1174">Um <see cref="T:System.Linq.Expressions.ElementInit" /> que tem as propriedades <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" /> e <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> definidas para os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1174">An <see cref="T:System.Linq.Expressions.ElementInit" /> that has the <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" /> and <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-1175">O `addMethod` parâmetro deve representar um método de instância nomeado "Add" (diferencia maiusculas de minúsculas).</span><span class="sxs-lookup"><span data-stu-id="f7da9-1175">The `addMethod` parameter must represent an instance method named "Add" (case insensitive).</span></span> <span data-ttu-id="f7da9-1176">O método add deve ter o mesmo número de parâmetros que o número de elementos em `arguments`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1176">The add method must have the same number of parameters as the number of elements in `arguments`.</span></span> <span data-ttu-id="f7da9-1177">O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade de cada elemento na `arguments` deve ser atribuível ao tipo do parâmetro correspondente do método add, possivelmente após *citando*.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1177">The <xref:System.Linq.Expressions.Expression.Type%2A> property of each element in `arguments` must be assignable to the type of the corresponding parameter of the add method, possibly after *quoting*.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f7da9-1178">Um elemento será ser colocado entre aspas somente se o parâmetro do método correspondente é do tipo <xref:System.Linq.Expressions.Expression>.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1178">An element will be quoted only if the corresponding method parameter is of type <xref:System.Linq.Expressions.Expression>.</span></span> <span data-ttu-id="f7da9-1179">Delimitação significa que o elemento é encapsulado em um <xref:System.Linq.Expressions.ExpressionType.Quote> nó.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1179">Quoting means the element is wrapped in a <xref:System.Linq.Expressions.ExpressionType.Quote> node.</span></span> <span data-ttu-id="f7da9-1180">O nó resultante é um <xref:System.Linq.Expressions.UnaryExpression> cujos <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> propriedade é o elemento de `arguments`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1180">The resulting node is a <xref:System.Linq.Expressions.UnaryExpression> whose <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> property is the element of `arguments`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f7da9-1181">O exemplo a seguir demonstra como usar o <xref:System.Linq.Expressions.Expression.ElementInit%28System.Reflection.MethodInfo%2CSystem.Linq.Expressions.Expression%5B%5D%29> método para criar um <xref:System.Linq.Expressions.ElementInit> que representa a chamada a <xref:System.Collections.Generic.Dictionary%602.Add%2A> método para inicializar um elemento de uma coleção de dicionário.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1181">The following example demonstrates how to use the <xref:System.Linq.Expressions.Expression.ElementInit%28System.Reflection.MethodInfo%2CSystem.Linq.Expressions.Expression%5B%5D%29> method to create an <xref:System.Linq.Expressions.ElementInit> that represents calling the <xref:System.Collections.Generic.Dictionary%602.Add%2A> method to initialize an element of a dictionary collection.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.Expression#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#4)]
 [!code-vb[System.Linq.Expressions.Expression#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f7da9-1182">
            <paramref name="addMethod" /> ou <paramref name="arguments" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1182">
              <paramref name="addMethod" /> or <paramref name="arguments" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f7da9-1183">O método representado por addMethod não é nomeado "Add" (não diferencia maiúsculas de minúsculas).</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1183">The method that addMethod represents is not named "Add" (case insensitive).</span>
          </span>
          <span data-ttu-id="f7da9-1184">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1184">-or-</span>
          </span>
          <span data-ttu-id="f7da9-1185">O método representado por addMethod não é um método de instância.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1185">The method that addMethod represents is not an instance method.</span>
          </span>
          <span data-ttu-id="f7da9-1186">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1186">-or-</span>
          </span>
          <span data-ttu-id="f7da9-1187">arguments não contém o mesmo número de elementos que o número de parâmetros para o método representado por addMethod.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1187">arguments does not contain the same number of elements as the number of parameters for the method that addMethod represents.</span>
          </span>
          <span data-ttu-id="f7da9-1188">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1188">-or-</span>
          </span>
          <span data-ttu-id="f7da9-1189">A propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> de um ou mais elementos de <paramref name="arguments" /> não pode ser atribuída ao tipo do parâmetro correspondente do método representado por <paramref name="addMethod" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1189">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of one or more elements of <paramref name="arguments" /> is not assignable to the type of the corresponding parameter of the method that <paramref name="addMethod" /> represents.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Empty">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DefaultExpression Empty ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DefaultExpression Empty() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Empty" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Empty () As DefaultExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DefaultExpression ^ Empty();" />
      <MemberSignature Language="F#" Value="static member Empty : unit -&gt; System.Linq.Expressions.DefaultExpression" Usage="System.Linq.Expressions.Expression.Empty " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DefaultExpression</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="f7da9-1190">Cria uma expressão vazia com o tipo <see cref="T:System.Void" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1190">Creates an empty expression that has <see cref="T:System.Void" /> type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-1191">O <see cref="T:System.Linq.Expressions.DefaultExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Default" /> e a propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> definida como <see cref="T:System.Void" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1191">A <see cref="T:System.Linq.Expressions.DefaultExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Default" /> and the <see cref="P:System.Linq.Expressions.Expression.Type" /> property set to <see cref="T:System.Void" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-1192">Uma expressão vazia pode ser usada onde uma expressão é esperada, mas nenhuma ação é desejada.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1192">An empty expression can be used where an expression is expected but no action is desired.</span></span> <span data-ttu-id="f7da9-1193">Por exemplo, você pode usar uma expressão vazia como a última expressão em uma expressão de bloco.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1193">For example, you can use an empty expression as the last expression in a block expression.</span></span> <span data-ttu-id="f7da9-1194">Nesse caso, o valor de retorno da expressão no bloco é nulo.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1194">In this case, the block expression's return value is void.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f7da9-1195">O exemplo de código a seguir mostra como criar uma expressão vazia e adicioná-lo a uma expressão de bloco.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1195">The following code example shows how to create an empty expression and add it to a block expression.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#31](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#31)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#31](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#31)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equal">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f7da9-1196">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma comparação de igualdade.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1196">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an equality comparison.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equal">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Equal (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Equal(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Equal(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equal (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Equal(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member Equal : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Equal (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="f7da9-1197">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1197">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="f7da9-1198">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1198">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-1199">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma comparação de igualdade.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1199">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an equality comparison.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-1200">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Equal" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1200">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Equal" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-1201">Resultante <xref:System.Linq.Expressions.BinaryExpression> tem o <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriedade definida como o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1201">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="f7da9-1202">O <xref:System.Linq.Expressions.Expression.Type%2A> estiver definida como o tipo de nó.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1202">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="f7da9-1203">Se o nó é elevado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> é de propriedade `true`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1203">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> property is `true`.</span></span> <span data-ttu-id="f7da9-1204">Caso contrário, será `false`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1204">Otherwise, it is `false`.</span></span> <span data-ttu-id="f7da9-1205">A propriedade <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> sempre é `false`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1205">The <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> property is always `false`.</span></span> <span data-ttu-id="f7da9-1206">As informações a seguir descrevem o método de implementação, o tipo de nó, e se um nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1206">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="f7da9-1207">Implementando método</span><span class="sxs-lookup"><span data-stu-id="f7da9-1207">Implementing Method</span></span>  
 <span data-ttu-id="f7da9-1208">As regras a seguir determinam o método de implementação para a operação:</span><span class="sxs-lookup"><span data-stu-id="f7da9-1208">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="f7da9-1209">Se o <xref:System.Linq.Expressions.Expression.Type%2A> propriedade deles `left` ou `right` representa um tipo definido pelo usuário que sobrecarrega o operador de igualdade, o <xref:System.Reflection.MethodInfo> que representa que o método é o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1209">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the equality operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="f7da9-1210">Caso contrário, o método de implementação é `null`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1210">Otherwise, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="f7da9-1211">Tipo de nó e versão com comparação de precisão x sem comparação de precisão</span><span class="sxs-lookup"><span data-stu-id="f7da9-1211">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="f7da9-1212">Se o método de implementação não for `null`:</span><span class="sxs-lookup"><span data-stu-id="f7da9-1212">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="f7da9-1213">Se `left`. Tipo e `right`. Tipo podem ser atribuídos aos tipos de argumento correspondente do método de implementação, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1213">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="f7da9-1214">O tipo do nó é o tipo de retorno do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1214">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="f7da9-1215">Se as duas seguintes condições forem atendidas, o nó é elevado e o tipo de nó é <xref:System.Boolean>:</span><span class="sxs-lookup"><span data-stu-id="f7da9-1215">If the following two conditions are satisfied, the node is lifted and the type of the node is <xref:System.Boolean>:</span></span>  
  
    -   <span data-ttu-id="f7da9-1216">`left`. Tipo e `right`. Tipo são os dois tipos de valor de que pelo menos um é anulável e os tipos não anuláveis correspondentes são iguais para os tipos de argumento correspondente do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1216">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="f7da9-1217">O tipo de retorno do método de implementação é <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1217">The return type of the implementing method is <xref:System.Boolean>.</span></span>  
  
 <span data-ttu-id="f7da9-1218">Se o método de implementação é `null`:</span><span class="sxs-lookup"><span data-stu-id="f7da9-1218">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="f7da9-1219">Se `left`. Tipo e `right`. Tipo são não anuláveis, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1219">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="f7da9-1220">O tipo de nó é <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1220">The type of the node is <xref:System.Boolean>.</span></span>  
  
-   <span data-ttu-id="f7da9-1221">Se `left`. Tipo e `right`. Tipo são anuláveis, o nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1221">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="f7da9-1222">O tipo de nó é <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1222">The type of the node is <xref:System.Boolean>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f7da9-1223">O exemplo de código a seguir mostra como criar uma expressão que verifica se os valores dos dois argumentos forem iguais.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1223">The following code example shows how to create an expression that checks whether the values of its two arguments are equal.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#8)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f7da9-1224">
            <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1224">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f7da9-1225">O operador de igualdade não está definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1225">The equality operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Equal">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Equal (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, bool liftToNull, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Equal(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, bool liftToNull, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Equal(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equal (left As Expression, right As Expression, liftToNull As Boolean, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Equal(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, bool liftToNull, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member Equal : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * bool * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Equal (left, right, liftToNull, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="liftToNull" Type="System.Boolean" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="f7da9-1226">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1226">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="f7da9-1227">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1227">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="liftToNull">
          <span data-ttu-id="f7da9-1228">
            <see langword="true" /> para definir <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> como <see langword="true" />; <see langword="false" /> para definir <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> como <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1228">
              <see langword="true" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="true" />; <see langword="false" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="false" />.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="f7da9-1229">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1229">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-1230">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma comparação de igualdade.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1230">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an equality comparison.</span>
          </span>
          <span data-ttu-id="f7da9-1231">O método de implementação pode ser especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1231">The implementing method can be specified.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-1232">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Equal" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1232">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Equal" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-1233">Resultante <xref:System.Linq.Expressions.BinaryExpression> tem o <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriedade definida como o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1233">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="f7da9-1234">O <xref:System.Linq.Expressions.Expression.Type%2A> estiver definida como o tipo de nó.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1234">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="f7da9-1235">Se o nó é elevado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> é de propriedade `true` e o <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriedade é igual a `liftToNull`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1235">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> property is `true` and the <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> property is equal to `liftToNull`.</span></span> <span data-ttu-id="f7da9-1236">Caso contrário, eles são ambos `false`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1236">Otherwise, they are both `false`.</span></span> <span data-ttu-id="f7da9-1237">As informações a seguir descrevem o método de implementação, o tipo de nó, e se um nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1237">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="f7da9-1238">Implementando método</span><span class="sxs-lookup"><span data-stu-id="f7da9-1238">Implementing Method</span></span>  
 <span data-ttu-id="f7da9-1239">As regras a seguir determinam o método de implementação para a operação:</span><span class="sxs-lookup"><span data-stu-id="f7da9-1239">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="f7da9-1240">Se `method` não é `null` e representa um não-nulo, `static` (`Shared` no Visual Basic) método que usa dois argumentos, é o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1240">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method.</span></span>  
  
-   <span data-ttu-id="f7da9-1241">Caso contrário, se o <xref:System.Linq.Expressions.Expression.Type%2A> propriedade deles `left` ou `right` representa um tipo definido pelo usuário que sobrecarrega o operador de igualdade, o <xref:System.Reflection.MethodInfo> que representa que o método é o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1241">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the equality operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="f7da9-1242">Caso contrário, o método de implementação é `null`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1242">Otherwise, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="f7da9-1243">Tipo de nó e versão com comparação de precisão x sem comparação de precisão</span><span class="sxs-lookup"><span data-stu-id="f7da9-1243">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="f7da9-1244">Se o método de implementação não for `null`:</span><span class="sxs-lookup"><span data-stu-id="f7da9-1244">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="f7da9-1245">Se `left`. Tipo e `right`. Tipo podem ser atribuídos aos tipos de argumento correspondente do método de implementação, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1245">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="f7da9-1246">O tipo do nó é o tipo de retorno do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1246">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="f7da9-1247">Se as duas seguintes condições forem atendidas, o nó é eliminado; Além disso, o tipo do nó é anulável <xref:System.Boolean> se `liftToNull` é `true` ou <xref:System.Boolean> se `liftToNull` é `false`:</span><span class="sxs-lookup"><span data-stu-id="f7da9-1247">If the following two conditions are satisfied, the node is lifted; also, the type of the node is nullable <xref:System.Boolean> if `liftToNull` is `true` or <xref:System.Boolean> if `liftToNull` is `false`:</span></span>  
  
    -   <span data-ttu-id="f7da9-1248">`left`. Tipo e `right`. Tipo são os dois tipos de valor de que pelo menos um é anulável e os tipos não anuláveis correspondentes são iguais para os tipos de argumento correspondente do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1248">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="f7da9-1249">O tipo de retorno do método de implementação é <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1249">The return type of the implementing method is <xref:System.Boolean>.</span></span>  
  
 <span data-ttu-id="f7da9-1250">Se o método de implementação é `null`:</span><span class="sxs-lookup"><span data-stu-id="f7da9-1250">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="f7da9-1251">Se `left`. Tipo e `right`. Tipo são não anuláveis, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1251">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="f7da9-1252">O tipo de nó é <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1252">The type of the node is <xref:System.Boolean>.</span></span>  
  
-   <span data-ttu-id="f7da9-1253">Se `left`. Tipo e `right`. Tipo são anuláveis, o nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1253">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="f7da9-1254">O tipo do nó é anulável <xref:System.Boolean> se `liftToNull` é `true` ou <xref:System.Boolean> se `liftToNull` é `false`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1254">The type of the node is nullable <xref:System.Boolean> if `liftToNull` is `true` or <xref:System.Boolean> if `liftToNull` is `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f7da9-1255">
            <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1255">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f7da9-1256">
            <paramref name="method" /> não é <see langword="null" /> e o método que ele representa retorna <see langword="void" />, não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) ou não tem exatamente dois argumentos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1256">
              <paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f7da9-1257">
            <paramref name="method" /> é <see langword="null" /> e o operador de igualdade não está definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1257">
              <paramref name="method" /> is <see langword="null" /> and the equality operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ExclusiveOr">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f7da9-1258">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação <see langword="XOR" /> bit a bit.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1258">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise <see langword="XOR" /> operation.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ExclusiveOr">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ExclusiveOr (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ExclusiveOr(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ExclusiveOr(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ExclusiveOr (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ExclusiveOr(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member ExclusiveOr : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.ExclusiveOr (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="f7da9-1259">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1259">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="f7da9-1260">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1260">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-1261">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação <see langword="XOR" /> bit a bit, usando <c>op_ExclusiveOr</c> para tipos definidos pelo usuário.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1261">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise <see langword="XOR" /> operation, using <c>op_ExclusiveOr</c> for user-defined types.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-1262">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOr" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1262">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOr" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-1263">Resultante <xref:System.Linq.Expressions.BinaryExpression> tem o <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriedade definida como o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1263">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="f7da9-1264">O <xref:System.Linq.Expressions.Expression.Type%2A> estiver definida como o tipo de nó.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1264">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="f7da9-1265">Se o nó é elevado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> e <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriedades estiverem `true`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1265">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="f7da9-1266">Caso contrário, eles são `false`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1266">Otherwise, they are `false`.</span></span> <span data-ttu-id="f7da9-1267">A propriedade <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> é `null`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1267">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="f7da9-1268">As informações a seguir descrevem o método de implementação, o tipo de nó, e se um nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1268">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="f7da9-1269">Implementando método</span><span class="sxs-lookup"><span data-stu-id="f7da9-1269">Implementing Method</span></span>  
 <span data-ttu-id="f7da9-1270">As regras a seguir determinam o método de implementação para a operação:</span><span class="sxs-lookup"><span data-stu-id="f7da9-1270">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="f7da9-1271">Se o <xref:System.Linq.Expressions.Expression.Type%2A> propriedade deles `left` ou `right` representa um tipo definido pelo usuário que sobrecarrega o `XOR` operador, o <xref:System.Reflection.MethodInfo> que representa que o método é o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1271">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the `XOR` operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="f7da9-1272">Caso contrário, se `left`. Tipo e `right`. Tipo são tipos de inteiros ou boolianos, o método de implementação é `null`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1272">Otherwise, if `left`.Type and `right`.Type are integral or Boolean types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="f7da9-1273">Tipo de nó e versão com comparação de precisão x sem comparação de precisão</span><span class="sxs-lookup"><span data-stu-id="f7da9-1273">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="f7da9-1274">Se o método de implementação não for `null`:</span><span class="sxs-lookup"><span data-stu-id="f7da9-1274">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="f7da9-1275">Se `left`. Tipo e `right`. Tipo podem ser atribuídos aos tipos de argumento correspondente do método de implementação, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1275">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="f7da9-1276">O tipo do nó é o tipo de retorno do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1276">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="f7da9-1277">Se as duas seguintes condições forem atendidas, o nó é levantado e o tipo de nó é o tipo que permite valor nulo que corresponde ao tipo de retorno do método de implementação:</span><span class="sxs-lookup"><span data-stu-id="f7da9-1277">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="f7da9-1278">`left`. Tipo e `right`. Tipo são os dois tipos de valor de que pelo menos um é anulável e os tipos não anuláveis correspondentes são iguais para os tipos de argumento correspondente do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1278">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="f7da9-1279">O tipo de retorno do método de implementação é um tipo de valor não anulável.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1279">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="f7da9-1280">Se o método de implementação é `null`:</span><span class="sxs-lookup"><span data-stu-id="f7da9-1280">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="f7da9-1281">Se `left`. Tipo e `right`. Tipo são não anuláveis, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1281">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="f7da9-1282">O tipo de nó é o tipo de resultado de predefinido `XOR` operador.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1282">The type of the node is the result type of the predefined `XOR` operator.</span></span>  
  
-   <span data-ttu-id="f7da9-1283">Se `left`. Tipo e `right`. Tipo são anuláveis, o nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1283">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="f7da9-1284">O tipo de nó é o tipo que permite valor nulo que corresponde ao tipo de resultado de predefinido `XOR` operador.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1284">The type of the node is the nullable type that corresponds to the result type of the predefined `XOR` operator.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f7da9-1285">O exemplo de código a seguir mostra como criar uma expressão que representa a operação XOR lógica.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1285">The following code example shows how to create an expression that represents the logical XOR operation.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#9)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f7da9-1286">
            <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1286">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f7da9-1287">O operador <see langword="XOR" /> não está definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1287">The <see langword="XOR" /> operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ExclusiveOr">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ExclusiveOr (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ExclusiveOr(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ExclusiveOr(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ExclusiveOr (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ExclusiveOr(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member ExclusiveOr : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.ExclusiveOr (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="f7da9-1288">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1288">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="f7da9-1289">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1289">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="f7da9-1290">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1290">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-1291">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação <see langword="XOR" /> bit a bit, usando <c>op_ExclusiveOr</c> para tipos definidos pelo usuário.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1291">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise <see langword="XOR" /> operation, using <c>op_ExclusiveOr</c> for user-defined types.</span>
          </span>
          <span data-ttu-id="f7da9-1292">O método de implementação pode ser especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1292">The implementing method can be specified.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-1293">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOr" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1293">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOr" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-1294">Resultante <xref:System.Linq.Expressions.BinaryExpression> tem o <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriedade definida como o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1294">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="f7da9-1295">O <xref:System.Linq.Expressions.Expression.Type%2A> estiver definida como o tipo de nó.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1295">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="f7da9-1296">Se o nó é elevado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> e <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriedades estiverem `true`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1296">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="f7da9-1297">Caso contrário, eles são `false`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1297">Otherwise, they are `false`.</span></span> <span data-ttu-id="f7da9-1298">A propriedade <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> é `null`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1298">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="f7da9-1299">As informações a seguir descrevem o método de implementação, o tipo de nó, e se um nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1299">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="f7da9-1300">Implementando método</span><span class="sxs-lookup"><span data-stu-id="f7da9-1300">Implementing Method</span></span>  
 <span data-ttu-id="f7da9-1301">As regras a seguir determinam o escolhido a implementação de método para a operação:</span><span class="sxs-lookup"><span data-stu-id="f7da9-1301">The following rules determine the chosen implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="f7da9-1302">Se `method` não é `null` e representa um não-nulo, `static` (`Shared` no Visual Basic) método que usa dois argumentos, é o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1302">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method.</span></span>  
  
-   <span data-ttu-id="f7da9-1303">Caso contrário, se o <xref:System.Linq.Expressions.Expression.Type%2A> propriedade deles `left` ou `right` representa um tipo definido pelo usuário que sobrecarrega o `XOR` operador, o <xref:System.Reflection.MethodInfo> que representa que o método é o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1303">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the `XOR` operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="f7da9-1304">Caso contrário, se `left`. Tipo e `right`. Tipo são tipos de inteiros ou boolianos, o método de implementação é `null`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1304">Otherwise, if `left`.Type and `right`.Type are integral or Boolean types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="f7da9-1305">Tipo de nó e versão com comparação de precisão x sem comparação de precisão</span><span class="sxs-lookup"><span data-stu-id="f7da9-1305">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="f7da9-1306">Se o método de implementação não for `null`:</span><span class="sxs-lookup"><span data-stu-id="f7da9-1306">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="f7da9-1307">Se `left`. Tipo e `right`. Tipo podem ser atribuídos aos tipos de argumento correspondente do método de implementação, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1307">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="f7da9-1308">O tipo do nó é o tipo de retorno do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1308">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="f7da9-1309">Se as duas seguintes condições forem atendidas, o nó é levantado e o tipo de nó é o tipo que permite valor nulo que corresponde ao tipo de retorno do método de implementação:</span><span class="sxs-lookup"><span data-stu-id="f7da9-1309">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="f7da9-1310">`left`. Tipo e `right`. Tipo são os dois tipos de valor de que pelo menos um é anulável e os tipos não anuláveis correspondentes são iguais para os tipos de argumento correspondente do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1310">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="f7da9-1311">O tipo de retorno do método de implementação é um tipo de valor não anulável.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1311">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="f7da9-1312">Se o método de implementação é `null`:</span><span class="sxs-lookup"><span data-stu-id="f7da9-1312">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="f7da9-1313">Se `left`. Tipo e `right`. Tipo são não anuláveis, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1313">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="f7da9-1314">O tipo de nó é o tipo de resultado de predefinido `XOR` operador.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1314">The type of the node is the result type of the predefined `XOR` operator.</span></span>  
  
-   <span data-ttu-id="f7da9-1315">Se `left`. Tipo e `right`. Tipo são anuláveis, o nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1315">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="f7da9-1316">O tipo de nó é o tipo que permite valor nulo que corresponde ao tipo de resultado de predefinido `XOR` operador.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1316">The type of the node is the nullable type that corresponds to the result type of the predefined `XOR` operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f7da9-1317">
            <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1317">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f7da9-1318">
            <paramref name="method" /> não é <see langword="null" /> e o método que ele representa retorna <see langword="void" />, não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) ou não tem exatamente dois argumentos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1318">
              <paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f7da9-1319">
            <paramref name="method" /> é <see langword="null" /> e o operador <see langword="XOR" /> não foi definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1319">
              <paramref name="method" /> is <see langword="null" /> and the <see langword="XOR" /> operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ExclusiveOrAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f7da9-1320">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição XOR bit a bit.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1320">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise XOR assignment operation.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ExclusiveOrAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ExclusiveOrAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ExclusiveOrAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ExclusiveOrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ExclusiveOrAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ExclusiveOrAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member ExclusiveOrAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.ExclusiveOrAssign (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="f7da9-1321">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1321">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="f7da9-1322">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1322">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-1323">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição XOR bit a bit, usando <c>op_ExclusiveOr</c> para tipos definidos pelo usuário.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1323">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise XOR assignment operation, using <c>op_ExclusiveOr</c> for user-defined types.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-1324">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1324">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ExclusiveOrAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ExclusiveOrAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ExclusiveOrAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ExclusiveOrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ExclusiveOrAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ExclusiveOrAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member ExclusiveOrAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.ExclusiveOrAssign (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="f7da9-1325">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1325">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="f7da9-1326">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1326">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="f7da9-1327">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1327">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-1328">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição XOR bit a bit, usando <c>op_ExclusiveOr</c> para tipos definidos pelo usuário.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1328">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise XOR assignment operation, using <c>op_ExclusiveOr</c> for user-defined types.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-1329">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1329">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ExclusiveOrAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ExclusiveOrAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ExclusiveOrAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ExclusiveOrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ExclusiveOrAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ExclusiveOrAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member ExclusiveOrAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.ExclusiveOrAssign (left, right, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="f7da9-1330">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1330">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="f7da9-1331">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1331">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="f7da9-1332">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1332">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <param name="conversion">
          <span data-ttu-id="f7da9-1333">Um <see cref="T:System.Linq.Expressions.LambdaExpression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1333">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-1334">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição XOR bit a bit, usando <c>op_ExclusiveOr</c> para tipos definidos pelo usuário.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1334">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise XOR assignment operation, using <c>op_ExclusiveOr</c> for user-defined types.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-1335">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1335">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Field">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f7da9-1336">Cria um <see cref="T:System.Linq.Expressions.MemberExpression" /> que representa o acesso a um campo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1336">Creates a <see cref="T:System.Linq.Expressions.MemberExpression" /> that represents accessing a field.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Field">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression Field (System.Linq.Expressions.Expression expression, System.Reflection.FieldInfo field);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression Field(class System.Linq.Expressions.Expression expression, class System.Reflection.FieldInfo field) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Field(System.Linq.Expressions.Expression,System.Reflection.FieldInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberExpression ^ Field(System::Linq::Expressions::Expression ^ expression, System::Reflection::FieldInfo ^ field);" />
      <MemberSignature Language="F#" Value="static member Field : System.Linq.Expressions.Expression * System.Reflection.FieldInfo -&gt; System.Linq.Expressions.MemberExpression" Usage="System.Linq.Expressions.Expression.Field (expression, field)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="field" Type="System.Reflection.FieldInfo" />
      </Parameters>
      <Docs>
        <param name="expression">
          <span data-ttu-id="f7da9-1337">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1337">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> property equal to.</span>
          </span>
          <span data-ttu-id="f7da9-1338">Para <see langword="static" /> (<see langword="Shared" /> no Visual Basic), <paramref name="expression" /> deve ser <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1338">For <see langword="static" /> (<see langword="Shared" /> in Visual Basic), <paramref name="expression" /> must be <see langword="null" />.</span>
          </span>
        </param>
        <param name="field">
          <span data-ttu-id="f7da9-1339">O <see cref="T:System.Reflection.FieldInfo" /> com um valor igual ao qual a <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> propriedade será definida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1339">The <see cref="T:System.Reflection.FieldInfo" /> to set the <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-1340">Cria um <see cref="T:System.Linq.Expressions.MemberExpression" /> que representa o acesso a um campo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1340">Creates a <see cref="T:System.Linq.Expressions.MemberExpression" /> that represents accessing a field.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-1341">Um <see cref="T:System.Linq.Expressions.MemberExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" /> e as propriedades <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> e <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1341">A <see cref="T:System.Linq.Expressions.MemberExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" /> and the <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> and <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-1342">O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade resultantes <xref:System.Linq.Expressions.MemberExpression> é igual ao <xref:System.Reflection.FieldInfo.FieldType%2A> propriedade `field`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1342">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.MemberExpression> is equal to the <xref:System.Reflection.FieldInfo.FieldType%2A> property of `field`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f7da9-1343">
            <paramref name="field" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1343">
              <paramref name="field" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="f7da9-1344">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1344">-or-</span>
          </span>
          <span data-ttu-id="f7da9-1345">O campo representado por <paramref name="field" /> não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) e <paramref name="expression" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1345">The field represented by <paramref name="field" /> is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic) and <paramref name="expression" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f7da9-1346">
            <paramref name="expression" />.Type não pode ser atribuído ao tipo declarativo do campo representado por <paramref name="field" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1346">
              <paramref name="expression" />.Type is not assignable to the declaring type of the field represented by <paramref name="field" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Field">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression Field (System.Linq.Expressions.Expression expression, string fieldName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression Field(class System.Linq.Expressions.Expression expression, string fieldName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Field(System.Linq.Expressions.Expression,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberExpression ^ Field(System::Linq::Expressions::Expression ^ expression, System::String ^ fieldName);" />
      <MemberSignature Language="F#" Value="static member Field : System.Linq.Expressions.Expression * string -&gt; System.Linq.Expressions.MemberExpression" Usage="System.Linq.Expressions.Expression.Field (expression, fieldName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="fieldName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="expression">
          <span data-ttu-id="f7da9-1347">Um <see cref="T:System.Linq.Expressions.Expression" /> cujo <see cref="P:System.Linq.Expressions.Expression.Type" /> contém um campo chamado <paramref name="fieldName" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1347">An <see cref="T:System.Linq.Expressions.Expression" /> whose <see cref="P:System.Linq.Expressions.Expression.Type" /> contains a field named <paramref name="fieldName" />.</span>
          </span>
          <span data-ttu-id="f7da9-1348">Pode ser nulo para campos estáticos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1348">This can be null for static fields.</span>
          </span>
        </param>
        <param name="fieldName">
          <span data-ttu-id="f7da9-1349">O nome de um campo a ser acessado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1349">The name of a field to be accessed.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-1350">Cria um <see cref="T:System.Linq.Expressions.MemberExpression" /> que representa o acesso a um campo dado o nome do campo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1350">Creates a <see cref="T:System.Linq.Expressions.MemberExpression" /> that represents accessing a field given the name of the field.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-1351">Um <see cref="T:System.Linq.Expressions.MemberExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, a propriedade <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> definida como <paramref name="expression" /> e a propriedade <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> definida como o <see cref="T:System.Reflection.FieldInfo" /> que representa o campo indicado por <paramref name="fieldName" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1351">A <see cref="T:System.Linq.Expressions.MemberExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, the <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> property set to <paramref name="expression" />, and the <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> property set to the <see cref="T:System.Reflection.FieldInfo" /> that represents the field denoted by <paramref name="fieldName" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-1352">O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade resultantes <xref:System.Linq.Expressions.MemberExpression> é igual ao <xref:System.Reflection.FieldInfo.FieldType%2A> propriedade o <xref:System.Reflection.FieldInfo> que representa o campo indicado por `fieldName`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1352">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.MemberExpression> is equal to the <xref:System.Reflection.FieldInfo.FieldType%2A> property of the <xref:System.Reflection.FieldInfo> that represents the field denoted by `fieldName`.</span></span>  
  
 <span data-ttu-id="f7da9-1353">Este método pesquisa `expression`. Tipo e seus tipos base para um campo que tem o nome `fieldName`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1353">This method searches `expression`.Type and its base types for a field that has the name `fieldName`.</span></span> <span data-ttu-id="f7da9-1354">Campos públicos terá preferência em relação aos campos não públicos.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1354">Public fields are given preference over non-public fields.</span></span> <span data-ttu-id="f7da9-1355">Se um campo correspondente for encontrado, esse método passa `expression` e o <xref:System.Reflection.FieldInfo> que representa o campo para <xref:System.Linq.Expressions.Expression.Field%2A>.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1355">If a matching field is found, this method passes `expression` and the <xref:System.Reflection.FieldInfo> that represents that field to <xref:System.Linq.Expressions.Expression.Field%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f7da9-1356">O exemplo de código a seguir mostra como criar uma expressão que representa o acesso a um campo.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1356">The following code example shows how to create an expression that represents accessing a field.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#37](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#37)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#37](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#37)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f7da9-1357">
            <paramref name="expression" /> ou <paramref name="fieldName" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1357">
              <paramref name="expression" /> or <paramref name="fieldName" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f7da9-1358">Nenhum campo nomeado <paramref name="fieldName" /> é definido no tipo <paramref name="expression" /> ou em seus tipos base.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1358">No field named <paramref name="fieldName" /> is defined in <paramref name="expression" />.Type or its base types.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Field">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression Field (System.Linq.Expressions.Expression expression, Type type, string fieldName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression Field(class System.Linq.Expressions.Expression expression, class System.Type type, string fieldName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Field(System.Linq.Expressions.Expression,System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberExpression ^ Field(System::Linq::Expressions::Expression ^ expression, Type ^ type, System::String ^ fieldName);" />
      <MemberSignature Language="F#" Value="static member Field : System.Linq.Expressions.Expression * Type * string -&gt; System.Linq.Expressions.MemberExpression" Usage="System.Linq.Expressions.Expression.Field (expression, type, fieldName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="fieldName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="expression">
          <span data-ttu-id="f7da9-1359">O objeto recipiente do campo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1359">The containing object of the field.</span>
          </span>
          <span data-ttu-id="f7da9-1360">Pode ser nulo para campos estáticos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1360">This can be null for static fields.</span>
          </span>
        </param>
        <param name="type">
          <span data-ttu-id="f7da9-1361">O <see cref="P:System.Linq.Expressions.Expression.Type" /> que contém o campo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1361">The <see cref="P:System.Linq.Expressions.Expression.Type" /> that contains the field.</span>
          </span>
        </param>
        <param name="fieldName">
          <span data-ttu-id="f7da9-1362">O campo a ser acessado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1362">The field to be accessed.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-1363">Cria um <see cref="T:System.Linq.Expressions.MemberExpression" /> que representa o acesso a um campo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1363">Creates a <see cref="T:System.Linq.Expressions.MemberExpression" /> that represents accessing a field.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-1364">O <see cref="T:System.Linq.Expressions.MemberExpression" /> criado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1364">The created <see cref="T:System.Linq.Expressions.MemberExpression" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetActionType">
      <MemberSignature Language="C#" Value="public static Type GetActionType (params Type[] typeArgs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetActionType(class System.Type[] typeArgs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.GetActionType(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetActionType (ParamArray typeArgs As Type()) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetActionType(... cli::array &lt;Type ^&gt; ^ typeArgs);" />
      <MemberSignature Language="F#" Value="static member GetActionType : Type[] -&gt; Type" Usage="System.Linq.Expressions.Expression.GetActionType typeArgs" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArgs" Type="System.Type[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="typeArgs">
          <span data-ttu-id="f7da9-1365">Uma matriz de um a dezesseis objetos <see cref="T:System.Type" /> que especifica os argumentos de tipo para o tipo de delegado <see langword="System.Action" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1365">An array of up to sixteen <see cref="T:System.Type" /> objects that specify the type arguments for the <see langword="System.Action" /> delegate type.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-1366">Cria um objeto <see cref="T:System.Type" /> que representa um tipo de delegado genérico <c>System.Action</c> que tem argumentos de tipo específicos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1366">Creates a <see cref="T:System.Type" /> object that represents a generic <c>System.Action</c> delegate type that has specific type arguments.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-1367">O tipo de um delegado <c>System.Action</c> que tem os argumentos de tipo especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1367">The type of a <c>System.Action</c> delegate that has the specified type arguments.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-1368">Por exemplo, se os elementos de `typeArgs` representam os tipos `T1…Tn`, resultante <xref:System.Type> objeto representa o tipo de delegado construído `System.Action<T1,…,Tn>` em c# ou `System.Action(Of T1,…,Tn)` no Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1368">As an example, if the elements of `typeArgs` represent the types `T1…Tn`, the resulting <xref:System.Type> object represents the constructed delegate type `System.Action<T1,…,Tn>` in C# or `System.Action(Of T1,…,Tn)` in Visual Basic.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f7da9-1369">
            <paramref name="typeArgs" /> contém mais de dezesseis elementos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1369">
              <paramref name="typeArgs" /> contains more than sixteen elements.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f7da9-1370">
            <paramref name="typeArgs" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1370">
              <paramref name="typeArgs" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetDelegateType">
      <MemberSignature Language="C#" Value="public static Type GetDelegateType (params Type[] typeArgs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetDelegateType(class System.Type[] typeArgs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.GetDelegateType(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDelegateType (ParamArray typeArgs As Type()) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetDelegateType(... cli::array &lt;Type ^&gt; ^ typeArgs);" />
      <MemberSignature Language="F#" Value="static member GetDelegateType : Type[] -&gt; Type" Usage="System.Linq.Expressions.Expression.GetDelegateType typeArgs" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArgs" Type="System.Type[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="typeArgs">
          <span data-ttu-id="f7da9-1371">Os argumentos de tipo do delegado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1371">The type arguments of the delegate.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-1372">Obtém um objeto <see cref="P:System.Linq.Expressions.Expression.Type" /> que representa um tipo de delegado genérico <c>System.Func</c> ou <c>System.Action</c> que tem argumentos de tipo específicos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1372">Gets a <see cref="P:System.Linq.Expressions.Expression.Type" /> object that represents a generic <c>System.Func</c> or <c>System.Action</c> delegate type that has specific type arguments.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-1373">O tipo de delegado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1373">The delegate type.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-1374">O último argumento de tipo determina o tipo de retorno do delegado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1374">The last type argument determines the return type of the delegate.</span></span> <span data-ttu-id="f7da9-1375">Se nenhuma ação ou Func é grande o suficiente, ele irá gerar um tipo de delegado personalizado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1375">If no Func or Action is large enough, it will generate a custom delegate type.</span></span>  
  
 <span data-ttu-id="f7da9-1376">Assim como Func, o último argumento é o tipo de retorno.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1376">As with Func, the last argument is the return type.</span></span> <span data-ttu-id="f7da9-1377">Ele pode ser definido como System. void para produzir uma ação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1377">It can be set to System.Void to produce an Action.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetFuncType">
      <MemberSignature Language="C#" Value="public static Type GetFuncType (params Type[] typeArgs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetFuncType(class System.Type[] typeArgs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.GetFuncType(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFuncType (ParamArray typeArgs As Type()) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetFuncType(... cli::array &lt;Type ^&gt; ^ typeArgs);" />
      <MemberSignature Language="F#" Value="static member GetFuncType : Type[] -&gt; Type" Usage="System.Linq.Expressions.Expression.GetFuncType typeArgs" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArgs" Type="System.Type[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="typeArgs">
          <span data-ttu-id="f7da9-1378">Uma matriz de um a dezessete objetos <see cref="T:System.Type" /> que especifica os argumentos de tipo para o tipo de delegado <see langword="System.Func" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1378">An array of one to seventeen <see cref="T:System.Type" /> objects that specify the type arguments for the <see langword="System.Func" /> delegate type.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-1379">Cria um objeto <see cref="P:System.Linq.Expressions.Expression.Type" /> que representa um tipo de delegado genérico <c>System.Func</c>, que tem argumentos de tipo específicos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1379">Creates a <see cref="P:System.Linq.Expressions.Expression.Type" /> object that represents a generic <c>System.Func</c> delegate type that has specific type arguments.</span>
          </span>
          <span data-ttu-id="f7da9-1380">O último argumento de tipo especifica o tipo de retorno do delegado criado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1380">The last type argument specifies the return type of the created delegate.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-1381">O tipo de um delegado <c>System.Func</c> que tem os argumentos de tipo especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1381">The type of a <c>System.Func</c> delegate that has the specified type arguments.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-1382">`typeArgs` deve conter pelo menos um e no máximo dezessete elementos.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1382">`typeArgs` must contain at least one and at most seventeen elements.</span></span>  
  
 <span data-ttu-id="f7da9-1383">Por exemplo, se os elementos de `typeArgs` representam os tipos `T1…Tn`, resultante <xref:System.Type> objeto representa o tipo de delegado construído `System.Func<T1,…,Tn>` em c# ou `System.Func(Of T1,…,Tn)` no Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1383">As an example, if the elements of `typeArgs` represent the types `T1…Tn`, the resulting <xref:System.Type> object represents the constructed delegate type `System.Func<T1,…,Tn>` in C# or `System.Func(Of T1,…,Tn)` in Visual Basic.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f7da9-1384">
            <paramref name="typeArgs" /> contém menos de um ou mais de dezessete elementos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1384">
              <paramref name="typeArgs" /> contains fewer than one or more than seventeen elements.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f7da9-1385">
            <paramref name="typeArgs" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1385">
              <paramref name="typeArgs" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Goto">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f7da9-1386">Cria um <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa uma instrução "go to".</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1386">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a "go to" statement.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Goto">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Goto (System.Linq.Expressions.LabelTarget target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Goto(class System.Linq.Expressions.LabelTarget target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Goto (target As LabelTarget) As GotoExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Goto(System::Linq::Expressions::LabelTarget ^ target);" />
      <MemberSignature Language="F#" Value="static member Goto : System.Linq.Expressions.LabelTarget -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.Goto target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
      </Parameters>
      <Docs>
        <param name="target">
          <span data-ttu-id="f7da9-1387">O <see cref="T:System.Linq.Expressions.LabelTarget" /> para o qual o <see cref="T:System.Linq.Expressions.GotoExpression" /> irá.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1387">The <see cref="T:System.Linq.Expressions.LabelTarget" /> that the <see cref="T:System.Linq.Expressions.GotoExpression" /> will jump to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-1388">Cria um <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa uma instrução "go to".</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1388">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a "go to" statement.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-1389">Um <see cref="T:System.Linq.Expressions.GotoExpression" /> com <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Goto, a propriedade <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> definida para o valor especificado e um valor nulo a ser passado para o rótulo de destino após saltar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1389">A <see cref="T:System.Linq.Expressions.GotoExpression" /> with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> equal to Goto, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> property set to the specified value, and a null value to be passed to the target label upon jumping.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="f7da9-1390">O exemplo a seguir demonstra como criar uma expressão que contém um <xref:System.Linq.Expressions.GotoExpression> objeto.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1390">The following example demonstrates how to create an expression that contains a <xref:System.Linq.Expressions.GotoExpression> object.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#45](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#45)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#45](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#45)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Goto">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Goto (System.Linq.Expressions.LabelTarget target, System.Linq.Expressions.Expression value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Goto(class System.Linq.Expressions.LabelTarget target, class System.Linq.Expressions.Expression value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Goto (target As LabelTarget, value As Expression) As GotoExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Goto(System::Linq::Expressions::LabelTarget ^ target, System::Linq::Expressions::Expression ^ value);" />
      <MemberSignature Language="F#" Value="static member Goto : System.Linq.Expressions.LabelTarget * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.Goto (target, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="target">
          <span data-ttu-id="f7da9-1391">O <see cref="T:System.Linq.Expressions.LabelTarget" /> para o qual o <see cref="T:System.Linq.Expressions.GotoExpression" /> irá.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1391">The <see cref="T:System.Linq.Expressions.LabelTarget" /> that the <see cref="T:System.Linq.Expressions.GotoExpression" /> will jump to.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="f7da9-1392">O valor que será passado para o rótulo associado ao saltar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1392">The value that will be passed to the associated label upon jumping.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-1393">Cria um <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa uma instrução "go to".</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1393">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a "go to" statement.</span>
          </span>
          <span data-ttu-id="f7da9-1394">O valor passado para o rótulo no salto pode ser especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1394">The value passed to the label upon jumping can be specified.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-1395">Um <see cref="T:System.Linq.Expressions.GotoExpression" /> com <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Goto, a propriedade <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> definida para <paramref name="target" /> e <paramref name="value" /> a ser passado para o rótulo de destino ao saltar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1395">A <see cref="T:System.Linq.Expressions.GotoExpression" /> with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> equal to Goto, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> property set to <paramref name="target" />, and <paramref name="value" /> to be passed to the target label upon jumping.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Goto">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Goto (System.Linq.Expressions.LabelTarget target, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Goto(class System.Linq.Expressions.LabelTarget target, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Goto(System::Linq::Expressions::LabelTarget ^ target, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Goto : System.Linq.Expressions.LabelTarget * Type -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.Goto (target, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="target">
          <span data-ttu-id="f7da9-1396">O <see cref="T:System.Linq.Expressions.LabelTarget" /> para o qual o <see cref="T:System.Linq.Expressions.GotoExpression" /> irá.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1396">The <see cref="T:System.Linq.Expressions.LabelTarget" /> that the <see cref="T:System.Linq.Expressions.GotoExpression" /> will jump to.</span>
          </span>
        </param>
        <param name="type">
          <span data-ttu-id="f7da9-1397">Um <see cref="T:System.Type" /> para definir a propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1397">An <see cref="T:System.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-1398">Cria um <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa uma instrução "go to" com o tipo especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1398">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a "go to" statement with the specified type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-1399">Um <see cref="T:System.Linq.Expressions.GotoExpression" /> com <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Goto, a propriedade <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> definida para o valor especificado, a propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> definida para <paramref name="type" /> e um valor nulo a serem passados para o rótulo de destino após saltar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1399">A <see cref="T:System.Linq.Expressions.GotoExpression" /> with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> equal to Goto, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> property set to the specified value, the <see cref="P:System.Linq.Expressions.Expression.Type" /> property set to <paramref name="type" />, and a null value to be passed to the target label upon jumping.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Goto">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Goto (System.Linq.Expressions.LabelTarget target, System.Linq.Expressions.Expression value, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Goto(class System.Linq.Expressions.LabelTarget target, class System.Linq.Expressions.Expression value, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Goto(System::Linq::Expressions::LabelTarget ^ target, System::Linq::Expressions::Expression ^ value, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Goto : System.Linq.Expressions.LabelTarget * System.Linq.Expressions.Expression * Type -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.Goto (target, value, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="target">
          <span data-ttu-id="f7da9-1400">O <see cref="T:System.Linq.Expressions.LabelTarget" /> para o qual o <see cref="T:System.Linq.Expressions.GotoExpression" /> irá.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1400">The <see cref="T:System.Linq.Expressions.LabelTarget" /> that the <see cref="T:System.Linq.Expressions.GotoExpression" /> will jump to.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="f7da9-1401">O valor que será passado para o rótulo associado ao saltar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1401">The value that will be passed to the associated label upon jumping.</span>
          </span>
        </param>
        <param name="type">
          <span data-ttu-id="f7da9-1402">Um <see cref="T:System.Type" /> para definir a propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1402">An <see cref="T:System.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-1403">Cria um <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa uma instrução "go to" com o tipo especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1403">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a "go to" statement with the specified type.</span>
          </span>
          <span data-ttu-id="f7da9-1404">O valor passado para o rótulo no salto pode ser especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1404">The value passed to the label upon jumping can be specified.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-1405">Um <see cref="T:System.Linq.Expressions.GotoExpression" /> com <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Goto, a propriedade <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> definida para <paramref name="target" />, a propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> definida para <paramref name="type" /> e <paramref name="value" /> a ser passado para o rótulo de destino ao saltar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1405">A <see cref="T:System.Linq.Expressions.GotoExpression" /> with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> equal to Goto, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> property set to <paramref name="target" />, the <see cref="P:System.Linq.Expressions.Expression.Type" /> property set to <paramref name="type" />, and <paramref name="value" /> to be passed to the target label upon jumping.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GreaterThan">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f7da9-1406">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma comparação numérica "maior que".</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1406">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a "greater than" numeric comparison.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GreaterThan">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression GreaterThan (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression GreaterThan(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.GreaterThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GreaterThan (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ GreaterThan(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member GreaterThan : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.GreaterThan (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="f7da9-1407">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1407">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="f7da9-1408">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1408">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-1409">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma comparação numérica "maior que".</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1409">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a "greater than" numeric comparison.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-1410">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThan" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1410">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThan" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-1411">Resultante <xref:System.Linq.Expressions.BinaryExpression> tem o <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriedade definida como o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1411">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="f7da9-1412">O <xref:System.Linq.Expressions.Expression.Type%2A> estiver definida como o tipo de nó.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1412">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="f7da9-1413">Se o nó é elevado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> é de propriedade `true`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1413">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> property is `true`.</span></span> <span data-ttu-id="f7da9-1414">Caso contrário, será `false`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1414">Otherwise, it is `false`.</span></span> <span data-ttu-id="f7da9-1415">A propriedade <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> sempre é `false`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1415">The <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> property is always `false`.</span></span> <span data-ttu-id="f7da9-1416">A propriedade <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> é `null`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1416">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="f7da9-1417">As informações a seguir descrevem o método de implementação, o tipo de nó, e se um nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1417">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="f7da9-1418">Implementando método</span><span class="sxs-lookup"><span data-stu-id="f7da9-1418">Implementing Method</span></span>  
 <span data-ttu-id="f7da9-1419">As regras a seguir determinam o método de implementação para a operação:</span><span class="sxs-lookup"><span data-stu-id="f7da9-1419">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="f7da9-1420">Se o <xref:System.Linq.Expressions.Expression.Type%2A> propriedade deles `left` ou `right` representa um tipo definido pelo usuário que sobrecarrega o operador "maior que", o <xref:System.Reflection.MethodInfo> que representa que o método é o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1420">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the "greater than" operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="f7da9-1421">Caso contrário, se `left`. Tipo e `right`. Tipo de tipos numéricos, o método de implementação está `null`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1421">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="f7da9-1422">Tipo de nó e versão com comparação de precisão x sem comparação de precisão</span><span class="sxs-lookup"><span data-stu-id="f7da9-1422">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="f7da9-1423">Se o método de implementação não for `null`:</span><span class="sxs-lookup"><span data-stu-id="f7da9-1423">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="f7da9-1424">Se `left`. Tipo e `right`. Tipo podem ser atribuídos aos tipos de argumento correspondente do método de implementação, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1424">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="f7da9-1425">O tipo do nó é o tipo de retorno do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1425">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="f7da9-1426">Se as duas seguintes condições forem atendidas, o nó é elevado e o tipo de nó é <xref:System.Boolean>:</span><span class="sxs-lookup"><span data-stu-id="f7da9-1426">If the following two conditions are satisfied, the node is lifted and the type of the node is <xref:System.Boolean>:</span></span>  
  
    -   <span data-ttu-id="f7da9-1427">`left`. Tipo e `right`. Tipo são os dois tipos de valor de que pelo menos um é anulável e os tipos não anuláveis correspondentes são iguais para os tipos de argumento correspondente do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1427">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="f7da9-1428">O tipo de retorno do método de implementação é <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1428">The return type of the implementing method is <xref:System.Boolean>.</span></span>  
  
 <span data-ttu-id="f7da9-1429">Se o método de implementação é `null`:</span><span class="sxs-lookup"><span data-stu-id="f7da9-1429">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="f7da9-1430">Se `left`. Tipo e `right`. Tipo são não anuláveis, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1430">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="f7da9-1431">O tipo de nó é <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1431">The type of the node is <xref:System.Boolean>.</span></span>  
  
-   <span data-ttu-id="f7da9-1432">Se `left`. Tipo e `right`. Tipo são anuláveis, o nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1432">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="f7da9-1433">O tipo de nó é <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1433">The type of the node is <xref:System.Boolean>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f7da9-1434">O exemplo de código a seguir mostra como criar uma expressão que compara dois inteiros.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1434">The following code example shows how to create an expression that compares two integers.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#10)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f7da9-1435">
            <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1435">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f7da9-1436">O operador “maior que” não está definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1436">The "greater than" operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GreaterThan">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression GreaterThan (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, bool liftToNull, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression GreaterThan(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, bool liftToNull, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.GreaterThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GreaterThan (left As Expression, right As Expression, liftToNull As Boolean, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ GreaterThan(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, bool liftToNull, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member GreaterThan : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * bool * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.GreaterThan (left, right, liftToNull, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="liftToNull" Type="System.Boolean" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="f7da9-1437">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1437">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="f7da9-1438">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1438">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="liftToNull">
          <span data-ttu-id="f7da9-1439">
            <see langword="true" /> para definir <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> como <see langword="true" />; <see langword="false" /> para definir <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> como <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1439">
              <see langword="true" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="true" />; <see langword="false" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="false" />.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="f7da9-1440">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1440">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-1441">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma comparação numérica "maior que".</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1441">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a "greater than" numeric comparison.</span>
          </span>
          <span data-ttu-id="f7da9-1442">O método de implementação pode ser especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1442">The implementing method can be specified.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-1443">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThan" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1443">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThan" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-1444">Resultante <xref:System.Linq.Expressions.BinaryExpression> tem o <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriedade definida como o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1444">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="f7da9-1445">O <xref:System.Linq.Expressions.Expression.Type%2A> estiver definida como o tipo de nó.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1445">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="f7da9-1446">Se o nó é elevado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> é de propriedade `true` e o <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriedade é igual a `liftToNull`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1446">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> property is `true` and the <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> property is equal to `liftToNull`.</span></span> <span data-ttu-id="f7da9-1447">Caso contrário, eles são ambos `false`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1447">Otherwise, they are both `false`.</span></span> <span data-ttu-id="f7da9-1448">A propriedade <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> é `null`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1448">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="f7da9-1449">As informações a seguir descrevem o método de implementação, o tipo de nó, e se um nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1449">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="f7da9-1450">Implementando método</span><span class="sxs-lookup"><span data-stu-id="f7da9-1450">Implementing Method</span></span>  
 <span data-ttu-id="f7da9-1451">As regras a seguir determinam o método de implementação para a operação:</span><span class="sxs-lookup"><span data-stu-id="f7da9-1451">The following rules determine the implementing method for the operation :</span></span>  
  
-   <span data-ttu-id="f7da9-1452">Se `method` não é `null` e representa um não-nulo, `static` (`Shared` no Visual Basic) método que usa dois argumentos, é o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1452">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method.</span></span>  
  
-   <span data-ttu-id="f7da9-1453">Caso contrário, se o <xref:System.Linq.Expressions.Expression.Type%2A> propriedade deles `left` ou `right` representa um tipo definido pelo usuário que sobrecarrega o operador "maior que", o <xref:System.Reflection.MethodInfo> que representa que o método é o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1453">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the "greater than" operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="f7da9-1454">Caso contrário, se `left`. Tipo e `right`. Tipo de tipos numéricos, o método de implementação está `null`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1454">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="f7da9-1455">Tipo de nó e versão com comparação de precisão x sem comparação de precisão</span><span class="sxs-lookup"><span data-stu-id="f7da9-1455">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="f7da9-1456">Se o método de implementação não for `null`:</span><span class="sxs-lookup"><span data-stu-id="f7da9-1456">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="f7da9-1457">Se `left`. Tipo e `right`. Tipo podem ser atribuídos aos tipos de argumento correspondente do método de implementação, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1457">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="f7da9-1458">O tipo do nó é o tipo de retorno do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1458">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="f7da9-1459">Se as duas seguintes condições forem atendidas, o nó é eliminado; Além disso, o tipo do nó é anulável <xref:System.Boolean> se `liftToNull` é `true` ou <xref:System.Boolean> se `liftToNull` é `false`:</span><span class="sxs-lookup"><span data-stu-id="f7da9-1459">If the following two conditions are satisfied, the node is lifted; also, the type of the node is nullable <xref:System.Boolean> if `liftToNull` is `true` or <xref:System.Boolean> if `liftToNull` is `false`:</span></span>  
  
    -   <span data-ttu-id="f7da9-1460">`left`. Tipo e `right`. Tipo são os dois tipos de valor de que pelo menos um é anulável e os tipos não anuláveis correspondentes são iguais para os tipos de argumento correspondente do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1460">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="f7da9-1461">O tipo de retorno do método de implementação é <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1461">The return type of the implementing method is <xref:System.Boolean>.</span></span>  
  
 <span data-ttu-id="f7da9-1462">Se o método de implementação é `null`:</span><span class="sxs-lookup"><span data-stu-id="f7da9-1462">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="f7da9-1463">Se `left`. Tipo e `right`. Tipo são não anuláveis, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1463">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="f7da9-1464">O tipo de nó é <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1464">The type of the node is <xref:System.Boolean>.</span></span>  
  
-   <span data-ttu-id="f7da9-1465">Se `left`. Tipo e `right`. Tipo são anuláveis, o nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1465">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="f7da9-1466">O tipo do nó é anulável <xref:System.Boolean> se `liftToNull` é `true` ou <xref:System.Boolean> se `liftToNull` é `false`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1466">The type of the node is nullable <xref:System.Boolean> if `liftToNull` is `true` or <xref:System.Boolean> if `liftToNull` is `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f7da9-1467">
            <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1467">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f7da9-1468">
            <paramref name="method" /> não é <see langword="null" /> e o método que ele representa retorna <see langword="void" />, não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) ou não tem exatamente dois argumentos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1468">
              <paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f7da9-1469">
            <paramref name="method" /> é <see langword="null" /> e o operador "maior que" não foi definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1469">
              <paramref name="method" /> is <see langword="null" /> and the "greater than" operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GreaterThanOrEqual">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f7da9-1470">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma comparação numérica "maior ou igual a".</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1470">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a "greater than or equal" numeric comparison.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression GreaterThanOrEqual (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression GreaterThanOrEqual(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.GreaterThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GreaterThanOrEqual (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ GreaterThanOrEqual(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member GreaterThanOrEqual : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.GreaterThanOrEqual (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="f7da9-1471">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1471">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="f7da9-1472">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1472">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-1473">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma comparação numérica "maior ou igual a".</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1473">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a "greater than or equal" numeric comparison.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-1474">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThanOrEqual" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1474">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThanOrEqual" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-1475">Resultante <xref:System.Linq.Expressions.BinaryExpression> tem o <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriedade definida como o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1475">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="f7da9-1476">O <xref:System.Linq.Expressions.Expression.Type%2A> estiver definida como o tipo de nó.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1476">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="f7da9-1477">Se o nó é elevado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> é de propriedade `true`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1477">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> property is `true`.</span></span> <span data-ttu-id="f7da9-1478">Caso contrário, será `false`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1478">Otherwise, it is `false`.</span></span> <span data-ttu-id="f7da9-1479">A propriedade <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> sempre é `false`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1479">The <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> property is always `false`.</span></span> <span data-ttu-id="f7da9-1480">A propriedade <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> é `null`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1480">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="f7da9-1481">As informações a seguir descrevem o método de implementação, o tipo de nó, e se um nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1481">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="f7da9-1482">Implementando método</span><span class="sxs-lookup"><span data-stu-id="f7da9-1482">Implementing Method</span></span>  
 <span data-ttu-id="f7da9-1483">As regras a seguir determinam o método de implementação para a operação:</span><span class="sxs-lookup"><span data-stu-id="f7da9-1483">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="f7da9-1484">Se o <xref:System.Linq.Expressions.Expression.Type%2A> propriedade deles `left` ou `right` representa um tipo definido pelo usuário que sobrecarrega o operador "maior que ou igual", o <xref:System.Reflection.MethodInfo> que representa que o método é o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1484">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the "greater than or equal" operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="f7da9-1485">Caso contrário, se `left`. Tipo e `right`. Tipo de tipos numéricos, o método de implementação está `null`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1485">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="f7da9-1486">Tipo de nó e versão com comparação de precisão x sem comparação de precisão</span><span class="sxs-lookup"><span data-stu-id="f7da9-1486">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="f7da9-1487">Se o método de implementação não for `null`:</span><span class="sxs-lookup"><span data-stu-id="f7da9-1487">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="f7da9-1488">Se `left`. Tipo e `right`. Tipo podem ser atribuídos aos tipos de argumento correspondente do método de implementação, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1488">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="f7da9-1489">O tipo do nó é o tipo de retorno do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1489">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="f7da9-1490">Se as duas seguintes condições forem atendidas, o nó é elevado e o tipo de nó é <xref:System.Boolean>:</span><span class="sxs-lookup"><span data-stu-id="f7da9-1490">If the following two conditions are satisfied, the node is lifted and the type of the node is <xref:System.Boolean>:</span></span>  
  
    -   <span data-ttu-id="f7da9-1491">`left`. Tipo e `right`. Tipo são os dois tipos de valor de que pelo menos um é anulável e os tipos não anuláveis correspondentes são iguais para os tipos de argumento correspondente do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1491">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="f7da9-1492">O tipo de retorno do método de implementação é <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1492">The return type of the implementing method is <xref:System.Boolean>.</span></span>  
  
 <span data-ttu-id="f7da9-1493">Se o método de implementação é `null`:</span><span class="sxs-lookup"><span data-stu-id="f7da9-1493">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="f7da9-1494">Se `left`. Tipo e `right`. Tipo são não anuláveis, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1494">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="f7da9-1495">O tipo de nó é <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1495">The type of the node is <xref:System.Boolean>.</span></span>  
  
-   <span data-ttu-id="f7da9-1496">Se `left`. Tipo e `right`. Tipo são anuláveis, o nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1496">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="f7da9-1497">O tipo de nó é <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1497">The type of the node is <xref:System.Boolean>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f7da9-1498">O exemplo de código a seguir mostra como criar uma expressão que compara dois inteiros.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1498">The following code example shows how to create an expression that compares two integers.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#11)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f7da9-1499">
            <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1499">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f7da9-1500">O operador “maior ou igual a” não está definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1500">The "greater than or equal" operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression GreaterThanOrEqual (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, bool liftToNull, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression GreaterThanOrEqual(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, bool liftToNull, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.GreaterThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GreaterThanOrEqual (left As Expression, right As Expression, liftToNull As Boolean, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ GreaterThanOrEqual(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, bool liftToNull, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member GreaterThanOrEqual : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * bool * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.GreaterThanOrEqual (left, right, liftToNull, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="liftToNull" Type="System.Boolean" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="f7da9-1501">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1501">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="f7da9-1502">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1502">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="liftToNull">
          <span data-ttu-id="f7da9-1503">
            <see langword="true" /> para definir <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> como <see langword="true" />; <see langword="false" /> para definir <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> como <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1503">
              <see langword="true" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="true" />; <see langword="false" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="false" />.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="f7da9-1504">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1504">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-1505">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma comparação numérica "maior ou igual a".</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1505">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a "greater than or equal" numeric comparison.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-1506">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThanOrEqual" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1506">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThanOrEqual" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-1507">Resultante <xref:System.Linq.Expressions.BinaryExpression> tem o <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriedade definida como o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1507">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="f7da9-1508">O <xref:System.Linq.Expressions.Expression.Type%2A> estiver definida como o tipo de nó.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1508">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="f7da9-1509">Se o nó é elevado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> é de propriedade `true` e o <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriedade é igual a `liftToNull`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1509">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> property is `true` and the <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> property is equal to `liftToNull`.</span></span> <span data-ttu-id="f7da9-1510">Caso contrário, eles são ambos `false`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1510">Otherwise, they are both `false`.</span></span> <span data-ttu-id="f7da9-1511">A propriedade <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> é `null`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1511">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="f7da9-1512">As informações a seguir descrevem o método de implementação, o tipo de nó, e se um nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1512">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="f7da9-1513">Implementando método</span><span class="sxs-lookup"><span data-stu-id="f7da9-1513">Implementing Method</span></span>  
 <span data-ttu-id="f7da9-1514">As regras a seguir determinam o método de implementação para a operação:</span><span class="sxs-lookup"><span data-stu-id="f7da9-1514">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="f7da9-1515">Se `method` não é `null` e representa um não-nulo, `static` (`Shared` no Visual Basic) método que usa dois argumentos, é o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1515">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method.</span></span>  
  
-   <span data-ttu-id="f7da9-1516">Caso contrário, se o <xref:System.Linq.Expressions.Expression.Type%2A> propriedade deles `left` ou `right` representa um tipo definido pelo usuário que sobrecarrega o operador "maior que ou igual", o <xref:System.Reflection.MethodInfo> que representa que o método é o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1516">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the "greater than or equal" operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="f7da9-1517">Caso contrário, se `left`. Tipo e `right`. Tipo de tipos numéricos, o método de implementação está `null`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1517">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="f7da9-1518">Tipo de nó e versão com comparação de precisão x sem comparação de precisão</span><span class="sxs-lookup"><span data-stu-id="f7da9-1518">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="f7da9-1519">Se o método de implementação não for `null`:</span><span class="sxs-lookup"><span data-stu-id="f7da9-1519">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="f7da9-1520">Se `left`. Tipo e `right`. Tipo podem ser atribuídos aos tipos de argumento correspondente do método de implementação, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1520">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="f7da9-1521">O tipo do nó é o tipo de retorno do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1521">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="f7da9-1522">Se as duas seguintes condições forem atendidas, o nó é eliminado; Além disso, o tipo do nó é anulável <xref:System.Boolean> se `liftToNull` é `true` ou <xref:System.Boolean> se `liftToNull` é `false`:</span><span class="sxs-lookup"><span data-stu-id="f7da9-1522">If the following two conditions are satisfied, the node is lifted; also, the type of the node is nullable <xref:System.Boolean> if `liftToNull` is `true` or <xref:System.Boolean> if `liftToNull` is `false`:</span></span>  
  
    -   <span data-ttu-id="f7da9-1523">`left`. Tipo e `right`. Tipo são os dois tipos de valor de que pelo menos um é anulável e os tipos não anuláveis correspondentes são iguais para os tipos de argumento correspondente do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1523">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="f7da9-1524">O tipo de retorno do método de implementação é <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1524">The return type of the implementing method is <xref:System.Boolean>.</span></span>  
  
 <span data-ttu-id="f7da9-1525">Se o método de implementação é `null`:</span><span class="sxs-lookup"><span data-stu-id="f7da9-1525">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="f7da9-1526">Se `left`. Tipo e `right`. Tipo são não anuláveis, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1526">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="f7da9-1527">O tipo de nó é <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1527">The type of the node is <xref:System.Boolean>.</span></span>  
  
-   <span data-ttu-id="f7da9-1528">Se `left`. Tipo e `right`. Tipo são anuláveis, o nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1528">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="f7da9-1529">O tipo do nó é anulável <xref:System.Boolean> se `liftToNull` é `true` ou <xref:System.Boolean> se `liftToNull` é `false`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1529">The type of the node is nullable <xref:System.Boolean> if `liftToNull` is `true` or <xref:System.Boolean> if `liftToNull` is `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f7da9-1530">
            <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1530">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f7da9-1531">
            <paramref name="method" /> não é <see langword="null" /> e o método que ele representa retorna <see langword="void" />, não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) ou não tem exatamente dois argumentos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1531">
              <paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f7da9-1532">
            <paramref name="method" /> é <see langword="null" /> e o operador "maior ou igual a" não foi definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1532">
              <paramref name="method" /> is <see langword="null" /> and the "greater than or equal" operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="IfThen">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ConditionalExpression IfThen (System.Linq.Expressions.Expression test, System.Linq.Expressions.Expression ifTrue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ConditionalExpression IfThen(class System.Linq.Expressions.Expression test, class System.Linq.Expressions.Expression ifTrue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.IfThen(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IfThen (test As Expression, ifTrue As Expression) As ConditionalExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ConditionalExpression ^ IfThen(System::Linq::Expressions::Expression ^ test, System::Linq::Expressions::Expression ^ ifTrue);" />
      <MemberSignature Language="F#" Value="static member IfThen : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.ConditionalExpression" Usage="System.Linq.Expressions.Expression.IfThen (test, ifTrue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ConditionalExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="test" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="ifTrue" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="test">
          <span data-ttu-id="f7da9-1533">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1533">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> property equal to.</span>
          </span>
        </param>
        <param name="ifTrue">
          <span data-ttu-id="f7da9-1534">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1534">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-1535">Cria um <see cref="T:System.Linq.Expressions.ConditionalExpression" /> que representa um bloco condicional com uma instrução <see langword="if" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1535">Creates a <see cref="T:System.Linq.Expressions.ConditionalExpression" /> that represents a conditional block with an <see langword="if" /> statement.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-1536">Um <see cref="T:System.Linq.Expressions.ConditionalExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> e as propriedades <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> e <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> definidas como os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1536">A <see cref="T:System.Linq.Expressions.ConditionalExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> and the <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />, properties set to the specified values.</span>
          </span>
          <span data-ttu-id="f7da9-1537">A propriedade <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> foi definida como a expressão padrão e o tipo do <see cref="T:System.Linq.Expressions.ConditionalExpression" /> resultante retornado por esse método é <see cref="T:System.Void" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1537">The <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> property is set to default expression and the type of the resulting <see cref="T:System.Linq.Expressions.ConditionalExpression" /> returned by this method is <see cref="T:System.Void" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="f7da9-1538">O exemplo de código a seguir mostra como criar uma expressão que representa um bloco condicional.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1538">The following code example shows how to create an expression that represents a conditional block.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#32](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#32)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#32](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#32)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IfThenElse">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ConditionalExpression IfThenElse (System.Linq.Expressions.Expression test, System.Linq.Expressions.Expression ifTrue, System.Linq.Expressions.Expression ifFalse);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ConditionalExpression IfThenElse(class System.Linq.Expressions.Expression test, class System.Linq.Expressions.Expression ifTrue, class System.Linq.Expressions.Expression ifFalse) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.IfThenElse(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IfThenElse (test As Expression, ifTrue As Expression, ifFalse As Expression) As ConditionalExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ConditionalExpression ^ IfThenElse(System::Linq::Expressions::Expression ^ test, System::Linq::Expressions::Expression ^ ifTrue, System::Linq::Expressions::Expression ^ ifFalse);" />
      <MemberSignature Language="F#" Value="static member IfThenElse : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.ConditionalExpression" Usage="System.Linq.Expressions.Expression.IfThenElse (test, ifTrue, ifFalse)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ConditionalExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="test" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="ifTrue" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="ifFalse" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="test">
          <span data-ttu-id="f7da9-1539">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1539">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> property equal to.</span>
          </span>
        </param>
        <param name="ifTrue">
          <span data-ttu-id="f7da9-1540">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1540">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> property equal to.</span>
          </span>
        </param>
        <param name="ifFalse">
          <span data-ttu-id="f7da9-1541">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1541">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-1542">Cria um <see cref="T:System.Linq.Expressions.ConditionalExpression" /> que representa um bloco condicional com as instruções <see langword="if" /> e <see langword="else" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1542">Creates a <see cref="T:System.Linq.Expressions.ConditionalExpression" /> that represents a conditional block with <see langword="if" /> and <see langword="else" /> statements.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-1543">Um <see cref="T:System.Linq.Expressions.ConditionalExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> e as propriedades <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> e <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1543">A <see cref="T:System.Linq.Expressions.ConditionalExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> and the <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />, and <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> properties set to the specified values.</span>
          </span>
          <span data-ttu-id="f7da9-1544">O tipo de <see cref="T:System.Linq.Expressions.ConditionalExpression" /> resultante retornado por esse método é <see cref="T:System.Void" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1544">The type of the resulting <see cref="T:System.Linq.Expressions.ConditionalExpression" /> returned by this method is <see cref="T:System.Void" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="f7da9-1545">O exemplo de código a seguir mostra como criar uma expressão que representa um bloco condicional.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1545">The following code example shows how to create an expression that represents a conditional block.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#33](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#33)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#33](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#33)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Increment">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f7da9-1546">Cria um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa o incremento do valor da expressão em 1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1546">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the incrementing of the expression value by 1.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Increment">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Increment (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Increment(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Increment(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Increment(System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member Increment : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Increment expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression">
          <span data-ttu-id="f7da9-1547">Um <see cref="T:System.Linq.Expressions.Expression" /> a ser incrementado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1547">An <see cref="T:System.Linq.Expressions.Expression" /> to increment.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-1548">Cria um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa o incremento do valor da expressão em 1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1548">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the incrementing of the expression value by 1.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-1549">Um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa a expressão incrementada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1549">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the incremented expression.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-1550">Esta expressão é funcional e não altera o valor do objeto que é passado para ele.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1550">This expression is functional and does not change the value of the object that is passed to it.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f7da9-1551">O exemplo de código a seguir mostra como criar uma expressão que representa uma operação de incremento.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1551">The following code example shows how to create an expression that represents an increment operation.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#24)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#24)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Increment">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Increment (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Increment(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Increment(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Increment(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member Increment : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Increment (expression, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">
          <span data-ttu-id="f7da9-1552">Um <see cref="T:System.Linq.Expressions.Expression" /> a ser incrementado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1552">An <see cref="T:System.Linq.Expressions.Expression" /> to increment.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="f7da9-1553">Um <see cref="T:System.Reflection.MethodInfo" /> que representa o método de implementação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1553">A <see cref="T:System.Reflection.MethodInfo" /> that represents the implementing method.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-1554">Cria um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa o incremento da expressão em 1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1554">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the incrementing of the expression by 1.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-1555">Um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa a expressão incrementada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1555">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the incremented expression.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-1556">Esta expressão é funcional e não altera o valor do objeto que é passado para ele.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1556">This expression is functional and does not change the value of the object that is passed to it.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Invoke">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f7da9-1557">Cria um <see cref="T:System.Linq.Expressions.InvocationExpression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1557">Creates an <see cref="T:System.Linq.Expressions.InvocationExpression" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.InvocationExpression Invoke (System.Linq.Expressions.Expression expression, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.InvocationExpression Invoke(class System.Linq.Expressions.Expression expression, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Invoke(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::InvocationExpression ^ Invoke(System::Linq::Expressions::Expression ^ expression, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Invoke : System.Linq.Expressions.Expression * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.InvocationExpression" Usage="System.Linq.Expressions.Expression.Invoke (expression, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.InvocationExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="expression">
          <span data-ttu-id="f7da9-1558">Um <see cref="T:System.Linq.Expressions.Expression" /> que representa a expressão de delegado ou lambda à qual aplicar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1558">An <see cref="T:System.Linq.Expressions.Expression" /> that represents the delegate or lambda expression to be applied to.</span>
          </span>
        </param>
        <param name="arguments">
          <span data-ttu-id="f7da9-1559">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.Expression" /> que representam os argumentos aos quais a expressão de delegado ou lambda é aplicada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1559">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.Expression" /> objects that represent the arguments that the delegate or lambda expression is applied to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-1560">Cria um <see cref="T:System.Linq.Expressions.InvocationExpression" /> que se aplica a uma expressão de delegado ou lambda para uma lista de expressões de argumento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1560">Creates an <see cref="T:System.Linq.Expressions.InvocationExpression" /> that applies a delegate or lambda expression to a list of argument expressions.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-1561">Um <see cref="T:System.Linq.Expressions.InvocationExpression" /> que se aplica à expressão de delegado ou lambda especificada para os argumentos fornecidos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1561">An <see cref="T:System.Linq.Expressions.InvocationExpression" /> that applies the specified delegate or lambda expression to the provided arguments.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-1562">O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade resultantes <xref:System.Linq.Expressions.InvocationExpression> representa o tipo de retorno do delegado que é representado pela `expression`. Tipo.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1562">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.InvocationExpression> represents the return type of the delegate that is represented by `expression`.Type.</span></span>  
  
 <span data-ttu-id="f7da9-1563">O <xref:System.Linq.Expressions.InvocationExpression.Arguments%2A> propriedade resultantes <xref:System.Linq.Expressions.InvocationExpression> está vazia se `arguments` é `null`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1563">The <xref:System.Linq.Expressions.InvocationExpression.Arguments%2A> property of the resulting <xref:System.Linq.Expressions.InvocationExpression> is empty if `arguments` is `null`.</span></span> <span data-ttu-id="f7da9-1564">Caso contrário, ele contém os mesmos elementos `arguments` , exceto que alguns deles <xref:System.Linq.Expressions.Expression> objetos podem estar *entre aspas*.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1564">Otherwise, it contains the same elements as `arguments` except that some of these <xref:System.Linq.Expressions.Expression> objects may be *quoted*.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f7da9-1565">Um elemento será ser colocado entre aspas somente se o parâmetro correspondente ao delegado representado por `expression` é do tipo <xref:System.Linq.Expressions.Expression>.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1565">An element will be quoted only if the corresponding parameter of the delegate represented by `expression` is of type <xref:System.Linq.Expressions.Expression>.</span></span> <span data-ttu-id="f7da9-1566">Delimitação significa que o elemento é encapsulado em um <xref:System.Linq.Expressions.ExpressionType.Quote> nó.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1566">Quoting means the element is wrapped in a <xref:System.Linq.Expressions.ExpressionType.Quote> node.</span></span> <span data-ttu-id="f7da9-1567">O nó resultante é um <xref:System.Linq.Expressions.UnaryExpression> cujos <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> propriedade é o elemento de `arguments`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1567">The resulting node is a <xref:System.Linq.Expressions.UnaryExpression> whose <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> property is the element of `arguments`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f7da9-1568">O exemplo a seguir demonstra como usar o <xref:System.Linq.Expressions.Expression.Invoke%28System.Linq.Expressions.Expression%2CSystem.Linq.Expressions.Expression%5B%5D%29> método para criar um <xref:System.Linq.Expressions.InvocationExpression> que representa a invocação de uma expressão lambda com argumentos especificados.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1568">The following example demonstrates how to use the <xref:System.Linq.Expressions.Expression.Invoke%28System.Linq.Expressions.Expression%2CSystem.Linq.Expressions.Expression%5B%5D%29> method to create an <xref:System.Linq.Expressions.InvocationExpression> that represents the invocation of a lambda expression with specified arguments.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.Expression#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#6)]
 [!code-vb[System.Linq.Expressions.Expression#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f7da9-1569">
            <paramref name="expression" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1569">
              <paramref name="expression" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f7da9-1570">
            <paramref name="expression" />.Type não representa um tipo de delegado nem um <see cref="T:System.Linq.Expressions.Expression`1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1570">
              <paramref name="expression" />.Type does not represent a delegate type or an <see cref="T:System.Linq.Expressions.Expression`1" />.</span>
          </span>
          <span data-ttu-id="f7da9-1571">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1571">-or-</span>
          </span>
          <span data-ttu-id="f7da9-1572">A propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> de um elemento de <paramref name="arguments" /> não é atribuível ao tipo de parâmetro correspondente ao delegado representado por <paramref name="expression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1572">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of an element of <paramref name="arguments" /> is not assignable to the type of the corresponding parameter of the delegate represented by <paramref name="expression" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f7da9-1573">
            <paramref name="arguments" /> não contém o mesmo número de elementos da lista de parâmetros para o delegado representado por <paramref name="expression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1573">
              <paramref name="arguments" /> does not contain the same number of elements as the list of parameters for the delegate represented by <paramref name="expression" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.InvocationExpression Invoke (System.Linq.Expressions.Expression expression, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.InvocationExpression Invoke(class System.Linq.Expressions.Expression expression, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Invoke(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::InvocationExpression ^ Invoke(System::Linq::Expressions::Expression ^ expression, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Invoke : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.InvocationExpression" Usage="System.Linq.Expressions.Expression.Invoke (expression, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.InvocationExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="expression">
          <span data-ttu-id="f7da9-1574">Um <see cref="T:System.Linq.Expressions.Expression" /> que representa a expressão de delegado ou lambda a ser aplicada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1574">An <see cref="T:System.Linq.Expressions.Expression" /> that represents the delegate or lambda expression to be applied.</span>
          </span>
        </param>
        <param name="arguments">
          <span data-ttu-id="f7da9-1575">Uma matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> que representam os argumentos aos quais que a expressão de delegado ou lambda são aplicados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1575">An array of <see cref="T:System.Linq.Expressions.Expression" /> objects that represent the arguments that the delegate or lambda expression is applied to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-1576">Cria um <see cref="T:System.Linq.Expressions.InvocationExpression" /> que se aplica a uma expressão de delegado ou lambda para uma lista de expressões de argumento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1576">Creates an <see cref="T:System.Linq.Expressions.InvocationExpression" /> that applies a delegate or lambda expression to a list of argument expressions.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-1577">Um <see cref="T:System.Linq.Expressions.InvocationExpression" /> que se aplica à expressão de delegado ou lambda especificada para os argumentos fornecidos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1577">An <see cref="T:System.Linq.Expressions.InvocationExpression" /> that applies the specified delegate or lambda expression to the provided arguments.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-1578">O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade resultantes <xref:System.Linq.Expressions.InvocationExpression> representa o tipo de retorno do delegado que é representado pela `expression`. Tipo.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1578">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.InvocationExpression> represents the return type of the delegate that is represented by `expression`.Type.</span></span>  
  
 <span data-ttu-id="f7da9-1579">O <xref:System.Linq.Expressions.InvocationExpression.Arguments%2A> propriedade resultantes <xref:System.Linq.Expressions.InvocationExpression> está vazia se `arguments` é `null`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1579">The <xref:System.Linq.Expressions.InvocationExpression.Arguments%2A> property of the resulting <xref:System.Linq.Expressions.InvocationExpression> is empty if `arguments` is `null`.</span></span> <span data-ttu-id="f7da9-1580">Caso contrário, ele contém os mesmos elementos `arguments` , exceto que alguns deles <xref:System.Linq.Expressions.Expression> objetos podem estar *entre aspas*.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1580">Otherwise, it contains the same elements as `arguments` except that some of these <xref:System.Linq.Expressions.Expression> objects may be *quoted*.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f7da9-1581">Um elemento será ser colocado entre aspas somente se o parâmetro correspondente ao delegado representado por `expression` é do tipo <xref:System.Linq.Expressions.Expression>.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1581">An element will be quoted only if the corresponding parameter of the delegate represented by `expression` is of type <xref:System.Linq.Expressions.Expression>.</span></span> <span data-ttu-id="f7da9-1582">Delimitação significa que o elemento é encapsulado em um <xref:System.Linq.Expressions.ExpressionType.Quote> nó.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1582">Quoting means the element is wrapped in a <xref:System.Linq.Expressions.ExpressionType.Quote> node.</span></span> <span data-ttu-id="f7da9-1583">O nó resultante é um <xref:System.Linq.Expressions.UnaryExpression> cujos <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> propriedade é o elemento de `arguments`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1583">The resulting node is a <xref:System.Linq.Expressions.UnaryExpression> whose <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> property is the element of `arguments`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f7da9-1584">O exemplo a seguir demonstra como usar o <xref:System.Linq.Expressions.Expression.Invoke%28System.Linq.Expressions.Expression%2CSystem.Linq.Expressions.Expression%5B%5D%29> método para criar um <xref:System.Linq.Expressions.InvocationExpression> que representa a invocação de uma expressão lambda com argumentos especificados.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1584">The following example demonstrates how to use the <xref:System.Linq.Expressions.Expression.Invoke%28System.Linq.Expressions.Expression%2CSystem.Linq.Expressions.Expression%5B%5D%29> method to create an <xref:System.Linq.Expressions.InvocationExpression> that represents the invocation of a lambda expression with specified arguments.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.Expression#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#6)]
 [!code-vb[System.Linq.Expressions.Expression#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f7da9-1585">
            <paramref name="expression" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1585">
              <paramref name="expression" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f7da9-1586">
            <paramref name="expression" />.Type não representa um tipo de delegado nem um <see cref="T:System.Linq.Expressions.Expression`1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1586">
              <paramref name="expression" />.Type does not represent a delegate type or an <see cref="T:System.Linq.Expressions.Expression`1" />.</span>
          </span>
          <span data-ttu-id="f7da9-1587">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1587">-or-</span>
          </span>
          <span data-ttu-id="f7da9-1588">A propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> de um elemento de <paramref name="arguments" /> não é atribuível ao tipo de parâmetro correspondente ao delegado representado por <paramref name="expression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1588">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of an element of <paramref name="arguments" /> is not assignable to the type of the corresponding parameter of the delegate represented by <paramref name="expression" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f7da9-1589">
            <paramref name="arguments" /> não contém o mesmo número de elementos da lista de parâmetros para o delegado representado por <paramref name="expression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1589">
              <paramref name="arguments" /> does not contain the same number of elements as the list of parameters for the delegate represented by <paramref name="expression" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsFalse">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f7da9-1590">Retorna se a expressão é avaliada como false.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1590">Returns whether the expression evaluates to false.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsFalse">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression IsFalse (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression IsFalse(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.IsFalse(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ IsFalse(System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member IsFalse : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.IsFalse expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression">
          <span data-ttu-id="f7da9-1591">Um <see cref="T:System.Linq.Expressions.Expression" /> a ser avaliado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1591">An <see cref="T:System.Linq.Expressions.Expression" /> to evaluate.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-1592">Retorna se a expressão é avaliada como false.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1592">Returns whether the expression evaluates to false.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-1593">Uma instância de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1593">An instance of <see cref="T:System.Linq.Expressions.UnaryExpression" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFalse">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression IsFalse (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression IsFalse(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.IsFalse(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ IsFalse(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member IsFalse : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.IsFalse (expression, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">
          <span data-ttu-id="f7da9-1594">Um <see cref="T:System.Linq.Expressions.Expression" /> a ser avaliado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1594">An <see cref="T:System.Linq.Expressions.Expression" /> to evaluate.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="f7da9-1595">Um <see cref="T:System.Reflection.MethodInfo" /> que representa o método de implementação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1595">A <see cref="T:System.Reflection.MethodInfo" /> that represents the implementing method.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-1596">Retorna se a expressão é avaliada como false.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1596">Returns whether the expression evaluates to false.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-1597">Uma instância de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1597">An instance of <see cref="T:System.Linq.Expressions.UnaryExpression" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsTrue">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f7da9-1598">Retorna se a expressão é avaliada como true.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1598">Returns whether the expression evaluates to true.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsTrue">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression IsTrue (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression IsTrue(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.IsTrue(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ IsTrue(System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member IsTrue : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.IsTrue expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression">
          <span data-ttu-id="f7da9-1599">Um <see cref="T:System.Linq.Expressions.Expression" /> a ser avaliado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1599">An <see cref="T:System.Linq.Expressions.Expression" /> to evaluate.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-1600">Retorna se a expressão é avaliada como true.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1600">Returns whether the expression evaluates to true.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-1601">Uma instância de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1601">An instance of <see cref="T:System.Linq.Expressions.UnaryExpression" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsTrue">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression IsTrue (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression IsTrue(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.IsTrue(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ IsTrue(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member IsTrue : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.IsTrue (expression, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">
          <span data-ttu-id="f7da9-1602">Um <see cref="T:System.Linq.Expressions.Expression" /> a ser avaliado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1602">An <see cref="T:System.Linq.Expressions.Expression" /> to evaluate.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="f7da9-1603">Um <see cref="T:System.Reflection.MethodInfo" /> que representa o método de implementação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1603">A <see cref="T:System.Reflection.MethodInfo" /> that represents the implementing method.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-1604">Retorna se a expressão é avaliada como true.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1604">Returns whether the expression evaluates to true.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-1605">Uma instância de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1605">An instance of <see cref="T:System.Linq.Expressions.UnaryExpression" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Label">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f7da9-1606">Cria um <see cref="T:System.Linq.Expressions.LabelTarget" /> que representa um demonstrativo de retorno.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1606">Creates a <see cref="T:System.Linq.Expressions.LabelTarget" /> representing a label.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LabelTarget Label ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LabelTarget Label() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Label" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Label () As LabelTarget" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LabelTarget ^ Label();" />
      <MemberSignature Language="F#" Value="static member Label : unit -&gt; System.Linq.Expressions.LabelTarget" Usage="System.Linq.Expressions.Expression.Label " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LabelTarget</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="f7da9-1607">Cria um <see cref="T:System.Linq.Expressions.LabelTarget" /> que representa um rótulo com um tipo void e sem nenhum nome.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1607">Creates a <see cref="T:System.Linq.Expressions.LabelTarget" /> representing a label with void type and no name.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-1608">O novo <see cref="T:System.Linq.Expressions.LabelTarget" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1608">The new <see cref="T:System.Linq.Expressions.LabelTarget" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="f7da9-1609">O exemplo a seguir demonstra como criar uma expressão que contém um <xref:System.Linq.Expressions.LabelTarget> objeto.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1609">The following example demonstrates how to create an expression that contains a <xref:System.Linq.Expressions.LabelTarget> object.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#43](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#43)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#43](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#43)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LabelExpression Label (System.Linq.Expressions.LabelTarget target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LabelExpression Label(class System.Linq.Expressions.LabelTarget target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Label(System.Linq.Expressions.LabelTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Label (target As LabelTarget) As LabelExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LabelExpression ^ Label(System::Linq::Expressions::LabelTarget ^ target);" />
      <MemberSignature Language="F#" Value="static member Label : System.Linq.Expressions.LabelTarget -&gt; System.Linq.Expressions.LabelExpression" Usage="System.Linq.Expressions.Expression.Label target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LabelExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
      </Parameters>
      <Docs>
        <param name="target">
          <span data-ttu-id="f7da9-1610">O <see cref="T:System.Linq.Expressions.LabelTarget" /> ao qual esse <see cref="T:System.Linq.Expressions.LabelExpression" /> será associado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1610">The <see cref="T:System.Linq.Expressions.LabelTarget" /> which this <see cref="T:System.Linq.Expressions.LabelExpression" /> will be associated with.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-1611">Cria um <see cref="T:System.Linq.Expressions.LabelExpression" /> que representa um rótulo com um valor padrão.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1611">Creates a <see cref="T:System.Linq.Expressions.LabelExpression" /> representing a label without a default value.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-1612">Um <see cref="T:System.Linq.Expressions.LabelExpression" /> sem um valor padrão.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1612">A <see cref="T:System.Linq.Expressions.LabelExpression" /> without a default value.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LabelTarget Label (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LabelTarget Label(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Label(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Label (name As String) As LabelTarget" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LabelTarget ^ Label(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member Label : string -&gt; System.Linq.Expressions.LabelTarget" Usage="System.Linq.Expressions.Expression.Label name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LabelTarget</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="f7da9-1613">O nome do rótulo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1613">The name of the label.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-1614">Cria um <see cref="T:System.Linq.Expressions.LabelTarget" /> que representa um rótulo com um tipo void e o nome fornecido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1614">Creates a <see cref="T:System.Linq.Expressions.LabelTarget" /> representing a label with void type and the given name.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-1615">O novo <see cref="T:System.Linq.Expressions.LabelTarget" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1615">The new <see cref="T:System.Linq.Expressions.LabelTarget" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LabelTarget Label (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LabelTarget Label(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Label(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LabelTarget ^ Label(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Label : Type -&gt; System.Linq.Expressions.LabelTarget" Usage="System.Linq.Expressions.Expression.Label type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LabelTarget</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">
          <span data-ttu-id="f7da9-1616">O tipo de valor que é passado ao saltar para o rótulo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1616">The type of value that is passed when jumping to the label.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-1617">Cria um <see cref="T:System.Linq.Expressions.LabelTarget" /> que representa um rótulo com o tipo fornecido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1617">Creates a <see cref="T:System.Linq.Expressions.LabelTarget" /> representing a label with the given type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-1618">O novo <see cref="T:System.Linq.Expressions.LabelTarget" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1618">The new <see cref="T:System.Linq.Expressions.LabelTarget" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="f7da9-1619">O exemplo a seguir demonstra como usar um <xref:System.Linq.Expressions.LabelTarget> objeto em uma expressão de loop.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1619">The following example demonstrates how to use a <xref:System.Linq.Expressions.LabelTarget> object in a loop expression.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#44](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#44)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#44](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#44)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LabelExpression Label (System.Linq.Expressions.LabelTarget target, System.Linq.Expressions.Expression defaultValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LabelExpression Label(class System.Linq.Expressions.LabelTarget target, class System.Linq.Expressions.Expression defaultValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Label(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Label (target As LabelTarget, defaultValue As Expression) As LabelExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LabelExpression ^ Label(System::Linq::Expressions::LabelTarget ^ target, System::Linq::Expressions::Expression ^ defaultValue);" />
      <MemberSignature Language="F#" Value="static member Label : System.Linq.Expressions.LabelTarget * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.LabelExpression" Usage="System.Linq.Expressions.Expression.Label (target, defaultValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LabelExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="defaultValue" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="target">
          <span data-ttu-id="f7da9-1620">O <see cref="T:System.Linq.Expressions.LabelTarget" /> ao qual esse <see cref="T:System.Linq.Expressions.LabelExpression" /> será associado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1620">The <see cref="T:System.Linq.Expressions.LabelTarget" /> which this <see cref="T:System.Linq.Expressions.LabelExpression" /> will be associated with.</span>
          </span>
        </param>
        <param name="defaultValue">
          <span data-ttu-id="f7da9-1621">O valor desse <see cref="T:System.Linq.Expressions.LabelExpression" /> quando o rótulo é acessado por meio de fluxo de controle normal.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1621">The value of this <see cref="T:System.Linq.Expressions.LabelExpression" /> when the label is reached through regular control flow.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-1622">Cria um <see cref="T:System.Linq.Expressions.LabelExpression" /> que representa um rótulo com o valor padrão fornecido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1622">Creates a <see cref="T:System.Linq.Expressions.LabelExpression" /> representing a label with the given default value.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-1623">Um <see cref="T:System.Linq.Expressions.LabelExpression" /> com o valor padrão fornecido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1623">A <see cref="T:System.Linq.Expressions.LabelExpression" /> with the given default value.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LabelTarget Label (Type type, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LabelTarget Label(class System.Type type, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Label(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LabelTarget ^ Label(Type ^ type, System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member Label : Type * string -&gt; System.Linq.Expressions.LabelTarget" Usage="System.Linq.Expressions.Expression.Label (type, name)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LabelTarget</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">
          <span data-ttu-id="f7da9-1624">O tipo de valor que é passado ao saltar para o rótulo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1624">The type of value that is passed when jumping to the label.</span>
          </span>
        </param>
        <param name="name">
          <span data-ttu-id="f7da9-1625">O nome do rótulo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1625">The name of the label.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-1626">Cria um <see cref="T:System.Linq.Expressions.LabelTarget" /> que representa um rótulo com o tipo e nome fornecidos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1626">Creates a <see cref="T:System.Linq.Expressions.LabelTarget" /> representing a label with the given type and name.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-1627">O novo <see cref="T:System.Linq.Expressions.LabelTarget" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1627">The new <see cref="T:System.Linq.Expressions.LabelTarget" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Lambda">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f7da9-1628">Uma árvore de expressão que representa uma expressão lambda.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1628">Creates an expression tree that represents a lambda expression.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (System.Linq.Expressions.Expression body, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Linq.Expressions.Expression body, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (body As Expression, parameters As IEnumerable(Of ParameterExpression)) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(System::Linq::Expressions::Expression ^ body, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : System.Linq.Expressions.Expression * seq&lt;System.Linq.Expressions.ParameterExpression&gt; -&gt; System.Linq.Expressions.LambdaExpression" Usage="System.Linq.Expressions.Expression.Lambda (body, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="body">
          <span data-ttu-id="f7da9-1629">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1629">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span>
          </span>
        </param>
        <param name="parameters">
          <span data-ttu-id="f7da9-1630">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> a serem usados para preencher a coleção de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1630">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-1631">Cria uma LambdaExpression criando primeiro um tipo delegado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1631">Creates a LambdaExpression by first constructing a delegate type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-1632">Um <see cref="T:System.Linq.Expressions.LambdaExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> igual a Lambda e as propriedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1632">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> that has the <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> property equal to Lambda and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (System.Linq.Expressions.Expression body, params System.Linq.Expressions.ParameterExpression[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.ParameterExpression[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.Linq.Expressions.ParameterExpression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (body As Expression, ParamArray parameters As ParameterExpression()) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(System::Linq::Expressions::Expression ^ body, ... cli::array &lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : System.Linq.Expressions.Expression * System.Linq.Expressions.ParameterExpression[] -&gt; System.Linq.Expressions.LambdaExpression" Usage="System.Linq.Expressions.Expression.Lambda (body, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="parameters" Type="System.Linq.Expressions.ParameterExpression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="body">
          <span data-ttu-id="f7da9-1633">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1633">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span>
          </span>
        </param>
        <param name="parameters">
          <span data-ttu-id="f7da9-1634">Uma matriz de objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> a serem usados para popular a coleção de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1634">An array of <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-1635">Cria um <see cref="T:System.Linq.Expressions.LambdaExpression" /> criando primeiro um tipo delegado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1635">Creates a <see cref="T:System.Linq.Expressions.LambdaExpression" /> by first constructing a delegate type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-1636">Um <see cref="T:System.Linq.Expressions.LambdaExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> e as propriedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1636">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-1637">O `parameters` parâmetro não deve ter mais de dezesseis elementos.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1637">The `parameters` parameter must not have more than sixteen elements.</span></span>  
  
 <span data-ttu-id="f7da9-1638">Os elementos de `parameters` deve ser igual às expressões de parâmetro na referência `body`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1638">The elements of `parameters` must be reference equal to the parameter expressions in `body`.</span></span>  
  
 <span data-ttu-id="f7da9-1639">Este método constrói um tipo de delegado apropriado de uma da `System.Func` delegados genéricos.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1639">This method constructs an appropriate delegate type from one of the `System.Func` generic delegates.</span></span> <span data-ttu-id="f7da9-1640">Ele passa o tipo de delegado para um dos <xref:System.Linq.Expressions.ExpressionType.Lambda> métodos de fábrica para criar um <xref:System.Linq.Expressions.LambdaExpression>.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1640">It then passes the delegate type to one of the <xref:System.Linq.Expressions.ExpressionType.Lambda> factory methods to create a <xref:System.Linq.Expressions.LambdaExpression>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f7da9-1641">
            <paramref name="body" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1641">
              <paramref name="body" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="f7da9-1642">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1642">-or-</span>
          </span>
          <span data-ttu-id="f7da9-1643">Um ou mais elementos de <paramref name="parameters" /> são <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1643">One or more elements of <paramref name="parameters" /> are <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f7da9-1644">
            <paramref name="parameters" /> contém mais de dezesseis elementos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1644">
              <paramref name="parameters" /> contains more than sixteen elements.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (System.Linq.Expressions.Expression body, bool tailCall, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Linq.Expressions.Expression body, bool tailCall, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (body As Expression, tailCall As Boolean, parameters As IEnumerable(Of ParameterExpression)) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(System::Linq::Expressions::Expression ^ body, bool tailCall, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : System.Linq.Expressions.Expression * bool * seq&lt;System.Linq.Expressions.ParameterExpression&gt; -&gt; System.Linq.Expressions.LambdaExpression" Usage="System.Linq.Expressions.Expression.Lambda (body, tailCall, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="tailCall" Type="System.Boolean" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="body">
          <span data-ttu-id="f7da9-1645">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1645">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span>
          </span>
        </param>
        <param name="tailCall">
          <span data-ttu-id="f7da9-1646">Um <see cref="T:System.Boolean" /> que indica se a otimização de chamada final será aplicada ao compilar a expressão criada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1646">A <see cref="T:System.Boolean" /> that indicates if tail call optimization will be applied when compiling the created expression.</span>
          </span>
        </param>
        <param name="parameters">
          <span data-ttu-id="f7da9-1647">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> a serem usados para preencher a coleção de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1647">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-1648">Cria uma LambdaExpression criando primeiro um tipo delegado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1648">Creates a LambdaExpression by first constructing a delegate type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-1649">Um <see cref="T:System.Linq.Expressions.LambdaExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> igual a Lambda e as propriedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1649">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> that has the <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> property equal to Lambda and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (System.Linq.Expressions.Expression body, bool tailCall, params System.Linq.Expressions.ParameterExpression[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Linq.Expressions.Expression body, bool tailCall, class System.Linq.Expressions.ParameterExpression[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.Boolean,System.Linq.Expressions.ParameterExpression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (body As Expression, tailCall As Boolean, ParamArray parameters As ParameterExpression()) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(System::Linq::Expressions::Expression ^ body, bool tailCall, ... cli::array &lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : System.Linq.Expressions.Expression * bool * System.Linq.Expressions.ParameterExpression[] -&gt; System.Linq.Expressions.LambdaExpression" Usage="System.Linq.Expressions.Expression.Lambda (body, tailCall, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="tailCall" Type="System.Boolean" />
        <Parameter Name="parameters" Type="System.Linq.Expressions.ParameterExpression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="body">
          <span data-ttu-id="f7da9-1650">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1650">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span>
          </span>
        </param>
        <param name="tailCall">
          <span data-ttu-id="f7da9-1651">Um <see cref="T:System.Boolean" /> que indica se a otimização de chamada final será aplicada ao compilar a expressão criada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1651">A <see cref="T:System.Boolean" /> that indicates if tail call optimization will be applied when compiling the created expression.</span>
          </span>
        </param>
        <param name="parameters">
          <span data-ttu-id="f7da9-1652">Uma matriz que contém os objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> a serem usados para popular a coleção <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1652">An array that contains <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-1653">Cria uma LambdaExpression criando primeiro um tipo delegado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1653">Creates a LambdaExpression by first constructing a delegate type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-1654">Um <see cref="T:System.Linq.Expressions.LambdaExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> igual a Lambda e as propriedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1654">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> that has the <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> property equal to Lambda and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (System.Linq.Expressions.Expression body, string name, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Linq.Expressions.Expression body, string name, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.String,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (body As Expression, name As String, parameters As IEnumerable(Of ParameterExpression)) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(System::Linq::Expressions::Expression ^ body, System::String ^ name, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : System.Linq.Expressions.Expression * string * seq&lt;System.Linq.Expressions.ParameterExpression&gt; -&gt; System.Linq.Expressions.LambdaExpression" Usage="System.Linq.Expressions.Expression.Lambda (body, name, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="body">
          <span data-ttu-id="f7da9-1655">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1655">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span>
          </span>
        </param>
        <param name="name">
          <span data-ttu-id="f7da9-1656">O nome para o lambda.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1656">The name for the lambda.</span>
          </span>
          <span data-ttu-id="f7da9-1657">Usada para emitir informações de depuração.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1657">Used for emitting debug information.</span>
          </span>
        </param>
        <param name="parameters">
          <span data-ttu-id="f7da9-1658">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> a serem usados para preencher a coleção de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1658">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-1659">Cria uma LambdaExpression criando primeiro um tipo delegado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1659">Creates a LambdaExpression by first constructing a delegate type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-1660">Um <see cref="T:System.Linq.Expressions.LambdaExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> igual a Lambda e as propriedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1660">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> that has the <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> property equal to Lambda and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (Type delegateType, System.Linq.Expressions.Expression body, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Type delegateType, class System.Linq.Expressions.Expression body, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (delegateType As Type, body As Expression, parameters As IEnumerable(Of ParameterExpression)) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(Type ^ delegateType, System::Linq::Expressions::Expression ^ body, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : Type * System.Linq.Expressions.Expression * seq&lt;System.Linq.Expressions.ParameterExpression&gt; -&gt; System.Linq.Expressions.LambdaExpression" Usage="System.Linq.Expressions.Expression.Lambda (delegateType, body, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="delegateType">
          <span data-ttu-id="f7da9-1661">Um <see cref="T:System.Type" /> que representa uma assinatura de delegado para lambda.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1661">A <see cref="T:System.Type" /> that represents a delegate signature for the lambda.</span>
          </span>
        </param>
        <param name="body">
          <span data-ttu-id="f7da9-1662">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1662">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span>
          </span>
        </param>
        <param name="parameters">
          <span data-ttu-id="f7da9-1663">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> a serem usados para preencher a coleção de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1663">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-1664">Cria um <see cref="T:System.Linq.Expressions.LambdaExpression" /> criando primeiro um tipo delegado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1664">Creates a <see cref="T:System.Linq.Expressions.LambdaExpression" /> by first constructing a delegate type.</span>
          </span>
          <span data-ttu-id="f7da9-1665">Ele pode ser usado quando o tipo de delegado não é conhecido em tempo de compilação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1665">It can be used when the delegate type is not known at compile time.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-1666">Um objeto que representa uma expressão lambda que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> e as propriedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1666">An object that represents a lambda expression which has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-1667">O objeto que é retornado por essa função é do tipo <xref:System.Linq.Expressions.Expression%601>.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1667">The object that is returned from this function is of type <xref:System.Linq.Expressions.Expression%601>.</span></span> <span data-ttu-id="f7da9-1668">O <xref:System.Linq.Expressions.LambdaExpression> tipo é usado para representar o objeto retornado porque o tipo concreto da expressão lambda não é conhecido em tempo de compilação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1668">The <xref:System.Linq.Expressions.LambdaExpression> type is used to represent the returned object because the concrete type of the lambda expression is not known at compile time.</span></span>  
  
 <span data-ttu-id="f7da9-1669">O número de parâmetros para o tipo de delegado representado por`delegateType` deve igual ao comprimento da `parameters`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1669">The number of parameters for the delegate type represented by`delegateType` must equal the length of `parameters`.</span></span>  
  
 <span data-ttu-id="f7da9-1670">Os elementos de `parameters` deve ser igual às expressões de parâmetro na referência `body`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1670">The elements of `parameters` must be reference equal to the parameter expressions in `body`.</span></span>  
  
 <span data-ttu-id="f7da9-1671">O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade do objeto resultante é igual a `delegateType`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1671">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting object is equal to `delegateType`.</span></span> <span data-ttu-id="f7da9-1672">Se `parameters` está `null`, o <xref:System.Linq.Expressions.LambdaExpression.Parameters%2A> propriedade do objeto resultante é uma coleção vazia.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1672">If `parameters` is `null`, the <xref:System.Linq.Expressions.LambdaExpression.Parameters%2A> property of the resulting object is an empty collection.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f7da9-1673">O exemplo a seguir demonstra como criar uma expressão que representa uma expressão lambda que adiciona 1 para o argumento passado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1673">The following example demonstrates how to create an expression that represents a lambda expression that adds 1 to the passed argument.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#42](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#42)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#42](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f7da9-1674">
            <paramref name="delegateType" /> ou <paramref name="body" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1674">
              <paramref name="delegateType" /> or <paramref name="body" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="f7da9-1675">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1675">-or-</span>
          </span>
          <span data-ttu-id="f7da9-1676">Um ou mais elementos em <paramref name="parameters" /> são <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1676">One or more elements in <paramref name="parameters" /> are <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f7da9-1677">
            <paramref name="delegateType" /> não representa um tipo de delegado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1677">
              <paramref name="delegateType" /> does not represent a delegate type.</span>
          </span>
          <span data-ttu-id="f7da9-1678">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1678">-or-</span>
          </span>
          <span data-ttu-id="f7da9-1679">
            <paramref name="body" />.Type representa um tipo que não é atribuível ao tipo de retorno do tipo de delegado representado por <paramref name="delegateType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1679">
              <paramref name="body" />.Type represents a type that is not assignable to the return type of the delegate type represented by <paramref name="delegateType" />.</span>
          </span>
          <span data-ttu-id="f7da9-1680">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1680">-or-</span>
          </span>
          <span data-ttu-id="f7da9-1681">
            <paramref name="parameters" /> não contém o mesmo número de elementos da lista de parâmetros para o tipo de delegado representado por <paramref name="delegateType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1681">
              <paramref name="parameters" /> does not contain the same number of elements as the list of parameters for the delegate type represented by <paramref name="delegateType" />.</span>
          </span>
          <span data-ttu-id="f7da9-1682">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1682">-or-</span>
          </span>
          <span data-ttu-id="f7da9-1683">A propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> de um elemento de <paramref name="parameters" /> não é atribuível do tipo de parâmetro correspondente do tipo de delegado representado por <paramref name="delegateType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1683">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of an element of <paramref name="parameters" /> is not assignable from the type of the corresponding parameter type of the delegate type represented by <paramref name="delegateType" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (Type delegateType, System.Linq.Expressions.Expression body, params System.Linq.Expressions.ParameterExpression[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Type delegateType, class System.Linq.Expressions.Expression body, class System.Linq.Expressions.ParameterExpression[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.ParameterExpression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (delegateType As Type, body As Expression, ParamArray parameters As ParameterExpression()) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(Type ^ delegateType, System::Linq::Expressions::Expression ^ body, ... cli::array &lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : Type * System.Linq.Expressions.Expression * System.Linq.Expressions.ParameterExpression[] -&gt; System.Linq.Expressions.LambdaExpression" Usage="System.Linq.Expressions.Expression.Lambda (delegateType, body, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="parameters" Type="System.Linq.Expressions.ParameterExpression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="delegateType">
          <span data-ttu-id="f7da9-1684">Um <see cref="T:System.Type" /> que representa uma assinatura de delegado para lambda.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1684">A <see cref="T:System.Type" /> that represents a delegate signature for the lambda.</span>
          </span>
        </param>
        <param name="body">
          <span data-ttu-id="f7da9-1685">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1685">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span>
          </span>
        </param>
        <param name="parameters">
          <span data-ttu-id="f7da9-1686">Uma matriz de objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> a serem usados para popular a coleção de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1686">An array of <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-1687">Cria um <see cref="T:System.Linq.Expressions.LambdaExpression" /> criando primeiro um tipo delegado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1687">Creates a <see cref="T:System.Linq.Expressions.LambdaExpression" /> by first constructing a delegate type.</span>
          </span>
          <span data-ttu-id="f7da9-1688">Ele pode ser usado quando o tipo de delegado não é conhecido em tempo de compilação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1688">It can be used when the delegate type is not known at compile time.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-1689">Um objeto que representa uma expressão lambda que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> e as propriedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1689">An object that represents a lambda expression which has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-1690">O objeto que é retornado por essa função é do tipo <xref:System.Linq.Expressions.Expression%601>.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1690">The object that is returned from this function is of type <xref:System.Linq.Expressions.Expression%601>.</span></span> <span data-ttu-id="f7da9-1691">O <xref:System.Linq.Expressions.LambdaExpression> tipo é usado para representar o objeto retornado porque o tipo concreto da expressão lambda não é conhecido em tempo de compilação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1691">The <xref:System.Linq.Expressions.LambdaExpression> type is used to represent the returned object because the concrete type of the lambda expression is not known at compile time.</span></span>  
  
 <span data-ttu-id="f7da9-1692">O número de parâmetros para o tipo de delegado representado por `delegateType` deve igual ao comprimento da `parameters`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1692">The number of parameters for the delegate type represented by `delegateType` must equal the length of `parameters`.</span></span>  
  
 <span data-ttu-id="f7da9-1693">Os elementos de `parameters` deve ser igual às expressões de parâmetro na referência `body`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1693">The elements of `parameters` must be reference equal to the parameter expressions in `body`.</span></span>  
  
 <span data-ttu-id="f7da9-1694">O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade do objeto resultante é igual a `delegateType`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1694">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting object is equal to `delegateType`.</span></span> <span data-ttu-id="f7da9-1695">Se `parameters` está `null`, o <xref:System.Linq.Expressions.LambdaExpression.Parameters%2A> propriedade do objeto resultante é uma coleção vazia.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1695">If `parameters` is `null`, the <xref:System.Linq.Expressions.LambdaExpression.Parameters%2A> property of the resulting object is an empty collection.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f7da9-1696">
            <paramref name="delegateType" /> ou <paramref name="body" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1696">
              <paramref name="delegateType" /> or <paramref name="body" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="f7da9-1697">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1697">-or-</span>
          </span>
          <span data-ttu-id="f7da9-1698">Um ou mais elementos em <paramref name="parameters" /> são <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1698">One or more elements in <paramref name="parameters" /> are <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f7da9-1699">
            <paramref name="delegateType" /> não representa um tipo de delegado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1699">
              <paramref name="delegateType" /> does not represent a delegate type.</span>
          </span>
          <span data-ttu-id="f7da9-1700">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1700">-or-</span>
          </span>
          <span data-ttu-id="f7da9-1701">
            <paramref name="body" />.Type representa um tipo que não é atribuível ao tipo de retorno do tipo de delegado representado por <paramref name="delegateType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1701">
              <paramref name="body" />.Type represents a type that is not assignable to the return type of the delegate type represented by <paramref name="delegateType" />.</span>
          </span>
          <span data-ttu-id="f7da9-1702">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1702">-or-</span>
          </span>
          <span data-ttu-id="f7da9-1703">
            <paramref name="parameters" /> não contém o mesmo número de elementos da lista de parâmetros para o tipo de delegado representado por <paramref name="delegateType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1703">
              <paramref name="parameters" /> does not contain the same number of elements as the list of parameters for the delegate type represented by <paramref name="delegateType" />.</span>
          </span>
          <span data-ttu-id="f7da9-1704">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1704">-or-</span>
          </span>
          <span data-ttu-id="f7da9-1705">A propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> de um elemento de <paramref name="parameters" /> não é atribuível do tipo de parâmetro correspondente do tipo de delegado representado por <paramref name="delegateType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1705">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of an element of <paramref name="parameters" /> is not assignable from the type of the corresponding parameter type of the delegate type represented by <paramref name="delegateType" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (System.Linq.Expressions.Expression body, string name, bool tailCall, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Linq.Expressions.Expression body, string name, bool tailCall, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (body As Expression, name As String, tailCall As Boolean, parameters As IEnumerable(Of ParameterExpression)) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(System::Linq::Expressions::Expression ^ body, System::String ^ name, bool tailCall, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : System.Linq.Expressions.Expression * string * bool * seq&lt;System.Linq.Expressions.ParameterExpression&gt; -&gt; System.Linq.Expressions.LambdaExpression" Usage="System.Linq.Expressions.Expression.Lambda (body, name, tailCall, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="tailCall" Type="System.Boolean" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="body">
          <span data-ttu-id="f7da9-1706">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1706">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span>
          </span>
        </param>
        <param name="name">
          <span data-ttu-id="f7da9-1707">O nome para o lambda.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1707">The name for the lambda.</span>
          </span>
          <span data-ttu-id="f7da9-1708">Usada para emitir informações de depuração.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1708">Used for emitting debug information.</span>
          </span>
        </param>
        <param name="tailCall">
          <span data-ttu-id="f7da9-1709">Um <see cref="T:System.Boolean" /> que indica se a otimização de chamada final será aplicada ao compilar a expressão criada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1709">A <see cref="T:System.Boolean" /> that indicates if tail call optimization will be applied when compiling the created expression.</span>
          </span>
        </param>
        <param name="parameters">
          <span data-ttu-id="f7da9-1710">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> a serem usados para preencher a coleção de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1710">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-1711">Cria uma LambdaExpression criando primeiro um tipo delegado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1711">Creates a LambdaExpression by first constructing a delegate type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-1712">Um <see cref="T:System.Linq.Expressions.LambdaExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> igual a Lambda e as propriedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1712">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> that has the <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> property equal to Lambda and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (Type delegateType, System.Linq.Expressions.Expression body, bool tailCall, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Type delegateType, class System.Linq.Expressions.Expression body, bool tailCall, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (delegateType As Type, body As Expression, tailCall As Boolean, parameters As IEnumerable(Of ParameterExpression)) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(Type ^ delegateType, System::Linq::Expressions::Expression ^ body, bool tailCall, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : Type * System.Linq.Expressions.Expression * bool * seq&lt;System.Linq.Expressions.ParameterExpression&gt; -&gt; System.Linq.Expressions.LambdaExpression" Usage="System.Linq.Expressions.Expression.Lambda (delegateType, body, tailCall, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="tailCall" Type="System.Boolean" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="delegateType">
          <span data-ttu-id="f7da9-1713">Um <see cref="P:System.Linq.Expressions.Expression.Type" /> que representa a assinatura de delegado para o lambda.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1713">A <see cref="P:System.Linq.Expressions.Expression.Type" /> representing the delegate signature for the lambda.</span>
          </span>
        </param>
        <param name="body">
          <span data-ttu-id="f7da9-1714">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1714">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span>
          </span>
        </param>
        <param name="tailCall">
          <span data-ttu-id="f7da9-1715">Um <see cref="T:System.Boolean" /> que indica se a otimização de chamada final será aplicada ao compilar a expressão criada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1715">A <see cref="T:System.Boolean" /> that indicates if tail call optimization will be applied when compiling the created expression.</span>
          </span>
        </param>
        <param name="parameters">
          <span data-ttu-id="f7da9-1716">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> a serem usados para preencher a coleção de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1716">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-1717">Cria uma LambdaExpression criando primeiro um tipo delegado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1717">Creates a LambdaExpression by first constructing a delegate type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-1718">Um <see cref="T:System.Linq.Expressions.LambdaExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> igual a Lambda e as propriedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1718">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> that has the <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> property equal to Lambda and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (Type delegateType, System.Linq.Expressions.Expression body, bool tailCall, params System.Linq.Expressions.ParameterExpression[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Type delegateType, class System.Linq.Expressions.Expression body, bool tailCall, class System.Linq.Expressions.ParameterExpression[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Boolean,System.Linq.Expressions.ParameterExpression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (delegateType As Type, body As Expression, tailCall As Boolean, ParamArray parameters As ParameterExpression()) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(Type ^ delegateType, System::Linq::Expressions::Expression ^ body, bool tailCall, ... cli::array &lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : Type * System.Linq.Expressions.Expression * bool * System.Linq.Expressions.ParameterExpression[] -&gt; System.Linq.Expressions.LambdaExpression" Usage="System.Linq.Expressions.Expression.Lambda (delegateType, body, tailCall, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="tailCall" Type="System.Boolean" />
        <Parameter Name="parameters" Type="System.Linq.Expressions.ParameterExpression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="delegateType">
          <span data-ttu-id="f7da9-1719">Um <see cref="P:System.Linq.Expressions.Expression.Type" /> que representa a assinatura de delegado para o lambda.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1719">A <see cref="P:System.Linq.Expressions.Expression.Type" /> representing the delegate signature for the lambda.</span>
          </span>
        </param>
        <param name="body">
          <span data-ttu-id="f7da9-1720">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1720">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span>
          </span>
        </param>
        <param name="tailCall">
          <span data-ttu-id="f7da9-1721">Um <see cref="T:System.Boolean" /> que indica se a otimização de chamada final será aplicada ao compilar a expressão criada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1721">A <see cref="T:System.Boolean" /> that indicates if tail call optimization will be applied when compiling the created expression.</span>
          </span>
        </param>
        <param name="parameters">
          <span data-ttu-id="f7da9-1722">Uma matriz que contém os objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> a serem usados para popular a coleção <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1722">An array that contains <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-1723">Cria uma LambdaExpression criando primeiro um tipo delegado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1723">Creates a LambdaExpression by first constructing a delegate type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-1724">Um <see cref="T:System.Linq.Expressions.LambdaExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> igual a Lambda e as propriedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1724">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> that has the <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> property equal to Lambda and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (Type delegateType, System.Linq.Expressions.Expression body, string name, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Type delegateType, class System.Linq.Expressions.Expression body, string name, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.String,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (delegateType As Type, body As Expression, name As String, parameters As IEnumerable(Of ParameterExpression)) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(Type ^ delegateType, System::Linq::Expressions::Expression ^ body, System::String ^ name, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : Type * System.Linq.Expressions.Expression * string * seq&lt;System.Linq.Expressions.ParameterExpression&gt; -&gt; System.Linq.Expressions.LambdaExpression" Usage="System.Linq.Expressions.Expression.Lambda (delegateType, body, name, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="delegateType">
          <span data-ttu-id="f7da9-1725">Um <see cref="P:System.Linq.Expressions.Expression.Type" /> que representa a assinatura de delegado para o lambda.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1725">A <see cref="P:System.Linq.Expressions.Expression.Type" /> representing the delegate signature for the lambda.</span>
          </span>
        </param>
        <param name="body">
          <span data-ttu-id="f7da9-1726">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1726">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span>
          </span>
        </param>
        <param name="name">
          <span data-ttu-id="f7da9-1727">O nome para o lambda.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1727">The name for the lambda.</span>
          </span>
          <span data-ttu-id="f7da9-1728">Usada para emitir informações de depuração.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1728">Used for emitting debug information.</span>
          </span>
        </param>
        <param name="parameters">
          <span data-ttu-id="f7da9-1729">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> a serem usados para preencher a coleção de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1729">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-1730">Cria uma LambdaExpression criando primeiro um tipo delegado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1730">Creates a LambdaExpression by first constructing a delegate type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-1731">Um <see cref="T:System.Linq.Expressions.LambdaExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> igual a Lambda e as propriedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1731">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> that has the <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> property equal to Lambda and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (Type delegateType, System.Linq.Expressions.Expression body, string name, bool tailCall, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Type delegateType, class System.Linq.Expressions.Expression body, string name, bool tailCall, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (delegateType As Type, body As Expression, name As String, tailCall As Boolean, parameters As IEnumerable(Of ParameterExpression)) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(Type ^ delegateType, System::Linq::Expressions::Expression ^ body, System::String ^ name, bool tailCall, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : Type * System.Linq.Expressions.Expression * string * bool * seq&lt;System.Linq.Expressions.ParameterExpression&gt; -&gt; System.Linq.Expressions.LambdaExpression" Usage="System.Linq.Expressions.Expression.Lambda (delegateType, body, name, tailCall, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="tailCall" Type="System.Boolean" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="delegateType">
          <span data-ttu-id="f7da9-1732">Um <see cref="P:System.Linq.Expressions.Expression.Type" /> que representa a assinatura de delegado para o lambda.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1732">A <see cref="P:System.Linq.Expressions.Expression.Type" /> representing the delegate signature for the lambda.</span>
          </span>
        </param>
        <param name="body">
          <span data-ttu-id="f7da9-1733">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1733">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span>
          </span>
        </param>
        <param name="name">
          <span data-ttu-id="f7da9-1734">O nome para o lambda.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1734">The name for the lambda.</span>
          </span>
          <span data-ttu-id="f7da9-1735">Usada para emitir informações de depuração.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1735">Used for emitting debug information.</span>
          </span>
        </param>
        <param name="tailCall">
          <span data-ttu-id="f7da9-1736">Um <see cref="T:System.Boolean" /> que indica se a otimização de chamada final será aplicada ao compilar a expressão criada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1736">A <see cref="T:System.Boolean" /> that indicates if tail call optimization will be applied when compiling the created expression.</span>
          </span>
        </param>
        <param name="parameters">
          <span data-ttu-id="f7da9-1737">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> a serem usados para preencher a coleção de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1737">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-1738">Cria uma LambdaExpression criando primeiro um tipo delegado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1738">Creates a LambdaExpression by first constructing a delegate type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-1739">Um <see cref="T:System.Linq.Expressions.LambdaExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> igual a Lambda e as propriedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1739">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> that has the <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> property equal to Lambda and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda&lt;TDelegate&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.Expression&lt;TDelegate&gt; Lambda&lt;TDelegate&gt; (System.Linq.Expressions.Expression body, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.Expression`1&lt;!!TDelegate&gt; Lambda&lt;TDelegate&gt;(class System.Linq.Expressions.Expression body, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda(Of TDelegate) (body As Expression, parameters As IEnumerable(Of ParameterExpression)) As Expression(Of TDelegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TDelegate&gt;&#xA; static System::Linq::Expressions::Expression&lt;TDelegate&gt; ^ Lambda(System::Linq::Expressions::Expression ^ body, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : System.Linq.Expressions.Expression * seq&lt;System.Linq.Expressions.ParameterExpression&gt; -&gt; System.Linq.Expressions.Expression&lt;'Delegate&gt;" Usage="System.Linq.Expressions.Expression.Lambda (body, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression&lt;TDelegate&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TDelegate" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TDelegate">
          <span data-ttu-id="f7da9-1740">Um tipo de delegado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1740">A delegate type.</span>
          </span>
        </typeparam>
        <param name="body">
          <span data-ttu-id="f7da9-1741">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1741">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span>
          </span>
        </param>
        <param name="parameters">
          <span data-ttu-id="f7da9-1742">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> a serem usados para preencher a coleção de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1742">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-1743">Cria um <see cref="T:System.Linq.Expressions.Expression`1" /> no qual o tipo de delegado é conhecido em tempo de compilação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1743">Creates an <see cref="T:System.Linq.Expressions.Expression`1" /> where the delegate type is known at compile time.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-1744">Um <see cref="T:System.Linq.Expressions.Expression`1" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> e as propriedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1744">An <see cref="T:System.Linq.Expressions.Expression`1" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-1745">O número de parâmetros para o tipo de delegado `TDelegate` deve ser igual ao número de elementos em `parameters`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1745">The number of parameters for the delegate type `TDelegate` must equal the number of elements in `parameters`.</span></span>  
  
 <span data-ttu-id="f7da9-1746">Os elementos de `parameters` deve ser igual às expressões de parâmetro na referência `body`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1746">The elements of `parameters` must be reference equal to the parameter expressions in `body`.</span></span>  
  
 <span data-ttu-id="f7da9-1747">O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade do objeto resultante representa o tipo `TDelegate`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1747">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting object represents the type `TDelegate`.</span></span> <span data-ttu-id="f7da9-1748">Se `parameters` está `null`, o <xref:System.Linq.Expressions.LambdaExpression.Parameters%2A> propriedade do objeto resultante é uma coleção vazia.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1748">If `parameters` is `null`, the <xref:System.Linq.Expressions.LambdaExpression.Parameters%2A> property of the resulting object is an empty collection.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f7da9-1749">
            <paramref name="body" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1749">
              <paramref name="body" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="f7da9-1750">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1750">-or-</span>
          </span>
          <span data-ttu-id="f7da9-1751">Um ou mais elementos em <paramref name="parameters" /> são <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1751">One or more elements in <paramref name="parameters" /> are <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f7da9-1752">
            <paramref name="TDelegate" /> não é um tipo de delegado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1752">
              <paramref name="TDelegate" /> is not a delegate type.</span>
          </span>
          <span data-ttu-id="f7da9-1753">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1753">-or-</span>
          </span>
          <span data-ttu-id="f7da9-1754">
            <paramref name="body" />.Type representa um tipo que não pode ser atribuído ao tipo de retorno de <paramref name="TDelegate" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1754">
              <paramref name="body" />.Type represents a type that is not assignable to the return type of <paramref name="TDelegate" />.</span>
          </span>
          <span data-ttu-id="f7da9-1755">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1755">-or-</span>
          </span>
          <span data-ttu-id="f7da9-1756">
            <paramref name="parameters" /> não contém o mesmo número de elementos que a lista de parâmetros de <paramref name="TDelegate" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1756">
              <paramref name="parameters" /> does not contain the same number of elements as the list of parameters for <paramref name="TDelegate" />.</span>
          </span>
          <span data-ttu-id="f7da9-1757">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1757">-or-</span>
          </span>
          <span data-ttu-id="f7da9-1758">A propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> de um elemento de <paramref name="parameters" /> não pode ser atribuída do tipo de parâmetro correspondente de <paramref name="TDelegate" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1758">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of an element of <paramref name="parameters" /> is not assignable from the type of the corresponding parameter type of <paramref name="TDelegate" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Lambda&lt;TDelegate&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.Expression&lt;TDelegate&gt; Lambda&lt;TDelegate&gt; (System.Linq.Expressions.Expression body, params System.Linq.Expressions.ParameterExpression[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.Expression`1&lt;!!TDelegate&gt; Lambda&lt;TDelegate&gt;(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.ParameterExpression[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.Linq.Expressions.ParameterExpression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda(Of TDelegate) (body As Expression, ParamArray parameters As ParameterExpression()) As Expression(Of TDelegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TDelegate&gt;&#xA; static System::Linq::Expressions::Expression&lt;TDelegate&gt; ^ Lambda(System::Linq::Expressions::Expression ^ body, ... cli::array &lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : System.Linq.Expressions.Expression * System.Linq.Expressions.ParameterExpression[] -&gt; System.Linq.Expressions.Expression&lt;'Delegate&gt;" Usage="System.Linq.Expressions.Expression.Lambda (body, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression&lt;TDelegate&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TDelegate" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="parameters" Type="System.Linq.Expressions.ParameterExpression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TDelegate">
          <span data-ttu-id="f7da9-1759">Um tipo de delegado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1759">A delegate type.</span>
          </span>
        </typeparam>
        <param name="body">
          <span data-ttu-id="f7da9-1760">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1760">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span>
          </span>
        </param>
        <param name="parameters">
          <span data-ttu-id="f7da9-1761">Uma matriz de objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> a serem usados para popular a coleção de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1761">An array of <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-1762">Cria um <see cref="T:System.Linq.Expressions.Expression`1" /> no qual o tipo de delegado é conhecido em tempo de compilação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1762">Creates an <see cref="T:System.Linq.Expressions.Expression`1" /> where the delegate type is known at compile time.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-1763">Um <see cref="T:System.Linq.Expressions.Expression`1" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> e as propriedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1763">An <see cref="T:System.Linq.Expressions.Expression`1" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-1764">O número de parâmetros para o tipo de delegado `TDelegate` deve ser igual ao número de elementos em `parameters`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1764">The number of parameters for the delegate type `TDelegate` must equal the number of elements in `parameters`.</span></span>  
  
 <span data-ttu-id="f7da9-1765">Os elementos de `parameters` deve ser igual às expressões de parâmetro na referência`body`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1765">The elements of `parameters` must be reference equal to the parameter expressions in`body`.</span></span>  
  
 <span data-ttu-id="f7da9-1766">O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade do objeto resultante representa o tipo `TDelegate`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1766">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting object represents the type `TDelegate`.</span></span> <span data-ttu-id="f7da9-1767">Se `parameters` está `null`, o <xref:System.Linq.Expressions.LambdaExpression.Parameters%2A> propriedade do objeto resultante é uma coleção vazia.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1767">If `parameters` is `null`, the <xref:System.Linq.Expressions.LambdaExpression.Parameters%2A> property of the resulting object is an empty collection.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f7da9-1768">
            <paramref name="body" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1768">
              <paramref name="body" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="f7da9-1769">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1769">-or-</span>
          </span>
          <span data-ttu-id="f7da9-1770">Um ou mais elementos em <paramref name="parameters" /> são <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1770">One or more elements in <paramref name="parameters" /> are <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f7da9-1771">
            <paramref name="TDelegate" /> não é um tipo de delegado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1771">
              <paramref name="TDelegate" /> is not a delegate type.</span>
          </span>
          <span data-ttu-id="f7da9-1772">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1772">-or-</span>
          </span>
          <span data-ttu-id="f7da9-1773">
            <paramref name="body" />.Type representa um tipo que não pode ser atribuído ao tipo de retorno de <paramref name="TDelegate" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1773">
              <paramref name="body" />.Type represents a type that is not assignable to the return type of <paramref name="TDelegate" />.</span>
          </span>
          <span data-ttu-id="f7da9-1774">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1774">-or-</span>
          </span>
          <span data-ttu-id="f7da9-1775">
            <paramref name="parameters" /> não contém o mesmo número de elementos que a lista de parâmetros de <paramref name="TDelegate" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1775">
              <paramref name="parameters" /> does not contain the same number of elements as the list of parameters for <paramref name="TDelegate" />.</span>
          </span>
          <span data-ttu-id="f7da9-1776">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1776">-or-</span>
          </span>
          <span data-ttu-id="f7da9-1777">A propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> de um elemento de <paramref name="parameters" /> não pode ser atribuída do tipo de parâmetro correspondente de <paramref name="TDelegate" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1777">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of an element of <paramref name="parameters" /> is not assignable from the type of the corresponding parameter type of <paramref name="TDelegate" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Lambda&lt;TDelegate&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.Expression&lt;TDelegate&gt; Lambda&lt;TDelegate&gt; (System.Linq.Expressions.Expression body, bool tailCall, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.Expression`1&lt;!!TDelegate&gt; Lambda&lt;TDelegate&gt;(class System.Linq.Expressions.Expression body, bool tailCall, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda(Of TDelegate) (body As Expression, tailCall As Boolean, parameters As IEnumerable(Of ParameterExpression)) As Expression(Of TDelegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TDelegate&gt;&#xA; static System::Linq::Expressions::Expression&lt;TDelegate&gt; ^ Lambda(System::Linq::Expressions::Expression ^ body, bool tailCall, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : System.Linq.Expressions.Expression * bool * seq&lt;System.Linq.Expressions.ParameterExpression&gt; -&gt; System.Linq.Expressions.Expression&lt;'Delegate&gt;" Usage="System.Linq.Expressions.Expression.Lambda (body, tailCall, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression&lt;TDelegate&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TDelegate" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="tailCall" Type="System.Boolean" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TDelegate">
          <span data-ttu-id="f7da9-1778">O tipo de delegado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1778">The delegate type.</span>
          </span>
        </typeparam>
        <param name="body">
          <span data-ttu-id="f7da9-1779">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1779">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span>
          </span>
        </param>
        <param name="tailCall">
          <span data-ttu-id="f7da9-1780">Um <see cref="T:System.Boolean" /> que indica se a otimização de chamada final será aplicada ao compilar a expressão criada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1780">A <see cref="T:System.Boolean" /> that indicates if tail call optimization will be applied when compiling the created expression.</span>
          </span>
        </param>
        <param name="parameters">
          <span data-ttu-id="f7da9-1781">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> a serem usados para preencher a coleção de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1781">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-1782">Cria um <see cref="T:System.Linq.Expressions.Expression`1" /> no qual o tipo de delegado é conhecido em tempo de compilação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1782">Creates an <see cref="T:System.Linq.Expressions.Expression`1" /> where the delegate type is known at compile time.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-1783">Um <see cref="T:System.Linq.Expressions.Expression`1" /> que tem a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> e as propriedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1783">An <see cref="T:System.Linq.Expressions.Expression`1" /> that has the <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda&lt;TDelegate&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.Expression&lt;TDelegate&gt; Lambda&lt;TDelegate&gt; (System.Linq.Expressions.Expression body, bool tailCall, params System.Linq.Expressions.ParameterExpression[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.Expression`1&lt;!!TDelegate&gt; Lambda&lt;TDelegate&gt;(class System.Linq.Expressions.Expression body, bool tailCall, class System.Linq.Expressions.ParameterExpression[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.Boolean,System.Linq.Expressions.ParameterExpression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda(Of TDelegate) (body As Expression, tailCall As Boolean, ParamArray parameters As ParameterExpression()) As Expression(Of TDelegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TDelegate&gt;&#xA; static System::Linq::Expressions::Expression&lt;TDelegate&gt; ^ Lambda(System::Linq::Expressions::Expression ^ body, bool tailCall, ... cli::array &lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : System.Linq.Expressions.Expression * bool * System.Linq.Expressions.ParameterExpression[] -&gt; System.Linq.Expressions.Expression&lt;'Delegate&gt;" Usage="System.Linq.Expressions.Expression.Lambda (body, tailCall, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression&lt;TDelegate&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TDelegate" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="tailCall" Type="System.Boolean" />
        <Parameter Name="parameters" Type="System.Linq.Expressions.ParameterExpression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TDelegate">
          <span data-ttu-id="f7da9-1784">O tipo de delegado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1784">The delegate type.</span>
          </span>
        </typeparam>
        <param name="body">
          <span data-ttu-id="f7da9-1785">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1785">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span>
          </span>
        </param>
        <param name="tailCall">
          <span data-ttu-id="f7da9-1786">Um <see cref="T:System.Boolean" /> que indica se a otimização de chamada final será aplicada ao compilar a expressão criada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1786">A <see cref="T:System.Boolean" /> that indicates if tail call optimization will be applied when compiling the created expression.</span>
          </span>
        </param>
        <param name="parameters">
          <span data-ttu-id="f7da9-1787">Uma matriz que contém os objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> a serem usados para popular a coleção <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1787">An array that contains <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-1788">Cria um <see cref="T:System.Linq.Expressions.Expression`1" /> no qual o tipo de delegado é conhecido em tempo de compilação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1788">Creates an <see cref="T:System.Linq.Expressions.Expression`1" /> where the delegate type is known at compile time.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-1789">Um <see cref="T:System.Linq.Expressions.Expression`1" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> e as propriedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1789">An <see cref="T:System.Linq.Expressions.Expression`1" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda&lt;TDelegate&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.Expression&lt;TDelegate&gt; Lambda&lt;TDelegate&gt; (System.Linq.Expressions.Expression body, string name, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.Expression`1&lt;!!TDelegate&gt; Lambda&lt;TDelegate&gt;(class System.Linq.Expressions.Expression body, string name, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.String,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda(Of TDelegate) (body As Expression, name As String, parameters As IEnumerable(Of ParameterExpression)) As Expression(Of TDelegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TDelegate&gt;&#xA; static System::Linq::Expressions::Expression&lt;TDelegate&gt; ^ Lambda(System::Linq::Expressions::Expression ^ body, System::String ^ name, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : System.Linq.Expressions.Expression * string * seq&lt;System.Linq.Expressions.ParameterExpression&gt; -&gt; System.Linq.Expressions.Expression&lt;'Delegate&gt;" Usage="System.Linq.Expressions.Expression.Lambda (body, name, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression&lt;TDelegate&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TDelegate" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TDelegate">
          <span data-ttu-id="f7da9-1790">O tipo de delegado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1790">The delegate type.</span>
          </span>
        </typeparam>
        <param name="body">
          <span data-ttu-id="f7da9-1791">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1791">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span>
          </span>
        </param>
        <param name="name">
          <span data-ttu-id="f7da9-1792">O nome do lambda.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1792">The name of the lambda.</span>
          </span>
          <span data-ttu-id="f7da9-1793">Usado para gerar informações de depuração.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1793">Used for generating debugging information.</span>
          </span>
        </param>
        <param name="parameters">
          <span data-ttu-id="f7da9-1794">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> a serem usados para preencher a coleção de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1794">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-1795">Cria um <see cref="T:System.Linq.Expressions.Expression`1" /> no qual o tipo de delegado é conhecido em tempo de compilação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1795">Creates an <see cref="T:System.Linq.Expressions.Expression`1" /> where the delegate type is known at compile time.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-1796">Um <see cref="T:System.Linq.Expressions.Expression`1" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> e as propriedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1796">An <see cref="T:System.Linq.Expressions.Expression`1" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda&lt;TDelegate&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.Expression&lt;TDelegate&gt; Lambda&lt;TDelegate&gt; (System.Linq.Expressions.Expression body, string name, bool tailCall, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.Expression`1&lt;!!TDelegate&gt; Lambda&lt;TDelegate&gt;(class System.Linq.Expressions.Expression body, string name, bool tailCall, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda(Of TDelegate) (body As Expression, name As String, tailCall As Boolean, parameters As IEnumerable(Of ParameterExpression)) As Expression(Of TDelegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TDelegate&gt;&#xA; static System::Linq::Expressions::Expression&lt;TDelegate&gt; ^ Lambda(System::Linq::Expressions::Expression ^ body, System::String ^ name, bool tailCall, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : System.Linq.Expressions.Expression * string * bool * seq&lt;System.Linq.Expressions.ParameterExpression&gt; -&gt; System.Linq.Expressions.Expression&lt;'Delegate&gt;" Usage="System.Linq.Expressions.Expression.Lambda (body, name, tailCall, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression&lt;TDelegate&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TDelegate" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="tailCall" Type="System.Boolean" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TDelegate">
          <span data-ttu-id="f7da9-1797">O tipo de delegado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1797">The delegate type.</span>
          </span>
        </typeparam>
        <param name="body">
          <span data-ttu-id="f7da9-1798">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1798">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span>
          </span>
        </param>
        <param name="name">
          <span data-ttu-id="f7da9-1799">O nome do lambda.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1799">The name of the lambda.</span>
          </span>
          <span data-ttu-id="f7da9-1800">Usado para gerar informações de depuração.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1800">Used for generating debugging info.</span>
          </span>
        </param>
        <param name="tailCall">
          <span data-ttu-id="f7da9-1801">Um <see cref="T:System.Boolean" /> que indica se a otimização de chamada final será aplicada ao compilar a expressão criada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1801">A <see cref="T:System.Boolean" /> that indicates if tail call optimization will be applied when compiling the created expression.</span>
          </span>
        </param>
        <param name="parameters">
          <span data-ttu-id="f7da9-1802">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> a serem usados para preencher a coleção de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1802">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-1803">Cria um <see cref="T:System.Linq.Expressions.Expression`1" /> no qual o tipo de delegado é conhecido em tempo de compilação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1803">Creates an <see cref="T:System.Linq.Expressions.Expression`1" /> where the delegate type is known at compile time.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-1804">Um <see cref="T:System.Linq.Expressions.Expression`1" /> que tem a propriedade <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> e as propriedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1804">An <see cref="T:System.Linq.Expressions.Expression`1" /> that has the <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="LeftShift">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f7da9-1805">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de deslocamento à esquerda bit a bit.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1805">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise left-shift operation.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LeftShift">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LeftShift (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LeftShift(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LeftShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LeftShift (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ LeftShift(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member LeftShift : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.LeftShift (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="f7da9-1806">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1806">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="f7da9-1807">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1807">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-1808">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de deslocamento à esquerda bit a bit.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1808">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise left-shift operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-1809">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.LeftShift" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1809">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.LeftShift" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-1810">Resultante <xref:System.Linq.Expressions.BinaryExpression> tem o <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriedade definida como o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1810">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="f7da9-1811">O <xref:System.Linq.Expressions.Expression.Type%2A> estiver definida como o tipo de nó.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1811">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="f7da9-1812">Se o nó é elevado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> e <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriedades estiverem `true`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1812">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="f7da9-1813">Caso contrário, eles são `false`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1813">Otherwise, they are `false`.</span></span> <span data-ttu-id="f7da9-1814">A propriedade <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> é `null`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1814">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="f7da9-1815">As informações a seguir descrevem o método de implementação, o tipo de nó, e se um nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1815">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="f7da9-1816">Implementando método</span><span class="sxs-lookup"><span data-stu-id="f7da9-1816">Implementing Method</span></span>  
 <span data-ttu-id="f7da9-1817">As seguintes regras de determinam o método de implementação selecionado para a operação:</span><span class="sxs-lookup"><span data-stu-id="f7da9-1817">The following rules determine the selected implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="f7da9-1818">Se o <xref:System.Linq.Expressions.Expression.Type%2A> propriedade deles `left` ou `right` representa um tipo definido pelo usuário que sobrecarrega o operador de deslocamento à esquerda, o <xref:System.Reflection.MethodInfo> que representa que o método é o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1818">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the left-shift operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="f7da9-1819">Caso contrário, se `left`. Tipo é um tipo integral (um dos <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, ou os tipos que permitem valor nulos correspondentes) e `right`. É do tipo <xref:System.Int32>, o método de implementação é `null`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1819">Otherwise, if `left`.Type is an integral type (one of <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, or the corresponding nullable types) and `right`.Type is <xref:System.Int32>, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="f7da9-1820">Tipo de nó e versão com comparação de precisão x sem comparação de precisão</span><span class="sxs-lookup"><span data-stu-id="f7da9-1820">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="f7da9-1821">Se o método de implementação não for `null`:</span><span class="sxs-lookup"><span data-stu-id="f7da9-1821">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="f7da9-1822">Se `left`. Tipo e `right`. Tipo podem ser atribuídos aos tipos de argumento correspondente do método de implementação, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1822">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="f7da9-1823">O tipo do nó é o tipo de retorno do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1823">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="f7da9-1824">Se as duas seguintes condições forem atendidas, o nó é levantado e o tipo de nó é o tipo que permite valor nulo que corresponde ao tipo de retorno do método de implementação:</span><span class="sxs-lookup"><span data-stu-id="f7da9-1824">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="f7da9-1825">`left`. Tipo e `right`. Tipo são os dois tipos de valor de que pelo menos um é anulável e os tipos não anuláveis correspondentes são iguais para os tipos de argumento correspondente do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1825">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="f7da9-1826">O tipo de retorno do método de implementação é um tipo de valor não anulável.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1826">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="f7da9-1827">Se o método de implementação é `null`:</span><span class="sxs-lookup"><span data-stu-id="f7da9-1827">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="f7da9-1828">Se `left`. Tipo e `right`. Tipo são não anuláveis, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1828">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="f7da9-1829">O tipo do nó é o tipo de resultado do operador de deslocamento à esquerda predefinido.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1829">The type of the node is the result type of the predefined left-shift operator.</span></span>  
  
-   <span data-ttu-id="f7da9-1830">Se `left`. Tipo e `right`. Tipo são anuláveis, o nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1830">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="f7da9-1831">O tipo de nó é o tipo que permite valor nulo que corresponde ao tipo de resultado do operador de deslocamento à esquerda predefinido.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1831">The type of the node is the nullable type that corresponds to the result type of the predefined left-shift operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f7da9-1832">
            <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1832">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f7da9-1833">O operador de deslocamento à esquerda não foi definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1833">The left-shift operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="LeftShift">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LeftShift (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LeftShift(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LeftShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LeftShift (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ LeftShift(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member LeftShift : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.LeftShift (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="f7da9-1834">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1834">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="f7da9-1835">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1835">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="f7da9-1836">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1836">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-1837">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de deslocamento à esquerda bit a bit.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1837">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise left-shift operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-1838">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.LeftShift" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1838">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.LeftShift" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-1839">Resultante <xref:System.Linq.Expressions.BinaryExpression> tem o <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriedade definida como o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1839">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="f7da9-1840">O <xref:System.Linq.Expressions.Expression.Type%2A> estiver definida como o tipo de nó.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1840">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="f7da9-1841">Se o nó é elevado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> e <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriedades estiverem `true`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1841">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="f7da9-1842">Caso contrário, eles são `false`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1842">Otherwise, they are `false`.</span></span> <span data-ttu-id="f7da9-1843">A propriedade <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> é `null`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1843">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="f7da9-1844">As informações a seguir descrevem o método de implementação, o tipo de nó, e se um nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1844">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="f7da9-1845">Implementando método</span><span class="sxs-lookup"><span data-stu-id="f7da9-1845">Implementing Method</span></span>  
 <span data-ttu-id="f7da9-1846">As seguintes regras de determinam o método de implementação selecionado para a operação:</span><span class="sxs-lookup"><span data-stu-id="f7da9-1846">The following rules determine the selected implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="f7da9-1847">Se `method` não é `null` e representa um não-nulo, `static` (`Shared` no Visual Basic) método que usa dois argumentos, é o método de implementação para o nó.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1847">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method for the node.</span></span>  
  
-   <span data-ttu-id="f7da9-1848">Caso contrário, se o <xref:System.Linq.Expressions.Expression.Type%2A> propriedade deles `left` ou `right` representa um tipo definido pelo usuário que sobrecarrega o operador de deslocamento à esquerda, o <xref:System.Reflection.MethodInfo> que representa que o método é o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1848">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the left-shift operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="f7da9-1849">Caso contrário, se `left`. Tipo é um tipo integral (um dos <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, ou os tipos que permitem valor nulos correspondentes) e `right`. É do tipo <xref:System.Int32>, o método de implementação é `null`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1849">Otherwise, if `left`.Type is an integral type (one of <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, or the corresponding nullable types) and `right`.Type is <xref:System.Int32>, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="f7da9-1850">Tipo de nó e versão com comparação de precisão x sem comparação de precisão</span><span class="sxs-lookup"><span data-stu-id="f7da9-1850">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="f7da9-1851">Se o método de implementação não for `null`:</span><span class="sxs-lookup"><span data-stu-id="f7da9-1851">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="f7da9-1852">Se `left`. Tipo e `right`. Tipo podem ser atribuídos aos tipos de argumento correspondente do método de implementação, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1852">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="f7da9-1853">O tipo do nó é o tipo de retorno do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1853">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="f7da9-1854">Se as duas seguintes condições forem atendidas, o nó é levantado e o tipo de nó é o tipo que permite valor nulo que corresponde ao tipo de retorno do método de implementação:</span><span class="sxs-lookup"><span data-stu-id="f7da9-1854">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="f7da9-1855">`left`. Tipo e `right`. Tipo são os dois tipos de valor de que pelo menos um é anulável e os tipos não anuláveis correspondentes são iguais para os tipos de argumento correspondente do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1855">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="f7da9-1856">O tipo de retorno do método de implementação é um tipo de valor não anulável.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1856">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="f7da9-1857">Se o método de implementação é `null`:</span><span class="sxs-lookup"><span data-stu-id="f7da9-1857">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="f7da9-1858">Se `left`. Tipo e `right`. Tipo são não anuláveis, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1858">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="f7da9-1859">O tipo do nó é o tipo de resultado do operador de deslocamento à esquerda predefinido.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1859">The type of the node is the result type of the predefined left-shift operator.</span></span>  
  
-   <span data-ttu-id="f7da9-1860">Se `left`. Tipo e `right`. Tipo são anuláveis, o nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1860">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="f7da9-1861">O tipo de nó é o tipo que permite valor nulo que corresponde ao tipo de resultado do operador de deslocamento à esquerda predefinido.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1861">The type of the node is the nullable type that corresponds to the result type of the predefined left-shift operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f7da9-1862">
            <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1862">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f7da9-1863">
            <paramref name="method" /> não é <see langword="null" /> e o método que ele representa retorna <see langword="void" />, não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) ou não tem exatamente dois argumentos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1863">
              <paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f7da9-1864">
            <paramref name="method" /> é <see langword="null" /> e o operador de deslocamento à esquerda não foi definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1864">
              <paramref name="method" /> is <see langword="null" /> and the left-shift operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="LeftShiftAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f7da9-1865">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição de deslocamento à esquerda bit a bit.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1865">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise left-shift assignment operation.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LeftShiftAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LeftShiftAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LeftShiftAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LeftShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LeftShiftAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ LeftShiftAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member LeftShiftAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.LeftShiftAssign (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="f7da9-1866">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1866">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="f7da9-1867">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1867">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-1868">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição de deslocamento à esquerda bit a bit.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1868">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise left-shift assignment operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-1869">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1869">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LeftShiftAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LeftShiftAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LeftShiftAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LeftShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LeftShiftAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ LeftShiftAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member LeftShiftAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.LeftShiftAssign (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="f7da9-1870">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1870">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="f7da9-1871">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1871">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="f7da9-1872">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1872">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-1873">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição de deslocamento à esquerda bit a bit.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1873">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise left-shift assignment operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-1874">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1874">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LeftShiftAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LeftShiftAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LeftShiftAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LeftShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LeftShiftAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ LeftShiftAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member LeftShiftAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.LeftShiftAssign (left, right, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="f7da9-1875">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1875">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="f7da9-1876">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1876">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="f7da9-1877">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1877">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <param name="conversion">
          <span data-ttu-id="f7da9-1878">Um <see cref="T:System.Linq.Expressions.LambdaExpression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1878">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-1879">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição de deslocamento à esquerda bit a bit.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1879">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise left-shift assignment operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-1880">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1880">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="LessThan">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f7da9-1881">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma comparação numérica "menor que".</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1881">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a "less than" numeric comparison.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LessThan">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LessThan (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LessThan(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LessThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LessThan (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ LessThan(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member LessThan : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.LessThan (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="f7da9-1882">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1882">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="f7da9-1883">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1883">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-1884">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma comparação numérica "menor que".</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1884">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a "less than" numeric comparison.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-1885">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.LessThan" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1885">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.LessThan" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-1886">Resultante <xref:System.Linq.Expressions.BinaryExpression> tem o <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriedade definida como o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1886">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="f7da9-1887">O <xref:System.Linq.Expressions.Expression.Type%2A> estiver definida como o tipo de nó.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1887">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="f7da9-1888">Se o nó é elevado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> é de propriedade `true`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1888">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> property is `true`.</span></span> <span data-ttu-id="f7da9-1889">Caso contrário, será `false`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1889">Otherwise, it is `false`.</span></span> <span data-ttu-id="f7da9-1890">A propriedade <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> sempre é `false`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1890">The <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> property is always `false`.</span></span> <span data-ttu-id="f7da9-1891">A propriedade <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> é `null`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1891">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="f7da9-1892">As informações a seguir descrevem o método de implementação, o tipo de nó, e se um nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1892">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="f7da9-1893">Implementando método</span><span class="sxs-lookup"><span data-stu-id="f7da9-1893">Implementing Method</span></span>  
 <span data-ttu-id="f7da9-1894">O método de implementação para a operação é escolhido com base nas seguintes regras:</span><span class="sxs-lookup"><span data-stu-id="f7da9-1894">The implementing method for the operation is chosen based on the following rules:</span></span>  
  
-   <span data-ttu-id="f7da9-1895">Se o <xref:System.Linq.Expressions.Expression.Type%2A> propriedade deles `left` ou `right` representa um tipo definido pelo usuário que sobrecarrega o operador "menor que" o <xref:System.Reflection.MethodInfo> que representa que o método é o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1895">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the "less than" operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="f7da9-1896">Caso contrário, se `left`. Tipo e `right`. Tipo de tipos numéricos, o método de implementação está `null`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1896">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="f7da9-1897">Tipo de nó e versão com comparação de precisão x sem comparação de precisão</span><span class="sxs-lookup"><span data-stu-id="f7da9-1897">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="f7da9-1898">Se o método de implementação não for `null`:</span><span class="sxs-lookup"><span data-stu-id="f7da9-1898">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="f7da9-1899">Se `left`. Tipo e `right`. Tipo podem ser atribuídos aos tipos de argumento correspondente do método de implementação, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1899">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="f7da9-1900">O tipo do nó é o tipo de retorno do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1900">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="f7da9-1901">Se as duas seguintes condições forem atendidas, o nó é elevado e o tipo de nó é <xref:System.Boolean>:</span><span class="sxs-lookup"><span data-stu-id="f7da9-1901">If the following two conditions are satisfied, the node is lifted and the type of the node is <xref:System.Boolean>:</span></span>  
  
    -   <span data-ttu-id="f7da9-1902">`left`. Tipo e `right`. Tipo são os dois tipos de valor de que pelo menos um é anulável e os tipos não anuláveis correspondentes são iguais para os tipos de argumento correspondente do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1902">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="f7da9-1903">O tipo de retorno do método de implementação é <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1903">The return type of the implementing method is <xref:System.Boolean>.</span></span>  
  
 <span data-ttu-id="f7da9-1904">Se o método de implementação é `null`:</span><span class="sxs-lookup"><span data-stu-id="f7da9-1904">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="f7da9-1905">Se `left`. Tipo e `right`. Tipo são não anuláveis, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1905">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="f7da9-1906">O tipo de nó é <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1906">The type of the node is <xref:System.Boolean>.</span></span>  
  
-   <span data-ttu-id="f7da9-1907">Se `left`. Tipo e `right`. Tipo são anuláveis, o nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1907">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="f7da9-1908">O tipo de nó é <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1908">The type of the node is <xref:System.Boolean>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f7da9-1909">O exemplo de código a seguir mostra como criar uma expressão que compara dois inteiros.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1909">The following code example shows how to create an expression that compares two integers.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#25)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#25)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f7da9-1910">
            <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1910">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f7da9-1911">O operador “menor que” não está definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1911">The "less than" operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="LessThan">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LessThan (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, bool liftToNull, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LessThan(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, bool liftToNull, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LessThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LessThan (left As Expression, right As Expression, liftToNull As Boolean, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ LessThan(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, bool liftToNull, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member LessThan : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * bool * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.LessThan (left, right, liftToNull, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="liftToNull" Type="System.Boolean" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="f7da9-1912">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1912">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="f7da9-1913">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1913">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="liftToNull">
          <span data-ttu-id="f7da9-1914">
            <see langword="true" /> para definir <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> como <see langword="true" />; <see langword="false" /> para definir <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> como <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1914">
              <see langword="true" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="true" />; <see langword="false" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="false" />.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="f7da9-1915">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1915">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-1916">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma comparação numérica "menor que".</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1916">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a "less than" numeric comparison.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-1917">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.LessThan" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1917">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.LessThan" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-1918">Resultante <xref:System.Linq.Expressions.BinaryExpression> tem o <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriedade definida como o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1918">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="f7da9-1919">O <xref:System.Linq.Expressions.Expression.Type%2A> estiver definida como o tipo de nó.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1919">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="f7da9-1920">Se o nó é elevado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> é de propriedade `true` e o <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriedade é igual a `liftToNull`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1920">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> property is `true` and the <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> property is equal to `liftToNull`.</span></span> <span data-ttu-id="f7da9-1921">Caso contrário, eles são ambos `false`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1921">Otherwise, they are both `false`.</span></span> <span data-ttu-id="f7da9-1922">A propriedade <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> é `null`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1922">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="f7da9-1923">As informações a seguir descrevem o método de implementação, o tipo de nó, e se um nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1923">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="f7da9-1924">Implementando método</span><span class="sxs-lookup"><span data-stu-id="f7da9-1924">Implementing Method</span></span>  
 <span data-ttu-id="f7da9-1925">As regras a seguir determinam o método de implementação para a operação:</span><span class="sxs-lookup"><span data-stu-id="f7da9-1925">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="f7da9-1926">Se `method` não é `null` e representa um não-nulo, `static` (`Shared` no Visual Basic) método que usa dois argumentos, é o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1926">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method.</span></span>  
  
-   <span data-ttu-id="f7da9-1927">Caso contrário, se o <xref:System.Linq.Expressions.Expression.Type%2A> propriedade deles `left` ou `right` representa um tipo definido pelo usuário que sobrecarrega o operador "menor que" o <xref:System.Reflection.MethodInfo> que representa que o método é o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1927">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the "less than" operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="f7da9-1928">Caso contrário, se `left`. Tipo e `right`. Tipo de tipos numéricos, o método de implementação está `null`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1928">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="f7da9-1929">Tipo de nó e versão com comparação de precisão x sem comparação de precisão</span><span class="sxs-lookup"><span data-stu-id="f7da9-1929">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="f7da9-1930">Se o método de implementação não for `null`:</span><span class="sxs-lookup"><span data-stu-id="f7da9-1930">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="f7da9-1931">Se `left`. Tipo e `right`. Tipo podem ser atribuídos aos tipos de argumento correspondente do método de implementação, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1931">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="f7da9-1932">O tipo do nó é o tipo de retorno do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1932">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="f7da9-1933">Se as duas seguintes condições forem atendidas, o nó é eliminado; Além disso, o tipo do nó é anulável <xref:System.Boolean> se `liftToNull` é `true` ou <xref:System.Boolean> se `liftToNull` é `false`:</span><span class="sxs-lookup"><span data-stu-id="f7da9-1933">If the following two conditions are satisfied, the node is lifted; also, the type of the node is nullable <xref:System.Boolean> if `liftToNull` is `true` or <xref:System.Boolean> if `liftToNull` is `false`:</span></span>  
  
    -   <span data-ttu-id="f7da9-1934">`left`. Tipo e `right`. Tipo são os dois tipos de valor de que pelo menos um é anulável e os tipos não anuláveis correspondentes são iguais para os tipos de argumento correspondente do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1934">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="f7da9-1935">O tipo de retorno do método de implementação é <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1935">The return type of the implementing method is <xref:System.Boolean>.</span></span>  
  
 <span data-ttu-id="f7da9-1936">Se o método de implementação é `null`:</span><span class="sxs-lookup"><span data-stu-id="f7da9-1936">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="f7da9-1937">Se `left`. Tipo e `right`. Tipo são não anuláveis, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1937">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="f7da9-1938">O tipo de nó é <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1938">The type of the node is <xref:System.Boolean>.</span></span>  
  
-   <span data-ttu-id="f7da9-1939">Se `left`. Tipo e `right`. Tipo são anuláveis, o nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1939">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="f7da9-1940">O tipo do nó é anulável <xref:System.Boolean> se `liftToNull` é `true` ou <xref:System.Boolean> se `liftToNull` é `false`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1940">The type of the node is nullable <xref:System.Boolean> if `liftToNull` is `true` or <xref:System.Boolean> if `liftToNull` is `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f7da9-1941">
            <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1941">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f7da9-1942">
            <paramref name="method" /> não é <see langword="null" /> e o método que ele representa retorna <see langword="void" />, não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) ou não tem exatamente dois argumentos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1942">
              <paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f7da9-1943">
            <paramref name="method" /> é <see langword="null" /> e o operador "menor que" não está definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1943">
              <paramref name="method" /> is <see langword="null" /> and the "less than" operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="LessThanOrEqual">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f7da9-1944">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma comparação numérica "menor ou igual a".</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1944">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a " less than or equal" numeric comparison.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LessThanOrEqual (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LessThanOrEqual(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LessThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LessThanOrEqual (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ LessThanOrEqual(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member LessThanOrEqual : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.LessThanOrEqual (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="f7da9-1945">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1945">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="f7da9-1946">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1946">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-1947">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma comparação numérica "menor ou igual a".</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1947">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a " less than or equal" numeric comparison.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-1948">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.LessThanOrEqual" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1948">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.LessThanOrEqual" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-1949">Resultante <xref:System.Linq.Expressions.BinaryExpression> tem o <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriedade definida como o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1949">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="f7da9-1950">O <xref:System.Linq.Expressions.Expression.Type%2A> estiver definida como o tipo de nó.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1950">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="f7da9-1951">Se o nó é elevado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> é de propriedade `true`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1951">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> property is `true`.</span></span> <span data-ttu-id="f7da9-1952">Caso contrário, será `false`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1952">Otherwise, it is `false`.</span></span> <span data-ttu-id="f7da9-1953">A propriedade <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> sempre é `false`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1953">The <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> property is always `false`.</span></span> <span data-ttu-id="f7da9-1954">A propriedade <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> é `null`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1954">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="f7da9-1955">As informações a seguir descrevem o método de implementação, o tipo de nó, e se um nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1955">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="f7da9-1956">Implementando método</span><span class="sxs-lookup"><span data-stu-id="f7da9-1956">Implementing Method</span></span>  
 <span data-ttu-id="f7da9-1957">As regras a seguir determinam o método de implementação para a operação:</span><span class="sxs-lookup"><span data-stu-id="f7da9-1957">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="f7da9-1958">Se o <xref:System.Linq.Expressions.Expression.Type%2A> propriedade deles `left` ou `right` representa um tipo definido pelo usuário que sobrecarrega o operador "menor ou igual", o <xref:System.Reflection.MethodInfo> que representa que o método é o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1958">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the "less than or equal" operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="f7da9-1959">Caso contrário, se `left`. Tipo e `right`. Tipo de tipos numéricos, o método de implementação está `null`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1959">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="f7da9-1960">Tipo de nó e versão com comparação de precisão x sem comparação de precisão</span><span class="sxs-lookup"><span data-stu-id="f7da9-1960">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="f7da9-1961">Se o método de implementação não for `null`:</span><span class="sxs-lookup"><span data-stu-id="f7da9-1961">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="f7da9-1962">Se `left`. Tipo e `right`. Tipo podem ser atribuídos aos tipos de argumento correspondente do método de implementação, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1962">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="f7da9-1963">O tipo do nó é o tipo de retorno do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1963">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="f7da9-1964">Se as duas seguintes condições forem atendidas, o nó é elevado e o tipo de nó é <xref:System.Boolean>:</span><span class="sxs-lookup"><span data-stu-id="f7da9-1964">If the following two conditions are satisfied, the node is lifted and the type of the node is <xref:System.Boolean>:</span></span>  
  
    -   <span data-ttu-id="f7da9-1965">`left`. Tipo e `right`. Tipo são os dois tipos de valor de que pelo menos um é anulável e os tipos não anuláveis correspondentes são iguais para os tipos de argumento correspondente do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1965">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="f7da9-1966">O tipo de retorno do método de implementação é <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1966">The return type of the implementing method is <xref:System.Boolean>.</span></span>  
  
 <span data-ttu-id="f7da9-1967">Se o método de implementação é `null`:</span><span class="sxs-lookup"><span data-stu-id="f7da9-1967">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="f7da9-1968">Se `left`. Tipo e `right`. Tipo são não anuláveis, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1968">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="f7da9-1969">O tipo de nó é <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1969">The type of the node is <xref:System.Boolean>.</span></span>  
  
-   <span data-ttu-id="f7da9-1970">Se `left`. Tipo e `right`. Tipo são anuláveis, o nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1970">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="f7da9-1971">O tipo de nó é <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1971">The type of the node is <xref:System.Boolean>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f7da9-1972">O exemplo de código a seguir mostra como criar uma expressão que compara dois inteiros.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1972">The following code example shows how to create an expression that compares two integers.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#26)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#26)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f7da9-1973">
            <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1973">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f7da9-1974">O operador "menor ou igual a" não foi definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1974">The "less than or equal" operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LessThanOrEqual (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, bool liftToNull, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LessThanOrEqual(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, bool liftToNull, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LessThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LessThanOrEqual (left As Expression, right As Expression, liftToNull As Boolean, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ LessThanOrEqual(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, bool liftToNull, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member LessThanOrEqual : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * bool * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.LessThanOrEqual (left, right, liftToNull, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="liftToNull" Type="System.Boolean" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="f7da9-1975">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1975">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="f7da9-1976">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1976">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="liftToNull">
          <span data-ttu-id="f7da9-1977">
            <see langword="true" /> para definir <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> como <see langword="true" />; <see langword="false" /> para definir <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> como <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1977">
              <see langword="true" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="true" />; <see langword="false" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="false" />.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="f7da9-1978">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1978">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-1979">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma comparação numérica "menor ou igual a".</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1979">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a "less than or equal" numeric comparison.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-1980">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.LessThanOrEqual" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-1980">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.LessThanOrEqual" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-1981">Resultante <xref:System.Linq.Expressions.BinaryExpression> tem o <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriedade definida como o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1981">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="f7da9-1982">O <xref:System.Linq.Expressions.Expression.Type%2A> estiver definida como o tipo de nó.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1982">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="f7da9-1983">Se o nó é elevado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> é de propriedade `true` e o <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriedade é igual a `liftToNull`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1983">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> property is `true` and the <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> property is equal to `liftToNull`.</span></span> <span data-ttu-id="f7da9-1984">Caso contrário, eles são ambos `false`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1984">Otherwise, they are both `false`.</span></span> <span data-ttu-id="f7da9-1985">A propriedade <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> é `null`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1985">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="f7da9-1986">As informações a seguir descrevem o método de implementação, o tipo de nó, e se um nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1986">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="f7da9-1987">Implementando método</span><span class="sxs-lookup"><span data-stu-id="f7da9-1987">Implementing Method</span></span>  
 <span data-ttu-id="f7da9-1988">As regras a seguir determinam o método de implementação para a operação:</span><span class="sxs-lookup"><span data-stu-id="f7da9-1988">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="f7da9-1989">Se `method` não é `null` e representa um não-nulo, `static` (`Shared` no Visual Basic) método que usa dois argumentos, é o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1989">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method.</span></span>  
  
-   <span data-ttu-id="f7da9-1990">Caso contrário, se o <xref:System.Linq.Expressions.Expression.Type%2A> propriedade deles `left` ou `right` representa um tipo definido pelo usuário que sobrecarrega o operador "menor ou igual", o <xref:System.Reflection.MethodInfo> que representa que o método é o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1990">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the "less than or equal" operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="f7da9-1991">Caso contrário, se `left`. Tipo e `right`. Tipo de tipos numéricos, o método de implementação está `null`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1991">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="f7da9-1992">Tipo de nó e versão com comparação de precisão x sem comparação de precisão</span><span class="sxs-lookup"><span data-stu-id="f7da9-1992">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="f7da9-1993">Se o método de implementação não for `null`:</span><span class="sxs-lookup"><span data-stu-id="f7da9-1993">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="f7da9-1994">Se `left`. Tipo e `right`. Tipo podem ser atribuídos aos tipos de argumento correspondente do método de implementação, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1994">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="f7da9-1995">O tipo do nó é o tipo de retorno do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1995">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="f7da9-1996">Se as duas seguintes condições forem atendidas, o nó é eliminado; Além disso, o tipo do nó é anulável <xref:System.Boolean> se `liftToNull` é `true` ou <xref:System.Boolean> se `liftToNull` é `false`:</span><span class="sxs-lookup"><span data-stu-id="f7da9-1996">If the following two conditions are satisfied, the node is lifted; also, the type of the node is nullable <xref:System.Boolean> if `liftToNull` is `true` or <xref:System.Boolean> if `liftToNull` is `false`:</span></span>  
  
    -   <span data-ttu-id="f7da9-1997">`left`. Tipo e `right`. Tipo são os dois tipos de valor de que pelo menos um é anulável e os tipos não anuláveis correspondentes são iguais para os tipos de argumento correspondente do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1997">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="f7da9-1998">O tipo de retorno do método de implementação é <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="f7da9-1998">The return type of the implementing method is <xref:System.Boolean>.</span></span>  
  
 <span data-ttu-id="f7da9-1999">Se o método de implementação é `null`:</span><span class="sxs-lookup"><span data-stu-id="f7da9-1999">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="f7da9-2000">Se `left`. Tipo e `right`. Tipo são não anuláveis, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2000">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="f7da9-2001">O tipo de nó é <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2001">The type of the node is <xref:System.Boolean>.</span></span>  
  
-   <span data-ttu-id="f7da9-2002">Se `left`. Tipo e `right`. Tipo são anuláveis, o nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2002">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="f7da9-2003">O tipo do nó é anulável <xref:System.Boolean> se `liftToNull` é `true` ou <xref:System.Boolean> se `liftToNull` é `false`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2003">The type of the node is nullable <xref:System.Boolean> if `liftToNull` is `true` or <xref:System.Boolean> if `liftToNull` is `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f7da9-2004">
            <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2004">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f7da9-2005">
            <paramref name="method" /> não é <see langword="null" /> e o método que ele representa retorna <see langword="void" />, não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) ou não tem exatamente dois argumentos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2005">
              <paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f7da9-2006">
            <paramref name="method" /> é <see langword="null" /> e o operador "menor ou igual a" não foi definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2006">
              <paramref name="method" /> is <see langword="null" /> and the "less than or equal" operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ListBind">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f7da9-2007">Cria um objeto <see cref="T:System.Linq.Expressions.MemberListBinding" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2007">Creates a <see cref="T:System.Linq.Expressions.MemberListBinding" /> object.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ListBind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberListBinding ListBind (System.Reflection.MemberInfo member, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ElementInit&gt; initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberListBinding ListBind(class System.Reflection.MemberInfo member, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ElementInit&gt; initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MemberInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ListBind (member As MemberInfo, initializers As IEnumerable(Of ElementInit)) As MemberListBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberListBinding ^ ListBind(System::Reflection::MemberInfo ^ member, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ElementInit ^&gt; ^ initializers);" />
      <MemberSignature Language="F#" Value="static member ListBind : System.Reflection.MemberInfo * seq&lt;System.Linq.Expressions.ElementInit&gt; -&gt; System.Linq.Expressions.MemberListBinding" Usage="System.Linq.Expressions.Expression.ListBind (member, initializers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberListBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="member" Type="System.Reflection.MemberInfo" />
        <Parameter Name="initializers" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ElementInit&gt;" />
      </Parameters>
      <Docs>
        <param name="member">
          <span data-ttu-id="f7da9-2008">Um <see cref="T:System.Reflection.MemberInfo" /> que representa um campo ou propriedade igual à qual definir a propriedade <see cref="P:System.Linq.Expressions.MemberBinding.Member" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2008">A <see cref="T:System.Reflection.MemberInfo" /> that represents a field or property to set the <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property equal to.</span>
          </span>
        </param>
        <param name="initializers">
          <span data-ttu-id="f7da9-2009">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.ElementInit" /> a serem usados para preencher a coleção de <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2009">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.ElementInit" /> objects to use to populate the <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-2010">Cria um <see cref="T:System.Linq.Expressions.MemberListBinding" /> em que o membro é um campo ou propriedade.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2010">Creates a <see cref="T:System.Linq.Expressions.MemberListBinding" /> where the member is a field or property.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-2011">Um <see cref="T:System.Linq.Expressions.MemberListBinding" /> que tem a propriedade <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> igual a <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" /> e as propriedades <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> e <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2011">A <see cref="T:System.Linq.Expressions.MemberListBinding" /> that has the <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> property equal to <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" /> and the <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> and <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f7da9-2012">
            <paramref name="member" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2012">
              <paramref name="member" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="f7da9-2013">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2013">-or-</span>
          </span>
          <span data-ttu-id="f7da9-2014">Um ou mais elementos de <paramref name="initializers" /> são <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2014">One or more elements of <paramref name="initializers" /> are <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f7da9-2015">
            <paramref name="member" /> não representa um campo ou propriedade.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2015">
              <paramref name="member" /> does not represent a field or property.</span>
          </span>
          <span data-ttu-id="f7da9-2016">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2016">-or-</span>
          </span>
          <span data-ttu-id="f7da9-2017">O <see cref="P:System.Reflection.FieldInfo.FieldType" /> ou <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> do campo ou propriedade representada por <paramref name="member" /> não implementa <see cref="T:System.Collections.IEnumerable" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2017">The <see cref="P:System.Reflection.FieldInfo.FieldType" /> or <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> of the field or property that <paramref name="member" /> represents does not implement <see cref="T:System.Collections.IEnumerable" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ListBind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberListBinding ListBind (System.Reflection.MemberInfo member, params System.Linq.Expressions.ElementInit[] initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberListBinding ListBind(class System.Reflection.MemberInfo member, class System.Linq.Expressions.ElementInit[] initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MemberInfo,System.Linq.Expressions.ElementInit[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ListBind (member As MemberInfo, ParamArray initializers As ElementInit()) As MemberListBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberListBinding ^ ListBind(System::Reflection::MemberInfo ^ member, ... cli::array &lt;System::Linq::Expressions::ElementInit ^&gt; ^ initializers);" />
      <MemberSignature Language="F#" Value="static member ListBind : System.Reflection.MemberInfo * System.Linq.Expressions.ElementInit[] -&gt; System.Linq.Expressions.MemberListBinding" Usage="System.Linq.Expressions.Expression.ListBind (member, initializers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberListBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="member" Type="System.Reflection.MemberInfo" />
        <Parameter Name="initializers" Type="System.Linq.Expressions.ElementInit[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="member">
          <span data-ttu-id="f7da9-2018">Um <see cref="T:System.Reflection.MemberInfo" /> que representa um campo ou propriedade igual à qual definir a propriedade <see cref="P:System.Linq.Expressions.MemberBinding.Member" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2018">A <see cref="T:System.Reflection.MemberInfo" /> that represents a field or property to set the <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property equal to.</span>
          </span>
        </param>
        <param name="initializers">
          <span data-ttu-id="f7da9-2019">Uma matriz de objetos <see cref="T:System.Linq.Expressions.ElementInit" /> a serem usados para popular a coleção de <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2019">An array of <see cref="T:System.Linq.Expressions.ElementInit" /> objects to use to populate the <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-2020">Cria um <see cref="T:System.Linq.Expressions.MemberListBinding" /> em que o membro é um campo ou propriedade.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2020">Creates a <see cref="T:System.Linq.Expressions.MemberListBinding" /> where the member is a field or property.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-2021">Um <see cref="T:System.Linq.Expressions.MemberListBinding" /> que tem a propriedade <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> igual a <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" /> e as propriedades <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> e <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2021">A <see cref="T:System.Linq.Expressions.MemberListBinding" /> that has the <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> property equal to <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" /> and the <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> and <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f7da9-2022">
            <paramref name="member" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2022">
              <paramref name="member" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="f7da9-2023">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2023">-or-</span>
          </span>
          <span data-ttu-id="f7da9-2024">Um ou mais elementos de <paramref name="initializers" /> são <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2024">One or more elements of <paramref name="initializers" /> are <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f7da9-2025">
            <paramref name="member" /> não representa um campo ou propriedade.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2025">
              <paramref name="member" /> does not represent a field or property.</span>
          </span>
          <span data-ttu-id="f7da9-2026">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2026">-or-</span>
          </span>
          <span data-ttu-id="f7da9-2027">O <see cref="P:System.Reflection.FieldInfo.FieldType" /> ou <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> do campo ou propriedade representada por <paramref name="member" /> não implementa <see cref="T:System.Collections.IEnumerable" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2027">The <see cref="P:System.Reflection.FieldInfo.FieldType" /> or <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> of the field or property that <paramref name="member" /> represents does not implement <see cref="T:System.Collections.IEnumerable" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ListBind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberListBinding ListBind (System.Reflection.MethodInfo propertyAccessor, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ElementInit&gt; initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberListBinding ListBind(class System.Reflection.MethodInfo propertyAccessor, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ElementInit&gt; initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ListBind (propertyAccessor As MethodInfo, initializers As IEnumerable(Of ElementInit)) As MemberListBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberListBinding ^ ListBind(System::Reflection::MethodInfo ^ propertyAccessor, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ElementInit ^&gt; ^ initializers);" />
      <MemberSignature Language="F#" Value="static member ListBind : System.Reflection.MethodInfo * seq&lt;System.Linq.Expressions.ElementInit&gt; -&gt; System.Linq.Expressions.MemberListBinding" Usage="System.Linq.Expressions.Expression.ListBind (propertyAccessor, initializers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberListBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyAccessor" Type="System.Reflection.MethodInfo" />
        <Parameter Name="initializers" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ElementInit&gt;" />
      </Parameters>
      <Docs>
        <param name="propertyAccessor">
          <span data-ttu-id="f7da9-2028">Um <see cref="T:System.Reflection.MethodInfo" /> que representa um método de acessador de propriedade.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2028">A <see cref="T:System.Reflection.MethodInfo" /> that represents a property accessor method.</span>
          </span>
        </param>
        <param name="initializers">
          <span data-ttu-id="f7da9-2029">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.ElementInit" /> a serem usados para preencher a coleção de <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2029">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.ElementInit" /> objects to use to populate the <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-2030">Cria um <see cref="T:System.Linq.Expressions.MemberListBinding" /> com base em um método de acessador de propriedade especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2030">Creates a <see cref="T:System.Linq.Expressions.MemberListBinding" /> based on a specified property accessor method.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-2031">Um <see cref="T:System.Linq.Expressions.MemberListBinding" /> que tem a propriedade <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> igual a <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" />, a propriedade <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> definida para o <see cref="T:System.Reflection.MemberInfo" /> que representa a propriedade acessada em <paramref name="propertyAccessor" /> e <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> populada com os elementos de <paramref name="initializers" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2031">A <see cref="T:System.Linq.Expressions.MemberListBinding" /> that has the <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> property equal to <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" />, the <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property set to the <see cref="T:System.Reflection.MemberInfo" /> that represents the property accessed in <paramref name="propertyAccessor" />, and <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> populated with the elements of <paramref name="initializers" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f7da9-2032">
            <paramref name="propertyAccessor" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2032">
              <paramref name="propertyAccessor" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="f7da9-2033">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2033">-or-</span>
          </span>
          <span data-ttu-id="f7da9-2034">Um ou mais elementos de <paramref name="initializers" /> são <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2034">One or more elements of <paramref name="initializers" /> are <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f7da9-2035">
            <paramref name="propertyAccessor" /> não representa um método de acessador de propriedade.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2035">
              <paramref name="propertyAccessor" /> does not represent a property accessor method.</span>
          </span>
          <span data-ttu-id="f7da9-2036">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2036">-or-</span>
          </span>
          <span data-ttu-id="f7da9-2037">O <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> da propriedade acessada pelo método representado por <paramref name="propertyAccessor" /> não implementa <see cref="T:System.Collections.IEnumerable" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2037">The <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> of the property that the method represented by <paramref name="propertyAccessor" /> accesses does not implement <see cref="T:System.Collections.IEnumerable" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ListBind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberListBinding ListBind (System.Reflection.MethodInfo propertyAccessor, params System.Linq.Expressions.ElementInit[] initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberListBinding ListBind(class System.Reflection.MethodInfo propertyAccessor, class System.Linq.Expressions.ElementInit[] initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MethodInfo,System.Linq.Expressions.ElementInit[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ListBind (propertyAccessor As MethodInfo, ParamArray initializers As ElementInit()) As MemberListBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberListBinding ^ ListBind(System::Reflection::MethodInfo ^ propertyAccessor, ... cli::array &lt;System::Linq::Expressions::ElementInit ^&gt; ^ initializers);" />
      <MemberSignature Language="F#" Value="static member ListBind : System.Reflection.MethodInfo * System.Linq.Expressions.ElementInit[] -&gt; System.Linq.Expressions.MemberListBinding" Usage="System.Linq.Expressions.Expression.ListBind (propertyAccessor, initializers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberListBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyAccessor" Type="System.Reflection.MethodInfo" />
        <Parameter Name="initializers" Type="System.Linq.Expressions.ElementInit[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="propertyAccessor">
          <span data-ttu-id="f7da9-2038">Um <see cref="T:System.Reflection.MethodInfo" /> que representa um método de acessador de propriedade.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2038">A <see cref="T:System.Reflection.MethodInfo" /> that represents a property accessor method.</span>
          </span>
        </param>
        <param name="initializers">
          <span data-ttu-id="f7da9-2039">Uma matriz de objetos <see cref="T:System.Linq.Expressions.ElementInit" /> a serem usados para popular a coleção de <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2039">An array of <see cref="T:System.Linq.Expressions.ElementInit" /> objects to use to populate the <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-2040">Cria um objeto <see cref="T:System.Linq.Expressions.MemberListBinding" /> com base em um método de acessador de propriedade especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2040">Creates a <see cref="T:System.Linq.Expressions.MemberListBinding" /> object based on a specified property accessor method.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-2041">Um <see cref="T:System.Linq.Expressions.MemberListBinding" /> que tem a propriedade <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> igual a <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" />, a propriedade <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> definida para o <see cref="T:System.Reflection.MemberInfo" /> que representa a propriedade acessada em <paramref name="propertyAccessor" /> e <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> populada com os elementos de <paramref name="initializers" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2041">A <see cref="T:System.Linq.Expressions.MemberListBinding" /> that has the <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> property equal to <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" />, the <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property set to the <see cref="T:System.Reflection.MemberInfo" /> that represents the property accessed in <paramref name="propertyAccessor" />, and <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> populated with the elements of <paramref name="initializers" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f7da9-2042">
            <paramref name="propertyAccessor" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2042">
              <paramref name="propertyAccessor" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="f7da9-2043">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2043">-or-</span>
          </span>
          <span data-ttu-id="f7da9-2044">Um ou mais elementos de <paramref name="initializers" /> são <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2044">One or more elements of <paramref name="initializers" /> are <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f7da9-2045">
            <paramref name="propertyAccessor" /> não representa um método de acessador de propriedade.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2045">
              <paramref name="propertyAccessor" /> does not represent a property accessor method.</span>
          </span>
          <span data-ttu-id="f7da9-2046">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2046">-or-</span>
          </span>
          <span data-ttu-id="f7da9-2047">O <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> da propriedade acessada pelo método representado por <paramref name="propertyAccessor" /> não implementa <see cref="T:System.Collections.IEnumerable" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2047">The <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> of the property that the method represented by <paramref name="propertyAccessor" /> accesses does not implement <see cref="T:System.Collections.IEnumerable" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ListInit">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f7da9-2048">Cria um <see cref="T:System.Linq.Expressions.ListInitExpression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2048">Creates a <see cref="T:System.Linq.Expressions.ListInitExpression" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ListInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ListInitExpression ListInit (System.Linq.Expressions.NewExpression newExpression, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ElementInit&gt; initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ListInitExpression ListInit(class System.Linq.Expressions.NewExpression newExpression, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ElementInit&gt; initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ListInitExpression ^ ListInit(System::Linq::Expressions::NewExpression ^ newExpression, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ElementInit ^&gt; ^ initializers);" />
      <MemberSignature Language="F#" Value="static member ListInit : System.Linq.Expressions.NewExpression * seq&lt;System.Linq.Expressions.ElementInit&gt; -&gt; System.Linq.Expressions.ListInitExpression" Usage="System.Linq.Expressions.Expression.ListInit (newExpression, initializers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ListInitExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newExpression" Type="System.Linq.Expressions.NewExpression" />
        <Parameter Name="initializers" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ElementInit&gt;" />
      </Parameters>
      <Docs>
        <param name="newExpression">
          <span data-ttu-id="f7da9-2049">Um <see cref="T:System.Linq.Expressions.NewExpression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2049">A <see cref="T:System.Linq.Expressions.NewExpression" /> to set the <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> property equal to.</span>
          </span>
        </param>
        <param name="initializers">
          <span data-ttu-id="f7da9-2050">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.ElementInit" /> a serem usados para preencher a coleção de <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2050">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.ElementInit" /> objects to use to populate the <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-2051">Cria um <see cref="T:System.Linq.Expressions.ListInitExpression" /> que usa objetos <see cref="T:System.Linq.Expressions.ElementInit" /> especificados para inicializar uma coleção.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2051">Creates a <see cref="T:System.Linq.Expressions.ListInitExpression" /> that uses specified <see cref="T:System.Linq.Expressions.ElementInit" /> objects to initialize a collection.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-2052">Um <see cref="T:System.Linq.Expressions.ListInitExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> e as propriedades <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> e <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2052">A <see cref="T:System.Linq.Expressions.ListInitExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> and the <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> and <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-2053">O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade de `newExpression` deve representar um tipo que implementa <xref:System.Collections.IEnumerable>.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2053">The <xref:System.Linq.Expressions.Expression.Type%2A> property of `newExpression` must represent a type that implements <xref:System.Collections.IEnumerable>.</span></span>  
  
 <span data-ttu-id="f7da9-2054">O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade resultantes <xref:System.Linq.Expressions.ListInitExpression> é igual a `newExpression`. Tipo.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2054">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.ListInitExpression> is equal to `newExpression`.Type.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f7da9-2055">O exemplo a seguir demonstra como usar o <xref:System.Linq.Expressions.Expression.ListInit%28System.Linq.Expressions.NewExpression%2CSystem.Linq.Expressions.ElementInit%5B%5D%29> método para criar um <xref:System.Linq.Expressions.ListInitExpression> que representa a inicialização de uma nova instância de dicionário com dois pares de chave-valor.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2055">The following example demonstrates how to use the <xref:System.Linq.Expressions.Expression.ListInit%28System.Linq.Expressions.NewExpression%2CSystem.Linq.Expressions.ElementInit%5B%5D%29> method to create a <xref:System.Linq.Expressions.ListInitExpression> that represents the initialization of a new dictionary instance with two key-value pairs.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.Expression#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#7)]
 [!code-vb[System.Linq.Expressions.Expression#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f7da9-2056">
            <paramref name="newExpression" /> ou <paramref name="initializers" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2056">
              <paramref name="newExpression" /> or <paramref name="initializers" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="f7da9-2057">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2057">-or-</span>
          </span>
          <span data-ttu-id="f7da9-2058">Um ou mais elementos de <paramref name="initializers" /> são <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2058">One or more elements of <paramref name="initializers" /> are <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f7da9-2059">
            <paramref name="newExpression" />.Type não implementa <see cref="T:System.Collections.IEnumerable" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2059">
              <paramref name="newExpression" />.Type does not implement <see cref="T:System.Collections.IEnumerable" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ListInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ListInitExpression ListInit (System.Linq.Expressions.NewExpression newExpression, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ListInitExpression ListInit(class System.Linq.Expressions.NewExpression newExpression, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ListInitExpression ^ ListInit(System::Linq::Expressions::NewExpression ^ newExpression, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ initializers);" />
      <MemberSignature Language="F#" Value="static member ListInit : System.Linq.Expressions.NewExpression * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.ListInitExpression" Usage="System.Linq.Expressions.Expression.ListInit (newExpression, initializers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ListInitExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newExpression" Type="System.Linq.Expressions.NewExpression" />
        <Parameter Name="initializers" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="newExpression">
          <span data-ttu-id="f7da9-2060">Um <see cref="T:System.Linq.Expressions.NewExpression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2060">A <see cref="T:System.Linq.Expressions.NewExpression" /> to set the <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> property equal to.</span>
          </span>
        </param>
        <param name="initializers">
          <span data-ttu-id="f7da9-2061">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.Expression" /> a serem usados para preencher a coleção de <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2061">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-2062">Cria um <see cref="T:System.Linq.Expressions.ListInitExpression" /> que usa um método chamado "Add" para adicionar elementos a uma coleção.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2062">Creates a <see cref="T:System.Linq.Expressions.ListInitExpression" /> that uses a method named "Add" to add elements to a collection.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-2063">Uma <see cref="T:System.Linq.Expressions.ListInitExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> e a propriedade <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> definida para o valor especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2063">A <see cref="T:System.Linq.Expressions.ListInitExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> and the <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> property set to the specified value.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-2064">O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade de `newExpression` deve representar um tipo que implementa <xref:System.Collections.IEnumerable>.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2064">The <xref:System.Linq.Expressions.Expression.Type%2A> property of `newExpression` must represent a type that implements <xref:System.Collections.IEnumerable>.</span></span>  
  
 <span data-ttu-id="f7da9-2065">Para usar essa sobrecarga de <xref:System.Linq.Expressions.Expression.ListInit%28System.Linq.Expressions.NewExpression%2CSystem.Collections.Generic.IEnumerable%7BSystem.Linq.Expressions.Expression%7D%29>, `newExpression`. Tipo ou seu tipo base deve declarar um único método nomeado "Add" (diferencia maiusculas de minúsculas) que aceita exatamente um argumento.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2065">In order to use this overload of <xref:System.Linq.Expressions.Expression.ListInit%28System.Linq.Expressions.NewExpression%2CSystem.Collections.Generic.IEnumerable%7BSystem.Linq.Expressions.Expression%7D%29>, `newExpression`.Type or its base type must declare a single method named "Add" (case insensitive) that takes exactly one argument.</span></span> <span data-ttu-id="f7da9-2066">O tipo do argumento deve ser atribuível do tipo representado pela <xref:System.Linq.Expressions.Expression.Type%2A> propriedade do primeiro elemento de `initializers`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2066">The type of the argument must be assignable from the type represented by the <xref:System.Linq.Expressions.Expression.Type%2A> property of the first element of `initializers`.</span></span>  
  
 <span data-ttu-id="f7da9-2067">O <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> propriedade retornada <xref:System.Linq.Expressions.ListInitExpression> contém um elemento do tipo <xref:System.Linq.Expressions.ElementInit> para cada elemento da `initializers`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2067">The <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> property of the returned <xref:System.Linq.Expressions.ListInitExpression> contains one element of type <xref:System.Linq.Expressions.ElementInit> for each element of `initializers`.</span></span> <span data-ttu-id="f7da9-2068">O <xref:System.Linq.Expressions.ElementInit.Arguments%2A> propriedade de cada elemento de <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> é uma coleção de singleton que contém o elemento correspondente de `initializers`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2068">The <xref:System.Linq.Expressions.ElementInit.Arguments%2A> property of each element of <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> is a singleton collection that contains the corresponding element of `initializers`.</span></span> <span data-ttu-id="f7da9-2069">O <xref:System.Linq.Expressions.ElementInit.AddMethod%2A> propriedade de cada elemento de <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> representa o método add que foi descoberto no `newExpression`. Tipo ou seu tipo base.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2069">The <xref:System.Linq.Expressions.ElementInit.AddMethod%2A> property of each element of <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> represents the add method that was discovered on `newExpression`.Type or its base type.</span></span>  
  
 <span data-ttu-id="f7da9-2070">O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade resultantes <xref:System.Linq.Expressions.ListInitExpression> é igual a `newExpression`. Tipo.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2070">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.ListInitExpression> is equal to `newExpression`.Type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f7da9-2071">
            <paramref name="newExpression" /> ou <paramref name="initializers" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2071">
              <paramref name="newExpression" /> or <paramref name="initializers" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="f7da9-2072">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2072">-or-</span>
          </span>
          <span data-ttu-id="f7da9-2073">Um ou mais elementos de <paramref name="initializers" /> são <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2073">One or more elements of <paramref name="initializers" /> are <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f7da9-2074">
            <paramref name="newExpression" />.Type não implementa <see cref="T:System.Collections.IEnumerable" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2074">
              <paramref name="newExpression" />.Type does not implement <see cref="T:System.Collections.IEnumerable" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f7da9-2075">Não há nenhum método de instância nomeado "Add" (não diferencia maiúsculas de minúsculas) declarado em <paramref name="newExpression" />.Type ou no tipo base dele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2075">There is no instance method named "Add" (case insensitive) declared in <paramref name="newExpression" />.Type or its base type.</span>
          </span>
          <span data-ttu-id="f7da9-2076">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2076">-or-</span>
          </span>
          <span data-ttu-id="f7da9-2077">O método add no <paramref name="newExpression" />.Type ou no tipo base dele não aceita exatamente um argumento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2077">The add method on <paramref name="newExpression" />.Type or its base type does not take exactly one argument.</span>
          </span>
          <span data-ttu-id="f7da9-2078">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2078">-or-</span>
          </span>
          <span data-ttu-id="f7da9-2079">O tipo representado pela propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> do primeiro elemento de <paramref name="initializers" /> não é atribuível ao tipo de argumento do método add em <paramref name="newExpression" />.Type ou no tipo base dele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2079">The type represented by the <see cref="P:System.Linq.Expressions.Expression.Type" /> property of the first element of <paramref name="initializers" /> is not assignable to the argument type of the add method on <paramref name="newExpression" />.Type or its base type.</span>
          </span>
          <span data-ttu-id="f7da9-2080">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2080">-or-</span>
          </span>
          <span data-ttu-id="f7da9-2081">Existe mais de um método compatível com o argumento nomeado "Add" (não diferencia maiúsculas de minúsculas) em <paramref name="newExpression" />.Type e/ou o tipo base dele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2081">More than one argument-compatible method named "Add" (case-insensitive) exists on <paramref name="newExpression" />.Type and/or its base type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ListInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ListInitExpression ListInit (System.Linq.Expressions.NewExpression newExpression, params System.Linq.Expressions.ElementInit[] initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ListInitExpression ListInit(class System.Linq.Expressions.NewExpression newExpression, class System.Linq.Expressions.ElementInit[] initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Linq.Expressions.ElementInit[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ListInitExpression ^ ListInit(System::Linq::Expressions::NewExpression ^ newExpression, ... cli::array &lt;System::Linq::Expressions::ElementInit ^&gt; ^ initializers);" />
      <MemberSignature Language="F#" Value="static member ListInit : System.Linq.Expressions.NewExpression * System.Linq.Expressions.ElementInit[] -&gt; System.Linq.Expressions.ListInitExpression" Usage="System.Linq.Expressions.Expression.ListInit (newExpression, initializers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ListInitExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newExpression" Type="System.Linq.Expressions.NewExpression" />
        <Parameter Name="initializers" Type="System.Linq.Expressions.ElementInit[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="newExpression">
          <span data-ttu-id="f7da9-2082">Um <see cref="T:System.Linq.Expressions.NewExpression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2082">A <see cref="T:System.Linq.Expressions.NewExpression" /> to set the <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> property equal to.</span>
          </span>
        </param>
        <param name="initializers">
          <span data-ttu-id="f7da9-2083">Uma matriz de objetos <see cref="T:System.Linq.Expressions.ElementInit" /> a serem usados para popular a coleção de <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2083">An array of <see cref="T:System.Linq.Expressions.ElementInit" /> objects to use to populate the <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-2084">Cria um <see cref="T:System.Linq.Expressions.ListInitExpression" /> que usa objetos <see cref="T:System.Linq.Expressions.ElementInit" /> especificados para inicializar uma coleção.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2084">Creates a <see cref="T:System.Linq.Expressions.ListInitExpression" /> that uses specified <see cref="T:System.Linq.Expressions.ElementInit" /> objects to initialize a collection.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-2085">Um <see cref="T:System.Linq.Expressions.ListInitExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> e as propriedades <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> e <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2085">A <see cref="T:System.Linq.Expressions.ListInitExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> and the <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> and <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-2086">O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade de `newExpression` deve representar um tipo que implementa <xref:System.Collections.IEnumerable>.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2086">The <xref:System.Linq.Expressions.Expression.Type%2A> property of `newExpression` must represent a type that implements <xref:System.Collections.IEnumerable>.</span></span>  
  
 <span data-ttu-id="f7da9-2087">O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade resultantes <xref:System.Linq.Expressions.ListInitExpression> é igual a `newExpression`. Tipo.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2087">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.ListInitExpression> is equal to `newExpression`.Type.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f7da9-2088">O exemplo a seguir demonstra como usar o <xref:System.Linq.Expressions.Expression.ListInit%28System.Linq.Expressions.NewExpression%2CSystem.Linq.Expressions.ElementInit%5B%5D%29> método para criar um <xref:System.Linq.Expressions.ListInitExpression> que representa a inicialização de uma nova instância de dicionário com dois pares de chave-valor.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2088">The following example demonstrates how to use the <xref:System.Linq.Expressions.Expression.ListInit%28System.Linq.Expressions.NewExpression%2CSystem.Linq.Expressions.ElementInit%5B%5D%29> method to create a <xref:System.Linq.Expressions.ListInitExpression> that represents the initialization of a new dictionary instance with two key-value pairs.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.Expression#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#7)]
 [!code-vb[System.Linq.Expressions.Expression#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f7da9-2089">
            <paramref name="newExpression" /> ou <paramref name="initializers" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2089">
              <paramref name="newExpression" /> or <paramref name="initializers" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="f7da9-2090">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2090">-or-</span>
          </span>
          <span data-ttu-id="f7da9-2091">Um ou mais elementos de <paramref name="initializers" /> são <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2091">One or more elements of <paramref name="initializers" /> are <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f7da9-2092">
            <paramref name="newExpression" />.Type não implementa <see cref="T:System.Collections.IEnumerable" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2092">
              <paramref name="newExpression" />.Type does not implement <see cref="T:System.Collections.IEnumerable" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ListInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ListInitExpression ListInit (System.Linq.Expressions.NewExpression newExpression, params System.Linq.Expressions.Expression[] initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ListInitExpression ListInit(class System.Linq.Expressions.NewExpression newExpression, class System.Linq.Expressions.Expression[] initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ListInitExpression ^ ListInit(System::Linq::Expressions::NewExpression ^ newExpression, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ initializers);" />
      <MemberSignature Language="F#" Value="static member ListInit : System.Linq.Expressions.NewExpression * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.ListInitExpression" Usage="System.Linq.Expressions.Expression.ListInit (newExpression, initializers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ListInitExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newExpression" Type="System.Linq.Expressions.NewExpression" />
        <Parameter Name="initializers" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="newExpression">
          <span data-ttu-id="f7da9-2093">Um <see cref="T:System.Linq.Expressions.NewExpression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2093">A <see cref="T:System.Linq.Expressions.NewExpression" /> to set the <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> property equal to.</span>
          </span>
        </param>
        <param name="initializers">
          <span data-ttu-id="f7da9-2094">Uma matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> a serem usados para popular a coleção de <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2094">An array of <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-2095">Cria um <see cref="T:System.Linq.Expressions.ListInitExpression" /> que usa um método chamado "Add" para adicionar elementos a uma coleção.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2095">Creates a <see cref="T:System.Linq.Expressions.ListInitExpression" /> that uses a method named "Add" to add elements to a collection.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-2096">Uma <see cref="T:System.Linq.Expressions.ListInitExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> e a propriedade <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> definida para o valor especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2096">A <see cref="T:System.Linq.Expressions.ListInitExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> and the <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> property set to the specified value.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-2097">O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade de `newExpression` deve representar um tipo que implementa <xref:System.Collections.IEnumerable>.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2097">The <xref:System.Linq.Expressions.Expression.Type%2A> property of `newExpression` must represent a type that implements <xref:System.Collections.IEnumerable>.</span></span>  
  
 <span data-ttu-id="f7da9-2098">Para usar essa sobrecarga de <xref:System.Linq.Expressions.Expression.ListInit%28System.Linq.Expressions.NewExpression%2CSystem.Linq.Expressions.Expression%5B%5D%29>, `newExpression`. Tipo ou seu tipo base deve declarar um único método nomeado "Add" (diferencia maiusculas de minúsculas) que aceita exatamente um argumento.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2098">In order to use this overload of <xref:System.Linq.Expressions.Expression.ListInit%28System.Linq.Expressions.NewExpression%2CSystem.Linq.Expressions.Expression%5B%5D%29>, `newExpression`.Type or its base type must declare a single method named "Add" (case insensitive) that takes exactly one argument.</span></span> <span data-ttu-id="f7da9-2099">O tipo do argumento deve ser atribuível do tipo representado pela <xref:System.Linq.Expressions.Expression.Type%2A> propriedade do primeiro elemento de `initializers`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2099">The type of the argument must be assignable from the type represented by the <xref:System.Linq.Expressions.Expression.Type%2A> property of the first element of `initializers`.</span></span>  
  
 <span data-ttu-id="f7da9-2100">O <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> propriedade retornada <xref:System.Linq.Expressions.ListInitExpression> contém um elemento do tipo <xref:System.Linq.Expressions.ElementInit> para cada elemento da `initializers`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2100">The <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> property of the returned <xref:System.Linq.Expressions.ListInitExpression> contains one element of type <xref:System.Linq.Expressions.ElementInit> for each element of `initializers`.</span></span> <span data-ttu-id="f7da9-2101">O <xref:System.Linq.Expressions.ElementInit.Arguments%2A> propriedade de cada elemento de <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> é uma coleção de singleton que contém o elemento correspondente de `initializers`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2101">The <xref:System.Linq.Expressions.ElementInit.Arguments%2A> property of each element of <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> is a singleton collection that contains the corresponding element of `initializers`.</span></span> <span data-ttu-id="f7da9-2102">O <xref:System.Linq.Expressions.ElementInit.AddMethod%2A> propriedade de cada elemento de <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> representa o método add que foi descoberto no `newExpression`. Tipo ou seu tipo base.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2102">The <xref:System.Linq.Expressions.ElementInit.AddMethod%2A> property of each element of <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> represents the add method that was discovered on `newExpression`.Type or its base type.</span></span>  
  
 <span data-ttu-id="f7da9-2103">O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade resultantes <xref:System.Linq.Expressions.ListInitExpression> é igual a `newExpression`. Tipo.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2103">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.ListInitExpression> is equal to `newExpression`.Type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f7da9-2104">
            <paramref name="newExpression" /> ou <paramref name="initializers" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2104">
              <paramref name="newExpression" /> or <paramref name="initializers" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="f7da9-2105">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2105">-or-</span>
          </span>
          <span data-ttu-id="f7da9-2106">Um ou mais elementos de <paramref name="initializers" /> são <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2106">One or more elements of <paramref name="initializers" /> are <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f7da9-2107">
            <paramref name="newExpression" />.Type não implementa <see cref="T:System.Collections.IEnumerable" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2107">
              <paramref name="newExpression" />.Type does not implement <see cref="T:System.Collections.IEnumerable" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f7da9-2108">Não há nenhum método de instância nomeado "Add" (não diferencia maiúsculas de minúsculas) declarado em <paramref name="newExpression" />.Type ou no tipo base dele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2108">There is no instance method named "Add" (case insensitive) declared in <paramref name="newExpression" />.Type or its base type.</span>
          </span>
          <span data-ttu-id="f7da9-2109">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2109">-or-</span>
          </span>
          <span data-ttu-id="f7da9-2110">O método add no <paramref name="newExpression" />.Type ou no tipo base dele não aceita exatamente um argumento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2110">The add method on <paramref name="newExpression" />.Type or its base type does not take exactly one argument.</span>
          </span>
          <span data-ttu-id="f7da9-2111">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2111">-or-</span>
          </span>
          <span data-ttu-id="f7da9-2112">O tipo representado pela propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> do primeiro elemento de <paramref name="initializers" /> não é atribuível ao tipo de argumento do método add em <paramref name="newExpression" />.Type ou no tipo base dele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2112">The type represented by the <see cref="P:System.Linq.Expressions.Expression.Type" /> property of the first element of <paramref name="initializers" /> is not assignable to the argument type of the add method on <paramref name="newExpression" />.Type or its base type.</span>
          </span>
          <span data-ttu-id="f7da9-2113">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2113">-or-</span>
          </span>
          <span data-ttu-id="f7da9-2114">Existe mais de um método compatível com o argumento nomeado "Add" (não diferencia maiúsculas de minúsculas) em <paramref name="newExpression" />.Type e/ou o tipo base dele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2114">More than one argument-compatible method named "Add" (case-insensitive) exists on <paramref name="newExpression" />.Type and/or its base type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ListInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ListInitExpression ListInit (System.Linq.Expressions.NewExpression newExpression, System.Reflection.MethodInfo addMethod, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ListInitExpression ListInit(class System.Linq.Expressions.NewExpression newExpression, class System.Reflection.MethodInfo addMethod, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ListInitExpression ^ ListInit(System::Linq::Expressions::NewExpression ^ newExpression, System::Reflection::MethodInfo ^ addMethod, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ initializers);" />
      <MemberSignature Language="F#" Value="static member ListInit : System.Linq.Expressions.NewExpression * System.Reflection.MethodInfo * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.ListInitExpression" Usage="System.Linq.Expressions.Expression.ListInit (newExpression, addMethod, initializers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ListInitExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newExpression" Type="System.Linq.Expressions.NewExpression" />
        <Parameter Name="addMethod" Type="System.Reflection.MethodInfo" />
        <Parameter Name="initializers" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="newExpression">
          <span data-ttu-id="f7da9-2115">Um <see cref="T:System.Linq.Expressions.NewExpression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2115">A <see cref="T:System.Linq.Expressions.NewExpression" /> to set the <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> property equal to.</span>
          </span>
        </param>
        <param name="addMethod">
          <span data-ttu-id="f7da9-2116">Um <see cref="T:System.Reflection.MethodInfo" /> que representa um método de instância nomeado "Add" (não diferencia maiúsculas de minúsculas), que adiciona um elemento a uma coleção.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2116">A <see cref="T:System.Reflection.MethodInfo" /> that represents an instance method named "Add" (case insensitive), that adds an element to a collection.</span>
          </span>
        </param>
        <param name="initializers">
          <span data-ttu-id="f7da9-2117">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.Expression" /> a serem usados para preencher a coleção de <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2117">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-2118">Cria um <see cref="T:System.Linq.Expressions.ListInitExpression" /> que usa um método especificado para adicionar elementos a uma coleção.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2118">Creates a <see cref="T:System.Linq.Expressions.ListInitExpression" /> that uses a specified method to add elements to a collection.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-2119">Uma <see cref="T:System.Linq.Expressions.ListInitExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> e a propriedade <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> definida para o valor especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2119">A <see cref="T:System.Linq.Expressions.ListInitExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> and the <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> property set to the specified value.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-2120">O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade de `newExpression` deve representar um tipo que implementa <xref:System.Collections.IEnumerable>.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2120">The <xref:System.Linq.Expressions.Expression.Type%2A> property of `newExpression` must represent a type that implements <xref:System.Collections.IEnumerable>.</span></span>  
  
 <span data-ttu-id="f7da9-2121">Se `addMethod` está `null`, `newExpression`. Tipo ou seu tipo base deve declarar um único método nomeado "Add" (diferencia maiusculas de minúsculas) que aceita exatamente um argumento.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2121">If `addMethod` is `null`, `newExpression`.Type or its base type must declare a single method named "Add" (case insensitive) that takes exactly one argument.</span></span> <span data-ttu-id="f7da9-2122">Se `addMethod` não é `null`, ele deve representar um método de instância nomeado "Add" (diferencia maiusculas de minúsculas) e que tenha exatamente um parâmetro.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2122">If `addMethod` is not `null`, it must represent an instance method named "Add" (case insensitive) that has exactly one parameter.</span></span> <span data-ttu-id="f7da9-2123">O tipo representado pela <xref:System.Linq.Expressions.Expression.Type%2A> propriedade de cada elemento da `initializers` deve ser atribuível ao tipo de argumento do método add.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2123">The type represented by the <xref:System.Linq.Expressions.Expression.Type%2A> property of each element of `initializers` must be assignable to the argument type of the add method.</span></span>  
  
 <span data-ttu-id="f7da9-2124">O <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> propriedade retornada <xref:System.Linq.Expressions.ListInitExpression> contém um elemento do tipo <xref:System.Linq.Expressions.ElementInit> para cada elemento da `initializers`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2124">The <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> property of the returned <xref:System.Linq.Expressions.ListInitExpression> contains one element of type <xref:System.Linq.Expressions.ElementInit> for each element of `initializers`.</span></span> <span data-ttu-id="f7da9-2125">O <xref:System.Linq.Expressions.ElementInit.Arguments%2A> propriedade de cada elemento de <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> é uma coleção de singleton que contém o elemento correspondente de `initializers`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2125">The <xref:System.Linq.Expressions.ElementInit.Arguments%2A> property of each element of <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> is a singleton collection that contains the corresponding element of `initializers`.</span></span> <span data-ttu-id="f7da9-2126">O <xref:System.Linq.Expressions.ElementInit.AddMethod%2A> propriedade de cada elemento de <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> é igual a `addMethod`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2126">The <xref:System.Linq.Expressions.ElementInit.AddMethod%2A> property of each element of <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> is equal to `addMethod`.</span></span>  
  
 <span data-ttu-id="f7da9-2127">O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade resultantes <xref:System.Linq.Expressions.ListInitExpression> é igual a `newExpression`. Tipo.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2127">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.ListInitExpression> is equal to `newExpression`.Type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f7da9-2128">
            <paramref name="newExpression" /> ou <paramref name="initializers" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2128">
              <paramref name="newExpression" /> or <paramref name="initializers" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="f7da9-2129">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2129">-or-</span>
          </span>
          <span data-ttu-id="f7da9-2130">Um ou mais elementos de <paramref name="initializers" /> são <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2130">One or more elements of <paramref name="initializers" /> are <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f7da9-2131">
            <paramref name="newExpression" />.Type não implementa <see cref="T:System.Collections.IEnumerable" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2131">
              <paramref name="newExpression" />.Type does not implement <see cref="T:System.Collections.IEnumerable" />.</span>
          </span>
          <span data-ttu-id="f7da9-2132">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2132">-or-</span>
          </span>
          <span data-ttu-id="f7da9-2133">
            <paramref name="addMethod" /> não é <see langword="null" /> e não representa um método de instância nomeado "Add" (não diferencia maiúsculas de minúsculas) que aceita exatamente um argumento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2133">
              <paramref name="addMethod" /> is not <see langword="null" /> and it does not represent an instance method named "Add" (case insensitive) that takes exactly one argument.</span>
          </span>
          <span data-ttu-id="f7da9-2134">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2134">-or-</span>
          </span>
          <span data-ttu-id="f7da9-2135">
            <paramref name="addMethod" /> não é <see langword="null" /> e o tipo representado pela propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> de um ou mais elementos de <paramref name="initializers" /> não pode ser atribuída ao tipo de argumento do método representado por <paramref name="addMethod" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2135">
              <paramref name="addMethod" /> is not <see langword="null" /> and the type represented by the <see cref="P:System.Linq.Expressions.Expression.Type" /> property of one or more elements of <paramref name="initializers" /> is not assignable to the argument type of the method that <paramref name="addMethod" /> represents.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f7da9-2136">
            <paramref name="addMethod" /> é <see langword="null" /> e nenhum método de instância nomeado "Add" que aceita um argumento de tipo compatível existe no <paramref name="newExpression" />.Type ou no tipo base dele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2136">
              <paramref name="addMethod" /> is <see langword="null" /> and no instance method named "Add" that takes one type-compatible argument exists on <paramref name="newExpression" />.Type or its base type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ListInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ListInitExpression ListInit (System.Linq.Expressions.NewExpression newExpression, System.Reflection.MethodInfo addMethod, params System.Linq.Expressions.Expression[] initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ListInitExpression ListInit(class System.Linq.Expressions.NewExpression newExpression, class System.Reflection.MethodInfo addMethod, class System.Linq.Expressions.Expression[] initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ListInitExpression ^ ListInit(System::Linq::Expressions::NewExpression ^ newExpression, System::Reflection::MethodInfo ^ addMethod, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ initializers);" />
      <MemberSignature Language="F#" Value="static member ListInit : System.Linq.Expressions.NewExpression * System.Reflection.MethodInfo * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.ListInitExpression" Usage="System.Linq.Expressions.Expression.ListInit (newExpression, addMethod, initializers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ListInitExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newExpression" Type="System.Linq.Expressions.NewExpression" />
        <Parameter Name="addMethod" Type="System.Reflection.MethodInfo" />
        <Parameter Name="initializers" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="newExpression">
          <span data-ttu-id="f7da9-2137">Um <see cref="T:System.Linq.Expressions.NewExpression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2137">A <see cref="T:System.Linq.Expressions.NewExpression" /> to set the <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> property equal to.</span>
          </span>
        </param>
        <param name="addMethod">
          <span data-ttu-id="f7da9-2138">Um <see cref="T:System.Reflection.MethodInfo" /> que representa um método de instância que aceita um argumento, que adiciona um elemento a uma coleção.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2138">A <see cref="T:System.Reflection.MethodInfo" /> that represents an instance method that takes one argument, that adds an element to a collection.</span>
          </span>
        </param>
        <param name="initializers">
          <span data-ttu-id="f7da9-2139">Uma matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> a serem usados para popular a coleção de <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2139">An array of <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-2140">Cria um <see cref="T:System.Linq.Expressions.ListInitExpression" /> que usa um método especificado para adicionar elementos a uma coleção.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2140">Creates a <see cref="T:System.Linq.Expressions.ListInitExpression" /> that uses a specified method to add elements to a collection.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-2141">Uma <see cref="T:System.Linq.Expressions.ListInitExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> e a propriedade <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> definida para o valor especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2141">A <see cref="T:System.Linq.Expressions.ListInitExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> and the <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> property set to the specified value.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-2142">O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade de `newExpression` deve representar um tipo que implementa <xref:System.Collections.IEnumerable>.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2142">The <xref:System.Linq.Expressions.Expression.Type%2A> property of `newExpression` must represent a type that implements <xref:System.Collections.IEnumerable>.</span></span>  
  
 <span data-ttu-id="f7da9-2143">Se `addMethod` está `null`, `newExpression`. Tipo ou seu tipo base deve declarar um único método nomeado "Add" (diferencia maiusculas de minúsculas) que aceita exatamente um argumento.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2143">If `addMethod` is `null`, `newExpression`.Type or its base type must declare a single method named "Add" (case insensitive) that takes exactly one argument.</span></span> <span data-ttu-id="f7da9-2144">Se `addMethod` não é `null`, ele deve representar um método de instância nomeado "Add" (diferencia maiusculas de minúsculas) e que tenha exatamente um parâmetro.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2144">If `addMethod` is not `null`, it must represent an instance method named "Add" (case insensitive) that has exactly one parameter.</span></span> <span data-ttu-id="f7da9-2145">O tipo representado pela <xref:System.Linq.Expressions.Expression.Type%2A> propriedade de cada elemento da `initializers` deve ser atribuível ao tipo de argumento do método add.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2145">The type represented by the <xref:System.Linq.Expressions.Expression.Type%2A> property of each element of `initializers` must be assignable to the argument type of the add method.</span></span>  
  
 <span data-ttu-id="f7da9-2146">O <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> propriedade retornada <xref:System.Linq.Expressions.ListInitExpression> contém um elemento do tipo <xref:System.Linq.Expressions.ElementInit> para cada elemento da `initializers`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2146">The <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> property of the returned <xref:System.Linq.Expressions.ListInitExpression> contains one element of type <xref:System.Linq.Expressions.ElementInit> for each element of `initializers`.</span></span> <span data-ttu-id="f7da9-2147">O <xref:System.Linq.Expressions.ElementInit.Arguments%2A> propriedade de cada elemento de <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> é uma coleção de singleton que contém o elemento correspondente de `initializers`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2147">The <xref:System.Linq.Expressions.ElementInit.Arguments%2A> property of each element of <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> is a singleton collection that contains the corresponding element of `initializers`.</span></span> <span data-ttu-id="f7da9-2148">O <xref:System.Linq.Expressions.ElementInit.AddMethod%2A> propriedade de cada elemento de <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> é igual a `addMethod`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2148">The <xref:System.Linq.Expressions.ElementInit.AddMethod%2A> property of each element of <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> is equal to `addMethod`.</span></span>  
  
 <span data-ttu-id="f7da9-2149">O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade resultantes <xref:System.Linq.Expressions.ListInitExpression> é igual a `newExpression`. Tipo.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2149">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.ListInitExpression> is equal to `newExpression`.Type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f7da9-2150">
            <paramref name="newExpression" /> ou <paramref name="initializers" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2150">
              <paramref name="newExpression" /> or <paramref name="initializers" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="f7da9-2151">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2151">-or-</span>
          </span>
          <span data-ttu-id="f7da9-2152">Um ou mais elementos de <paramref name="initializers" /> são <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2152">One or more elements of <paramref name="initializers" /> are <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f7da9-2153">
            <paramref name="newExpression" />.Type não implementa <see cref="T:System.Collections.IEnumerable" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2153">
              <paramref name="newExpression" />.Type does not implement <see cref="T:System.Collections.IEnumerable" />.</span>
          </span>
          <span data-ttu-id="f7da9-2154">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2154">-or-</span>
          </span>
          <span data-ttu-id="f7da9-2155">
            <paramref name="addMethod" /> não é <see langword="null" /> e não representa um método de instância nomeado "Add" (não diferencia maiúsculas de minúsculas) que aceita exatamente um argumento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2155">
              <paramref name="addMethod" /> is not <see langword="null" /> and it does not represent an instance method named "Add" (case insensitive) that takes exactly one argument.</span>
          </span>
          <span data-ttu-id="f7da9-2156">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2156">-or-</span>
          </span>
          <span data-ttu-id="f7da9-2157">
            <paramref name="addMethod" /> não é <see langword="null" /> e o tipo representado pela propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> de um ou mais elementos de <paramref name="initializers" /> não pode ser atribuída ao tipo de argumento do método representado por <paramref name="addMethod" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2157">
              <paramref name="addMethod" /> is not <see langword="null" /> and the type represented by the <see cref="P:System.Linq.Expressions.Expression.Type" /> property of one or more elements of <paramref name="initializers" /> is not assignable to the argument type of the method that <paramref name="addMethod" /> represents.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f7da9-2158">
            <paramref name="addMethod" /> é <see langword="null" /> e nenhum método de instância nomeado "Add" que aceita um argumento de tipo compatível existe no <paramref name="newExpression" />.Type ou no tipo base dele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2158">
              <paramref name="addMethod" /> is <see langword="null" /> and no instance method named "Add" that takes one type-compatible argument exists on <paramref name="newExpression" />.Type or its base type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Loop">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f7da9-2159">Cria um <see cref="T:System.Linq.Expressions.LoopExpression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2159">Creates a <see cref="T:System.Linq.Expressions.LoopExpression" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Loop">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LoopExpression Loop (System.Linq.Expressions.Expression body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LoopExpression Loop(class System.Linq.Expressions.Expression body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Loop(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Loop (body As Expression) As LoopExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LoopExpression ^ Loop(System::Linq::Expressions::Expression ^ body);" />
      <MemberSignature Language="F#" Value="static member Loop : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.LoopExpression" Usage="System.Linq.Expressions.Expression.Loop body" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LoopExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="body">
          <span data-ttu-id="f7da9-2160">O corpo do loop.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2160">The body of the loop.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-2161">Cria um <see cref="T:System.Linq.Expressions.LoopExpression" /> com o corpo fornecido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2161">Creates a <see cref="T:System.Linq.Expressions.LoopExpression" /> with the given body.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-2162">O <see cref="T:System.Linq.Expressions.LoopExpression" /> criado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2162">The created <see cref="T:System.Linq.Expressions.LoopExpression" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Loop">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LoopExpression Loop (System.Linq.Expressions.Expression body, System.Linq.Expressions.LabelTarget break);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LoopExpression Loop(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.LabelTarget break) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Loop(System.Linq.Expressions.Expression,System.Linq.Expressions.LabelTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Loop (body As Expression, break As LabelTarget) As LoopExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LoopExpression ^ Loop(System::Linq::Expressions::Expression ^ body, System::Linq::Expressions::LabelTarget ^ break);" />
      <MemberSignature Language="F#" Value="static member Loop : System.Linq.Expressions.Expression * System.Linq.Expressions.LabelTarget -&gt; System.Linq.Expressions.LoopExpression" Usage="System.Linq.Expressions.Expression.Loop (body, break)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LoopExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="break" Type="System.Linq.Expressions.LabelTarget" />
      </Parameters>
      <Docs>
        <param name="body">
          <span data-ttu-id="f7da9-2163">O corpo do loop.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2163">The body of the loop.</span>
          </span>
        </param>
        <param name="break">
          <span data-ttu-id="f7da9-2164">O destino de interrupção usado pelo corpo do loop.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2164">The break target used by the loop body.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-2165">Cria um <see cref="T:System.Linq.Expressions.LoopExpression" /> com o destino corpo e interrupção determinado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2165">Creates a <see cref="T:System.Linq.Expressions.LoopExpression" /> with the given body and break target.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-2166">O <see cref="T:System.Linq.Expressions.LoopExpression" /> criado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2166">The created <see cref="T:System.Linq.Expressions.LoopExpression" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="f7da9-2167">O exemplo a seguir demonstra como criar uma expressão de bloco que contém um <xref:System.Linq.Expressions.LoopExpression> objeto.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2167">The following example demonstrates how to create a block expression that contains a <xref:System.Linq.Expressions.LoopExpression> object.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#44](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#44)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#44](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#44)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Loop">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LoopExpression Loop (System.Linq.Expressions.Expression body, System.Linq.Expressions.LabelTarget break, System.Linq.Expressions.LabelTarget continue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LoopExpression Loop(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.LabelTarget break, class System.Linq.Expressions.LabelTarget continue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Loop(System.Linq.Expressions.Expression,System.Linq.Expressions.LabelTarget,System.Linq.Expressions.LabelTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Loop (body As Expression, break As LabelTarget, continue As LabelTarget) As LoopExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LoopExpression ^ Loop(System::Linq::Expressions::Expression ^ body, System::Linq::Expressions::LabelTarget ^ break, System::Linq::Expressions::LabelTarget ^ continue);" />
      <MemberSignature Language="F#" Value="static member Loop : System.Linq.Expressions.Expression * System.Linq.Expressions.LabelTarget * System.Linq.Expressions.LabelTarget -&gt; System.Linq.Expressions.LoopExpression" Usage="System.Linq.Expressions.Expression.Loop (body, break, continue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LoopExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="break" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="continue" Type="System.Linq.Expressions.LabelTarget" />
      </Parameters>
      <Docs>
        <param name="body">
          <span data-ttu-id="f7da9-2168">O corpo do loop.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2168">The body of the loop.</span>
          </span>
        </param>
        <param name="break">
          <span data-ttu-id="f7da9-2169">O destino de interrupção usado pelo corpo do loop.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2169">The break target used by the loop body.</span>
          </span>
        </param>
        <param name="continue">
          <span data-ttu-id="f7da9-2170">O destino continue usado pelo corpo do loop.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2170">The continue target used by the loop body.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-2171">Cria um <see cref="T:System.Linq.Expressions.LoopExpression" /> com o corpo fornecido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2171">Creates a <see cref="T:System.Linq.Expressions.LoopExpression" /> with the given body.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-2172">O <see cref="T:System.Linq.Expressions.LoopExpression" /> criado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2172">The created <see cref="T:System.Linq.Expressions.LoopExpression" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MakeBinary">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f7da9-2173">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> chamando o método de fábrica apropriado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2173">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> by calling the appropriate factory method.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MakeBinary">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MakeBinary (System.Linq.Expressions.ExpressionType binaryType, System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MakeBinary(valuetype System.Linq.Expressions.ExpressionType binaryType, class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeBinary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeBinary (binaryType As ExpressionType, left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MakeBinary(System::Linq::Expressions::ExpressionType binaryType, System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member MakeBinary : System.Linq.Expressions.ExpressionType * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.MakeBinary (binaryType, left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binaryType" Type="System.Linq.Expressions.ExpressionType" />
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="binaryType">
          <span data-ttu-id="f7da9-2174">O <see cref="T:System.Linq.Expressions.ExpressionType" /> que especifica o tipo de operação binária.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2174">The <see cref="T:System.Linq.Expressions.ExpressionType" /> that specifies the type of binary operation.</span>
          </span>
        </param>
        <param name="left">
          <span data-ttu-id="f7da9-2175">Um <see cref="T:System.Linq.Expressions.Expression" /> que representa o operando esquerdo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2175">An <see cref="T:System.Linq.Expressions.Expression" /> that represents the left operand.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="f7da9-2176">Um <see cref="T:System.Linq.Expressions.Expression" /> que representa o operando direito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2176">An <see cref="T:System.Linq.Expressions.Expression" /> that represents the right operand.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-2177">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" />, considerando os operandos esquerdos e direito, chamando um método de fábrica apropriado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2177">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" />, given the left and right operands, by calling an appropriate factory method.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-2178">O <see cref="T:System.Linq.Expressions.BinaryExpression" /> que resulta de chamar o método de fábrica apropriado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2178">The <see cref="T:System.Linq.Expressions.BinaryExpression" /> that results from calling the appropriate factory method.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-2179">O `binaryType` parâmetro determina quais <xref:System.Linq.Expressions.BinaryExpression> chama esse método de método de fábrica.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2179">The `binaryType` parameter determines which <xref:System.Linq.Expressions.BinaryExpression> factory method this method calls.</span></span> <span data-ttu-id="f7da9-2180">Por exemplo, se `binaryType` está <xref:System.Linq.Expressions.ExpressionType.Subtract>, este método invoca <xref:System.Linq.Expressions.Expression.Subtract%2A>.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2180">For example, if `binaryType` is <xref:System.Linq.Expressions.ExpressionType.Subtract>, this method invokes <xref:System.Linq.Expressions.Expression.Subtract%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f7da9-2181">O exemplo a seguir demonstra como usar o <xref:System.Linq.Expressions.Expression.MakeBinary%28System.Linq.Expressions.ExpressionType%2CSystem.Linq.Expressions.Expression%2CSystem.Linq.Expressions.Expression%29> método para criar um <xref:System.Linq.Expressions.BinaryExpression> que representa a subtração de um número de outro.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2181">The following example demonstrates how to use the <xref:System.Linq.Expressions.Expression.MakeBinary%28System.Linq.Expressions.ExpressionType%2CSystem.Linq.Expressions.Expression%2CSystem.Linq.Expressions.Expression%29> method to create a <xref:System.Linq.Expressions.BinaryExpression> that represents the subtraction of one number from another.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.Expression#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#8)]
 [!code-vb[System.Linq.Expressions.Expression#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f7da9-2182">
            <paramref name="binaryType" /> não corresponde a um nó de expressão binária.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2182">
              <paramref name="binaryType" /> does not correspond to a binary expression node.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f7da9-2183">
            <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2183">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="MakeBinary">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MakeBinary (System.Linq.Expressions.ExpressionType binaryType, System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, bool liftToNull, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MakeBinary(valuetype System.Linq.Expressions.ExpressionType binaryType, class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, bool liftToNull, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeBinary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeBinary (binaryType As ExpressionType, left As Expression, right As Expression, liftToNull As Boolean, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MakeBinary(System::Linq::Expressions::ExpressionType binaryType, System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, bool liftToNull, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member MakeBinary : System.Linq.Expressions.ExpressionType * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * bool * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.MakeBinary (binaryType, left, right, liftToNull, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binaryType" Type="System.Linq.Expressions.ExpressionType" />
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="liftToNull" Type="System.Boolean" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="binaryType">
          <span data-ttu-id="f7da9-2184">O <see cref="T:System.Linq.Expressions.ExpressionType" /> que especifica o tipo de operação binária.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2184">The <see cref="T:System.Linq.Expressions.ExpressionType" /> that specifies the type of binary operation.</span>
          </span>
        </param>
        <param name="left">
          <span data-ttu-id="f7da9-2185">Um <see cref="T:System.Linq.Expressions.Expression" /> que representa o operando esquerdo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2185">An <see cref="T:System.Linq.Expressions.Expression" /> that represents the left operand.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="f7da9-2186">Um <see cref="T:System.Linq.Expressions.Expression" /> que representa o operando direito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2186">An <see cref="T:System.Linq.Expressions.Expression" /> that represents the right operand.</span>
          </span>
        </param>
        <param name="liftToNull">
          <span data-ttu-id="f7da9-2187">
            <see langword="true" /> para definir <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> como <see langword="true" />; <see langword="false" /> para definir <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> como <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2187">
              <see langword="true" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="true" />; <see langword="false" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="false" />.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="f7da9-2188">Um <see cref="T:System.Reflection.MethodInfo" /> que especifica o método de implementação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2188">A <see cref="T:System.Reflection.MethodInfo" /> that specifies the implementing method.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-2189">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" />, dado o operando esquerdo, o operando direito e o método de implementação, chamando o método de fábrica apropriado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2189">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" />, given the left operand, right operand and implementing method, by calling the appropriate factory method.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-2190">O <see cref="T:System.Linq.Expressions.BinaryExpression" /> que resulta de chamar o método de fábrica apropriado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2190">The <see cref="T:System.Linq.Expressions.BinaryExpression" /> that results from calling the appropriate factory method.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-2191">O `binaryType` parâmetro determina quais <xref:System.Linq.Expressions.BinaryExpression> método de fábrica que esse método chamará.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2191">The `binaryType` parameter determines which <xref:System.Linq.Expressions.BinaryExpression> factory method this method will call.</span></span> <span data-ttu-id="f7da9-2192">Por exemplo, se `binaryType` está <xref:System.Linq.Expressions.ExpressionType.Subtract>, este método invoca <xref:System.Linq.Expressions.Expression.Subtract%2A>.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2192">For example, if `binaryType` is <xref:System.Linq.Expressions.ExpressionType.Subtract>, this method invokes <xref:System.Linq.Expressions.Expression.Subtract%2A>.</span></span> <span data-ttu-id="f7da9-2193">O `liftToNull` e `method` parâmetros serão ignorados se o método de fábrica apropriado não tem um parâmetro correspondente.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2193">The `liftToNull` and `method` parameters are ignored if the appropriate factory method does not have a corresponding parameter.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f7da9-2194">
            <paramref name="binaryType" /> não corresponde a um nó de expressão binária.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2194">
              <paramref name="binaryType" /> does not correspond to a binary expression node.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f7da9-2195">
            <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2195">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="MakeBinary">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MakeBinary (System.Linq.Expressions.ExpressionType binaryType, System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, bool liftToNull, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MakeBinary(valuetype System.Linq.Expressions.ExpressionType binaryType, class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, bool liftToNull, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeBinary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeBinary (binaryType As ExpressionType, left As Expression, right As Expression, liftToNull As Boolean, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MakeBinary(System::Linq::Expressions::ExpressionType binaryType, System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, bool liftToNull, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member MakeBinary : System.Linq.Expressions.ExpressionType * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * bool * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.MakeBinary (binaryType, left, right, liftToNull, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binaryType" Type="System.Linq.Expressions.ExpressionType" />
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="liftToNull" Type="System.Boolean" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="binaryType">
          <span data-ttu-id="f7da9-2196">O <see cref="T:System.Linq.Expressions.ExpressionType" /> que especifica o tipo de operação binária.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2196">The <see cref="T:System.Linq.Expressions.ExpressionType" /> that specifies the type of binary operation.</span>
          </span>
        </param>
        <param name="left">
          <span data-ttu-id="f7da9-2197">Um <see cref="T:System.Linq.Expressions.Expression" /> que representa o operando esquerdo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2197">An <see cref="T:System.Linq.Expressions.Expression" /> that represents the left operand.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="f7da9-2198">Um <see cref="T:System.Linq.Expressions.Expression" /> que representa o operando direito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2198">An <see cref="T:System.Linq.Expressions.Expression" /> that represents the right operand.</span>
          </span>
        </param>
        <param name="liftToNull">
          <span data-ttu-id="f7da9-2199">
            <see langword="true" /> para definir <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> como <see langword="true" />; <see langword="false" /> para definir <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> como <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2199">
              <see langword="true" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="true" />; <see langword="false" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="false" />.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="f7da9-2200">Um <see cref="T:System.Reflection.MethodInfo" /> que especifica o método de implementação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2200">A <see cref="T:System.Reflection.MethodInfo" /> that specifies the implementing method.</span>
          </span>
        </param>
        <param name="conversion">
          <span data-ttu-id="f7da9-2201">Um <see cref="T:System.Linq.Expressions.LambdaExpression" /> que representa uma função de conversão de tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2201">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> that represents a type conversion function.</span>
          </span>
          <span data-ttu-id="f7da9-2202">Esse parâmetro é usado somente se <paramref name="binaryType" /> é <see cref="F:System.Linq.Expressions.ExpressionType.Coalesce" /> ou uma atribuição composta.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2202">This parameter is used only if <paramref name="binaryType" /> is <see cref="F:System.Linq.Expressions.ExpressionType.Coalesce" /> or compound assignment..</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-2203">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" />, dado o operando esquerdo, o operando direito, o método de implementação e a função de conversão de tipo, chamando o método de fábrica apropriado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2203">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" />, given the left operand, right operand, implementing method and type conversion function, by calling the appropriate factory method.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-2204">O <see cref="T:System.Linq.Expressions.BinaryExpression" /> que resulta de chamar o método de fábrica apropriado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2204">The <see cref="T:System.Linq.Expressions.BinaryExpression" /> that results from calling the appropriate factory method.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-2205">O `binaryType` parâmetro determina quais <xref:System.Linq.Expressions.BinaryExpression> método de fábrica que esse método chamará.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2205">The `binaryType` parameter determines which <xref:System.Linq.Expressions.BinaryExpression> factory method this method will call.</span></span> <span data-ttu-id="f7da9-2206">Por exemplo, se `binaryType` está <xref:System.Linq.Expressions.ExpressionType.Subtract>, este método invoca <xref:System.Linq.Expressions.Expression.Subtract%2A>.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2206">For example, if `binaryType` is <xref:System.Linq.Expressions.ExpressionType.Subtract>, this method invokes <xref:System.Linq.Expressions.Expression.Subtract%2A>.</span></span> <span data-ttu-id="f7da9-2207">O `liftToNull`, `method` e `conversion` parâmetros serão ignorados se o método de fábrica apropriado não tem um parâmetro correspondente.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2207">The `liftToNull`, `method` and `conversion` parameters are ignored if the appropriate factory method does not have a corresponding parameter.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f7da9-2208">
            <paramref name="binaryType" /> não corresponde a um nó de expressão binária.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2208">
              <paramref name="binaryType" /> does not correspond to a binary expression node.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f7da9-2209">
            <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2209">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="MakeCatchBlock">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.CatchBlock MakeCatchBlock (Type type, System.Linq.Expressions.ParameterExpression variable, System.Linq.Expressions.Expression body, System.Linq.Expressions.Expression filter);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.CatchBlock MakeCatchBlock(class System.Type type, class System.Linq.Expressions.ParameterExpression variable, class System.Linq.Expressions.Expression body, class System.Linq.Expressions.Expression filter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeCatchBlock(System.Type,System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::CatchBlock ^ MakeCatchBlock(Type ^ type, System::Linq::Expressions::ParameterExpression ^ variable, System::Linq::Expressions::Expression ^ body, System::Linq::Expressions::Expression ^ filter);" />
      <MemberSignature Language="F#" Value="static member MakeCatchBlock : Type * System.Linq.Expressions.ParameterExpression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.CatchBlock" Usage="System.Linq.Expressions.Expression.MakeCatchBlock (type, variable, body, filter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.CatchBlock</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="variable" Type="System.Linq.Expressions.ParameterExpression" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="filter" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="type">
          <span data-ttu-id="f7da9-2210">O <see cref="P:System.Linq.Expressions.Expression.Type" /> de <see cref="T:System.Exception" /> que esse <see cref="T:System.Linq.Expressions.CatchBlock" /> tratará.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2210">The <see cref="P:System.Linq.Expressions.Expression.Type" /> of <see cref="T:System.Exception" /> this <see cref="T:System.Linq.Expressions.CatchBlock" /> will handle.</span>
          </span>
        </param>
        <param name="variable">
          <span data-ttu-id="f7da9-2211">Uma <see cref="T:System.Linq.Expressions.ParameterExpression" /> que representa uma referência para o objeto <see cref="T:System.Exception" /> capturado por este manipulador.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2211">A <see cref="T:System.Linq.Expressions.ParameterExpression" /> representing a reference to the <see cref="T:System.Exception" /> object caught by this handler.</span>
          </span>
        </param>
        <param name="body">
          <span data-ttu-id="f7da9-2212">O corpo da instrução catch.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2212">The body of the catch statement.</span>
          </span>
        </param>
        <param name="filter">
          <span data-ttu-id="f7da9-2213">O corpo do filtro <see cref="T:System.Exception" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2213">The body of the <see cref="T:System.Exception" /> filter.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-2214">Cria um <see cref="T:System.Linq.Expressions.CatchBlock" /> que representa uma instrução catch com os elementos especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2214">Creates a <see cref="T:System.Linq.Expressions.CatchBlock" /> representing a catch statement with the specified elements.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-2215">O <see cref="T:System.Linq.Expressions.CatchBlock" /> criado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2215">The created <see cref="T:System.Linq.Expressions.CatchBlock" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-2216">`type` deve ser não nulo e corresponder ao tipo de `variable` (se ele é fornecido).</span><span class="sxs-lookup"><span data-stu-id="f7da9-2216">`type` must be non-null and match the type of `variable` (if it is supplied).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MakeDynamic">
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f7da9-2217">Cria uma <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa uma operação dinâmica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2217">Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" /> that represents a dynamic operation.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MakeDynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression MakeDynamic (Type delegateType, System.Runtime.CompilerServices.CallSiteBinder binder, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression MakeDynamic(class System.Type delegateType, class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeDynamic (delegateType As Type, binder As CallSiteBinder, arguments As IEnumerable(Of Expression)) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ MakeDynamic(Type ^ delegateType, System::Runtime::CompilerServices::CallSiteBinder ^ binder, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member MakeDynamic : Type * System.Runtime.CompilerServices.CallSiteBinder * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.DynamicExpression" Usage="System.Linq.Expressions.Expression.MakeDynamic (delegateType, binder, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="delegateType">
          <span data-ttu-id="f7da9-2218">O tipo do delegado usado pelo <see cref="T:System.Runtime.CompilerServices.CallSite" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2218">The type of the delegate used by the <see cref="T:System.Runtime.CompilerServices.CallSite" />.</span>
          </span>
        </param>
        <param name="binder">
          <span data-ttu-id="f7da9-2219">O associador de tempo de execução para a operação dinâmica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2219">The runtime binder for the dynamic operation.</span>
          </span>
        </param>
        <param name="arguments">
          <span data-ttu-id="f7da9-2220">Os argumentos para a operação dinâmica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2220">The arguments to the dynamic operation.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-2221">Cria uma <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa uma operação dinâmica associada pelo <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fornecido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2221">Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" /> that represents a dynamic operation bound by the provided <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-2222">Um <see cref="T:System.Linq.Expressions.DynamicExpression" /> que tem <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> e <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> e <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> definidas para os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2222">A <see cref="T:System.Linq.Expressions.DynamicExpression" /> that has <see cref="P:System.Linq.Expressions.Expression.NodeType" /> equal to <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> and has the <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" />, and <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeDynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression MakeDynamic (Type delegateType, System.Runtime.CompilerServices.CallSiteBinder binder, System.Linq.Expressions.Expression arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression MakeDynamic(class System.Type delegateType, class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Linq.Expressions.Expression arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeDynamic (delegateType As Type, binder As CallSiteBinder, arg0 As Expression) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ MakeDynamic(Type ^ delegateType, System::Runtime::CompilerServices::CallSiteBinder ^ binder, System::Linq::Expressions::Expression ^ arg0);" />
      <MemberSignature Language="F#" Value="static member MakeDynamic : Type * System.Runtime.CompilerServices.CallSiteBinder * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.DynamicExpression" Usage="System.Linq.Expressions.Expression.MakeDynamic (delegateType, binder, arg0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="delegateType">
          <span data-ttu-id="f7da9-2223">O tipo do delegado usado pelo <see cref="T:System.Runtime.CompilerServices.CallSite" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2223">The type of the delegate used by the <see cref="T:System.Runtime.CompilerServices.CallSite" />.</span>
          </span>
        </param>
        <param name="binder">
          <span data-ttu-id="f7da9-2224">O associador de tempo de execução para a operação dinâmica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2224">The runtime binder for the dynamic operation.</span>
          </span>
        </param>
        <param name="arg0">
          <span data-ttu-id="f7da9-2225">O argumento para a operação dinâmica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2225">The argument to the dynamic operation.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-2226">Cria um <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa uma operação dinâmica associada pelo <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fornecido e um argumento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2226">Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" /> that represents a dynamic operation bound by the provided <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> and one argument.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-2227">Um <see cref="T:System.Linq.Expressions.DynamicExpression" /> que tem <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> e <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> e <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> definidas para os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2227">A <see cref="T:System.Linq.Expressions.DynamicExpression" /> that has <see cref="P:System.Linq.Expressions.Expression.NodeType" /> equal to <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> and has the <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" />, and <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeDynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression MakeDynamic (Type delegateType, System.Runtime.CompilerServices.CallSiteBinder binder, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression MakeDynamic(class System.Type delegateType, class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeDynamic (delegateType As Type, binder As CallSiteBinder, ParamArray arguments As Expression()) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ MakeDynamic(Type ^ delegateType, System::Runtime::CompilerServices::CallSiteBinder ^ binder, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member MakeDynamic : Type * System.Runtime.CompilerServices.CallSiteBinder * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.DynamicExpression" Usage="System.Linq.Expressions.Expression.MakeDynamic (delegateType, binder, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="delegateType">
          <span data-ttu-id="f7da9-2228">O tipo do delegado usado pelo <see cref="T:System.Runtime.CompilerServices.CallSite" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2228">The type of the delegate used by the <see cref="T:System.Runtime.CompilerServices.CallSite" />.</span>
          </span>
        </param>
        <param name="binder">
          <span data-ttu-id="f7da9-2229">O associador de tempo de execução para a operação dinâmica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2229">The runtime binder for the dynamic operation.</span>
          </span>
        </param>
        <param name="arguments">
          <span data-ttu-id="f7da9-2230">Os argumentos para a operação dinâmica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2230">The arguments to the dynamic operation.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-2231">Cria uma <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa uma operação dinâmica associada pelo <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fornecido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2231">Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" /> that represents a dynamic operation bound by the provided <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-2232">Um <see cref="T:System.Linq.Expressions.DynamicExpression" /> que tem <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> e <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> e <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> definidas para os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2232">A <see cref="T:System.Linq.Expressions.DynamicExpression" /> that has <see cref="P:System.Linq.Expressions.Expression.NodeType" /> equal to <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> and has the <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" />, and <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeDynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression MakeDynamic (Type delegateType, System.Runtime.CompilerServices.CallSiteBinder binder, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression MakeDynamic(class System.Type delegateType, class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeDynamic (delegateType As Type, binder As CallSiteBinder, arg0 As Expression, arg1 As Expression) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ MakeDynamic(Type ^ delegateType, System::Runtime::CompilerServices::CallSiteBinder ^ binder, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1);" />
      <MemberSignature Language="F#" Value="static member MakeDynamic : Type * System.Runtime.CompilerServices.CallSiteBinder * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.DynamicExpression" Usage="System.Linq.Expressions.Expression.MakeDynamic (delegateType, binder, arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="delegateType">
          <span data-ttu-id="f7da9-2233">O tipo do delegado usado pelo <see cref="T:System.Runtime.CompilerServices.CallSite" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2233">The type of the delegate used by the <see cref="T:System.Runtime.CompilerServices.CallSite" />.</span>
          </span>
        </param>
        <param name="binder">
          <span data-ttu-id="f7da9-2234">O associador de tempo de execução para a operação dinâmica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2234">The runtime binder for the dynamic operation.</span>
          </span>
        </param>
        <param name="arg0">
          <span data-ttu-id="f7da9-2235">O primeiro argumento para a operação dinâmica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2235">The first argument to the dynamic operation.</span>
          </span>
        </param>
        <param name="arg1">
          <span data-ttu-id="f7da9-2236">O segundo argumento para a operação dinâmica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2236">The second argument to the dynamic operation.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-2237">Cria um <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa uma operação dinâmica associada pelo <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fornecido e dois argumentos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2237">Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" /> that represents a dynamic operation bound by the provided <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> and two arguments.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-2238">Um <see cref="T:System.Linq.Expressions.DynamicExpression" /> que tem <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> e <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> e <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> definidas para os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2238">A <see cref="T:System.Linq.Expressions.DynamicExpression" /> that has <see cref="P:System.Linq.Expressions.Expression.NodeType" /> equal to <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> and has the <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" />, and <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeDynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression MakeDynamic (Type delegateType, System.Runtime.CompilerServices.CallSiteBinder binder, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression MakeDynamic(class System.Type delegateType, class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeDynamic (delegateType As Type, binder As CallSiteBinder, arg0 As Expression, arg1 As Expression, arg2 As Expression) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ MakeDynamic(Type ^ delegateType, System::Runtime::CompilerServices::CallSiteBinder ^ binder, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2);" />
      <MemberSignature Language="F#" Value="static member MakeDynamic : Type * System.Runtime.CompilerServices.CallSiteBinder * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.DynamicExpression" Usage="System.Linq.Expressions.Expression.MakeDynamic (delegateType, binder, arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="delegateType">
          <span data-ttu-id="f7da9-2239">O tipo do delegado usado pelo <see cref="T:System.Runtime.CompilerServices.CallSite" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2239">The type of the delegate used by the <see cref="T:System.Runtime.CompilerServices.CallSite" />.</span>
          </span>
        </param>
        <param name="binder">
          <span data-ttu-id="f7da9-2240">O associador de tempo de execução para a operação dinâmica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2240">The runtime binder for the dynamic operation.</span>
          </span>
        </param>
        <param name="arg0">
          <span data-ttu-id="f7da9-2241">O primeiro argumento para a operação dinâmica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2241">The first argument to the dynamic operation.</span>
          </span>
        </param>
        <param name="arg1">
          <span data-ttu-id="f7da9-2242">O segundo argumento para a operação dinâmica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2242">The second argument to the dynamic operation.</span>
          </span>
        </param>
        <param name="arg2">
          <span data-ttu-id="f7da9-2243">O terceiro argumento para a operação dinâmica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2243">The third argument to the dynamic operation.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-2244">Cria um <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa uma operação dinâmica associada pelo <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fornecido e três argumentos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2244">Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" /> that represents a dynamic operation bound by the provided <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> and three arguments.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-2245">Um <see cref="T:System.Linq.Expressions.DynamicExpression" /> que tem <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> e <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> e <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> definidas para os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2245">A <see cref="T:System.Linq.Expressions.DynamicExpression" /> that has <see cref="P:System.Linq.Expressions.Expression.NodeType" /> equal to <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> and has the <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" />, and <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeDynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression MakeDynamic (Type delegateType, System.Runtime.CompilerServices.CallSiteBinder binder, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2, System.Linq.Expressions.Expression arg3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression MakeDynamic(class System.Type delegateType, class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2, class System.Linq.Expressions.Expression arg3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeDynamic (delegateType As Type, binder As CallSiteBinder, arg0 As Expression, arg1 As Expression, arg2 As Expression, arg3 As Expression) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ MakeDynamic(Type ^ delegateType, System::Runtime::CompilerServices::CallSiteBinder ^ binder, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2, System::Linq::Expressions::Expression ^ arg3);" />
      <MemberSignature Language="F#" Value="static member MakeDynamic : Type * System.Runtime.CompilerServices.CallSiteBinder * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.DynamicExpression" Usage="System.Linq.Expressions.Expression.MakeDynamic (delegateType, binder, arg0, arg1, arg2, arg3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg3" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="delegateType">
          <span data-ttu-id="f7da9-2246">O tipo do delegado usado pelo <see cref="T:System.Runtime.CompilerServices.CallSite" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2246">The type of the delegate used by the <see cref="T:System.Runtime.CompilerServices.CallSite" />.</span>
          </span>
        </param>
        <param name="binder">
          <span data-ttu-id="f7da9-2247">O associador de tempo de execução para a operação dinâmica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2247">The runtime binder for the dynamic operation.</span>
          </span>
        </param>
        <param name="arg0">
          <span data-ttu-id="f7da9-2248">O primeiro argumento para a operação dinâmica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2248">The first argument to the dynamic operation.</span>
          </span>
        </param>
        <param name="arg1">
          <span data-ttu-id="f7da9-2249">O segundo argumento para a operação dinâmica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2249">The second argument to the dynamic operation.</span>
          </span>
        </param>
        <param name="arg2">
          <span data-ttu-id="f7da9-2250">O terceiro argumento para a operação dinâmica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2250">The third argument to the dynamic operation.</span>
          </span>
        </param>
        <param name="arg3">
          <span data-ttu-id="f7da9-2251">O quarto argumento para a operação dinâmica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2251">The fourth argument to the dynamic operation.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-2252">Cria um <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa uma operação dinâmica associada pelo <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fornecido e quatro argumentos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2252">Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" /> that represents a dynamic operation bound by the provided <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> and four arguments.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-2253">Um <see cref="T:System.Linq.Expressions.DynamicExpression" /> que tem <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> e <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> e <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> definidas para os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2253">A <see cref="T:System.Linq.Expressions.DynamicExpression" /> that has <see cref="P:System.Linq.Expressions.Expression.NodeType" /> equal to <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> and has the <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" />, and <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeGoto">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression MakeGoto (System.Linq.Expressions.GotoExpressionKind kind, System.Linq.Expressions.LabelTarget target, System.Linq.Expressions.Expression value, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression MakeGoto(valuetype System.Linq.Expressions.GotoExpressionKind kind, class System.Linq.Expressions.LabelTarget target, class System.Linq.Expressions.Expression value, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeGoto(System.Linq.Expressions.GotoExpressionKind,System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ MakeGoto(System::Linq::Expressions::GotoExpressionKind kind, System::Linq::Expressions::LabelTarget ^ target, System::Linq::Expressions::Expression ^ value, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member MakeGoto : System.Linq.Expressions.GotoExpressionKind * System.Linq.Expressions.LabelTarget * System.Linq.Expressions.Expression * Type -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.MakeGoto (kind, target, value, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="kind" Type="System.Linq.Expressions.GotoExpressionKind" />
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="kind">
          <span data-ttu-id="f7da9-2254">O <see cref="T:System.Linq.Expressions.GotoExpressionKind" /> do <see cref="T:System.Linq.Expressions.GotoExpression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2254">The <see cref="T:System.Linq.Expressions.GotoExpressionKind" /> of the <see cref="T:System.Linq.Expressions.GotoExpression" />.</span>
          </span>
        </param>
        <param name="target">
          <span data-ttu-id="f7da9-2255">O <see cref="T:System.Linq.Expressions.LabelTarget" /> para o qual o <see cref="T:System.Linq.Expressions.GotoExpression" /> irá.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2255">The <see cref="T:System.Linq.Expressions.LabelTarget" /> that the <see cref="T:System.Linq.Expressions.GotoExpression" /> will jump to.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="f7da9-2256">O valor que será passado para o rótulo associado ao saltar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2256">The value that will be passed to the associated label upon jumping.</span>
          </span>
        </param>
        <param name="type">
          <span data-ttu-id="f7da9-2257">Um <see cref="T:System.Type" /> para definir a propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2257">An <see cref="T:System.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-2258">Cria um <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa um link do <see cref="T:System.Linq.Expressions.GotoExpressionKind" /> especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2258">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a jump of the specified <see cref="T:System.Linq.Expressions.GotoExpressionKind" />.</span>
          </span>
          <span data-ttu-id="f7da9-2259">O valor passado para o rótulo ao saltar também pode ser especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2259">The value passed to the label upon jumping can also be specified.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-2260">Um <see cref="T:System.Linq.Expressions.GotoExpression" /> com <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a <paramref name="kind" />, a propriedade <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> definida para <paramref name="target" />, a propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> definida para <paramref name="type" /> e <paramref name="value" /> a ser passado para o rótulo de destino ao saltar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2260">A <see cref="T:System.Linq.Expressions.GotoExpression" /> with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> equal to <paramref name="kind" />, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> property set to <paramref name="target" />, the <see cref="P:System.Linq.Expressions.Expression.Type" /> property set to <paramref name="type" />, and <paramref name="value" /> to be passed to the target label upon jumping.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeIndex">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.IndexExpression MakeIndex (System.Linq.Expressions.Expression instance, System.Reflection.PropertyInfo indexer, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.IndexExpression MakeIndex(class System.Linq.Expressions.Expression instance, class System.Reflection.PropertyInfo indexer, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeIndex(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeIndex (instance As Expression, indexer As PropertyInfo, arguments As IEnumerable(Of Expression)) As IndexExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::IndexExpression ^ MakeIndex(System::Linq::Expressions::Expression ^ instance, System::Reflection::PropertyInfo ^ indexer, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member MakeIndex : System.Linq.Expressions.Expression * System.Reflection.PropertyInfo * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.IndexExpression" Usage="System.Linq.Expressions.Expression.MakeIndex (instance, indexer, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.IndexExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="indexer" Type="System.Reflection.PropertyInfo" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="instance">
          <span data-ttu-id="f7da9-2261">O objeto ao qual a propriedade pertence.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2261">The object to which the property belongs.</span>
          </span>
          <span data-ttu-id="f7da9-2262">Deve ser nulo se a propriedade for <see langword="static" /> (<see langword="shared" /> no Visual Basic).</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2262">It should be null if the property is <see langword="static" /> (<see langword="shared" /> in Visual Basic).</span>
          </span>
        </param>
        <param name="indexer">
          <span data-ttu-id="f7da9-2263">Um <see cref="T:System.Linq.Expressions.Expression" /> representando a propriedade a indexar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2263">An <see cref="T:System.Linq.Expressions.Expression" /> representing the property to index.</span>
          </span>
        </param>
        <param name="arguments">
          <span data-ttu-id="f7da9-2264">Um <c>IEnumerable&lt;Expression&gt;</c> (<c>IEnumerable (Of Expression)</c> no Visual Basic) que contém os argumentos que serão usados para indexar a propriedade.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2264">An <c>IEnumerable&lt;Expression&gt;</c> (<c>IEnumerable (Of Expression)</c> in Visual Basic) that contains the arguments that will be used to index the property.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-2265">Cria um <see cref="T:System.Linq.Expressions.IndexExpression" /> que representa o acesso a uma propriedade indexada em um objeto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2265">Creates an <see cref="T:System.Linq.Expressions.IndexExpression" /> that represents accessing an indexed property in an object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-2266">O <see cref="T:System.Linq.Expressions.IndexExpression" /> criado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2266">The created <see cref="T:System.Linq.Expressions.IndexExpression" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeMemberAccess">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression MakeMemberAccess (System.Linq.Expressions.Expression expression, System.Reflection.MemberInfo member);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression MakeMemberAccess(class System.Linq.Expressions.Expression expression, class System.Reflection.MemberInfo member) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeMemberAccess(System.Linq.Expressions.Expression,System.Reflection.MemberInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberExpression ^ MakeMemberAccess(System::Linq::Expressions::Expression ^ expression, System::Reflection::MemberInfo ^ member);" />
      <MemberSignature Language="F#" Value="static member MakeMemberAccess : System.Linq.Expressions.Expression * System.Reflection.MemberInfo -&gt; System.Linq.Expressions.MemberExpression" Usage="System.Linq.Expressions.Expression.MakeMemberAccess (expression, member)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="member" Type="System.Reflection.MemberInfo" />
      </Parameters>
      <Docs>
        <param name="expression">
          <span data-ttu-id="f7da9-2267">Um <see cref="T:System.Linq.Expressions.Expression" /> que representa o objeto ao qual o membro pertence.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2267">An <see cref="T:System.Linq.Expressions.Expression" /> that represents the object that the member belongs to.</span>
          </span>
          <span data-ttu-id="f7da9-2268">Isso pode ser nulo para membros estáticos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2268">This can be null for static members.</span>
          </span>
        </param>
        <param name="member">
          <span data-ttu-id="f7da9-2269">O <see cref="T:System.Reflection.MemberInfo" /> que descreve a propriedade ou o campo a ser acessado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2269">The <see cref="T:System.Reflection.MemberInfo" /> that describes the field or property to be accessed.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-2270">Cria um <see cref="T:System.Linq.Expressions.MemberExpression" /> que representa o acesso a um campo ou uma propriedade.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2270">Creates a <see cref="T:System.Linq.Expressions.MemberExpression" /> that represents accessing either a field or a property.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-2271">O <see cref="T:System.Linq.Expressions.MemberExpression" /> que resulta de chamar o método de fábrica apropriado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2271">The <see cref="T:System.Linq.Expressions.MemberExpression" /> that results from calling the appropriate factory method.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-2272">Esse método pode ser usado para criar uma <xref:System.Linq.Expressions.MemberExpression> que representa o acesso a um campo ou uma propriedade, dependendo do tipo de `member`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2272">This method can be used to create a <xref:System.Linq.Expressions.MemberExpression> that represents accessing either a field or a property, depending on the type of `member`.</span></span> <span data-ttu-id="f7da9-2273">Se `member` é do tipo <xref:System.Reflection.FieldInfo>, este método chama <xref:System.Linq.Expressions.Expression.Field%2A> para criar o <xref:System.Linq.Expressions.MemberExpression>.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2273">If `member` is of type <xref:System.Reflection.FieldInfo>, this method calls <xref:System.Linq.Expressions.Expression.Field%2A> to create the <xref:System.Linq.Expressions.MemberExpression>.</span></span> <span data-ttu-id="f7da9-2274">Se `member` é do tipo <xref:System.Reflection.PropertyInfo>, este método chama <xref:System.Linq.Expressions.Expression.Property%2A> para criar o <xref:System.Linq.Expressions.MemberExpression>.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2274">If `member` is of type <xref:System.Reflection.PropertyInfo>, this method calls <xref:System.Linq.Expressions.Expression.Property%2A> to create the <xref:System.Linq.Expressions.MemberExpression>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f7da9-2275">
            <paramref name="member" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2275">
              <paramref name="member" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f7da9-2276">
            <paramref name="member" /> não representa um campo ou propriedade.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2276">
              <paramref name="member" /> does not represent a field or property.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="MakeTry">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.TryExpression MakeTry (Type type, System.Linq.Expressions.Expression body, System.Linq.Expressions.Expression finally, System.Linq.Expressions.Expression fault, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.CatchBlock&gt; handlers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.TryExpression MakeTry(class System.Type type, class System.Linq.Expressions.Expression body, class System.Linq.Expressions.Expression finally, class System.Linq.Expressions.Expression fault, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.CatchBlock&gt; handlers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeTry(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.CatchBlock})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::TryExpression ^ MakeTry(Type ^ type, System::Linq::Expressions::Expression ^ body, System::Linq::Expressions::Expression ^ finally, System::Linq::Expressions::Expression ^ fault, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::CatchBlock ^&gt; ^ handlers);" />
      <MemberSignature Language="F#" Value="static member MakeTry : Type * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * seq&lt;System.Linq.Expressions.CatchBlock&gt; -&gt; System.Linq.Expressions.TryExpression" Usage="System.Linq.Expressions.Expression.MakeTry (type, body, finally, fault, handlers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.TryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="finally" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="fault" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="handlers" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.CatchBlock&gt;" />
      </Parameters>
      <Docs>
        <param name="type">
          <span data-ttu-id="f7da9-2277">O tipo de resultado da expressão try.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2277">The result type of the try expression.</span>
          </span>
          <span data-ttu-id="f7da9-2278">Se for null, o corpo e todos os manipuladores devem ter tipo idêntico.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2278">If null, bodh and all handlers must have identical type.</span>
          </span>
        </param>
        <param name="body">
          <span data-ttu-id="f7da9-2279">O corpo do bloco try.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2279">The body of the try block.</span>
          </span>
        </param>
        <param name="finally">
          <span data-ttu-id="f7da9-2280">O corpo do bloco finally.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2280">The body of the finally block.</span>
          </span>
          <span data-ttu-id="f7da9-2281">Passe null se o bloco try não tem bloco finally associado a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2281">Pass null if the try block has no finally block associated with it.</span>
          </span>
        </param>
        <param name="fault">
          <span data-ttu-id="f7da9-2282">O corpo do bloco de falha.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2282">The body of the fault block.</span>
          </span>
          <span data-ttu-id="f7da9-2283">Passe null se o bloco try não tem bloco fault associado a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2283">Pass null if the try block has no fault block associated with it.</span>
          </span>
        </param>
        <param name="handlers">
          <span data-ttu-id="f7da9-2284">Uma coleção de <see cref="T:System.Linq.Expressions.CatchBlock" />s representando as instruções catch a serem associados com o bloco try.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2284">A collection of <see cref="T:System.Linq.Expressions.CatchBlock" />s representing the catch statements to be associated with the try block.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-2285">Cria um <see cref="T:System.Linq.Expressions.TryExpression" /> que representa um bloco try com os elementos especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2285">Creates a <see cref="T:System.Linq.Expressions.TryExpression" /> representing a try block with the specified elements.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-2286">O <see cref="T:System.Linq.Expressions.TryExpression" /> criado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2286">The created <see cref="T:System.Linq.Expressions.TryExpression" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MakeUnary">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f7da9-2287">Cria uma <see cref="T:System.Linq.Expressions.UnaryExpression" /> chamando o método de fábrica apropriado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2287">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> by calling the appropriate factory method.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MakeUnary">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression MakeUnary (System.Linq.Expressions.ExpressionType unaryType, System.Linq.Expressions.Expression operand, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression MakeUnary(valuetype System.Linq.Expressions.ExpressionType unaryType, class System.Linq.Expressions.Expression operand, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeUnary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ MakeUnary(System::Linq::Expressions::ExpressionType unaryType, System::Linq::Expressions::Expression ^ operand, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member MakeUnary : System.Linq.Expressions.ExpressionType * System.Linq.Expressions.Expression * Type -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.MakeUnary (unaryType, operand, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="unaryType" Type="System.Linq.Expressions.ExpressionType" />
        <Parameter Name="operand" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="unaryType">
          <span data-ttu-id="f7da9-2288">O <see cref="T:System.Linq.Expressions.ExpressionType" /> que especifica o tipo de operação unária.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2288">The <see cref="T:System.Linq.Expressions.ExpressionType" /> that specifies the type of unary operation.</span>
          </span>
        </param>
        <param name="operand">
          <span data-ttu-id="f7da9-2289">Um <see cref="T:System.Linq.Expressions.Expression" /> que representa o operando.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2289">An <see cref="T:System.Linq.Expressions.Expression" /> that represents the operand.</span>
          </span>
        </param>
        <param name="type">
          <span data-ttu-id="f7da9-2290">O <see cref="T:System.Type" /> que especifica o tipo no qual converter (passe <see langword="null" /> se não for aplicável).</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2290">The <see cref="T:System.Type" /> that specifies the type to be converted to (pass <see langword="null" /> if not applicable).</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-2291">Dado um determinado operando, cria um <see cref="T:System.Linq.Expressions.UnaryExpression" /> chamando o método de fábrica apropriado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2291">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" />, given an operand, by calling the appropriate factory method.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-2292">O <see cref="T:System.Linq.Expressions.UnaryExpression" /> que resulta de chamar o método de fábrica apropriado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2292">The <see cref="T:System.Linq.Expressions.UnaryExpression" /> that results from calling the appropriate factory method.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-2293">O `unaryType` parâmetro determina quais <xref:System.Linq.Expressions.UnaryExpression> chama esse método de método de fábrica.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2293">The `unaryType` parameter determines which <xref:System.Linq.Expressions.UnaryExpression> factory method this method calls.</span></span> <span data-ttu-id="f7da9-2294">Por exemplo, se `unaryType` é igual a <xref:System.Linq.Expressions.ExpressionType.Convert>, este método invoca <xref:System.Linq.Expressions.Expression.Convert%2A>.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2294">For example, if `unaryType` is equal to <xref:System.Linq.Expressions.ExpressionType.Convert>, this method invokes <xref:System.Linq.Expressions.Expression.Convert%2A>.</span></span> <span data-ttu-id="f7da9-2295">O `type`parâmetro será ignorado se ele não se aplica ao método de fábrica que é chamado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2295">The `type`parameter is ignored if it does not apply to the factory method that is called.</span></span>  

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f7da9-2296">
            <paramref name="operand" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2296">
              <paramref name="operand" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f7da9-2297">
            <paramref name="unaryType" /> não corresponde a um nó de expressão unária.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2297">
              <paramref name="unaryType" /> does not correspond to a unary expression node.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="MakeUnary">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression MakeUnary (System.Linq.Expressions.ExpressionType unaryType, System.Linq.Expressions.Expression operand, Type type, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression MakeUnary(valuetype System.Linq.Expressions.ExpressionType unaryType, class System.Linq.Expressions.Expression operand, class System.Type type, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeUnary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Type,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ MakeUnary(System::Linq::Expressions::ExpressionType unaryType, System::Linq::Expressions::Expression ^ operand, Type ^ type, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member MakeUnary : System.Linq.Expressions.ExpressionType * System.Linq.Expressions.Expression * Type * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.MakeUnary (unaryType, operand, type, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="unaryType" Type="System.Linq.Expressions.ExpressionType" />
        <Parameter Name="operand" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="unaryType">
          <span data-ttu-id="f7da9-2298">O <see cref="T:System.Linq.Expressions.ExpressionType" /> que especifica o tipo de operação unária.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2298">The <see cref="T:System.Linq.Expressions.ExpressionType" /> that specifies the type of unary operation.</span>
          </span>
        </param>
        <param name="operand">
          <span data-ttu-id="f7da9-2299">Um <see cref="T:System.Linq.Expressions.Expression" /> que representa o operando.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2299">An <see cref="T:System.Linq.Expressions.Expression" /> that represents the operand.</span>
          </span>
        </param>
        <param name="type">
          <span data-ttu-id="f7da9-2300">O <see cref="T:System.Type" /> que especifica o tipo no qual converter (passe <see langword="null" /> se não for aplicável).</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2300">The <see cref="T:System.Type" /> that specifies the type to be converted to (pass <see langword="null" /> if not applicable).</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="f7da9-2301">O <see cref="T:System.Reflection.MethodInfo" /> que representa o método de implementação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2301">The <see cref="T:System.Reflection.MethodInfo" /> that represents the implementing method.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-2302">Cria um <see cref="T:System.Linq.Expressions.UnaryExpression" />, dado um operando e um método de implementação, chamando o método de fábrica apropriado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2302">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" />, given an operand and implementing method, by calling the appropriate factory method.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-2303">O <see cref="T:System.Linq.Expressions.UnaryExpression" /> que resulta de chamar o método de fábrica apropriado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2303">The <see cref="T:System.Linq.Expressions.UnaryExpression" /> that results from calling the appropriate factory method.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-2304">O `unaryType` parâmetro determina quais <xref:System.Linq.Expressions.UnaryExpression> chama esse método de método de fábrica.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2304">The `unaryType` parameter determines which <xref:System.Linq.Expressions.UnaryExpression> factory method this method calls.</span></span> <span data-ttu-id="f7da9-2305">Por exemplo, se `unaryType` é igual a <xref:System.Linq.Expressions.ExpressionType.Convert>, este método invoca <xref:System.Linq.Expressions.Expression.Convert%2A>.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2305">For example, if `unaryType` is equal to <xref:System.Linq.Expressions.ExpressionType.Convert>, this method invokes <xref:System.Linq.Expressions.Expression.Convert%2A>.</span></span> <span data-ttu-id="f7da9-2306">O `type` e `method` parâmetros serão ignorados se eles não se aplicam para o método de fábrica é chamado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2306">The `type` and `method` parameters are ignored if they do not apply to the factory method that is called.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f7da9-2307">
            <paramref name="operand" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2307">
              <paramref name="operand" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f7da9-2308">
            <paramref name="unaryType" /> não corresponde a um nó de expressão unária.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2308">
              <paramref name="unaryType" /> does not correspond to a unary expression node.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="MemberBind">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f7da9-2309">Cria uma <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> que representa a inicialização recursiva de membros de um membro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2309">Creates a <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> that represents the recursive initialization of members of a member.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MemberBind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberMemberBinding MemberBind (System.Reflection.MemberInfo member, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.MemberBinding&gt; bindings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberMemberBinding MemberBind(class System.Reflection.MemberInfo member, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.MemberBinding&gt; bindings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MemberInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MemberBind (member As MemberInfo, bindings As IEnumerable(Of MemberBinding)) As MemberMemberBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberMemberBinding ^ MemberBind(System::Reflection::MemberInfo ^ member, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::MemberBinding ^&gt; ^ bindings);" />
      <MemberSignature Language="F#" Value="static member MemberBind : System.Reflection.MemberInfo * seq&lt;System.Linq.Expressions.MemberBinding&gt; -&gt; System.Linq.Expressions.MemberMemberBinding" Usage="System.Linq.Expressions.Expression.MemberBind (member, bindings)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberMemberBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="member" Type="System.Reflection.MemberInfo" />
        <Parameter Name="bindings" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.MemberBinding&gt;" />
      </Parameters>
      <Docs>
        <param name="member">
          <span data-ttu-id="f7da9-2310">O <see cref="T:System.Reflection.MemberInfo" /> com um valor igual ao qual a <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> propriedade será definida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2310">The <see cref="T:System.Reflection.MemberInfo" /> to set the <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property equal to.</span>
          </span>
        </param>
        <param name="bindings">
          <span data-ttu-id="f7da9-2311">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.MemberBinding" /> a serem usados para preencher a coleção de <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2311">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.MemberBinding" /> objects to use to populate the <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-2312">Cria um <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> que representa a inicialização recursiva de membros de um campo ou propriedade.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2312">Creates a <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> that represents the recursive initialization of members of a field or property.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-2313">Um <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> que tem a propriedade <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> igual a <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" /> e as propriedades <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> e <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2313">A <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> that has the <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> property equal to <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" /> and the <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> and <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-2314">O `member` parâmetro deve representar um campo ou propriedade.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2314">The `member` parameter must represent a field or property.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f7da9-2315">
            <paramref name="member" /> ou <paramref name="bindings" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2315">
              <paramref name="member" /> or <paramref name="bindings" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f7da9-2316">
            <paramref name="member" /> não representa um campo ou propriedade.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2316">
              <paramref name="member" /> does not represent a field or property.</span>
          </span>
          <span data-ttu-id="f7da9-2317">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2317">-or-</span>
          </span>
          <span data-ttu-id="f7da9-2318">A propriedade <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> de um elemento de <paramref name="bindings" /> não representa um membro do tipo do campo ou propriedade representada por <paramref name="member" />.Type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2318">The <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property of an element of <paramref name="bindings" /> does not represent a member of the type of the field or property that <paramref name="member" /> represents.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="MemberBind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberMemberBinding MemberBind (System.Reflection.MemberInfo member, params System.Linq.Expressions.MemberBinding[] bindings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberMemberBinding MemberBind(class System.Reflection.MemberInfo member, class System.Linq.Expressions.MemberBinding[] bindings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MemberInfo,System.Linq.Expressions.MemberBinding[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MemberBind (member As MemberInfo, ParamArray bindings As MemberBinding()) As MemberMemberBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberMemberBinding ^ MemberBind(System::Reflection::MemberInfo ^ member, ... cli::array &lt;System::Linq::Expressions::MemberBinding ^&gt; ^ bindings);" />
      <MemberSignature Language="F#" Value="static member MemberBind : System.Reflection.MemberInfo * System.Linq.Expressions.MemberBinding[] -&gt; System.Linq.Expressions.MemberMemberBinding" Usage="System.Linq.Expressions.Expression.MemberBind (member, bindings)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberMemberBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="member" Type="System.Reflection.MemberInfo" />
        <Parameter Name="bindings" Type="System.Linq.Expressions.MemberBinding[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="member">
          <span data-ttu-id="f7da9-2319">O <see cref="T:System.Reflection.MemberInfo" /> com um valor igual ao qual a <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> propriedade será definida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2319">The <see cref="T:System.Reflection.MemberInfo" /> to set the <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property equal to.</span>
          </span>
        </param>
        <param name="bindings">
          <span data-ttu-id="f7da9-2320">Uma matriz de objetos <see cref="T:System.Linq.Expressions.MemberBinding" /> a serem usados para popular a coleção de <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2320">An array of <see cref="T:System.Linq.Expressions.MemberBinding" /> objects to use to populate the <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-2321">Cria um <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> que representa a inicialização recursiva de membros de um campo ou propriedade.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2321">Creates a <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> that represents the recursive initialization of members of a field or property.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-2322">Um <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> que tem a propriedade <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> igual a <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" /> e as propriedades <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> e <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2322">A <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> that has the <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> property equal to <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" /> and the <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> and <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-2323">O `member` parâmetro deve representar um campo ou propriedade.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2323">The `member` parameter must represent a field or property.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f7da9-2324">
            <paramref name="member" /> ou <paramref name="bindings" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2324">
              <paramref name="member" /> or <paramref name="bindings" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f7da9-2325">
            <paramref name="member" /> não representa um campo ou propriedade.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2325">
              <paramref name="member" /> does not represent a field or property.</span>
          </span>
          <span data-ttu-id="f7da9-2326">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2326">-or-</span>
          </span>
          <span data-ttu-id="f7da9-2327">A propriedade <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> de um elemento de <paramref name="bindings" /> não representa um membro do tipo do campo ou propriedade representada por <paramref name="member" />.Type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2327">The <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property of an element of <paramref name="bindings" /> does not represent a member of the type of the field or property that <paramref name="member" /> represents.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="MemberBind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberMemberBinding MemberBind (System.Reflection.MethodInfo propertyAccessor, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.MemberBinding&gt; bindings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberMemberBinding MemberBind(class System.Reflection.MethodInfo propertyAccessor, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.MemberBinding&gt; bindings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MemberBind (propertyAccessor As MethodInfo, bindings As IEnumerable(Of MemberBinding)) As MemberMemberBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberMemberBinding ^ MemberBind(System::Reflection::MethodInfo ^ propertyAccessor, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::MemberBinding ^&gt; ^ bindings);" />
      <MemberSignature Language="F#" Value="static member MemberBind : System.Reflection.MethodInfo * seq&lt;System.Linq.Expressions.MemberBinding&gt; -&gt; System.Linq.Expressions.MemberMemberBinding" Usage="System.Linq.Expressions.Expression.MemberBind (propertyAccessor, bindings)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberMemberBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyAccessor" Type="System.Reflection.MethodInfo" />
        <Parameter Name="bindings" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.MemberBinding&gt;" />
      </Parameters>
      <Docs>
        <param name="propertyAccessor">
          <span data-ttu-id="f7da9-2328">O <see cref="T:System.Reflection.MethodInfo" /> que representa um método de acessador de propriedade.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2328">The <see cref="T:System.Reflection.MethodInfo" /> that represents a property accessor method.</span>
          </span>
        </param>
        <param name="bindings">
          <span data-ttu-id="f7da9-2329">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.MemberBinding" /> a serem usados para preencher a coleção de <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2329">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.MemberBinding" /> objects to use to populate the <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-2330">Cria um <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> que representa a inicialização recursiva de membros de um membro que é acessado usando um método de acessador de propriedade.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2330">Creates a <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> that represents the recursive initialization of members of a member that is accessed by using a property accessor method.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-2331">Um <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> que tem a propriedade <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> igual a <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" />, a propriedade <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> definida para o <see cref="T:System.Reflection.PropertyInfo" /> que representa a propriedade acessada em <paramref name="propertyAccessor" /> e propriedades <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> definidas para os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2331">A <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> that has the <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> property equal to <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" />, the <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property set to the <see cref="T:System.Reflection.PropertyInfo" /> that represents the property accessed in <paramref name="propertyAccessor" />, and <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f7da9-2332">
            <paramref name="propertyAccessor" /> ou <paramref name="bindings" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2332">
              <paramref name="propertyAccessor" /> or <paramref name="bindings" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f7da9-2333">
            <paramref name="propertyAccessor" /> não representa um método de acessador de propriedade.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2333">
              <paramref name="propertyAccessor" /> does not represent a property accessor method.</span>
          </span>
          <span data-ttu-id="f7da9-2334">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2334">-or-</span>
          </span>
          <span data-ttu-id="f7da9-2335">A propriedade <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> de um elemento de <paramref name="bindings" /> não representa um membro do tipo da propriedade acessada pelo método representado por <paramref name="propertyAccessor" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2335">The <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property of an element of <paramref name="bindings" /> does not represent a member of the type of the property accessed by the method that <paramref name="propertyAccessor" /> represents.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="MemberBind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberMemberBinding MemberBind (System.Reflection.MethodInfo propertyAccessor, params System.Linq.Expressions.MemberBinding[] bindings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberMemberBinding MemberBind(class System.Reflection.MethodInfo propertyAccessor, class System.Linq.Expressions.MemberBinding[] bindings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MethodInfo,System.Linq.Expressions.MemberBinding[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MemberBind (propertyAccessor As MethodInfo, ParamArray bindings As MemberBinding()) As MemberMemberBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberMemberBinding ^ MemberBind(System::Reflection::MethodInfo ^ propertyAccessor, ... cli::array &lt;System::Linq::Expressions::MemberBinding ^&gt; ^ bindings);" />
      <MemberSignature Language="F#" Value="static member MemberBind : System.Reflection.MethodInfo * System.Linq.Expressions.MemberBinding[] -&gt; System.Linq.Expressions.MemberMemberBinding" Usage="System.Linq.Expressions.Expression.MemberBind (propertyAccessor, bindings)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberMemberBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyAccessor" Type="System.Reflection.MethodInfo" />
        <Parameter Name="bindings" Type="System.Linq.Expressions.MemberBinding[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="propertyAccessor">
          <span data-ttu-id="f7da9-2336">O <see cref="T:System.Reflection.MethodInfo" /> que representa um método de acessador de propriedade.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2336">The <see cref="T:System.Reflection.MethodInfo" /> that represents a property accessor method.</span>
          </span>
        </param>
        <param name="bindings">
          <span data-ttu-id="f7da9-2337">Uma matriz de objetos <see cref="T:System.Linq.Expressions.MemberBinding" /> a serem usados para popular a coleção de <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2337">An array of <see cref="T:System.Linq.Expressions.MemberBinding" /> objects to use to populate the <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-2338">Cria um <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> que representa a inicialização recursiva de membros de um membro que é acessado usando um método de acessador de propriedade.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2338">Creates a <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> that represents the recursive initialization of members of a member that is accessed by using a property accessor method.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-2339">Um <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> que tem a propriedade <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> igual a <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" />, a propriedade <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> definida para o <see cref="T:System.Reflection.PropertyInfo" /> que representa a propriedade acessada em <paramref name="propertyAccessor" /> e propriedades <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> definidas para os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2339">A <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> that has the <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> property equal to <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" />, the <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property set to the <see cref="T:System.Reflection.PropertyInfo" /> that represents the property accessed in <paramref name="propertyAccessor" />, and <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f7da9-2340">
            <paramref name="propertyAccessor" /> ou <paramref name="bindings" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2340">
              <paramref name="propertyAccessor" /> or <paramref name="bindings" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f7da9-2341">
            <paramref name="propertyAccessor" /> não representa um método de acessador de propriedade.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2341">
              <paramref name="propertyAccessor" /> does not represent a property accessor method.</span>
          </span>
          <span data-ttu-id="f7da9-2342">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2342">-or-</span>
          </span>
          <span data-ttu-id="f7da9-2343">A propriedade <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> de um elemento de <paramref name="bindings" /> não representa um membro do tipo da propriedade acessada pelo método representado por <paramref name="propertyAccessor" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2343">The <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property of an element of <paramref name="bindings" /> does not represent a member of the type of the property accessed by the method that <paramref name="propertyAccessor" /> represents.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="MemberInit">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f7da9-2344">Representa uma expressão que cria um novo objeto e inicializa uma propriedade do objeto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2344">Represents an expression that creates a new object and initializes a property of the object.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MemberInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberInitExpression MemberInit (System.Linq.Expressions.NewExpression newExpression, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.MemberBinding&gt; bindings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberInitExpression MemberInit(class System.Linq.Expressions.NewExpression newExpression, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.MemberBinding&gt; bindings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MemberInit(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberInitExpression ^ MemberInit(System::Linq::Expressions::NewExpression ^ newExpression, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::MemberBinding ^&gt; ^ bindings);" />
      <MemberSignature Language="F#" Value="static member MemberInit : System.Linq.Expressions.NewExpression * seq&lt;System.Linq.Expressions.MemberBinding&gt; -&gt; System.Linq.Expressions.MemberInitExpression" Usage="System.Linq.Expressions.Expression.MemberInit (newExpression, bindings)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberInitExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newExpression" Type="System.Linq.Expressions.NewExpression" />
        <Parameter Name="bindings" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.MemberBinding&gt;" />
      </Parameters>
      <Docs>
        <param name="newExpression">
          <span data-ttu-id="f7da9-2345">Um <see cref="T:System.Linq.Expressions.NewExpression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2345">A <see cref="T:System.Linq.Expressions.NewExpression" /> to set the <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> property equal to.</span>
          </span>
        </param>
        <param name="bindings">
          <span data-ttu-id="f7da9-2346">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.MemberBinding" /> a serem usados para preencher a coleção de <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2346">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.MemberBinding" /> objects to use to populate the <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-2347">Representa uma expressão que cria um novo objeto e inicializa uma propriedade do objeto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2347">Represents an expression that creates a new object and initializes a property of the object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-2348">Um <see cref="T:System.Linq.Expressions.MemberInitExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.MemberInit" /> e as propriedades <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> e <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2348">A <see cref="T:System.Linq.Expressions.MemberInitExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MemberInit" /> and the <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> and <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-2349">O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade resultantes <xref:System.Linq.Expressions.MemberInitExpression> é igual ao <xref:System.Linq.Expressions.Expression.Type%2A> propriedade `newExpression`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2349">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.MemberInitExpression> is equal to the <xref:System.Linq.Expressions.Expression.Type%2A> property of `newExpression`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f7da9-2350">O exemplo a seguir demonstra uma expressão que cria um novo objeto e inicializa uma propriedade do objeto.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2350">The following example demonstrates an expression that creates a new object and initializes a property of the object.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#40](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#40)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#40](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#40)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f7da9-2351">
            <paramref name="newExpression" /> ou <paramref name="bindings" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2351">
              <paramref name="newExpression" /> or <paramref name="bindings" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f7da9-2352">A propriedade <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> de um elemento de <paramref name="bindings" /> não representa um membro do tipo representado por <paramref name="newExpression" />.Type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2352">The <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property of an element of <paramref name="bindings" /> does not represent a member of the type that <paramref name="newExpression" />.Type represents.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="MemberInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberInitExpression MemberInit (System.Linq.Expressions.NewExpression newExpression, params System.Linq.Expressions.MemberBinding[] bindings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberInitExpression MemberInit(class System.Linq.Expressions.NewExpression newExpression, class System.Linq.Expressions.MemberBinding[] bindings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MemberInit(System.Linq.Expressions.NewExpression,System.Linq.Expressions.MemberBinding[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberInitExpression ^ MemberInit(System::Linq::Expressions::NewExpression ^ newExpression, ... cli::array &lt;System::Linq::Expressions::MemberBinding ^&gt; ^ bindings);" />
      <MemberSignature Language="F#" Value="static member MemberInit : System.Linq.Expressions.NewExpression * System.Linq.Expressions.MemberBinding[] -&gt; System.Linq.Expressions.MemberInitExpression" Usage="System.Linq.Expressions.Expression.MemberInit (newExpression, bindings)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberInitExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newExpression" Type="System.Linq.Expressions.NewExpression" />
        <Parameter Name="bindings" Type="System.Linq.Expressions.MemberBinding[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="newExpression">
          <span data-ttu-id="f7da9-2353">Um <see cref="T:System.Linq.Expressions.NewExpression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2353">A <see cref="T:System.Linq.Expressions.NewExpression" /> to set the <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> property equal to.</span>
          </span>
        </param>
        <param name="bindings">
          <span data-ttu-id="f7da9-2354">Uma matriz de objetos <see cref="T:System.Linq.Expressions.MemberBinding" /> a serem usados para popular a coleção de <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2354">An array of <see cref="T:System.Linq.Expressions.MemberBinding" /> objects to use to populate the <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-2355">Cria um <see cref="T:System.Linq.Expressions.MemberInitExpression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2355">Creates a <see cref="T:System.Linq.Expressions.MemberInitExpression" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-2356">Um <see cref="T:System.Linq.Expressions.MemberInitExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.MemberInit" /> e as propriedades <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> e <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2356">A <see cref="T:System.Linq.Expressions.MemberInitExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MemberInit" /> and the <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> and <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-2357">O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade resultantes <xref:System.Linq.Expressions.MemberInitExpression> é igual ao <xref:System.Linq.Expressions.Expression.Type%2A> propriedade `newExpression`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2357">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.MemberInitExpression> is equal to the <xref:System.Linq.Expressions.Expression.Type%2A> property of `newExpression`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f7da9-2358">O exemplo a seguir demonstra como usar o <xref:System.Linq.Expressions.Expression.MemberInit%28System.Linq.Expressions.NewExpression%2CSystem.Linq.Expressions.MemberBinding%5B%5D%29> método para criar um <xref:System.Linq.Expressions.MemberInitExpression> que representa a inicialização de dois membros de um novo objeto.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2358">The following example demonstrates how to use the <xref:System.Linq.Expressions.Expression.MemberInit%28System.Linq.Expressions.NewExpression%2CSystem.Linq.Expressions.MemberBinding%5B%5D%29> method to create a <xref:System.Linq.Expressions.MemberInitExpression> that represents the initialization of two members of a new object.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.Expression#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#9)]
 [!code-vb[System.Linq.Expressions.Expression#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f7da9-2359">
            <paramref name="newExpression" /> ou <paramref name="bindings" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2359">
              <paramref name="newExpression" /> or <paramref name="bindings" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f7da9-2360">A propriedade <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> de um elemento de <paramref name="bindings" /> não representa um membro do tipo representado por <paramref name="newExpression" />.Type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2360">The <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property of an element of <paramref name="bindings" /> does not represent a member of the type that <paramref name="newExpression" />.Type represents.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Modulo">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f7da9-2361">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação restante aritmética.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2361">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic remainder operation.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Modulo">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Modulo (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Modulo(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Modulo(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Modulo (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Modulo(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member Modulo : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Modulo (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="f7da9-2362">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2362">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="f7da9-2363">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2363">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-2364">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação restante aritmética.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2364">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic remainder operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-2365">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Modulo" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2365">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Modulo" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-2366">Resultante <xref:System.Linq.Expressions.BinaryExpression> tem o <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriedade definida como o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2366">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="f7da9-2367">O <xref:System.Linq.Expressions.Expression.Type%2A> estiver definida como o tipo de nó.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2367">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="f7da9-2368">Se o nó é elevado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> e <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriedades estiverem `true`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2368">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="f7da9-2369">Caso contrário, eles são `false`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2369">Otherwise, they are `false`.</span></span> <span data-ttu-id="f7da9-2370">A propriedade <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> é `null`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2370">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="f7da9-2371">As informações a seguir descrevem o método de implementação, o tipo de nó, e se um nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2371">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="f7da9-2372">Implementando método</span><span class="sxs-lookup"><span data-stu-id="f7da9-2372">Implementing Method</span></span>  
 <span data-ttu-id="f7da9-2373">As seguintes regras de determinam o método de implementação selecionado para a operação:</span><span class="sxs-lookup"><span data-stu-id="f7da9-2373">The following rules determine the selected implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="f7da9-2374">Se o <xref:System.Linq.Expressions.Expression.Type%2A> propriedade deles `left` ou `right` representa um tipo definido pelo usuário que sobrecarrega o operador de módulo, o <xref:System.Reflection.MethodInfo> que representa que o método é o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2374">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the modulus operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="f7da9-2375">Caso contrário, se `left`. Tipo e `right`. Tipo de tipos numéricos, o método de implementação está `null`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2375">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="f7da9-2376">Tipo de nó e versão com comparação de precisão x sem comparação de precisão</span><span class="sxs-lookup"><span data-stu-id="f7da9-2376">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="f7da9-2377">Se o método de implementação não for `null`:</span><span class="sxs-lookup"><span data-stu-id="f7da9-2377">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="f7da9-2378">Se `left`. Tipo e `right`. Tipo podem ser atribuídos aos tipos de argumento correspondente do método de implementação, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2378">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="f7da9-2379">O tipo do nó é o tipo de retorno do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2379">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="f7da9-2380">Se as duas seguintes condições forem atendidas, o nó é levantado e o tipo de nó é o tipo que permite valor nulo que corresponde ao tipo de retorno do método de implementação:</span><span class="sxs-lookup"><span data-stu-id="f7da9-2380">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="f7da9-2381">`left`. Tipo e `right`. Tipo são os dois tipos de valor de que pelo menos um é anulável e os tipos não anuláveis correspondentes são iguais para os tipos de argumento correspondente do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2381">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="f7da9-2382">O tipo de retorno do método de implementação é um tipo de valor não anulável.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2382">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="f7da9-2383">Se o método de implementação é `null`:</span><span class="sxs-lookup"><span data-stu-id="f7da9-2383">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="f7da9-2384">Se `left`. Tipo e `right`. Tipo são não anuláveis, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2384">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="f7da9-2385">O tipo do nó é o tipo de resultado do operador de módulo predefinido.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2385">The type of the node is the result type of the predefined modulus operator.</span></span>  
  
-   <span data-ttu-id="f7da9-2386">Se `left`. Tipo e `right`. Tipo são anuláveis, o nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2386">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="f7da9-2387">O tipo de nó é o tipo que permite valor nulo que corresponde ao tipo de resultado do operador de módulo predefinido.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2387">The type of the node is the nullable type that corresponds to the result type of the predefined modulus operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f7da9-2388">
            <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2388">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f7da9-2389">O operador modulus não está definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2389">The modulus operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Modulo">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Modulo (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Modulo(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Modulo(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Modulo (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Modulo(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member Modulo : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Modulo (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="f7da9-2390">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2390">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="f7da9-2391">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2391">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="f7da9-2392">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2392">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-2393">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação restante aritmética.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2393">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic remainder operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-2394">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Modulo" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2394">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Modulo" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-2395">Resultante <xref:System.Linq.Expressions.BinaryExpression> tem o <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriedade definida como o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2395">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="f7da9-2396">O <xref:System.Linq.Expressions.Expression.Type%2A> estiver definida como o tipo de nó.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2396">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="f7da9-2397">Se o nó é elevado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> e <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriedades estiverem `true`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2397">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="f7da9-2398">Caso contrário, eles são `false`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2398">Otherwise, they are `false`.</span></span> <span data-ttu-id="f7da9-2399">A propriedade <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> é `null`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2399">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="f7da9-2400">As informações a seguir descrevem o método de implementação, o tipo de nó, e se um nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2400">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="f7da9-2401">Implementando método</span><span class="sxs-lookup"><span data-stu-id="f7da9-2401">Implementing Method</span></span>  
 <span data-ttu-id="f7da9-2402">O método de implementação para a operação é escolhido com base nas seguintes regras:</span><span class="sxs-lookup"><span data-stu-id="f7da9-2402">The implementing method for the operation is chosen based on the following rules:</span></span>  
  
-   <span data-ttu-id="f7da9-2403">Se `method` não é `null` e representa um não-nulo, `static` (`Shared` no Visual Basic) método que usa dois argumentos, é o método de implementação para o nó.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2403">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method for the node.</span></span>  
  
-   <span data-ttu-id="f7da9-2404">Caso contrário, se o <xref:System.Linq.Expressions.Expression.Type%2A> propriedade deles `left` ou `right` representa um tipo definido pelo usuário que sobrecarrega o operador de módulo, o <xref:System.Reflection.MethodInfo> que representa que o método é o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2404">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the modulus operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="f7da9-2405">Caso contrário, se `left`. Tipo e `right`. Tipo de tipos numéricos, o método de implementação está `null`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2405">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="f7da9-2406">Tipo de nó e versão com comparação de precisão x sem comparação de precisão</span><span class="sxs-lookup"><span data-stu-id="f7da9-2406">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="f7da9-2407">Se o método de implementação não for `null`:</span><span class="sxs-lookup"><span data-stu-id="f7da9-2407">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="f7da9-2408">Se `left`. Tipo e `right`. Tipo podem ser atribuídos aos tipos de argumento correspondente do método de implementação, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2408">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="f7da9-2409">O tipo do nó é o tipo de retorno do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2409">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="f7da9-2410">Se as duas seguintes condições forem atendidas, o nó é levantado e o tipo de nó é o tipo que permite valor nulo que corresponde ao tipo de retorno do método de implementação:</span><span class="sxs-lookup"><span data-stu-id="f7da9-2410">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="f7da9-2411">`left`. Tipo e `right`. Tipo são os dois tipos de valor de que pelo menos um é anulável e os tipos não anuláveis correspondentes são iguais para os tipos de argumento correspondente do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2411">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="f7da9-2412">O tipo de retorno do método de implementação é um tipo de valor não anulável.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2412">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="f7da9-2413">Se o método de implementação é `null`:</span><span class="sxs-lookup"><span data-stu-id="f7da9-2413">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="f7da9-2414">Se `left`. Tipo e `right`. Tipo são não anuláveis, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2414">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="f7da9-2415">O tipo do nó é o tipo de resultado do operador de módulo predefinido.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2415">The type of the node is the result type of the predefined modulus operator.</span></span>  
  
-   <span data-ttu-id="f7da9-2416">Se `left`. Tipo e `right`. Tipo são anuláveis, o nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2416">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="f7da9-2417">O tipo de nó é o tipo que permite valor nulo que corresponde ao tipo de resultado do operador de módulo predefinido.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2417">The type of the node is the nullable type that corresponds to the result type of the predefined modulus operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f7da9-2418">
            <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2418">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f7da9-2419">
            <paramref name="method" /> não é <see langword="null" /> e o método que ele representa retorna <see langword="void" />, não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) ou não tem exatamente dois argumentos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2419">
              <paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f7da9-2420">
            <paramref name="method" /> é <see langword="null" /> e operador de módulo não foi definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2420">
              <paramref name="method" /> is <see langword="null" /> and the modulus operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ModuloAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f7da9-2421">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição pendente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2421">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a remainder assignment operation.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ModuloAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ModuloAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ModuloAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ModuloAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ModuloAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ModuloAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member ModuloAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.ModuloAssign (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="f7da9-2422">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2422">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="f7da9-2423">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2423">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-2424">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição pendente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2424">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a remainder assignment operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-2425">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.ModuloAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2425">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ModuloAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ModuloAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ModuloAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ModuloAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ModuloAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ModuloAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ModuloAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member ModuloAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.ModuloAssign (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="f7da9-2426">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2426">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="f7da9-2427">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2427">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="f7da9-2428">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2428">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-2429">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição pendente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2429">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a remainder assignment operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-2430">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.ModuloAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2430">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ModuloAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ModuloAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ModuloAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ModuloAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ModuloAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ModuloAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ModuloAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member ModuloAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.ModuloAssign (left, right, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="f7da9-2431">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2431">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="f7da9-2432">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2432">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="f7da9-2433">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2433">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <param name="conversion">
          <span data-ttu-id="f7da9-2434">Um <see cref="T:System.Linq.Expressions.LambdaExpression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2434">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-2435">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição pendente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2435">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a remainder assignment operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-2436">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.ModuloAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2436">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ModuloAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Multiply">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f7da9-2437">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação aritmética de multiplicação que não tem verificação de estouro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2437">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic multiplication operation that does not have overflow checking.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Multiply">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Multiply (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Multiply(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Multiply(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Multiply (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Multiply(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member Multiply : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Multiply (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="f7da9-2438">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2438">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="f7da9-2439">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2439">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-2440">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação aritmética de multiplicação que não tem verificação de estouro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2440">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic multiplication operation that does not have overflow checking.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-2441">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Multiply" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2441">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Multiply" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-2442">Resultante <xref:System.Linq.Expressions.BinaryExpression> tem o <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriedade definida como o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2442">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="f7da9-2443">O <xref:System.Linq.Expressions.Expression.Type%2A> estiver definida como o tipo de nó.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2443">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="f7da9-2444">Se o nó é elevado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> e <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriedades estiverem `true`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2444">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="f7da9-2445">Caso contrário, eles são `false`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2445">Otherwise, they are `false`.</span></span> <span data-ttu-id="f7da9-2446">A propriedade <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> é `null`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2446">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="f7da9-2447">As informações a seguir descrevem o método de implementação, o tipo de nó, e se um nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2447">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="f7da9-2448">Implementando método</span><span class="sxs-lookup"><span data-stu-id="f7da9-2448">Implementing Method</span></span>  
 <span data-ttu-id="f7da9-2449">As seguintes regras de determinam o método de implementação selecionado para a operação:</span><span class="sxs-lookup"><span data-stu-id="f7da9-2449">The following rules determine the selected implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="f7da9-2450">Se o <xref:System.Linq.Expressions.Expression.Type%2A> propriedade deles `left` ou `right` representa um tipo definido pelo usuário que sobrecarrega o operador de multiplicação, o <xref:System.Reflection.MethodInfo> que representa que o método é o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2450">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the multiplication operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="f7da9-2451">Caso contrário, se `left`. Tipo e `right`. Tipo de tipos numéricos, o método de implementação está `null`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2451">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="f7da9-2452">Tipo de nó e versão com comparação de precisão x sem comparação de precisão</span><span class="sxs-lookup"><span data-stu-id="f7da9-2452">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="f7da9-2453">Se o método de implementação não for `null`:</span><span class="sxs-lookup"><span data-stu-id="f7da9-2453">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="f7da9-2454">Se `left`. Tipo e `right`. Tipo podem ser atribuídos aos tipos de argumento correspondente do método de implementação, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2454">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="f7da9-2455">O tipo do nó é o tipo de retorno do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2455">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="f7da9-2456">Se as duas seguintes condições forem atendidas, o nó é levantado e o tipo de nó é o tipo que permite valor nulo que corresponde ao tipo de retorno do método de implementação:</span><span class="sxs-lookup"><span data-stu-id="f7da9-2456">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="f7da9-2457">`left`. Tipo e `right`. Tipo são os dois tipos de valor de que pelo menos um é anulável e os tipos não anuláveis correspondentes são iguais para os tipos de argumento correspondente do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2457">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="f7da9-2458">O tipo de retorno do método de implementação é um tipo de valor não anulável.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2458">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="f7da9-2459">Se o método de implementação é `null`:</span><span class="sxs-lookup"><span data-stu-id="f7da9-2459">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="f7da9-2460">Se `left`. Tipo e `right`. Tipo são não anuláveis, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2460">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="f7da9-2461">O tipo do nó é o tipo de resultado do operador de multiplicação predefinidos.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2461">The type of the node is the result type of the predefined multiplication operator.</span></span>  
  
-   <span data-ttu-id="f7da9-2462">Se `left`. Tipo e `right`. Tipo são anuláveis, o nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2462">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="f7da9-2463">O tipo de nó é o tipo que permite valor nulo que corresponde ao tipo de resultado do operador de multiplicação predefinidos.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2463">The type of the node is the nullable type that corresponds to the result type of the predefined multiplication operator.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f7da9-2464">O exemplo de código a seguir mostra como criar uma expressão que multiplica dois valores.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2464">The following code example shows how to create an expression that multiplies two values.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#27](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#27)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#27](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#27)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f7da9-2465">
            <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2465">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f7da9-2466">O operador de multiplicação não está definido como <paramref name="left" />.Type e <paramref name="right" />.Type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2466">The multiplication operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Multiply">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Multiply (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Multiply(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Multiply(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Multiply (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Multiply(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member Multiply : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Multiply (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="f7da9-2467">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2467">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="f7da9-2468">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2468">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="f7da9-2469">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2469">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-2470">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação aritmética de multiplicação que não tem verificação de estouro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2470">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic multiplication operation that does not have overflow checking.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-2471">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Multiply" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2471">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Multiply" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-2472">Resultante <xref:System.Linq.Expressions.BinaryExpression> tem o <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriedade definida como o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2472">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="f7da9-2473">O <xref:System.Linq.Expressions.Expression.Type%2A> estiver definida como o tipo de nó.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2473">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="f7da9-2474">Se o nó é elevado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> e <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriedades estiverem `true`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2474">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="f7da9-2475">Caso contrário, eles são `false`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2475">Otherwise, they are `false`.</span></span> <span data-ttu-id="f7da9-2476">A propriedade <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> é `null`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2476">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="f7da9-2477">As informações a seguir descrevem o método de implementação, o tipo de nó, e se um nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2477">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="f7da9-2478">Implementando método</span><span class="sxs-lookup"><span data-stu-id="f7da9-2478">Implementing Method</span></span>  
 <span data-ttu-id="f7da9-2479">As regras a seguir determinam o método de implementação para a operação:</span><span class="sxs-lookup"><span data-stu-id="f7da9-2479">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="f7da9-2480">Se `method` não é `null` e representa um não-nulo, `static` (`Shared` no Visual Basic) método que usa dois argumentos, é o método de implementação para o nó.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2480">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method for the node.</span></span>  
  
-   <span data-ttu-id="f7da9-2481">Caso contrário, se o <xref:System.Linq.Expressions.Expression.Type%2A> propriedade deles `left` ou `right` representa um tipo definido pelo usuário que sobrecarrega o operador de multiplicação, o <xref:System.Reflection.MethodInfo> que representa que o método é o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2481">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the multiplication operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="f7da9-2482">Caso contrário, se `left`. Tipo e `right`. Tipo de tipos numéricos, o método de implementação está `null`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2482">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="f7da9-2483">Tipo de nó e versão com comparação de precisão x sem comparação de precisão</span><span class="sxs-lookup"><span data-stu-id="f7da9-2483">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="f7da9-2484">Se o método de implementação não for `null`:</span><span class="sxs-lookup"><span data-stu-id="f7da9-2484">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="f7da9-2485">Se `left`. Tipo e `right`. Tipo podem ser atribuídos aos tipos de argumento correspondente do método de implementação, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2485">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="f7da9-2486">O tipo do nó é o tipo de retorno do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2486">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="f7da9-2487">Se as duas seguintes condições forem atendidas, o nó é levantado e o tipo de nó é o tipo que permite valor nulo que corresponde ao tipo de retorno do método de implementação:</span><span class="sxs-lookup"><span data-stu-id="f7da9-2487">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="f7da9-2488">`left`. Tipo e `right`. Tipo são os dois tipos de valor de que pelo menos um é anulável e os tipos não anuláveis correspondentes são iguais para os tipos de argumento correspondente do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2488">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="f7da9-2489">O tipo de retorno do método de implementação é um tipo de valor não anulável.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2489">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="f7da9-2490">Se o método de implementação é `null`:</span><span class="sxs-lookup"><span data-stu-id="f7da9-2490">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="f7da9-2491">Se `left`. Tipo e `right`. Tipo são não anuláveis, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2491">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="f7da9-2492">O tipo do nó é o tipo de resultado do operador de multiplicação predefinidos.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2492">The type of the node is the result type of the predefined multiplication operator.</span></span>  
  
-   <span data-ttu-id="f7da9-2493">Se `left`. Tipo e `right`. Tipo são anuláveis, o nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2493">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="f7da9-2494">O tipo de nó é o tipo que permite valor nulo que corresponde ao tipo de resultado do operador de multiplicação predefinidos.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2494">The type of the node is the nullable type that corresponds to the result type of the predefined multiplication operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f7da9-2495">
            <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2495">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f7da9-2496">
            <paramref name="method" /> não é <see langword="null" /> e o método que ele representa retorna <see langword="void" />, não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) ou não tem exatamente dois argumentos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2496">
              <paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f7da9-2497">
            <paramref name="method" /> é <see langword="null" /> e o operador de multiplicação não foi definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2497">
              <paramref name="method" /> is <see langword="null" /> and the multiplication operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="MultiplyAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f7da9-2498">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição de multiplicação que não tem verificação de estouro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2498">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a multiplication assignment operation that does not have overflow checking.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MultiplyAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MultiplyAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MultiplyAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MultiplyAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MultiplyAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MultiplyAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member MultiplyAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.MultiplyAssign (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="f7da9-2499">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2499">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="f7da9-2500">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2500">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-2501">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição de multiplicação que não tem verificação de estouro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2501">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a multiplication assignment operation that does not have overflow checking.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-2502">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2502">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MultiplyAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MultiplyAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MultiplyAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MultiplyAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MultiplyAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MultiplyAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member MultiplyAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.MultiplyAssign (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="f7da9-2503">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2503">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="f7da9-2504">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2504">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="f7da9-2505">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2505">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-2506">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição de multiplicação que não tem verificação de estouro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2506">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a multiplication assignment operation that does not have overflow checking.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-2507">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2507">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MultiplyAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MultiplyAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MultiplyAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MultiplyAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MultiplyAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MultiplyAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member MultiplyAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.MultiplyAssign (left, right, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="f7da9-2508">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2508">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="f7da9-2509">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2509">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="f7da9-2510">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2510">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <param name="conversion">
          <span data-ttu-id="f7da9-2511">Um <see cref="T:System.Linq.Expressions.LambdaExpression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2511">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-2512">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição de multiplicação que não tem verificação de estouro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2512">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a multiplication assignment operation that does not have overflow checking.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-2513">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2513">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MultiplyAssignChecked">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f7da9-2514">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição de multiplicação que tem verificação de estouro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2514">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a multiplication assignment operation that has overflow checking.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MultiplyAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MultiplyAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MultiplyAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MultiplyAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MultiplyAssignChecked (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MultiplyAssignChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member MultiplyAssignChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.MultiplyAssignChecked (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="f7da9-2515">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2515">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="f7da9-2516">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2516">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-2517">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição de multiplicação que tem verificação de estouro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2517">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a multiplication assignment operation that has overflow checking.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-2518">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2518">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MultiplyAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MultiplyAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MultiplyAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MultiplyAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MultiplyAssignChecked (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MultiplyAssignChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member MultiplyAssignChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.MultiplyAssignChecked (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="f7da9-2519">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2519">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="f7da9-2520">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2520">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="f7da9-2521">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2521">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-2522">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição de multiplicação que tem verificação de estouro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2522">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a multiplication assignment operation that has overflow checking.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-2523">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2523">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MultiplyAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MultiplyAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MultiplyAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MultiplyAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MultiplyAssignChecked (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MultiplyAssignChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member MultiplyAssignChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.MultiplyAssignChecked (left, right, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="f7da9-2524">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2524">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="f7da9-2525">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2525">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="f7da9-2526">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2526">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <param name="conversion">
          <span data-ttu-id="f7da9-2527">Um <see cref="T:System.Linq.Expressions.LambdaExpression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2527">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-2528">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição de multiplicação que tem verificação de estouro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2528">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a multiplication assignment operation that has overflow checking.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-2529">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2529">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MultiplyChecked">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f7da9-2530">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação aritmética de multiplicação que tem verificação de estouro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2530">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic multiplication operation that has overflow checking.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MultiplyChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MultiplyChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MultiplyChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MultiplyChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MultiplyChecked (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MultiplyChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member MultiplyChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.MultiplyChecked (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="f7da9-2531">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2531">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="f7da9-2532">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2532">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-2533">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação aritmética de multiplicação que tem verificação de estouro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2533">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic multiplication operation that has overflow checking.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-2534">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyChecked" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2534">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyChecked" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-2535">Resultante <xref:System.Linq.Expressions.BinaryExpression> tem o <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriedade definida como o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2535">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="f7da9-2536">O <xref:System.Linq.Expressions.Expression.Type%2A> estiver definida como o tipo de nó.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2536">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="f7da9-2537">Se o nó é elevado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> e <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriedades estiverem `true`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2537">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="f7da9-2538">Caso contrário, eles são `false`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2538">Otherwise, they are `false`.</span></span> <span data-ttu-id="f7da9-2539">A propriedade <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> é `null`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2539">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="f7da9-2540">As informações a seguir descrevem o método de implementação, o tipo de nó, e se um nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2540">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="f7da9-2541">Implementando método</span><span class="sxs-lookup"><span data-stu-id="f7da9-2541">Implementing Method</span></span>  
 <span data-ttu-id="f7da9-2542">As seguintes regras de determinam o método de implementação selecionado para a operação:</span><span class="sxs-lookup"><span data-stu-id="f7da9-2542">The following rules determine the selected implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="f7da9-2543">Se o <xref:System.Linq.Expressions.Expression.Type%2A> propriedade deles `left` ou `right` representa um tipo definido pelo usuário que sobrecarrega o operador de multiplicação, o <xref:System.Reflection.MethodInfo> que representa que o método é o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2543">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the multiplication operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="f7da9-2544">Caso contrário, se `left`. Tipo e `right`. Tipo de tipos numéricos, o método de implementação está `null`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2544">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="f7da9-2545">Tipo de nó e versão com comparação de precisão x sem comparação de precisão</span><span class="sxs-lookup"><span data-stu-id="f7da9-2545">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="f7da9-2546">Se o método de implementação não for `null`:</span><span class="sxs-lookup"><span data-stu-id="f7da9-2546">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="f7da9-2547">Se `left`. Tipo e `right`. Tipo podem ser atribuídos aos tipos de argumento correspondente do método de implementação, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2547">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="f7da9-2548">O tipo do nó é o tipo de retorno do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2548">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="f7da9-2549">Se as duas seguintes condições forem atendidas, o nó é levantado e o tipo de nó é o tipo que permite valor nulo que corresponde ao tipo de retorno do método de implementação:</span><span class="sxs-lookup"><span data-stu-id="f7da9-2549">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="f7da9-2550">`left`. Tipo e `right`. Tipo são os dois tipos de valor de que pelo menos um é anulável e os tipos não anuláveis correspondentes são iguais para os tipos de argumento correspondente do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2550">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="f7da9-2551">O tipo de retorno do método de implementação é um tipo de valor não anulável.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2551">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="f7da9-2552">Se o método de implementação é `null`:</span><span class="sxs-lookup"><span data-stu-id="f7da9-2552">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="f7da9-2553">Se `left`. Tipo e `right`. Tipo são não anuláveis, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2553">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="f7da9-2554">O tipo do nó é o tipo de resultado do operador de multiplicação predefinidos.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2554">The type of the node is the result type of the predefined multiplication operator.</span></span>  
  
-   <span data-ttu-id="f7da9-2555">Se `left`. Tipo e `right`. Tipo são anuláveis, o nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2555">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="f7da9-2556">O tipo de nó é o tipo que permite valor nulo que corresponde ao tipo de resultado do operador de multiplicação predefinidos.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2556">The type of the node is the nullable type that corresponds to the result type of the predefined multiplication operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f7da9-2557">
            <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2557">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f7da9-2558">O operador de multiplicação não está definido como <paramref name="left" />.Type e <paramref name="right" />.Type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2558">The multiplication operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="MultiplyChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MultiplyChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MultiplyChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MultiplyChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MultiplyChecked (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MultiplyChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member MultiplyChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.MultiplyChecked (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="f7da9-2559">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2559">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="f7da9-2560">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2560">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="f7da9-2561">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2561">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-2562">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação aritmética de multiplicação que tem verificação de estouro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2562">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic multiplication operation that has overflow checking.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-2563">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyChecked" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2563">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyChecked" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-2564">Resultante <xref:System.Linq.Expressions.BinaryExpression> tem o <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriedade definida como o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2564">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="f7da9-2565">O <xref:System.Linq.Expressions.Expression.Type%2A> estiver definida como o tipo de nó.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2565">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="f7da9-2566">Se o nó é elevado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> e <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriedades estiverem `true`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2566">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="f7da9-2567">Caso contrário, eles são `false`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2567">Otherwise, they are `false`.</span></span> <span data-ttu-id="f7da9-2568">A propriedade <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> é `null`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2568">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="f7da9-2569">As informações a seguir descrevem o método de implementação, o tipo de nó, e se um nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2569">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="f7da9-2570">Implementando método</span><span class="sxs-lookup"><span data-stu-id="f7da9-2570">Implementing Method</span></span>  
 <span data-ttu-id="f7da9-2571">As regras a seguir determinam o método de implementação para a operação:</span><span class="sxs-lookup"><span data-stu-id="f7da9-2571">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="f7da9-2572">Se `method` não é `null` e representa um não-nulo, `static` (`Shared` no Visual Basic) método que usa dois argumentos, é o método de implementação para o nó.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2572">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method for the node.</span></span>  
  
-   <span data-ttu-id="f7da9-2573">Caso contrário, se o <xref:System.Linq.Expressions.Expression.Type%2A> propriedade deles `left` ou `right` representa um tipo definido pelo usuário que sobrecarrega o operador de multiplicação, o <xref:System.Reflection.MethodInfo> que representa que o método é o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2573">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the multiplication operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="f7da9-2574">Caso contrário, se `left`. Tipo e `right`. Tipo de tipos numéricos, o método de implementação está `null`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2574">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="f7da9-2575">Tipo de nó e versão com comparação de precisão x sem comparação de precisão</span><span class="sxs-lookup"><span data-stu-id="f7da9-2575">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="f7da9-2576">Se o método de implementação não for `null`:</span><span class="sxs-lookup"><span data-stu-id="f7da9-2576">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="f7da9-2577">Se `left`. Tipo e `right`. Tipo podem ser atribuídos aos tipos de argumento correspondente do método de implementação, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2577">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="f7da9-2578">O tipo do nó é o tipo de retorno do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2578">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="f7da9-2579">Se as duas seguintes condições forem atendidas, o nó é levantado e o tipo de nó é o tipo que permite valor nulo que corresponde ao tipo de retorno do método de implementação:</span><span class="sxs-lookup"><span data-stu-id="f7da9-2579">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="f7da9-2580">`left`. Tipo e `right`. Tipo são os dois tipos de valor de que pelo menos um é anulável e os tipos não anuláveis correspondentes são iguais para os tipos de argumento correspondente do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2580">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="f7da9-2581">O tipo de retorno do método de implementação é um tipo de valor não anulável.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2581">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="f7da9-2582">Se o método de implementação é `null`:</span><span class="sxs-lookup"><span data-stu-id="f7da9-2582">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="f7da9-2583">Se `left`. Tipo e `right`. Tipo são não anuláveis, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2583">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="f7da9-2584">O tipo do nó é o tipo de resultado do operador de multiplicação predefinidos.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2584">The type of the node is the result type of the predefined multiplication operator.</span></span>  
  
-   <span data-ttu-id="f7da9-2585">Se `left`. Tipo e `right`. Tipo são anuláveis, o nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2585">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="f7da9-2586">O tipo de nó é o tipo que permite valor nulo que corresponde ao tipo de resultado do operador de multiplicação predefinidos.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2586">The type of the node is the nullable type that corresponds to the result type of the predefined multiplication operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f7da9-2587">
            <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2587">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f7da9-2588">
            <paramref name="method" /> não é <see langword="null" /> e o método que ele representa retorna <see langword="void" />, não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) ou não tem exatamente dois argumentos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2588">
              <paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f7da9-2589">
            <paramref name="method" /> é <see langword="null" /> e o operador de multiplicação não foi definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2589">
              <paramref name="method" /> is <see langword="null" /> and the multiplication operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Negate">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f7da9-2590">Cria uma <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa uma operação aritmética de negação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2590">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents an arithmetic negation operation.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Negate">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Negate (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Negate(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Negate(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Negate(System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member Negate : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Negate expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression">
          <span data-ttu-id="f7da9-2591">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2591">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-2592">Cria uma <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa uma operação aritmética de negação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2592">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents an arithmetic negation operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-2593">Uma <see cref="T:System.Linq.Expressions.UnaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Negate" /> e a propriedade <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> definida para o valor especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2593">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Negate" /> and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property set to the specified value.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-2594">O <xref:System.Linq.Expressions.UnaryExpression.Method%2A> propriedade resultantes <xref:System.Linq.Expressions.UnaryExpression> é definido como o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2594">The <xref:System.Linq.Expressions.UnaryExpression.Method%2A> property of the resulting <xref:System.Linq.Expressions.UnaryExpression> is set to the implementing method.</span></span> <span data-ttu-id="f7da9-2595">O <xref:System.Linq.Expressions.Expression.Type%2A> estiver definida como o tipo de nó.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2595">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="f7da9-2596">Se o nó é elevado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> e <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriedades estiverem `true`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2596">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="f7da9-2597">Caso contrário, eles são falsos.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2597">Otherwise, they are false.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="f7da9-2598">Implementando método</span><span class="sxs-lookup"><span data-stu-id="f7da9-2598">Implementing Method</span></span>  
 <span data-ttu-id="f7da9-2599">As regras a seguir determinam o método de implementação para a operação:</span><span class="sxs-lookup"><span data-stu-id="f7da9-2599">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="f7da9-2600">Se `expression`. Tipo é um tipo definido pelo usuário que define o operador de subtração unário a <xref:System.Reflection.MethodInfo> que representa que o método de implementação do operador é.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2600">If `expression`.Type is a user-defined type that defines the unary minus operator, the <xref:System.Reflection.MethodInfo> that represents that operator is the implementing method.</span></span>  
  
-   <span data-ttu-id="f7da9-2601">Caso contrário, se `expression`. Tipo é um tipo numérico, o método de implementação é `null`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2601">Otherwise, if `expression`.Type is a numeric type, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="f7da9-2602">Tipo de nó e versão com comparação de precisão x sem comparação de precisão</span><span class="sxs-lookup"><span data-stu-id="f7da9-2602">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="f7da9-2603">Se o método de implementação não for `null`:</span><span class="sxs-lookup"><span data-stu-id="f7da9-2603">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="f7da9-2604">Se `expression`. O tipo é atribuível ao tipo de argumento do método de implementação, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2604">If `expression`.Type is assignable to the argument type of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="f7da9-2605">O tipo do nó é o tipo de retorno do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2605">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="f7da9-2606">Se as duas seguintes condições forem atendidas, o nó é levantado e o tipo de nó é o tipo que permite valor nulo que corresponde ao tipo de retorno do método de implementação:</span><span class="sxs-lookup"><span data-stu-id="f7da9-2606">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="f7da9-2607">`expression`. É um tipo de valor anulável e o tipo de valor não anulável correspondente é igual ao tipo de argumento do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2607">`expression`.Type is a nullable value type and the corresponding non-nullable value type is equal to the argument type of the implementing method.</span></span>  
  
    -   <span data-ttu-id="f7da9-2608">O tipo de retorno do método de implementação é um tipo de valor não anulável.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2608">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="f7da9-2609">Se for o método de implementação `null`, o tipo de nó é `expression`. Tipo.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2609">If the implementing method is `null`, the type of the node is `expression`.Type.</span></span> <span data-ttu-id="f7da9-2610">Se `expression`. Tipo não anulável, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2610">If `expression`.Type is non-nullable, the node is not lifted.</span></span> <span data-ttu-id="f7da9-2611">Caso contrário, o nó é eliminado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2611">Otherwise, the node is lifted.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f7da9-2612">O exemplo a seguir demonstra como criar uma expressão que representa uma operação de negação aritmética.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2612">The following example demonstrates how to create an expression that represents an arithmetic negation operation.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#50](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#50)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#50](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#50)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f7da9-2613">
            <paramref name="expression" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2613">
              <paramref name="expression" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f7da9-2614">O operador de menos unário não está definido para <paramref name="expression" />.Type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2614">The unary minus operator is not defined for <paramref name="expression" />.Type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Negate">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Negate (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Negate(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Negate(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Negate(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member Negate : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Negate (expression, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">
          <span data-ttu-id="f7da9-2615">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2615">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="f7da9-2616">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2616">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-2617">Cria uma <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa uma operação aritmética de negação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2617">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents an arithmetic negation operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-2618">Um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Negate" /> e as propriedades <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> e <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2618">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Negate" /> and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> and <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-2619">O <xref:System.Linq.Expressions.UnaryExpression.Method%2A> propriedade resultantes <xref:System.Linq.Expressions.UnaryExpression> é definido como o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2619">The <xref:System.Linq.Expressions.UnaryExpression.Method%2A> property of the resulting <xref:System.Linq.Expressions.UnaryExpression> is set to the implementing method.</span></span> <span data-ttu-id="f7da9-2620">O <xref:System.Linq.Expressions.Expression.Type%2A> estiver definida como o tipo de nó.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2620">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="f7da9-2621">Se o nó é elevado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> e <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriedades estiverem `true`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2621">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="f7da9-2622">Caso contrário, eles são falsos.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2622">Otherwise, they are false.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="f7da9-2623">Implementando método</span><span class="sxs-lookup"><span data-stu-id="f7da9-2623">Implementing Method</span></span>  
 <span data-ttu-id="f7da9-2624">As regras a seguir determinam o método de implementação para a operação:</span><span class="sxs-lookup"><span data-stu-id="f7da9-2624">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="f7da9-2625">Se `method` não é `null` e representa um não-nulo, `static` (`Shared` no Visual Basic) método que aceita um argumento, ele é o método de implementação para o nó.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2625">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes one argument, it is the implementing method for the node.</span></span>  
  
-   <span data-ttu-id="f7da9-2626">Se `expression`. Tipo é um tipo definido pelo usuário que define o operador de subtração unário a <xref:System.Reflection.MethodInfo> que representa que o método de implementação do operador é.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2626">If `expression`.Type is a user-defined type that defines the unary minus operator, the <xref:System.Reflection.MethodInfo> that represents that operator is the implementing method.</span></span>  
  
-   <span data-ttu-id="f7da9-2627">Caso contrário, se `expression`. Tipo é um tipo numérico, o método de implementação é `null`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2627">Otherwise, if `expression`.Type is a numeric type, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="f7da9-2628">Tipo de nó e versão com comparação de precisão x sem comparação de precisão</span><span class="sxs-lookup"><span data-stu-id="f7da9-2628">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="f7da9-2629">Se o método de implementação não for `null`:</span><span class="sxs-lookup"><span data-stu-id="f7da9-2629">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="f7da9-2630">Se `expression`. O tipo é atribuível ao tipo de argumento do método de implementação, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2630">If `expression`.Type is assignable to the argument type of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="f7da9-2631">O tipo do nó é o tipo de retorno do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2631">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="f7da9-2632">Se as duas seguintes condições forem atendidas, o nó é levantado e o tipo de nó é o tipo que permite valor nulo que corresponde ao tipo de retorno do método de implementação:</span><span class="sxs-lookup"><span data-stu-id="f7da9-2632">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="f7da9-2633">`expression`. É um tipo de valor anulável e o tipo de valor não anulável correspondente é igual ao tipo de argumento do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2633">`expression`.Type is a nullable value type and the corresponding non-nullable value type is equal to the argument type of the implementing method.</span></span>  
  
    -   <span data-ttu-id="f7da9-2634">O tipo de retorno do método de implementação é um tipo de valor não anulável.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2634">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="f7da9-2635">Se for o método de implementação `null`, o tipo de nó é `expression`. Tipo.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2635">If the implementing method is `null`, the type of the node is `expression`.Type.</span></span> <span data-ttu-id="f7da9-2636">Se `expression`. Tipo não anulável, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2636">If `expression`.Type is non-nullable, the node is not lifted.</span></span> <span data-ttu-id="f7da9-2637">Caso contrário, o nó é eliminado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2637">Otherwise, the node is lifted.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f7da9-2638">
            <paramref name="expression" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2638">
              <paramref name="expression" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f7da9-2639">
            <paramref name="method" /> não é <see langword="null" /> e o método que ele representa retorna <see langword="void" />, não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) ou não tem exatamente um argumento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2639">
              <paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly one argument.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f7da9-2640">
            <paramref name="method" /> é <see langword="null" /> e o operador unário de menos não foi definido para <paramref name="expression" />.Type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2640">
              <paramref name="method" /> is <see langword="null" /> and the unary minus operator is not defined for <paramref name="expression" />.Type.</span>
          </span>
          <span data-ttu-id="f7da9-2641">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2641">-or-</span>
          </span>
          <span data-ttu-id="f7da9-2642">
            <paramref name="expression" />.Type (ou o respectivo tipo que não permite valor nulo correspondente se ele é um tipo que permite valor nulo) não é atribuível ao tipo de argumento do método representado por <paramref name="method" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2642">
              <paramref name="expression" />.Type (or its corresponding non-nullable type if it is a nullable value type) is not assignable to the argument type of the method represented by <paramref name="method" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="NegateChecked">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f7da9-2643">Cria um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa uma operação aritmética de negação de adição que tem verificação de estouro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2643">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents an arithmetic negation operation that has overflow checking.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="NegateChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression NegateChecked (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression NegateChecked(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.NegateChecked(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ NegateChecked(System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member NegateChecked : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.NegateChecked expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression">
          <span data-ttu-id="f7da9-2644">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2644">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-2645">Cria um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa uma operação aritmética de negação de adição que tem verificação de estouro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2645">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents an arithmetic negation operation that has overflow checking.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-2646">Uma <see cref="T:System.Linq.Expressions.UnaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.NegateChecked" /> e a propriedade <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> definida para o valor especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2646">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.NegateChecked" /> and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property set to the specified value.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-2647">O <xref:System.Linq.Expressions.UnaryExpression.Method%2A> propriedade resultantes <xref:System.Linq.Expressions.UnaryExpression> é definido como o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2647">The <xref:System.Linq.Expressions.UnaryExpression.Method%2A> property of the resulting <xref:System.Linq.Expressions.UnaryExpression> is set to the implementing method.</span></span> <span data-ttu-id="f7da9-2648">O <xref:System.Linq.Expressions.Expression.Type%2A> estiver definida como o tipo de nó.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2648">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="f7da9-2649">Se o nó é elevado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> e <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriedades estiverem `true`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2649">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="f7da9-2650">Caso contrário, eles são falsos.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2650">Otherwise, they are false.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="f7da9-2651">Implementando método</span><span class="sxs-lookup"><span data-stu-id="f7da9-2651">Implementing Method</span></span>  
 <span data-ttu-id="f7da9-2652">As regras a seguir determinam o método de implementação para a operação:</span><span class="sxs-lookup"><span data-stu-id="f7da9-2652">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="f7da9-2653">Se `expression`. Tipo é um tipo definido pelo usuário que define o operador de subtração unário a <xref:System.Reflection.MethodInfo> que representa que o método de implementação do operador é.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2653">If `expression`.Type is a user-defined type that defines the unary minus operator, the <xref:System.Reflection.MethodInfo> that represents that operator is the implementing method.</span></span>  
  
-   <span data-ttu-id="f7da9-2654">Caso contrário, se `expression`. Tipo é um tipo numérico, o método de implementação é `null`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2654">Otherwise, if `expression`.Type is a numeric type, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="f7da9-2655">Tipo de nó e versão com comparação de precisão x sem comparação de precisão</span><span class="sxs-lookup"><span data-stu-id="f7da9-2655">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="f7da9-2656">Se o método de implementação não for `null`:</span><span class="sxs-lookup"><span data-stu-id="f7da9-2656">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="f7da9-2657">Se `expression`. O tipo é atribuível ao tipo de argumento do método de implementação, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2657">If `expression`.Type is assignable to the argument type of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="f7da9-2658">O tipo do nó é o tipo de retorno do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2658">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="f7da9-2659">Se as duas seguintes condições forem atendidas, o nó é levantado e o tipo de nó é o tipo que permite valor nulo que corresponde ao tipo de retorno do método de implementação:</span><span class="sxs-lookup"><span data-stu-id="f7da9-2659">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="f7da9-2660">`expression`. É um tipo de valor anulável e o tipo de valor não anulável correspondente é igual ao tipo de argumento do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2660">`expression`.Type is a nullable value type and the corresponding non-nullable value type is equal to the argument type of the implementing method.</span></span>  
  
    -   <span data-ttu-id="f7da9-2661">O tipo de retorno do método de implementação é um tipo de valor não anulável.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2661">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="f7da9-2662">Se for o método de implementação `null`, o tipo de nó é `expression`. Tipo.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2662">If the implementing method is `null`, the type of the node is `expression`.Type.</span></span> <span data-ttu-id="f7da9-2663">Se `expression`. Tipo não anulável, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2663">If `expression`.Type is non-nullable, the node is not lifted.</span></span> <span data-ttu-id="f7da9-2664">Caso contrário, o nó é eliminado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2664">Otherwise, the node is lifted.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f7da9-2665">
            <paramref name="expression" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2665">
              <paramref name="expression" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f7da9-2666">O operador de menos unário não está definido para <paramref name="expression" />.Type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2666">The unary minus operator is not defined for <paramref name="expression" />.Type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="NegateChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression NegateChecked (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression NegateChecked(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.NegateChecked(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ NegateChecked(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member NegateChecked : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.NegateChecked (expression, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">
          <span data-ttu-id="f7da9-2667">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2667">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="f7da9-2668">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2668">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-2669">Cria um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa uma operação aritmética de negação de adição que tem verificação de estouro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2669">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents an arithmetic negation operation that has overflow checking.</span>
          </span>
          <span data-ttu-id="f7da9-2670">O método de implementação pode ser especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2670">The implementing method can be specified.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-2671">Um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.NegateChecked" /> e as propriedades <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> e <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2671">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.NegateChecked" /> and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> and <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-2672">O <xref:System.Linq.Expressions.UnaryExpression.Method%2A> propriedade resultantes <xref:System.Linq.Expressions.UnaryExpression> é definido como o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2672">The <xref:System.Linq.Expressions.UnaryExpression.Method%2A> property of the resulting <xref:System.Linq.Expressions.UnaryExpression> is set to the implementing method.</span></span> <span data-ttu-id="f7da9-2673">O <xref:System.Linq.Expressions.Expression.Type%2A> estiver definida como o tipo de nó.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2673">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="f7da9-2674">Se o nó é elevado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> e <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriedades estiverem `true`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2674">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="f7da9-2675">Caso contrário, eles são falsos.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2675">Otherwise, they are false.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="f7da9-2676">Implementando método</span><span class="sxs-lookup"><span data-stu-id="f7da9-2676">Implementing Method</span></span>  
 <span data-ttu-id="f7da9-2677">As regras a seguir determinam o método de implementação para a operação:</span><span class="sxs-lookup"><span data-stu-id="f7da9-2677">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="f7da9-2678">Se `method` não é `null` e representa um não-nulo, `static` (`Shared` no Visual Basic) método que aceita um argumento, ele é o método de implementação para o nó.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2678">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes one argument, it is the implementing method for the node.</span></span>  
  
-   <span data-ttu-id="f7da9-2679">Se `expression`. Tipo é um tipo definido pelo usuário que define o operador de subtração unário a <xref:System.Reflection.MethodInfo> que representa que o método de implementação do operador é.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2679">If `expression`.Type is a user-defined type that defines the unary minus operator, the <xref:System.Reflection.MethodInfo> that represents that operator is the implementing method.</span></span>  
  
-   <span data-ttu-id="f7da9-2680">Caso contrário, se `expression`. Tipo é um tipo numérico, o método de implementação é `null`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2680">Otherwise, if `expression`.Type is a numeric type, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="f7da9-2681">Tipo de nó e versão com comparação de precisão x sem comparação de precisão</span><span class="sxs-lookup"><span data-stu-id="f7da9-2681">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="f7da9-2682">Se o método de implementação não for `null`:</span><span class="sxs-lookup"><span data-stu-id="f7da9-2682">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="f7da9-2683">Se `expression`. O tipo é atribuível ao tipo de argumento do método de implementação, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2683">If `expression`.Type is assignable to the argument type of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="f7da9-2684">O tipo do nó é o tipo de retorno do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2684">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="f7da9-2685">Se as duas seguintes condições forem atendidas, o nó é levantado e o tipo de nó é o tipo que permite valor nulo que corresponde ao tipo de retorno do método de implementação:</span><span class="sxs-lookup"><span data-stu-id="f7da9-2685">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="f7da9-2686">`expression`. É um tipo de valor anulável e o tipo de valor não anulável correspondente é igual ao tipo de argumento do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2686">`expression`.Type is a nullable value type and the corresponding non-nullable value type is equal to the argument type of the implementing method.</span></span>  
  
    -   <span data-ttu-id="f7da9-2687">O tipo de retorno do método de implementação é um tipo de valor não anulável.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2687">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="f7da9-2688">Se for o método de implementação `null`, o tipo de nó é `expression`. Tipo.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2688">If the implementing method is `null`, the type of the node is `expression`.Type.</span></span> <span data-ttu-id="f7da9-2689">Se `expression`. Tipo não anulável, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2689">If `expression`.Type is non-nullable, the node is not lifted.</span></span> <span data-ttu-id="f7da9-2690">Caso contrário, o nó é eliminado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2690">Otherwise, the node is lifted.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f7da9-2691">
            <paramref name="expression" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2691">
              <paramref name="expression" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f7da9-2692">
            <paramref name="method" /> não é <see langword="null" /> e o método que ele representa retorna <see langword="void" />, não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) ou não tem exatamente um argumento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2692">
              <paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly one argument.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f7da9-2693">
            <paramref name="method" /> é <see langword="null" /> e o operador unário de menos não foi definido para <paramref name="expression" />.Type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2693">
              <paramref name="method" /> is <see langword="null" /> and the unary minus operator is not defined for <paramref name="expression" />.Type.</span>
          </span>
          <span data-ttu-id="f7da9-2694">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2694">-or-</span>
          </span>
          <span data-ttu-id="f7da9-2695">
            <paramref name="expression" />.Type (ou o respectivo tipo que não permite valor nulo correspondente se ele é um tipo que permite valor nulo) não é atribuível ao tipo de argumento do método representado por <paramref name="method" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2695">
              <paramref name="expression" />.Type (or its corresponding non-nullable type if it is a nullable value type) is not assignable to the argument type of the method represented by <paramref name="method" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="New">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f7da9-2696">Cria um <see cref="T:System.Linq.Expressions.NewExpression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2696">Creates a <see cref="T:System.Linq.Expressions.NewExpression" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="New">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewExpression New (System.Reflection.ConstructorInfo constructor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewExpression New(class System.Reflection.ConstructorInfo constructor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function New (constructor As ConstructorInfo) As NewExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::NewExpression ^ New(System::Reflection::ConstructorInfo ^ constructor);" />
      <MemberSignature Language="F#" Value="static member New : System.Reflection.ConstructorInfo -&gt; System.Linq.Expressions.NewExpression" Usage="System.Linq.Expressions.Expression.New constructor" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constructor" Type="System.Reflection.ConstructorInfo" />
      </Parameters>
      <Docs>
        <param name="constructor">
          <span data-ttu-id="f7da9-2697">O <see cref="T:System.Reflection.ConstructorInfo" /> com um valor igual ao qual a <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> propriedade será definida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2697">The <see cref="T:System.Reflection.ConstructorInfo" /> to set the <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-2698">Cria um <see cref="T:System.Linq.Expressions.NewExpression" /> que representa uma chamada ao construtor especificado que não aceita nenhum argumento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2698">Creates a <see cref="T:System.Linq.Expressions.NewExpression" /> that represents calling the specified constructor that takes no arguments.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-2699">Uma <see cref="T:System.Linq.Expressions.NewExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.New" /> e a propriedade <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> definida para o valor especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2699">A <see cref="T:System.Linq.Expressions.NewExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.New" /> and the <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> property set to the specified value.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-2700">O <xref:System.Linq.Expressions.NewExpression.Arguments%2A> e <xref:System.Linq.Expressions.NewExpression.Members%2A> propriedades resultantes <xref:System.Linq.Expressions.NewExpression> são coleções vazias.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2700">The <xref:System.Linq.Expressions.NewExpression.Arguments%2A> and <xref:System.Linq.Expressions.NewExpression.Members%2A> properties of the resulting <xref:System.Linq.Expressions.NewExpression> are empty collections.</span></span> <span data-ttu-id="f7da9-2701">O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade representa o tipo de declaração do construtor representado por `constructor`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2701">The <xref:System.Linq.Expressions.Expression.Type%2A> property represents the declaring type of the constructor represented by `constructor`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f7da9-2702">
            <paramref name="constructor" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2702">
              <paramref name="constructor" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f7da9-2703">O construtor representado por <paramref name="constructor" /> tem pelo menos um parâmetro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2703">The constructor that <paramref name="constructor" /> represents has at least one parameter.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="New">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewExpression New (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewExpression New(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.New(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::NewExpression ^ New(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member New : Type -&gt; System.Linq.Expressions.NewExpression" Usage="System.Linq.Expressions.Expression.New type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">
          <span data-ttu-id="f7da9-2704">Um <see cref="T:System.Type" /> contém um construtor que não aceita argumentos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2704">A <see cref="T:System.Type" /> that has a constructor that takes no arguments.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-2705">Cria um <see cref="T:System.Linq.Expressions.NewExpression" /> que representa uma chamada para o construtor sem parâmetro do tipo especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2705">Creates a <see cref="T:System.Linq.Expressions.NewExpression" /> that represents calling the parameterless constructor of the specified type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-2706">A <see cref="T:System.Linq.Expressions.NewExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.New" /> e a propriedade <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> definida como o <see cref="T:System.Reflection.ConstructorInfo" /> que representa o construtor sem parâmetros para o tipo especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2706">A <see cref="T:System.Linq.Expressions.NewExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.New" /> and the <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> property set to the <see cref="T:System.Reflection.ConstructorInfo" /> that represents the constructor without parameters for the specified type.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-2707">O `type` parâmetro deve representar um tipo que tem um construtor sem parâmetros.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2707">The `type` parameter must represent a type that has a constructor without parameters.</span></span>  
  
 <span data-ttu-id="f7da9-2708">O <xref:System.Linq.Expressions.NewExpression.Arguments%2A> e <xref:System.Linq.Expressions.NewExpression.Members%2A> propriedades resultantes <xref:System.Linq.Expressions.NewExpression> são coleções vazias.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2708">The <xref:System.Linq.Expressions.NewExpression.Arguments%2A> and <xref:System.Linq.Expressions.NewExpression.Members%2A> properties of the resulting <xref:System.Linq.Expressions.NewExpression> are empty collections.</span></span> <span data-ttu-id="f7da9-2709">O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade é igual a `type`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2709">The <xref:System.Linq.Expressions.Expression.Type%2A> property is equal to `type`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f7da9-2710">O exemplo a seguir demonstra como usar o <xref:System.Linq.Expressions.Expression.New%28System.Type%29> método para criar um <xref:System.Linq.Expressions.NewExpression> que representa a construção de uma nova instância de um objeto dictionary, chamando o construtor sem parâmetros.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2710">The following example demonstrates how to use the <xref:System.Linq.Expressions.Expression.New%28System.Type%29> method to create a <xref:System.Linq.Expressions.NewExpression> that represents constructing a new instance of a dictionary object by calling the constructor without parameters.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.Expression#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#10)]
 [!code-vb[System.Linq.Expressions.Expression#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f7da9-2711">
            <paramref name="type" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2711">
              <paramref name="type" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f7da9-2712">O tipo que <paramref name="type" /> representa não tem um construtor sem parâmetros.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2712">The type that <paramref name="type" /> represents does not have a constructor without parameters.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="New">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewExpression New (System.Reflection.ConstructorInfo constructor, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewExpression New(class System.Reflection.ConstructorInfo constructor, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function New (constructor As ConstructorInfo, arguments As IEnumerable(Of Expression)) As NewExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::NewExpression ^ New(System::Reflection::ConstructorInfo ^ constructor, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member New : System.Reflection.ConstructorInfo * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.NewExpression" Usage="System.Linq.Expressions.Expression.New (constructor, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constructor" Type="System.Reflection.ConstructorInfo" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="constructor">
          <span data-ttu-id="f7da9-2713">O <see cref="T:System.Reflection.ConstructorInfo" /> com um valor igual ao qual a <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> propriedade será definida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2713">The <see cref="T:System.Reflection.ConstructorInfo" /> to set the <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> property equal to.</span>
          </span>
        </param>
        <param name="arguments">
          <span data-ttu-id="f7da9-2714">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.Expression" /> a serem usados para preencher a coleção de <see cref="P:System.Linq.Expressions.NewExpression.Arguments" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2714">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-2715">Cria um <see cref="T:System.Linq.Expressions.NewExpression" /> que representa uma chamada ao construtor especificado com os argumentos especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2715">Creates a <see cref="T:System.Linq.Expressions.NewExpression" /> that represents calling the specified constructor with the specified arguments.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-2716">Um <see cref="T:System.Linq.Expressions.NewExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.New" /> e as propriedades <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> e <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2716">A <see cref="T:System.Linq.Expressions.NewExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.New" /> and the <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> and <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-2717">O `arguments` parâmetro deve conter o mesmo número de elementos que o número de parâmetros do construtor representado por `constructor`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2717">The `arguments` parameter must contain the same number of elements as the number of parameters for the constructor represented by `constructor`.</span></span> <span data-ttu-id="f7da9-2718">Se `arguments` está `null`, ele é considerado vazio e o <xref:System.Linq.Expressions.NewExpression.Arguments%2A> propriedade resultantes <xref:System.Linq.Expressions.NewExpression> é uma coleção vazia.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2718">If `arguments` is `null`, it is considered empty, and the <xref:System.Linq.Expressions.NewExpression.Arguments%2A> property of the resulting <xref:System.Linq.Expressions.NewExpression> is an empty collection.</span></span>  
  
 <span data-ttu-id="f7da9-2719">O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade resultantes <xref:System.Linq.Expressions.NewExpression> representa o tipo de declaração do construtor representado por `constructor`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2719">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.NewExpression> represents the declaring type of the constructor represented by `constructor`.</span></span> <span data-ttu-id="f7da9-2720">O <xref:System.Linq.Expressions.NewExpression.Members%2A> propriedade é uma coleção vazia.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2720">The <xref:System.Linq.Expressions.NewExpression.Members%2A> property is an empty collection.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f7da9-2721">
            <paramref name="constructor" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2721">
              <paramref name="constructor" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="f7da9-2722">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2722">-or-</span>
          </span>
          <span data-ttu-id="f7da9-2723">Um elemento de <paramref name="arguments" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2723">An element of <paramref name="arguments" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f7da9-2724">O parâmetro <paramref name="arguments" /> não contém o mesmo número de elementos que o número de parâmetros do construtor representado por <paramref name="constructor" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2724">The <paramref name="arguments" /> parameter does not contain the same number of elements as the number of parameters for the constructor that <paramref name="constructor" /> represents.</span>
          </span>
          <span data-ttu-id="f7da9-2725">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2725">-or-</span>
          </span>
          <span data-ttu-id="f7da9-2726">A propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> de um elemento de <paramref name="arguments" /> não pode ser atribuída ao tipo do parâmetro correspondente do construtor representado por <paramref name="constructor" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2726">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of an element of <paramref name="arguments" /> is not assignable to the type of the corresponding parameter of the constructor that <paramref name="constructor" /> represents.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="New">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewExpression New (System.Reflection.ConstructorInfo constructor, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewExpression New(class System.Reflection.ConstructorInfo constructor, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function New (constructor As ConstructorInfo, ParamArray arguments As Expression()) As NewExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::NewExpression ^ New(System::Reflection::ConstructorInfo ^ constructor, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member New : System.Reflection.ConstructorInfo * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.NewExpression" Usage="System.Linq.Expressions.Expression.New (constructor, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constructor" Type="System.Reflection.ConstructorInfo" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="constructor">
          <span data-ttu-id="f7da9-2727">O <see cref="T:System.Reflection.ConstructorInfo" /> com um valor igual ao qual a <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> propriedade será definida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2727">The <see cref="T:System.Reflection.ConstructorInfo" /> to set the <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> property equal to.</span>
          </span>
        </param>
        <param name="arguments">
          <span data-ttu-id="f7da9-2728">Uma matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> a serem usados para popular a coleção de <see cref="P:System.Linq.Expressions.NewExpression.Arguments" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2728">An array of <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-2729">Cria um <see cref="T:System.Linq.Expressions.NewExpression" /> que representa uma chamada ao construtor especificado com os argumentos especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2729">Creates a <see cref="T:System.Linq.Expressions.NewExpression" /> that represents calling the specified constructor with the specified arguments.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-2730">Um <see cref="T:System.Linq.Expressions.NewExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.New" /> e as propriedades <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> e <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2730">A <see cref="T:System.Linq.Expressions.NewExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.New" /> and the <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> and <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-2731">O `arguments` parâmetro deve conter o mesmo número de elementos que o número de parâmetros do construtor representado por `constructor`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2731">The `arguments` parameter must contain the same number of elements as the number of parameters for the constructor represented by `constructor`.</span></span> <span data-ttu-id="f7da9-2732">Se `arguments` está `null`, ele é considerado vazio e o <xref:System.Linq.Expressions.NewExpression.Arguments%2A> propriedade resultantes <xref:System.Linq.Expressions.NewExpression> é uma coleção vazia.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2732">If `arguments` is `null`, it is considered empty, and the <xref:System.Linq.Expressions.NewExpression.Arguments%2A> property of the resulting <xref:System.Linq.Expressions.NewExpression> is an empty collection.</span></span>  
  
 <span data-ttu-id="f7da9-2733">O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade resultantes <xref:System.Linq.Expressions.NewExpression> representa o tipo de declaração do construtor representado por `constructor`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2733">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.NewExpression> represents the declaring type of the constructor represented by `constructor`.</span></span> <span data-ttu-id="f7da9-2734">O <xref:System.Linq.Expressions.NewExpression.Members%2A> propriedade é uma coleção vazia.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2734">The <xref:System.Linq.Expressions.NewExpression.Members%2A> property is an empty collection.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f7da9-2735">
            <paramref name="constructor" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2735">
              <paramref name="constructor" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="f7da9-2736">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2736">-or-</span>
          </span>
          <span data-ttu-id="f7da9-2737">Um elemento de <paramref name="arguments" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2737">An element of <paramref name="arguments" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f7da9-2738">O tamanho de <paramref name="arguments" /> corresponde ao número de parâmetros do construtor representado por <paramref name="constructor" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2738">The length of <paramref name="arguments" /> does match the number of parameters for the constructor that <paramref name="constructor" /> represents.</span>
          </span>
          <span data-ttu-id="f7da9-2739">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2739">-or-</span>
          </span>
          <span data-ttu-id="f7da9-2740">A propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> de um elemento de <paramref name="arguments" /> não pode ser atribuída ao tipo do parâmetro correspondente do construtor representado por <paramref name="constructor" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2740">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of an element of <paramref name="arguments" /> is not assignable to the type of the corresponding parameter of the constructor that <paramref name="constructor" /> represents.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="New">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewExpression New (System.Reflection.ConstructorInfo constructor, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments, System.Collections.Generic.IEnumerable&lt;System.Reflection.MemberInfo&gt; members);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewExpression New(class System.Reflection.ConstructorInfo constructor, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments, class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.MemberInfo&gt; members) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression},System.Collections.Generic.IEnumerable{System.Reflection.MemberInfo})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function New (constructor As ConstructorInfo, arguments As IEnumerable(Of Expression), members As IEnumerable(Of MemberInfo)) As NewExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::NewExpression ^ New(System::Reflection::ConstructorInfo ^ constructor, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments, System::Collections::Generic::IEnumerable&lt;System::Reflection::MemberInfo ^&gt; ^ members);" />
      <MemberSignature Language="F#" Value="static member New : System.Reflection.ConstructorInfo * seq&lt;System.Linq.Expressions.Expression&gt; * seq&lt;System.Reflection.MemberInfo&gt; -&gt; System.Linq.Expressions.NewExpression" Usage="System.Linq.Expressions.Expression.New (constructor, arguments, members)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constructor" Type="System.Reflection.ConstructorInfo" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
        <Parameter Name="members" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.MemberInfo&gt;" />
      </Parameters>
      <Docs>
        <param name="constructor">
          <span data-ttu-id="f7da9-2741">O <see cref="T:System.Reflection.ConstructorInfo" /> com um valor igual ao qual a <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> propriedade será definida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2741">The <see cref="T:System.Reflection.ConstructorInfo" /> to set the <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> property equal to.</span>
          </span>
        </param>
        <param name="arguments">
          <span data-ttu-id="f7da9-2742">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.Expression" /> a serem usados para preencher a coleção de <see cref="P:System.Linq.Expressions.NewExpression.Arguments" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2742">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> collection.</span>
          </span>
        </param>
        <param name="members">
          <span data-ttu-id="f7da9-2743">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Reflection.MemberInfo" /> a serem usados para preencher a coleção de <see cref="P:System.Linq.Expressions.NewExpression.Members" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2743">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Reflection.MemberInfo" /> objects to use to populate the <see cref="P:System.Linq.Expressions.NewExpression.Members" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-2744">Cria um <see cref="T:System.Linq.Expressions.NewExpression" /> que representa uma chamada ao construtor especificado com os argumentos especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2744">Creates a <see cref="T:System.Linq.Expressions.NewExpression" /> that represents calling the specified constructor with the specified arguments.</span>
          </span>
          <span data-ttu-id="f7da9-2745">Os membros que acessam os campos inicializados pelo construtor são especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2745">The members that access the constructor initialized fields are specified.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-2746">Um <see cref="T:System.Linq.Expressions.NewExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.New" /> e as propriedades <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />, <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> e <see cref="P:System.Linq.Expressions.NewExpression.Members" /> definidas para os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2746">A <see cref="T:System.Linq.Expressions.NewExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.New" /> and the <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />, <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> and <see cref="P:System.Linq.Expressions.NewExpression.Members" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-2747">O `arguments` parâmetro deve conter o mesmo número de elementos que o número de parâmetros do construtor representado por `constructor`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2747">The `arguments` parameter must contain the same number of elements as the number of parameters for the constructor represented by `constructor`.</span></span> <span data-ttu-id="f7da9-2748">Se `arguments` está `null`, ele é considerado vazio e o <xref:System.Linq.Expressions.NewExpression.Arguments%2A> propriedade resultantes <xref:System.Linq.Expressions.NewExpression> é uma coleção vazia.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2748">If `arguments` is `null`, it is considered empty, and the <xref:System.Linq.Expressions.NewExpression.Arguments%2A> property of the resulting <xref:System.Linq.Expressions.NewExpression> is an empty collection.</span></span>  
  
 <span data-ttu-id="f7da9-2749">Se `members` está `null`, o <xref:System.Linq.Expressions.NewExpression.Members%2A> propriedade resultantes <xref:System.Linq.Expressions.NewExpression> é uma coleção vazia.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2749">If `members` is `null`, the <xref:System.Linq.Expressions.NewExpression.Members%2A> property of the resulting <xref:System.Linq.Expressions.NewExpression> is an empty collection.</span></span> <span data-ttu-id="f7da9-2750">Se `members` não é `null`, ele deve ter o mesmo número de elementos como `arguments` e cada elemento não deve ser `null`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2750">If `members` is not `null`, it must have the same number of elements as `arguments` and each element must not be `null`.</span></span> <span data-ttu-id="f7da9-2751">Cada elemento da `members` deve ser um <xref:System.Reflection.PropertyInfo>, <xref:System.Reflection.FieldInfo> ou <xref:System.Reflection.MethodInfo> que representa um membro de instância no tipo de declaração do construtor representado por `constructor`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2751">Each element of `members` must be a <xref:System.Reflection.PropertyInfo>, <xref:System.Reflection.FieldInfo> or <xref:System.Reflection.MethodInfo> that represents an instance member on the declaring type of the constructor represented by `constructor`.</span></span> <span data-ttu-id="f7da9-2752">Se ele representa uma propriedade, a propriedade deve ter um `get` acessador.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2752">If it represents a property, the property must have a `get` accessor.</span></span> <span data-ttu-id="f7da9-2753">O elemento correspondente de `arguments` para cada elemento de `members` deve ter uma <xref:System.Linq.Expressions.Expression.Type%2A> propriedade que representa um tipo que pode ser atribuído ao tipo do membro que o `members` elemento representa.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2753">The corresponding element of `arguments` for each element of `members` must have a <xref:System.Linq.Expressions.Expression.Type%2A> property that represents a type that is assignable to the type of the member that the `members` element represents.</span></span>  
  
 <span data-ttu-id="f7da9-2754">O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade resultantes <xref:System.Linq.Expressions.NewExpression> representa o tipo de declaração do construtor que `constructor` representa.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2754">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.NewExpression> represents the declaring type of the constructor that `constructor` represents.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f7da9-2755">
            <paramref name="constructor" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2755">
              <paramref name="constructor" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="f7da9-2756">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2756">-or-</span>
          </span>
          <span data-ttu-id="f7da9-2757">Um elemento de <paramref name="arguments" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2757">An element of <paramref name="arguments" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="f7da9-2758">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2758">-or-</span>
          </span>
          <span data-ttu-id="f7da9-2759">Um elemento de <paramref name="members" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2759">An element of <paramref name="members" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f7da9-2760">O parâmetro <paramref name="arguments" /> não contém o mesmo número de elementos que o número de parâmetros do construtor representado por <paramref name="constructor" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2760">The <paramref name="arguments" /> parameter does not contain the same number of elements as the number of parameters for the constructor that <paramref name="constructor" /> represents.</span>
          </span>
          <span data-ttu-id="f7da9-2761">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2761">-or-</span>
          </span>
          <span data-ttu-id="f7da9-2762">A propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> de um elemento de <paramref name="arguments" /> não pode ser atribuída ao tipo do parâmetro correspondente do construtor representado por <paramref name="constructor" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2762">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of an element of <paramref name="arguments" /> is not assignable to the type of the corresponding parameter of the constructor that <paramref name="constructor" /> represents.</span>
          </span>
          <span data-ttu-id="f7da9-2763">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2763">-or-</span>
          </span>
          <span data-ttu-id="f7da9-2764">O parâmetro <paramref name="members" /> não tem o mesmo número de elementos de <paramref name="arguments" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2764">The <paramref name="members" /> parameter does not have the same number of elements as <paramref name="arguments" />.</span>
          </span>
          <span data-ttu-id="f7da9-2765">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2765">-or-</span>
          </span>
          <span data-ttu-id="f7da9-2766">Um elemento de <paramref name="arguments" /> tem uma propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> que representa um tipo que não é atribuível ao tipo do membro que é representado pelo elemento correspondente de <paramref name="members" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2766">An element of <paramref name="arguments" /> has a <see cref="P:System.Linq.Expressions.Expression.Type" /> property that represents a type that is not assignable to the type of the member that is represented by the corresponding element of <paramref name="members" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="New">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewExpression New (System.Reflection.ConstructorInfo constructor, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments, params System.Reflection.MemberInfo[] members);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewExpression New(class System.Reflection.ConstructorInfo constructor, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments, class System.Reflection.MemberInfo[] members) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression},System.Reflection.MemberInfo[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function New (constructor As ConstructorInfo, arguments As IEnumerable(Of Expression), ParamArray members As MemberInfo()) As NewExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::NewExpression ^ New(System::Reflection::ConstructorInfo ^ constructor, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments, ... cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ members);" />
      <MemberSignature Language="F#" Value="static member New : System.Reflection.ConstructorInfo * seq&lt;System.Linq.Expressions.Expression&gt; * System.Reflection.MemberInfo[] -&gt; System.Linq.Expressions.NewExpression" Usage="System.Linq.Expressions.Expression.New (constructor, arguments, members)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constructor" Type="System.Reflection.ConstructorInfo" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
        <Parameter Name="members" Type="System.Reflection.MemberInfo[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="constructor">
          <span data-ttu-id="f7da9-2767">O <see cref="T:System.Reflection.ConstructorInfo" /> com um valor igual ao qual a <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> propriedade será definida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2767">The <see cref="T:System.Reflection.ConstructorInfo" /> to set the <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> property equal to.</span>
          </span>
        </param>
        <param name="arguments">
          <span data-ttu-id="f7da9-2768">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.Expression" /> a serem usados para preencher a coleção de <see cref="P:System.Linq.Expressions.NewExpression.Arguments" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2768">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> collection.</span>
          </span>
        </param>
        <param name="members">
          <span data-ttu-id="f7da9-2769">Uma matriz de objetos <see cref="T:System.Reflection.MemberInfo" /> a serem usados para popular a coleção de <see cref="P:System.Linq.Expressions.NewExpression.Members" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2769">An array of <see cref="T:System.Reflection.MemberInfo" /> objects to use to populate the <see cref="P:System.Linq.Expressions.NewExpression.Members" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-2770">Cria um <see cref="T:System.Linq.Expressions.NewExpression" /> que representa uma chamada ao construtor especificado com os argumentos especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2770">Creates a <see cref="T:System.Linq.Expressions.NewExpression" /> that represents calling the specified constructor with the specified arguments.</span>
          </span>
          <span data-ttu-id="f7da9-2771">Os membros que acessam os campos inicializados pelo construtor são especificados como uma matriz.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2771">The members that access the constructor initialized fields are specified as an array.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-2772">Um <see cref="T:System.Linq.Expressions.NewExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.New" /> e as propriedades <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />, <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> e <see cref="P:System.Linq.Expressions.NewExpression.Members" /> definidas para os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2772">A <see cref="T:System.Linq.Expressions.NewExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.New" /> and the <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />, <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> and <see cref="P:System.Linq.Expressions.NewExpression.Members" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-2773">O `arguments` parâmetro deve conter o mesmo número de elementos que o número de parâmetros do construtor representado por `constructor`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2773">The `arguments` parameter must contain the same number of elements as the number of parameters for the constructor represented by `constructor`.</span></span> <span data-ttu-id="f7da9-2774">Se `arguments` está `null`, ele é considerado vazio e o <xref:System.Linq.Expressions.NewExpression.Arguments%2A> propriedade resultantes <xref:System.Linq.Expressions.NewExpression> é uma coleção vazia.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2774">If `arguments` is `null`, it is considered empty, and the <xref:System.Linq.Expressions.NewExpression.Arguments%2A> property of the resulting <xref:System.Linq.Expressions.NewExpression> is an empty collection.</span></span>  
  
 <span data-ttu-id="f7da9-2775">Se `members` está `null`, o <xref:System.Linq.Expressions.NewExpression.Members%2A> propriedade resultantes <xref:System.Linq.Expressions.NewExpression> é uma coleção vazia.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2775">If `members` is `null`, the <xref:System.Linq.Expressions.NewExpression.Members%2A> property of the resulting <xref:System.Linq.Expressions.NewExpression> is an empty collection.</span></span> <span data-ttu-id="f7da9-2776">Se `members` não é `null`, ele deve ter o mesmo número de elementos como `arguments` e cada elemento não deve ser `null`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2776">If `members` is not `null`, it must have the same number of elements as `arguments` and each element must not be `null`.</span></span> <span data-ttu-id="f7da9-2777">Cada elemento da `members` deve ser um <xref:System.Reflection.PropertyInfo>, <xref:System.Reflection.FieldInfo> ou <xref:System.Reflection.MethodInfo> que representa um membro de instância no tipo de declaração do construtor representado por `constructor`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2777">Each element of `members` must be a <xref:System.Reflection.PropertyInfo>, <xref:System.Reflection.FieldInfo> or <xref:System.Reflection.MethodInfo> that represents an instance member on the declaring type of the constructor represented by `constructor`.</span></span> <span data-ttu-id="f7da9-2778">Se ele representa uma propriedade, a propriedade deve ser capaz de recuperar o valor do campo associado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2778">If it represents a property, the property must be able to retrieve the value of the associated field.</span></span> <span data-ttu-id="f7da9-2779">O elemento correspondente de `arguments` para cada elemento de `members` deve ter uma <xref:System.Linq.Expressions.Expression.Type%2A> propriedade que representa um tipo que pode ser atribuído ao tipo do membro que o `members` elemento representa.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2779">The corresponding element of `arguments` for each element of `members` must have a <xref:System.Linq.Expressions.Expression.Type%2A> property that represents a type that is assignable to the type of the member that the `members` element represents.</span></span>  
  
 <span data-ttu-id="f7da9-2780">O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade resultantes <xref:System.Linq.Expressions.NewExpression> representa o tipo de declaração do construtor que `constructor` representa.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2780">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.NewExpression> represents the declaring type of the constructor that `constructor` represents.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f7da9-2781">
            <paramref name="constructor" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2781">
              <paramref name="constructor" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="f7da9-2782">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2782">-or-</span>
          </span>
          <span data-ttu-id="f7da9-2783">Um elemento de <paramref name="arguments" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2783">An element of <paramref name="arguments" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="f7da9-2784">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2784">-or-</span>
          </span>
          <span data-ttu-id="f7da9-2785">Um elemento de <paramref name="members" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2785">An element of <paramref name="members" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f7da9-2786">O parâmetro <paramref name="arguments" /> não contém o mesmo número de elementos que o número de parâmetros do construtor representado por <paramref name="constructor" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2786">The <paramref name="arguments" /> parameter does not contain the same number of elements as the number of parameters for the constructor that <paramref name="constructor" /> represents.</span>
          </span>
          <span data-ttu-id="f7da9-2787">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2787">-or-</span>
          </span>
          <span data-ttu-id="f7da9-2788">A propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> de um elemento de <paramref name="arguments" /> não pode ser atribuída ao tipo do parâmetro correspondente do construtor representado por <paramref name="constructor" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2788">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of an element of <paramref name="arguments" /> is not assignable to the type of the corresponding parameter of the constructor that <paramref name="constructor" /> represents.</span>
          </span>
          <span data-ttu-id="f7da9-2789">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2789">-or-</span>
          </span>
          <span data-ttu-id="f7da9-2790">O parâmetro <paramref name="members" /> não tem o mesmo número de elementos de <paramref name="arguments" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2790">The <paramref name="members" /> parameter does not have the same number of elements as <paramref name="arguments" />.</span>
          </span>
          <span data-ttu-id="f7da9-2791">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2791">-or-</span>
          </span>
          <span data-ttu-id="f7da9-2792">Um elemento de <paramref name="arguments" /> tem uma propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> que representa um tipo que não é atribuível ao tipo do membro que é representado pelo elemento correspondente de <paramref name="members" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2792">An element of <paramref name="arguments" /> has a <see cref="P:System.Linq.Expressions.Expression.Type" /> property that represents a type that is not assignable to the type of the member that is represented by the corresponding element of <paramref name="members" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="NewArrayBounds">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f7da9-2793">Cria uma <see cref="T:System.Linq.Expressions.NewArrayExpression" /> que representa a criação de uma matriz que tem uma classificação especificada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2793">Creates a <see cref="T:System.Linq.Expressions.NewArrayExpression" /> that represents creating an array that has a specified rank.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="NewArrayBounds">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewArrayExpression NewArrayBounds (Type type, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; bounds);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewArrayExpression NewArrayBounds(class System.Type type, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; bounds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.NewArrayBounds(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::NewArrayExpression ^ NewArrayBounds(Type ^ type, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ bounds);" />
      <MemberSignature Language="F#" Value="static member NewArrayBounds : Type * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.NewArrayExpression" Usage="System.Linq.Expressions.Expression.NewArrayBounds (type, bounds)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewArrayExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="bounds" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="type">
          <span data-ttu-id="f7da9-2794">Um <see cref="T:System.Type" /> que representa o tipo de elemento da matriz.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2794">A <see cref="T:System.Type" /> that represents the element type of the array.</span>
          </span>
        </param>
        <param name="bounds">
          <span data-ttu-id="f7da9-2795">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.Expression" /> a serem usados para preencher a coleção de <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2795">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-2796">Cria uma <see cref="T:System.Linq.Expressions.NewArrayExpression" /> que representa a criação de uma matriz que tem uma classificação especificada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2796">Creates a <see cref="T:System.Linq.Expressions.NewArrayExpression" /> that represents creating an array that has a specified rank.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-2797">Uma <see cref="T:System.Linq.Expressions.NewArrayExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayBounds" /> e a propriedade <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> definida para o valor especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2797">A <see cref="T:System.Linq.Expressions.NewArrayExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayBounds" /> and the <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> property set to the specified value.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-2798">O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade resultantes <xref:System.Linq.Expressions.NewArrayExpression> representa um tipo de matriz cuja classificação é igual ao comprimento de `bounds` e cujo tipo de elemento é `type`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2798">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.NewArrayExpression> represents an array type whose rank is equal to the length of `bounds` and whose element type is `type`.</span></span>  
  
 <span data-ttu-id="f7da9-2799">O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade de cada elemento da `bounds` deve representar um tipo integral.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2799">The <xref:System.Linq.Expressions.Expression.Type%2A> property of each element of `bounds` must represent an integral type.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f7da9-2800">O exemplo a seguir demonstra como usar o <xref:System.Linq.Expressions.Expression.NewArrayBounds%2A> método para criar uma árvore de expressão que representa a criação de uma matriz de cadeia de caracteres que tem uma classificação de 2.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2800">The following example demonstrates how to use the <xref:System.Linq.Expressions.Expression.NewArrayBounds%2A> method to create an expression tree that represents creating a string array that has a rank of 2.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.Expression#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#2)]
 [!code-vb[System.Linq.Expressions.Expression#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f7da9-2801">
            <paramref name="type" /> ou <paramref name="bounds" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2801">
              <paramref name="type" /> or <paramref name="bounds" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="f7da9-2802">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2802">-or-</span>
          </span>
          <span data-ttu-id="f7da9-2803">Um elemento de <paramref name="bounds" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2803">An element of <paramref name="bounds" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f7da9-2804">A propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> de um elemento de <paramref name="bounds" /> não representa um tipo integral.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2804">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of an element of <paramref name="bounds" /> does not represent an integral type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="NewArrayBounds">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewArrayExpression NewArrayBounds (Type type, params System.Linq.Expressions.Expression[] bounds);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewArrayExpression NewArrayBounds(class System.Type type, class System.Linq.Expressions.Expression[] bounds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.NewArrayBounds(System.Type,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::NewArrayExpression ^ NewArrayBounds(Type ^ type, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ bounds);" />
      <MemberSignature Language="F#" Value="static member NewArrayBounds : Type * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.NewArrayExpression" Usage="System.Linq.Expressions.Expression.NewArrayBounds (type, bounds)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewArrayExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="bounds" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="type">
          <span data-ttu-id="f7da9-2805">Um <see cref="T:System.Type" /> que representa o tipo de elemento da matriz.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2805">A <see cref="T:System.Type" /> that represents the element type of the array.</span>
          </span>
        </param>
        <param name="bounds">
          <span data-ttu-id="f7da9-2806">Uma matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> a serem usados para popular a coleção de <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2806">An array of <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-2807">Cria uma <see cref="T:System.Linq.Expressions.NewArrayExpression" /> que representa a criação de uma matriz que tem uma classificação especificada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2807">Creates a <see cref="T:System.Linq.Expressions.NewArrayExpression" /> that represents creating an array that has a specified rank.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-2808">Uma <see cref="T:System.Linq.Expressions.NewArrayExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayBounds" /> e a propriedade <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> definida para o valor especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2808">A <see cref="T:System.Linq.Expressions.NewArrayExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayBounds" /> and the <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> property set to the specified value.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-2809">O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade resultantes <xref:System.Linq.Expressions.NewArrayExpression> representa um tipo de matriz cuja classificação é igual ao comprimento de `bounds` e cujo tipo de elemento é `type`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2809">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.NewArrayExpression> represents an array type whose rank is equal to the length of `bounds` and whose element type is `type`.</span></span>  
  
 <span data-ttu-id="f7da9-2810">O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade de cada elemento da `bounds` deve representar um tipo integral.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2810">The <xref:System.Linq.Expressions.Expression.Type%2A> property of each element of `bounds` must represent an integral type.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f7da9-2811">O exemplo a seguir demonstra como usar o <xref:System.Linq.Expressions.Expression.NewArrayBounds%2A> método para criar uma árvore de expressão que representa a criação de uma matriz de cadeia de caracteres que tem uma classificação de 2.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2811">The following example demonstrates how to use the <xref:System.Linq.Expressions.Expression.NewArrayBounds%2A> method to create an expression tree that represents creating a string array that has a rank of 2.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.Expression#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#2)]
 [!code-vb[System.Linq.Expressions.Expression#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f7da9-2812">
            <paramref name="type" /> ou <paramref name="bounds" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2812">
              <paramref name="type" /> or <paramref name="bounds" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="f7da9-2813">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2813">-or-</span>
          </span>
          <span data-ttu-id="f7da9-2814">Um elemento de <paramref name="bounds" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2814">An element of <paramref name="bounds" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f7da9-2815">A propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> de um elemento de <paramref name="bounds" /> não representa um tipo integral.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2815">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of an element of <paramref name="bounds" /> does not represent an integral type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="NewArrayInit">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f7da9-2816">Cria um <see cref="T:System.Linq.Expressions.NewArrayExpression" /> que representa a criação de uma matriz unidimensional e a inicialização dela de uma lista de elementos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2816">Creates a <see cref="T:System.Linq.Expressions.NewArrayExpression" /> that represents creating a one-dimensional array and initializing it from a list of elements.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="NewArrayInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewArrayExpression NewArrayInit (Type type, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewArrayExpression NewArrayInit(class System.Type type, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.NewArrayInit(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::NewArrayExpression ^ NewArrayInit(Type ^ type, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ initializers);" />
      <MemberSignature Language="F#" Value="static member NewArrayInit : Type * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.NewArrayExpression" Usage="System.Linq.Expressions.Expression.NewArrayInit (type, initializers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewArrayExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="initializers" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="type">
          <span data-ttu-id="f7da9-2817">Um <see cref="T:System.Type" /> que representa o tipo de elemento da matriz.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2817">A <see cref="T:System.Type" /> that represents the element type of the array.</span>
          </span>
        </param>
        <param name="initializers">
          <span data-ttu-id="f7da9-2818">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém objetos <see cref="T:System.Linq.Expressions.Expression" /> a serem usados para preencher a coleção de <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2818">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-2819">Cria um <see cref="T:System.Linq.Expressions.NewArrayExpression" /> que representa a criação de uma matriz unidimensional e a inicialização dela de uma lista de elementos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2819">Creates a <see cref="T:System.Linq.Expressions.NewArrayExpression" /> that represents creating a one-dimensional array and initializing it from a list of elements.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-2820">Uma <see cref="T:System.Linq.Expressions.NewArrayExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayInit" /> e a propriedade <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> definida para o valor especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2820">A <see cref="T:System.Linq.Expressions.NewArrayExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayInit" /> and the <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> property set to the specified value.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-2821">O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade de cada elemento de `initializers` deve representar um tipo que pode ser atribuído ao tipo representado pela `type`, possivelmente depois que estiver *entre aspas*.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2821">The <xref:System.Linq.Expressions.Expression.Type%2A> property of each element of `initializers` must represent a type that is assignable to the type represented by `type`, possibly after it is *quoted*.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f7da9-2822">Um elemento será ser colocado entre aspas somente se `type` é <xref:System.Linq.Expressions.Expression>.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2822">An element will be quoted only if `type` is <xref:System.Linq.Expressions.Expression>.</span></span> <span data-ttu-id="f7da9-2823">Delimitação significa que o elemento é encapsulado em um <xref:System.Linq.Expressions.ExpressionType.Quote> nó.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2823">Quoting means the element is wrapped in a <xref:System.Linq.Expressions.ExpressionType.Quote> node.</span></span> <span data-ttu-id="f7da9-2824">O nó resultante é um <xref:System.Linq.Expressions.UnaryExpression> cujos <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> propriedade é o elemento de `initializers`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2824">The resulting node is a <xref:System.Linq.Expressions.UnaryExpression> whose <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> property is the element of `initializers`.</span></span>  
  
 <span data-ttu-id="f7da9-2825">O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade resultantes <xref:System.Linq.Expressions.NewArrayExpression> representa uma matriz de tipo cuja posição é 1 e cujo tipo de elemento é `type`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2825">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.NewArrayExpression> represents an array type whose rank is 1 and whose element type is `type`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f7da9-2826">O exemplo a seguir demonstra como usar o <xref:System.Linq.Expressions.Expression.NewArrayInit%2A> método para criar uma árvore de expressão que representa a criação de uma matriz unidimensional de cadeia de caracteres que é inicializado com uma lista de expressões de cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2826">The following example demonstrates how to use the <xref:System.Linq.Expressions.Expression.NewArrayInit%2A> method to create an expression tree that represents creating a one-dimensional string array that is initialized with a list of string expressions.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.Expression#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#1)]
 [!code-vb[System.Linq.Expressions.Expression#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f7da9-2827">
            <paramref name="type" /> ou <paramref name="initializers" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2827">
              <paramref name="type" /> or <paramref name="initializers" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="f7da9-2828">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2828">-or-</span>
          </span>
          <span data-ttu-id="f7da9-2829">Um elemento de <paramref name="initializers" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2829">An element of <paramref name="initializers" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f7da9-2830">A propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> de um elemento <paramref name="initializers" /> representa um tipo que não é atribuível ao tipo representado por <paramref name="type" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2830">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of an element of <paramref name="initializers" /> represents a type that is not assignable to the type that <paramref name="type" /> represents.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="NewArrayInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewArrayExpression NewArrayInit (Type type, params System.Linq.Expressions.Expression[] initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewArrayExpression NewArrayInit(class System.Type type, class System.Linq.Expressions.Expression[] initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.NewArrayInit(System.Type,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::NewArrayExpression ^ NewArrayInit(Type ^ type, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ initializers);" />
      <MemberSignature Language="F#" Value="static member NewArrayInit : Type * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.NewArrayExpression" Usage="System.Linq.Expressions.Expression.NewArrayInit (type, initializers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewArrayExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="initializers" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="type">
          <span data-ttu-id="f7da9-2831">Um <see cref="T:System.Type" /> que representa o tipo de elemento da matriz.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2831">A <see cref="T:System.Type" /> that represents the element type of the array.</span>
          </span>
        </param>
        <param name="initializers">
          <span data-ttu-id="f7da9-2832">Uma matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> a serem usados para popular a coleção de <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2832">An array of <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-2833">Cria um <see cref="T:System.Linq.Expressions.NewArrayExpression" /> que representa a criação de uma matriz unidimensional e a inicialização dela de uma lista de elementos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2833">Creates a <see cref="T:System.Linq.Expressions.NewArrayExpression" /> that represents creating a one-dimensional array and initializing it from a list of elements.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-2834">Uma <see cref="T:System.Linq.Expressions.NewArrayExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayInit" /> e a propriedade <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> definida para o valor especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2834">A <see cref="T:System.Linq.Expressions.NewArrayExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayInit" /> and the <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> property set to the specified value.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-2835">O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade de cada elemento de `initializers` deve representar um tipo que pode ser atribuído ao tipo representado pela `type`, possivelmente depois que estiver *entre aspas*.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2835">The <xref:System.Linq.Expressions.Expression.Type%2A> property of each element of `initializers` must represent a type that is assignable to the type represented by `type`, possibly after it is *quoted*.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f7da9-2836">Um elemento será ser colocado entre aspas somente se `type` é <xref:System.Linq.Expressions.Expression>.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2836">An element will be quoted only if `type` is <xref:System.Linq.Expressions.Expression>.</span></span> <span data-ttu-id="f7da9-2837">Delimitação significa que o elemento é encapsulado em um <xref:System.Linq.Expressions.ExpressionType.Quote> nó.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2837">Quoting means the element is wrapped in a <xref:System.Linq.Expressions.ExpressionType.Quote> node.</span></span> <span data-ttu-id="f7da9-2838">O nó resultante é um <xref:System.Linq.Expressions.UnaryExpression> cujos <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> propriedade é o elemento de `initializers`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2838">The resulting node is a <xref:System.Linq.Expressions.UnaryExpression> whose <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> property is the element of `initializers`.</span></span>  
  
 <span data-ttu-id="f7da9-2839">O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade resultantes <xref:System.Linq.Expressions.NewArrayExpression> representa uma matriz de tipo cuja posição é 1 e cujo tipo de elemento é `type`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2839">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.NewArrayExpression> represents an array type whose rank is 1 and whose element type is `type`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f7da9-2840">O exemplo a seguir demonstra como usar o <xref:System.Linq.Expressions.Expression.NewArrayInit%2A> método para criar uma árvore de expressão que representa a criação de uma matriz unidimensional de cadeia de caracteres que é inicializado com uma lista de expressões de cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2840">The following example demonstrates how to use the <xref:System.Linq.Expressions.Expression.NewArrayInit%2A> method to create an expression tree that represents creating a one-dimensional string array that is initialized with a list of string expressions.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.Expression#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#1)]
 [!code-vb[System.Linq.Expressions.Expression#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f7da9-2841">
            <paramref name="type" /> ou <paramref name="initializers" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2841">
              <paramref name="type" /> or <paramref name="initializers" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="f7da9-2842">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2842">-or-</span>
          </span>
          <span data-ttu-id="f7da9-2843">Um elemento de <paramref name="initializers" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2843">An element of <paramref name="initializers" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f7da9-2844">A propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> de um elemento de <paramref name="initializers" /> representa um tipo que não é atribuível ao tipo <paramref name="type" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2844">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of an element of <paramref name="initializers" /> represents a type that is not assignable to the type <paramref name="type" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="NodeType">
      <MemberSignature Language="C#" Value="public virtual System.Linq.Expressions.ExpressionType NodeType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Linq.Expressions.ExpressionType NodeType" />
      <MemberSignature Language="DocId" Value="P:System.Linq.Expressions.Expression.NodeType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property NodeType As ExpressionType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Linq::Expressions::ExpressionType NodeType { System::Linq::Expressions::ExpressionType get(); };" />
      <MemberSignature Language="F#" Value="member this.NodeType : System.Linq.Expressions.ExpressionType" Usage="System.Linq.Expressions.Expression.NodeType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ExpressionType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f7da9-2845">Obtém o tipo de nó deste <see cref="T:System.Linq.Expressions.Expression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2845">Gets the node type of this <see cref="T:System.Linq.Expressions.Expression" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="f7da9-2846">Um dos valores de <see cref="T:System.Linq.Expressions.ExpressionType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2846">One of the <see cref="T:System.Linq.Expressions.ExpressionType" /> values.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-2847">O <xref:System.Linq.Expressions.Expression.NodeType%2A> propriedade fornece uma descrição mais especializada de um <xref:System.Linq.Expressions.Expression> que apenas seu tipo derivado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2847">The <xref:System.Linq.Expressions.Expression.NodeType%2A> property provides a more specialized description of an <xref:System.Linq.Expressions.Expression> than just its derived type.</span></span> <span data-ttu-id="f7da9-2848">Por exemplo, um <xref:System.Linq.Expressions.BinaryExpression> pode ser usado para representar muitos tipos diferentes de expressões binárias, como uma operação de divisão ou uma operação "maior que".</span><span class="sxs-lookup"><span data-stu-id="f7da9-2848">For example, a <xref:System.Linq.Expressions.BinaryExpression> can be used to represent many different kinds of binary expressions, such as a division operation or a "greater than" operation.</span></span> <span data-ttu-id="f7da9-2849">O <xref:System.Linq.Expressions.Expression.NodeType%2A> propriedade descreveria essas expressões binárias, como <xref:System.Linq.Expressions.ExpressionType.Divide> e <xref:System.Linq.Expressions.ExpressionType.GreaterThan>, respectivamente.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2849">The <xref:System.Linq.Expressions.Expression.NodeType%2A> property would describe these binary expressions as <xref:System.Linq.Expressions.ExpressionType.Divide> and <xref:System.Linq.Expressions.ExpressionType.GreaterThan>, respectively.</span></span>  
  
 <span data-ttu-id="f7da9-2850">O tipo CLR estático da expressão que o <xref:System.Linq.Expressions.Expression> representa de objeto é representado pelo <xref:System.Linq.Expressions.Expression.Type%2A> propriedade.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2850">The static CLR type of the expression that the <xref:System.Linq.Expressions.Expression> object represents is represented by the <xref:System.Linq.Expressions.Expression.Type%2A> property.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Not">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f7da9-2851">Cria um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa uma operação de complemento bit a bit.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2851">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a bitwise complement operation.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Not">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Not (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Not(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Not(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Not(System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member Not : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Not expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression">
          <span data-ttu-id="f7da9-2852">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2852">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-2853">Cria um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa uma operação de complemento bit a bit.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2853">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a bitwise complement operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-2854">Uma <see cref="T:System.Linq.Expressions.UnaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Not" /> e a propriedade <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> definida para o valor especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2854">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Not" /> and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property set to the specified value.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-2855">O <xref:System.Linq.Expressions.UnaryExpression.Method%2A> propriedade resultantes <xref:System.Linq.Expressions.UnaryExpression> é definido como o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2855">The <xref:System.Linq.Expressions.UnaryExpression.Method%2A> property of the resulting <xref:System.Linq.Expressions.UnaryExpression> is set to the implementing method.</span></span> <span data-ttu-id="f7da9-2856">O <xref:System.Linq.Expressions.Expression.Type%2A> estiver definida como o tipo de nó.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2856">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="f7da9-2857">Se o nó é elevado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> e <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriedades estiverem `true`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2857">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="f7da9-2858">Caso contrário, eles são `false`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2858">Otherwise, they are `false`.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="f7da9-2859">Implementando método</span><span class="sxs-lookup"><span data-stu-id="f7da9-2859">Implementing Method</span></span>  
 <span data-ttu-id="f7da9-2860">As regras a seguir determinam o método de implementação para a operação:</span><span class="sxs-lookup"><span data-stu-id="f7da9-2860">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="f7da9-2861">Se `expression`. Tipo é um tipo definido pelo usuário que define o não operador unário de <xref:System.Reflection.MethodInfo> que representa que o método de implementação do operador é.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2861">If `expression`.Type is a user-defined type that defines the unary not operator, the <xref:System.Reflection.MethodInfo> that represents that operator is the implementing method.</span></span>  
  
-   <span data-ttu-id="f7da9-2862">Caso contrário, se `expression`. É um tipo numérico ou booliano, o método de implementação é `null`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2862">Otherwise, if `expression`.Type is a numeric or Boolean type, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="f7da9-2863">Tipo de nó e versão com comparação de precisão x sem comparação de precisão</span><span class="sxs-lookup"><span data-stu-id="f7da9-2863">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="f7da9-2864">Se o método de implementação não for `null`:</span><span class="sxs-lookup"><span data-stu-id="f7da9-2864">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="f7da9-2865">Se `expression`. O tipo é atribuível ao tipo de argumento do método de implementação, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2865">If `expression`.Type is assignable to the argument type of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="f7da9-2866">O tipo do nó é o tipo de retorno do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2866">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="f7da9-2867">Se as duas seguintes condições forem atendidas, o nó é levantado e o tipo de nó é o tipo que permite valor nulo que corresponde ao tipo de retorno do método de implementação:</span><span class="sxs-lookup"><span data-stu-id="f7da9-2867">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="f7da9-2868">`expression`. É um tipo de valor anulável e o tipo não anulável correspondente é igual ao tipo de argumento do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2868">`expression`.Type is a nullable value type and the corresponding non-nullable type is equal to the argument type of the implementing method.</span></span>  
  
    -   <span data-ttu-id="f7da9-2869">O tipo de retorno do método de implementação é um tipo de valor não anulável.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2869">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="f7da9-2870">Se for o método de implementação `null`, o tipo de nó é `expression`. Tipo.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2870">If the implementing method is `null`, the type of the node is `expression`.Type.</span></span> <span data-ttu-id="f7da9-2871">Se `expression`. Tipo não anulável, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2871">If `expression`.Type is non-nullable, the node is not lifted.</span></span> <span data-ttu-id="f7da9-2872">Caso contrário, o nó é eliminado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2872">Otherwise, the node is lifted.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f7da9-2873">O exemplo a seguir demonstra como criar uma expressão que representa uma operação lógica não a operação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2873">The following example demonstrates how to create an expression that represents a logical NOT operation.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#51](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#51)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#51](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#51)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f7da9-2874">
            <paramref name="expression" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2874">
              <paramref name="expression" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f7da9-2875">O não operador unário não é definido para <paramref name="expression" />.Type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2875">The unary not operator is not defined for <paramref name="expression" />.Type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Not">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Not (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Not(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Not(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Not(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member Not : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Not (expression, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">
          <span data-ttu-id="f7da9-2876">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2876">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="f7da9-2877">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2877">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-2878">Cria um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa uma operação de complemento bit a bit.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2878">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a bitwise complement operation.</span>
          </span>
          <span data-ttu-id="f7da9-2879">O método de implementação pode ser especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2879">The implementing method can be specified.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-2880">Um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Not" /> e as propriedades <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> e <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2880">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Not" /> and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> and <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-2881">O <xref:System.Linq.Expressions.UnaryExpression.Method%2A> propriedade resultantes <xref:System.Linq.Expressions.UnaryExpression> é definido como o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2881">The <xref:System.Linq.Expressions.UnaryExpression.Method%2A> property of the resulting <xref:System.Linq.Expressions.UnaryExpression> is set to the implementing method.</span></span> <span data-ttu-id="f7da9-2882">O <xref:System.Linq.Expressions.Expression.Type%2A> estiver definida como o tipo de nó.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2882">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="f7da9-2883">Se o nó é elevado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> e <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriedades estiverem `true`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2883">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="f7da9-2884">Caso contrário, eles são `false`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2884">Otherwise, they are `false`.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="f7da9-2885">Implementando método</span><span class="sxs-lookup"><span data-stu-id="f7da9-2885">Implementing Method</span></span>  
 <span data-ttu-id="f7da9-2886">As regras a seguir determinam o método de implementação para a operação:</span><span class="sxs-lookup"><span data-stu-id="f7da9-2886">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="f7da9-2887">Se `method` não é `null` e representa um não-nulo, `static` (`Shared` no Visual Basic) método que aceita um argumento, ele é o método de implementação para o nó.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2887">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes one argument, it is the implementing method for the node.</span></span>  
  
-   <span data-ttu-id="f7da9-2888">Se `expression`. Tipo é um tipo definido pelo usuário que define o não operador unário de <xref:System.Reflection.MethodInfo> que representa que o método de implementação do operador é.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2888">If `expression`.Type is a user-defined type that defines the unary not operator, the <xref:System.Reflection.MethodInfo> that represents that operator is the implementing method.</span></span>  
  
-   <span data-ttu-id="f7da9-2889">Caso contrário, se `expression`. Tipo é um tipo numérico, o método de implementação é `null`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2889">Otherwise, if `expression`.Type is a numeric type, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="f7da9-2890">Tipo de nó e versão com comparação de precisão x sem comparação de precisão</span><span class="sxs-lookup"><span data-stu-id="f7da9-2890">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="f7da9-2891">Se o método de implementação não for `null`:</span><span class="sxs-lookup"><span data-stu-id="f7da9-2891">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="f7da9-2892">Se `expression`. O tipo é atribuível ao tipo de argumento do método de implementação, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2892">If `expression`.Type is assignable to the argument type of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="f7da9-2893">O tipo do nó é o tipo de retorno do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2893">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="f7da9-2894">Se as duas seguintes condições forem atendidas, o nó é levantado e o tipo de nó é o tipo que permite valor nulo que corresponde ao tipo de retorno do método de implementação:</span><span class="sxs-lookup"><span data-stu-id="f7da9-2894">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="f7da9-2895">`expression`. É um tipo de valor anulável e o tipo de valor não anulável correspondente é igual ao tipo de argumento do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2895">`expression`.Type is a nullable value type and the corresponding non-nullable value type is equal to the argument type of the implementing method.</span></span>  
  
    -   <span data-ttu-id="f7da9-2896">O tipo de retorno do método de implementação é um tipo de valor não anulável.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2896">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="f7da9-2897">Se for o método de implementação `null`, o tipo de nó é `expression`. Tipo.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2897">If the implementing method is `null`, the type of the node is `expression`.Type.</span></span> <span data-ttu-id="f7da9-2898">Se `expression`. Tipo não anulável, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2898">If `expression`.Type is non-nullable, the node is not lifted.</span></span> <span data-ttu-id="f7da9-2899">Caso contrário, o nó é eliminado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2899">Otherwise, the node is lifted.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f7da9-2900">
            <paramref name="expression" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2900">
              <paramref name="expression" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f7da9-2901">
            <paramref name="method" /> não é <see langword="null" /> e o método que ele representa retorna <see langword="void" />, não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) ou não tem exatamente um argumento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2901">
              <paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly one argument.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f7da9-2902">
            <paramref name="method" /> é <see langword="null" /> e o operador não unário não foi definido para <paramref name="expression" />.Type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2902">
              <paramref name="method" /> is <see langword="null" /> and the unary not operator is not defined for <paramref name="expression" />.Type.</span>
          </span>
          <span data-ttu-id="f7da9-2903">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2903">-or-</span>
          </span>
          <span data-ttu-id="f7da9-2904">
            <paramref name="expression" />.Type (ou o respectivo tipo que não permite valor nulo correspondente se ele é um tipo que permite valor nulo) não é atribuível ao tipo de argumento do método representado por <paramref name="method" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2904">
              <paramref name="expression" />.Type (or its corresponding non-nullable type if it is a nullable value type) is not assignable to the argument type of the method represented by <paramref name="method" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="NotEqual">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f7da9-2905">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma comparação de desigualdade.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2905">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an inequality comparison.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="NotEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression NotEqual (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression NotEqual(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.NotEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function NotEqual (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ NotEqual(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member NotEqual : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.NotEqual (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="f7da9-2906">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2906">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="f7da9-2907">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2907">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-2908">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma comparação de desigualdade.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2908">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an inequality comparison.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-2909">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.NotEqual" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2909">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.NotEqual" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-2910">Resultante <xref:System.Linq.Expressions.BinaryExpression> tem o <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriedade definida como o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2910">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="f7da9-2911">O <xref:System.Linq.Expressions.Expression.Type%2A> estiver definida como o tipo de nó.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2911">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="f7da9-2912">Se o nó é elevado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> é de propriedade `true`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2912">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> property is `true`.</span></span> <span data-ttu-id="f7da9-2913">Caso contrário, será `false`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2913">Otherwise, it is `false`.</span></span> <span data-ttu-id="f7da9-2914">A propriedade <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> sempre é `false`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2914">The <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> property is always `false`.</span></span> <span data-ttu-id="f7da9-2915">A propriedade <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> é `null`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2915">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="f7da9-2916">As informações a seguir descrevem o método de implementação, o tipo de nó, e se um nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2916">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="f7da9-2917">Implementando método</span><span class="sxs-lookup"><span data-stu-id="f7da9-2917">Implementing Method</span></span>  
 <span data-ttu-id="f7da9-2918">As regras a seguir determinam o método de implementação para a operação:</span><span class="sxs-lookup"><span data-stu-id="f7da9-2918">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="f7da9-2919">Se o <xref:System.Linq.Expressions.Expression.Type%2A> propriedade deles `left` ou `right` representa um tipo definido pelo usuário que sobrecarrega o operador de desigualdade, o <xref:System.Reflection.MethodInfo> que representa que o método é o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2919">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the inequality operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="f7da9-2920">Caso contrário, o método de implementação é `null`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2920">Otherwise, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="f7da9-2921">Tipo de nó e versão com comparação de precisão x sem comparação de precisão</span><span class="sxs-lookup"><span data-stu-id="f7da9-2921">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="f7da9-2922">Se o método de implementação não for `null`:</span><span class="sxs-lookup"><span data-stu-id="f7da9-2922">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="f7da9-2923">Se `left`. Tipo e `right`. Tipo podem ser atribuídos aos tipos de argumento correspondente do método de implementação, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2923">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="f7da9-2924">O tipo do nó é o tipo de retorno do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2924">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="f7da9-2925">Se as duas seguintes condições forem atendidas, o nó é elevado e o tipo de nó é <xref:System.Boolean>:</span><span class="sxs-lookup"><span data-stu-id="f7da9-2925">If the following two conditions are satisfied, the node is lifted and the type of the node is <xref:System.Boolean>:</span></span>  
  
    -   <span data-ttu-id="f7da9-2926">`left`. Tipo e `right`. Tipo são os dois tipos de valor de que pelo menos um é anulável e os tipos não anuláveis correspondentes são iguais para os tipos de argumento correspondente do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2926">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="f7da9-2927">O tipo de retorno do método de implementação é <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2927">The return type of the implementing method is <xref:System.Boolean>.</span></span>  
  
 <span data-ttu-id="f7da9-2928">Se o método de implementação é `null`:</span><span class="sxs-lookup"><span data-stu-id="f7da9-2928">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="f7da9-2929">Se `left`. Tipo e `right`. Tipo são não anuláveis, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2929">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="f7da9-2930">O tipo de nó é <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2930">The type of the node is <xref:System.Boolean>.</span></span>  
  
-   <span data-ttu-id="f7da9-2931">Se `left`. Tipo e `right`. Tipo são anuláveis, o nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2931">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="f7da9-2932">O tipo de nó é <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2932">The type of the node is <xref:System.Boolean>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f7da9-2933">
            <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2933">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f7da9-2934">O operador de desigualdade não está definido como <paramref name="left" />.Type e <paramref name="right" />.Type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2934">The inequality operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="NotEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression NotEqual (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, bool liftToNull, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression NotEqual(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, bool liftToNull, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.NotEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function NotEqual (left As Expression, right As Expression, liftToNull As Boolean, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ NotEqual(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, bool liftToNull, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member NotEqual : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * bool * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.NotEqual (left, right, liftToNull, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="liftToNull" Type="System.Boolean" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="f7da9-2935">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2935">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="f7da9-2936">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2936">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="liftToNull">
          <span data-ttu-id="f7da9-2937">
            <see langword="true" /> para definir <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> como <see langword="true" />; <see langword="false" /> para definir <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> como <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2937">
              <see langword="true" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="true" />; <see langword="false" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="false" />.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="f7da9-2938">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2938">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-2939">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma comparação de desigualdade.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2939">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an inequality comparison.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-2940">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.NotEqual" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2940">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.NotEqual" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-2941">Resultante <xref:System.Linq.Expressions.BinaryExpression> tem o <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriedade definida como o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2941">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="f7da9-2942">O <xref:System.Linq.Expressions.Expression.Type%2A> estiver definida como o tipo de nó.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2942">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="f7da9-2943">Se o nó é elevado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> é de propriedade `true` e o <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriedade é igual a `liftToNull`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2943">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> property is `true` and the <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> property is equal to `liftToNull`.</span></span> <span data-ttu-id="f7da9-2944">Caso contrário, eles são ambos `false`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2944">Otherwise, they are both `false`.</span></span> <span data-ttu-id="f7da9-2945">A propriedade <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> é `null`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2945">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="f7da9-2946">As informações a seguir descrevem o método de implementação, o tipo de nó, e se um nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2946">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="f7da9-2947">Implementando método</span><span class="sxs-lookup"><span data-stu-id="f7da9-2947">Implementing Method</span></span>  
 <span data-ttu-id="f7da9-2948">As regras a seguir determinam o método de implementação para a operação:</span><span class="sxs-lookup"><span data-stu-id="f7da9-2948">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="f7da9-2949">Se `method` não é `null` e representa um não-nulo, `static` (`Shared` no Visual Basic) método que usa dois argumentos, é o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2949">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method.</span></span>  
  
-   <span data-ttu-id="f7da9-2950">Caso contrário, se o <xref:System.Linq.Expressions.Expression.Type%2A> propriedade deles `left` ou `right` representa um tipo definido pelo usuário que sobrecarrega o operador de desigualdade, o <xref:System.Reflection.MethodInfo> que representa que o método é o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2950">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the inequality operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="f7da9-2951">Caso contrário, o método de implementação é `null`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2951">Otherwise, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="f7da9-2952">Tipo de nó e versão com comparação de precisão x sem comparação de precisão</span><span class="sxs-lookup"><span data-stu-id="f7da9-2952">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="f7da9-2953">Se o método de implementação não for `null`:</span><span class="sxs-lookup"><span data-stu-id="f7da9-2953">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="f7da9-2954">Se `left`. Tipo e `right`. Tipo podem ser atribuídos aos tipos de argumento correspondente do método de implementação, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2954">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="f7da9-2955">O tipo do nó é o tipo de retorno do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2955">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="f7da9-2956">Se as duas seguintes condições forem atendidas, o nó é eliminado; Além disso, o tipo do nó é anulável <xref:System.Boolean> se `liftToNull` é `true` ou <xref:System.Boolean> se `liftToNull` é `false`:</span><span class="sxs-lookup"><span data-stu-id="f7da9-2956">If the following two conditions are satisfied, the node is lifted; also, the type of the node is nullable <xref:System.Boolean> if `liftToNull` is `true` or <xref:System.Boolean> if `liftToNull` is `false`:</span></span>  
  
    -   <span data-ttu-id="f7da9-2957">`left`. Tipo e `right`. Tipo são os dois tipos de valor de que pelo menos um é anulável e os tipos não anuláveis correspondentes são iguais para os tipos de argumento correspondente do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2957">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="f7da9-2958">O tipo de retorno do método de implementação é <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2958">The return type of the implementing method is <xref:System.Boolean>.</span></span>  
  
 <span data-ttu-id="f7da9-2959">Se o método de implementação é `null`:</span><span class="sxs-lookup"><span data-stu-id="f7da9-2959">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="f7da9-2960">Se `left`. Tipo e `right`. Tipo são não anuláveis, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2960">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="f7da9-2961">O tipo de nó é <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2961">The type of the node is <xref:System.Boolean>.</span></span>  
  
-   <span data-ttu-id="f7da9-2962">Se `left`. Tipo e `right`. Tipo são anuláveis, o nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2962">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="f7da9-2963">O tipo do nó é anulável <xref:System.Boolean> se `liftToNull` é `true` ou <xref:System.Boolean> se `liftToNull` é `false`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2963">The type of the node is nullable <xref:System.Boolean> if `liftToNull` is `true` or <xref:System.Boolean> if `liftToNull` is `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f7da9-2964">
            <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2964">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f7da9-2965">
            <paramref name="method" /> não é <see langword="null" /> e o método que ele representa retorna <see langword="void" />, não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) ou não tem exatamente dois argumentos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2965">
              <paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f7da9-2966">
            <paramref name="method" /> é <see langword="null" /> e o operador de desigualdade não foi definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2966">
              <paramref name="method" /> is <see langword="null" /> and the inequality operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="OnesComplement">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f7da9-2967">Retorna a expressão que representa o complemento de um.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2967">Returns the expression representing the ones complement.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OnesComplement">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression OnesComplement (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression OnesComplement(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.OnesComplement(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ OnesComplement(System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member OnesComplement : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.OnesComplement expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression">
          <span data-ttu-id="f7da9-2968">Um <see cref="T:System.Linq.Expressions.Expression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2968">An <see cref="T:System.Linq.Expressions.Expression" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-2969">Retorna a expressão que representa o complemento de um.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2969">Returns the expression representing the ones complement.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-2970">Uma instância de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2970">An instance of <see cref="T:System.Linq.Expressions.UnaryExpression" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnesComplement">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression OnesComplement (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression OnesComplement(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.OnesComplement(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ OnesComplement(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member OnesComplement : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.OnesComplement (expression, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">
          <span data-ttu-id="f7da9-2971">Um <see cref="T:System.Linq.Expressions.Expression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2971">An <see cref="T:System.Linq.Expressions.Expression" />.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="f7da9-2972">Um <see cref="T:System.Reflection.MethodInfo" /> que representa o método de implementação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2972">A <see cref="T:System.Reflection.MethodInfo" /> that represents the implementing method.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-2973">Retorna a expressão que representa o complemento de um.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2973">Returns the expression representing the ones complement.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-2974">Uma instância de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2974">An instance of <see cref="T:System.Linq.Expressions.UnaryExpression" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Or">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f7da9-2975">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação <see langword="OR" /> bit a bit.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2975">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise <see langword="OR" /> operation.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Or">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Or (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Or(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Or(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Or (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Or(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member Or : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Or (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="f7da9-2976">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2976">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="f7da9-2977">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2977">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-2978">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação <see langword="OR" /> bit a bit.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2978">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise <see langword="OR" /> operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-2979">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Or" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-2979">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Or" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-2980">Resultante <xref:System.Linq.Expressions.BinaryExpression> tem o <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriedade definida como o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2980">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="f7da9-2981">O <xref:System.Linq.Expressions.Expression.Type%2A> estiver definida como o tipo de nó.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2981">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="f7da9-2982">Se o nó é elevado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> e <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriedades estiverem `true`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2982">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="f7da9-2983">Caso contrário, eles são `false`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2983">Otherwise, they are `false`.</span></span> <span data-ttu-id="f7da9-2984">A propriedade <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> é `null`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2984">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="f7da9-2985">As informações a seguir descrevem o método de implementação, o tipo de nó, e se um nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2985">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="f7da9-2986">Implementando método</span><span class="sxs-lookup"><span data-stu-id="f7da9-2986">Implementing Method</span></span>  
 <span data-ttu-id="f7da9-2987">As regras a seguir determinam o método de implementação para a operação:</span><span class="sxs-lookup"><span data-stu-id="f7da9-2987">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="f7da9-2988">Se o <xref:System.Linq.Expressions.Expression.Type%2A> propriedade deles `left` ou `right` representa um tipo definido pelo usuário que sobrecarrega o bit a bit `OR` operador, o <xref:System.Reflection.MethodInfo> que representa que o método é o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2988">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the bitwise `OR` operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="f7da9-2989">Caso contrário, se `left`. Tipo e `right`. Tipo são tipos de inteiros ou boolianos, o método de implementação é `null`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2989">Otherwise, if `left`.Type and `right`.Type are integral or Boolean types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="f7da9-2990">Tipo de nó e versão com comparação de precisão x sem comparação de precisão</span><span class="sxs-lookup"><span data-stu-id="f7da9-2990">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="f7da9-2991">Se o método de implementação não for `null`:</span><span class="sxs-lookup"><span data-stu-id="f7da9-2991">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="f7da9-2992">Se `left`. Tipo e `right`. Tipo podem ser atribuídos aos tipos de argumento correspondente do método de implementação, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2992">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="f7da9-2993">O tipo do nó é o tipo de retorno do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2993">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="f7da9-2994">Se as duas seguintes condições forem atendidas, o nó é levantado e o tipo de nó é o tipo que permite valor nulo que corresponde ao tipo de retorno do método de implementação:</span><span class="sxs-lookup"><span data-stu-id="f7da9-2994">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="f7da9-2995">`left`. Tipo e `right`. Tipo são os dois tipos de valor de que pelo menos um é anulável e os tipos não anuláveis correspondentes são iguais para os tipos de argumento correspondente do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2995">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="f7da9-2996">O tipo de retorno do método de implementação é um tipo de valor não anulável.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2996">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="f7da9-2997">Se o método de implementação é `null`:</span><span class="sxs-lookup"><span data-stu-id="f7da9-2997">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="f7da9-2998">Se `left`. Tipo e `right`. Tipo são não anuláveis, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2998">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="f7da9-2999">O tipo do nó é o tipo de resultado de predefinida bit a bit `OR` operador.</span><span class="sxs-lookup"><span data-stu-id="f7da9-2999">The type of the node is the result type of the predefined bitwise `OR` operator.</span></span>  
  
-   <span data-ttu-id="f7da9-3000">Se `left`. Tipo e `right`. Tipo são anuláveis, o nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3000">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="f7da9-3001">O tipo do nó é o tipo que permite valor nulo que corresponde ao tipo de resultado de predefinida bit a bit `OR` operador.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3001">The type of the node is the nullable type that corresponds to the result type of the predefined bitwise `OR` operator.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f7da9-3002">O exemplo de código a seguir mostra como criar uma expressão que representa uma operação OR lógica.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3002">The following code example shows how to create an expression that represents a logical OR operation.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#28](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#28)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#28](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#28)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f7da9-3003">
            <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3003">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f7da9-3004">O operador <see langword="OR" /> bit a bit não está definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3004">The bitwise <see langword="OR" /> operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Or">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Or (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Or(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Or(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Or (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Or(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member Or : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Or (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="f7da9-3005">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3005">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="f7da9-3006">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3006">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="f7da9-3007">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3007">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-3008">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação <see langword="OR" /> bit a bit.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3008">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise <see langword="OR" /> operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-3009">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Or" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3009">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Or" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-3010">Resultante <xref:System.Linq.Expressions.BinaryExpression> tem o <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriedade definida como o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3010">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="f7da9-3011">O <xref:System.Linq.Expressions.Expression.Type%2A> estiver definida como o tipo de nó.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3011">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="f7da9-3012">Se o nó é elevado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> e <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriedades estiverem `true`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3012">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="f7da9-3013">Caso contrário, eles são `false`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3013">Otherwise, they are `false`.</span></span> <span data-ttu-id="f7da9-3014">A propriedade <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> é `null`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3014">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="f7da9-3015">As informações a seguir descrevem o método de implementação, o tipo de nó, e se um nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3015">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="f7da9-3016">Implementando método</span><span class="sxs-lookup"><span data-stu-id="f7da9-3016">Implementing Method</span></span>  
 <span data-ttu-id="f7da9-3017">As regras a seguir determinam o método de implementação para a operação:</span><span class="sxs-lookup"><span data-stu-id="f7da9-3017">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="f7da9-3018">Se `method` não é `null` e representa um não-nulo, `static` (`Shared` no Visual Basic) método que usa dois argumentos, é o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3018">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method.</span></span>  
  
-   <span data-ttu-id="f7da9-3019">Caso contrário, se o <xref:System.Linq.Expressions.Expression.Type%2A> propriedade deles `left` ou `right` representa um tipo definido pelo usuário que sobrecarrega o bit a bit `OR` operador, o <xref:System.Reflection.MethodInfo> que representa que o método é o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3019">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the bitwise `OR` operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="f7da9-3020">Caso contrário, se `left`. Tipo e `right`. Tipo são tipos de inteiros ou boolianos, o método de implementação é `null`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3020">Otherwise, if `left`.Type and `right`.Type are integral or Boolean types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="f7da9-3021">Tipo de nó e versão com comparação de precisão x sem comparação de precisão</span><span class="sxs-lookup"><span data-stu-id="f7da9-3021">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="f7da9-3022">Se o método de implementação não for `null`:</span><span class="sxs-lookup"><span data-stu-id="f7da9-3022">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="f7da9-3023">Se `left`. Tipo e `right`. Tipo podem ser atribuídos aos tipos de argumento correspondente do método de implementação, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3023">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="f7da9-3024">O tipo do nó é o tipo de retorno do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3024">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="f7da9-3025">Se as duas seguintes condições forem atendidas, o nó é levantado e o tipo de nó é o tipo que permite valor nulo que corresponde ao tipo de retorno do método de implementação:</span><span class="sxs-lookup"><span data-stu-id="f7da9-3025">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="f7da9-3026">`left`. Tipo e `right`. Tipo são os dois tipos de valor de que pelo menos um é anulável e os tipos não anuláveis correspondentes são iguais para os tipos de argumento correspondente do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3026">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="f7da9-3027">O tipo de retorno do método de implementação é um tipo de valor não anulável.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3027">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="f7da9-3028">Se o método de implementação é `null`:</span><span class="sxs-lookup"><span data-stu-id="f7da9-3028">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="f7da9-3029">Se `left`. Tipo e `right`. Tipo são não anuláveis, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3029">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="f7da9-3030">O tipo do nó é o tipo de resultado de predefinida bit a bit `OR` operador.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3030">The type of the node is the result type of the predefined bitwise `OR` operator.</span></span>  
  
-   <span data-ttu-id="f7da9-3031">Se `left`. Tipo e `right`. Tipo são anuláveis, o nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3031">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="f7da9-3032">O tipo do nó é o tipo que permite valor nulo que corresponde ao tipo de resultado de predefinida bit a bit `OR` operador.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3032">The type of the node is the nullable type that corresponds to the result type of the predefined bitwise `OR` operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f7da9-3033">
            <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3033">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f7da9-3034">
            <paramref name="method" /> não é <see langword="null" /> e o método que ele representa retorna <see langword="void" />, não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) ou não tem exatamente dois argumentos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3034">
              <paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f7da9-3035">
            <paramref name="method" /> é <see langword="null" /> e o operador <see langword="OR" /> bit a bit não é definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3035">
              <paramref name="method" /> is <see langword="null" /> and the bitwise <see langword="OR" /> operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="OrAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f7da9-3036">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição OR bit a bit.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3036">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise OR assignment operation.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OrAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression OrAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression OrAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.OrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OrAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ OrAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member OrAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.OrAssign (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="f7da9-3037">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3037">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="f7da9-3038">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3038">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-3039">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição OR bit a bit.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3039">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise OR assignment operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-3040">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.OrAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3040">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.OrAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OrAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression OrAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression OrAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.OrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OrAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ OrAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member OrAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.OrAssign (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="f7da9-3041">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3041">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="f7da9-3042">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3042">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="f7da9-3043">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3043">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-3044">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição OR bit a bit.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3044">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise OR assignment operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-3045">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.OrAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3045">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.OrAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OrAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression OrAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression OrAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.OrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OrAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ OrAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member OrAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.OrAssign (left, right, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="f7da9-3046">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3046">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="f7da9-3047">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3047">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="f7da9-3048">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3048">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <param name="conversion">
          <span data-ttu-id="f7da9-3049">Um <see cref="T:System.Linq.Expressions.LambdaExpression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3049">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-3050">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição OR bit a bit.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3050">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise OR assignment operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-3051">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.OrAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3051">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.OrAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="OrElse">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f7da9-3052">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação condicional <see langword="OR" /> que avalia o segundo operando somente se o primeiro operador é avaliado como <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3052">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a conditional <see langword="OR" /> operation that evaluates the second operand only if the first operator evaluates to <see langword="false" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OrElse">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression OrElse (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression OrElse(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.OrElse(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OrElse (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ OrElse(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member OrElse : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.OrElse (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="f7da9-3053">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3053">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="f7da9-3054">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3054">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-3055">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação <see langword="OR" /> condicional que avalia o segundo operando somente se o primeiro operando é avaliado como <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3055">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a conditional <see langword="OR" /> operation that evaluates the second operand only if the first operand evaluates to <see langword="false" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-3056">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.OrElse" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3056">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.OrElse" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-3057">Resultante <xref:System.Linq.Expressions.BinaryExpression> tem o <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriedade definida como o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3057">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="f7da9-3058">O <xref:System.Linq.Expressions.Expression.Type%2A> estiver definida como o tipo de nó.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3058">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="f7da9-3059">Se o nó é elevado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> e <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriedades estiverem `true`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3059">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="f7da9-3060">Caso contrário, eles são `false`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3060">Otherwise, they are `false`.</span></span> <span data-ttu-id="f7da9-3061">A propriedade <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> é `null`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3061">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="f7da9-3062">As informações a seguir descrevem o método de implementação, o tipo de nó, e se um nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3062">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="f7da9-3063">Implementando método</span><span class="sxs-lookup"><span data-stu-id="f7da9-3063">Implementing Method</span></span>  
 <span data-ttu-id="f7da9-3064">As regras a seguir determinam o método de implementação para a operação:</span><span class="sxs-lookup"><span data-stu-id="f7da9-3064">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="f7da9-3065">Se o <xref:System.Linq.Expressions.Expression.Type%2A> propriedade deles `left` ou `right` representa um tipo definido pelo usuário que sobrecarrega o bit a bit `OR` operador, o <xref:System.Reflection.MethodInfo> que representa que o método é o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3065">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the bitwise `OR` operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="f7da9-3066">A condicional `OR` operador não pode ser sobrecarregado em c# ou Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3066">The conditional `OR` operator cannot be overloaded in C# or Visual Basic.</span></span> <span data-ttu-id="f7da9-3067">No entanto, a condicional `OR` operador é avaliado usando o bit a bit `OR` operador.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3067">However, the conditional `OR` operator is evaluated by using the bitwise `OR` operator.</span></span> <span data-ttu-id="f7da9-3068">Portanto, uma sobrecarga definido pelo usuário de bit a bit `OR` operador pode ser o método de implementação para esse tipo de nó.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3068">Thus, a user-defined overload of the bitwise `OR` operator can be the implementing method for this node type.</span></span>  
  
-   <span data-ttu-id="f7da9-3069">Caso contrário, se `left`. Tipo e `right`. Tipo são tipos boolianos, o método de implementação é `null`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3069">Otherwise, if `left`.Type and `right`.Type are Boolean types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="f7da9-3070">Tipo de nó e versão com comparação de precisão x sem comparação de precisão</span><span class="sxs-lookup"><span data-stu-id="f7da9-3070">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="f7da9-3071">Se o método de implementação não for `null`:</span><span class="sxs-lookup"><span data-stu-id="f7da9-3071">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="f7da9-3072">Se `left`. Tipo e `right`. Tipo podem ser atribuídos aos tipos de argumento correspondente do método de implementação, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3072">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="f7da9-3073">O tipo do nó é o tipo de retorno do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3073">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="f7da9-3074">Se as duas seguintes condições forem atendidas, o nó é levantado e o tipo de nó é o tipo que permite valor nulo que corresponde ao tipo de retorno do método de implementação:</span><span class="sxs-lookup"><span data-stu-id="f7da9-3074">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="f7da9-3075">`left`. Tipo e `right`. Tipo são os dois tipos de valor de que pelo menos um é anulável, e os tipos não anuláveis correspondentes são iguais para os tipos de argumento correspondente do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3075">`left`.Type and `right`.Type are both value types of which at least one is nullable, and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="f7da9-3076">O tipo de retorno do método de implementação é um tipo de valor não anulável.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3076">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="f7da9-3077">Se o método de implementação é `null`:</span><span class="sxs-lookup"><span data-stu-id="f7da9-3077">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="f7da9-3078">`left`. Tipo e `right`. Tipo são do mesmo tipo booliano.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3078">`left`.Type and `right`.Type are the same Boolean type.</span></span>  
  
-   <span data-ttu-id="f7da9-3079">Se `left`. Tipo e `right`. Tipo não anulável, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3079">If `left`.Type and `right`.Type are non-nullable, the node is not lifted.</span></span> <span data-ttu-id="f7da9-3080">O tipo do nó é o tipo de resultado da condicional predefinido `OR` operador.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3080">The type of the node is the result type of the predefined conditional `OR` operator.</span></span>  
  
-   <span data-ttu-id="f7da9-3081">Se `left`. Tipo e `right`. Tipo que permite valor nulo, o nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3081">If `left`.Type and `right`.Type are nullable, the node is lifted.</span></span> <span data-ttu-id="f7da9-3082">O tipo de nó é o tipo que permite valor nulo que corresponde ao tipo de resultado da condicional predefinido `OR` operador.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3082">The type of the node is the nullable type that corresponds to the result type of the predefined conditional `OR` operator.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f7da9-3083">O exemplo de código a seguir mostra como criar uma expressão que representa uma operação lógica `OR` operação que avalia o segundo operando somente se o primeiro operando é avaliado para `false`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3083">The following code example shows how to create an expression that represents a logical `OR` operation that evaluates the second operand only if the first operand evaluates to `false`.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#29](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#29)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#29](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#29)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f7da9-3084">
            <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3084">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f7da9-3085">O operador <see langword="OR" /> bit a bit não está definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3085">The bitwise <see langword="OR" /> operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span>
          </span>
          <span data-ttu-id="f7da9-3086">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3086">-or-</span>
          </span>
          <span data-ttu-id="f7da9-3087">
            <paramref name="left" />.Type e <paramref name="right" />.Type não são do mesmo tipo booliano.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3087">
              <paramref name="left" />.Type and <paramref name="right" />.Type are not the same Boolean type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="OrElse">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression OrElse (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression OrElse(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.OrElse(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OrElse (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ OrElse(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member OrElse : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.OrElse (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="f7da9-3088">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3088">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="f7da9-3089">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3089">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="f7da9-3090">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3090">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-3091">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação <see langword="OR" /> condicional que avalia o segundo operando somente se o primeiro operando é avaliado como <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3091">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a conditional <see langword="OR" /> operation that evaluates the second operand only if the first operand evaluates to <see langword="false" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-3092">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.OrElse" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3092">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.OrElse" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-3093">Resultante <xref:System.Linq.Expressions.BinaryExpression> tem o <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriedade definida como o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3093">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="f7da9-3094">O <xref:System.Linq.Expressions.Expression.Type%2A> estiver definida como o tipo de nó.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3094">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="f7da9-3095">Se o nó é elevado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> e <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriedades estiverem `true`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3095">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="f7da9-3096">Caso contrário, eles são `false`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3096">Otherwise, they are `false`.</span></span> <span data-ttu-id="f7da9-3097">A propriedade <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> é `null`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3097">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="f7da9-3098">As informações a seguir descrevem o método de implementação, o tipo de nó, e se um nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3098">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="f7da9-3099">Implementando método</span><span class="sxs-lookup"><span data-stu-id="f7da9-3099">Implementing Method</span></span>  
 <span data-ttu-id="f7da9-3100">As regras a seguir determinam o método de implementação para a operação:</span><span class="sxs-lookup"><span data-stu-id="f7da9-3100">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="f7da9-3101">Se `method` não é `null` e representa um não-nulo, `static` (`Shared` no Visual Basic) método que usa dois argumentos, é o método de implementação para o nó.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3101">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method for the node.</span></span>  
  
-   <span data-ttu-id="f7da9-3102">Caso contrário, se o <xref:System.Linq.Expressions.Expression.Type%2A> propriedade deles `left` ou `right` representa um tipo definido pelo usuário que sobrecarrega o bit a bit `OR` operador, o <xref:System.Reflection.MethodInfo> que representa que o método é o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3102">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the bitwise `OR` operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="f7da9-3103">A condicional `OR` operador não pode ser sobrecarregado em c# ou Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3103">The conditional `OR` operator cannot be overloaded in C# or Visual Basic.</span></span> <span data-ttu-id="f7da9-3104">No entanto, a condicional `OR` operador é avaliado usando o bit a bit `OR` operador.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3104">However, the conditional `OR` operator is evaluated by using the bitwise `OR` operator.</span></span> <span data-ttu-id="f7da9-3105">Portanto, uma sobrecarga definido pelo usuário de bit a bit `OR` operador pode ser o método de implementação para esse tipo de nó.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3105">Thus, a user-defined overload of the bitwise `OR` operator can be the implementing method for this node type.</span></span>  
  
-   <span data-ttu-id="f7da9-3106">Caso contrário, se `left`. Tipo e `right`. Tipo são tipos boolianos, o método de implementação é `null`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3106">Otherwise, if `left`.Type and `right`.Type are Boolean types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="f7da9-3107">Tipo de nó e versão com comparação de precisão x sem comparação de precisão</span><span class="sxs-lookup"><span data-stu-id="f7da9-3107">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="f7da9-3108">Se o método de implementação não for `null`:</span><span class="sxs-lookup"><span data-stu-id="f7da9-3108">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="f7da9-3109">Se `left`. Tipo e `right`. Tipo podem ser atribuídos aos tipos de argumento correspondente do método de implementação, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3109">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="f7da9-3110">O tipo do nó é o tipo de retorno do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3110">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="f7da9-3111">Se as duas seguintes condições forem atendidas, o nó é levantado e o tipo de nó é o tipo que permite valor nulo que corresponde ao tipo de retorno do método de implementação:</span><span class="sxs-lookup"><span data-stu-id="f7da9-3111">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="f7da9-3112">`left`. Tipo e `right`. Tipo são os dois tipos de valor de que pelo menos um é anulável, e os tipos não anuláveis correspondentes são iguais para os tipos de argumento correspondente do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3112">`left`.Type and `right`.Type are both value types of which at least one is nullable, and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="f7da9-3113">O tipo de retorno do método de implementação é um tipo de valor não anulável.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3113">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="f7da9-3114">Se o método de implementação é `null`:</span><span class="sxs-lookup"><span data-stu-id="f7da9-3114">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="f7da9-3115">`left`. Tipo e `right`. Tipo são do mesmo tipo booliano.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3115">`left`.Type and `right`.Type are the same Boolean type.</span></span>  
  
-   <span data-ttu-id="f7da9-3116">Se `left`. Tipo e `right`. Tipo não anulável, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3116">If `left`.Type and `right`.Type are non-nullable, the node is not lifted.</span></span> <span data-ttu-id="f7da9-3117">O tipo do nó é o tipo de resultado da condicional predefinido `OR` operador.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3117">The type of the node is the result type of the predefined conditional `OR` operator.</span></span>  
  
-   <span data-ttu-id="f7da9-3118">Se `left`. Tipo e `right`. Tipo que permite valor nulo, o nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3118">If `left`.Type and `right`.Type are nullable, the node is lifted.</span></span> <span data-ttu-id="f7da9-3119">O tipo de nó é o tipo que permite valor nulo que corresponde ao tipo de resultado da condicional predefinido `OR` operador.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3119">The type of the node is the nullable type that corresponds to the result type of the predefined conditional `OR` operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f7da9-3120">
            <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3120">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f7da9-3121">
            <paramref name="method" /> não é <see langword="null" /> e o método que ele representa retorna <see langword="void" />, não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) ou não tem exatamente dois argumentos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3121">
              <paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f7da9-3122">
            <paramref name="method" /> é <see langword="null" /> e o operador <see langword="OR" /> bit a bit não é definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3122">
              <paramref name="method" /> is <see langword="null" /> and the bitwise <see langword="OR" /> operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span>
          </span>
          <span data-ttu-id="f7da9-3123">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3123">-or-</span>
          </span>
          <span data-ttu-id="f7da9-3124">
            <paramref name="method" /> é <see langword="null" /> e Type.<paramref name="left" /> e Type.<paramref name="right" /> não são do mesmo tipo booliano.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3124">
              <paramref name="method" /> is <see langword="null" /> and <paramref name="left" />.Type and <paramref name="right" />.Type are not the same Boolean type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Parameter">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f7da9-3125">Cria um nó de <see cref="T:System.Linq.Expressions.ParameterExpression" /> que pode ser usado para identificar um parâmetro ou uma variável em uma árvore de expressão.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3125">Creates a <see cref="T:System.Linq.Expressions.ParameterExpression" /> node that can be used to identify a parameter or a variable in an expression tree.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Parameter">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ParameterExpression Parameter (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ParameterExpression Parameter(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Parameter(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ParameterExpression ^ Parameter(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Parameter : Type -&gt; System.Linq.Expressions.ParameterExpression" Usage="System.Linq.Expressions.Expression.Parameter type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ParameterExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">
          <span data-ttu-id="f7da9-3126">O tipo do parâmetro ou da variável.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3126">The type of the parameter or variable.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-3127">Cria um nó de <see cref="T:System.Linq.Expressions.ParameterExpression" /> que pode ser usado para identificar um parâmetro ou uma variável em uma árvore de expressão.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3127">Creates a <see cref="T:System.Linq.Expressions.ParameterExpression" /> node that can be used to identify a parameter or a variable in an expression tree.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-3128">Um nó de <see cref="T:System.Linq.Expressions.ParameterExpression" /> com o nome e tipo especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3128">A <see cref="T:System.Linq.Expressions.ParameterExpression" /> node with the specified name and type.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="f7da9-3129">O exemplo a seguir demonstra como criar uma <xref:System.Linq.Expressions.MethodCallExpression> objeto que imprime o valor de um <xref:System.Linq.Expressions.ParameterExpression> objeto.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3129">The following example demonstrates how to create a <xref:System.Linq.Expressions.MethodCallExpression> object that prints the value of a <xref:System.Linq.Expressions.ParameterExpression> object.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#49](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#49)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#49](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#49)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Parameter">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ParameterExpression Parameter (Type type, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ParameterExpression Parameter(class System.Type type, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Parameter(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ParameterExpression ^ Parameter(Type ^ type, System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member Parameter : Type * string -&gt; System.Linq.Expressions.ParameterExpression" Usage="System.Linq.Expressions.Expression.Parameter (type, name)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ParameterExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">
          <span data-ttu-id="f7da9-3130">O tipo do parâmetro ou da variável.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3130">The type of the parameter or variable.</span>
          </span>
        </param>
        <param name="name">
          <span data-ttu-id="f7da9-3131">O nome do parâmetro ou variável, usado para fins de depuração ou impressão apenas.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3131">The name of the parameter or variable, used for debugging or printing purpose only.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-3132">Cria um nó de <see cref="T:System.Linq.Expressions.ParameterExpression" /> que pode ser usado para identificar um parâmetro ou uma variável em uma árvore de expressão.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3132">Creates a <see cref="T:System.Linq.Expressions.ParameterExpression" /> node that can be used to identify a parameter or a variable in an expression tree.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-3133">Um <see cref="T:System.Linq.Expressions.ParameterExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Parameter" /> e as propriedades <see cref="P:System.Linq.Expressions.Expression.Type" /> e <see cref="P:System.Linq.Expressions.ParameterExpression.Name" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3133">A <see cref="T:System.Linq.Expressions.ParameterExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Parameter" /> and the <see cref="P:System.Linq.Expressions.Expression.Type" /> and <see cref="P:System.Linq.Expressions.ParameterExpression.Name" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f7da9-3134">
            <paramref name="type" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3134">
              <paramref name="type" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="PostDecrementAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f7da9-3135">Cria um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa a atribuição da expressão seguida de um decremento subsequente da expressão original em 1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3135">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the assignment of the expression followed by a subsequent decrement by 1 of the original expression.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PostDecrementAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression PostDecrementAssign (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression PostDecrementAssign(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PostDecrementAssign(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ PostDecrementAssign(System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member PostDecrementAssign : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.PostDecrementAssign expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression">
          <span data-ttu-id="f7da9-3136">Um <see cref="T:System.Linq.Expressions.Expression" /> no qual aplicar as operações.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3136">An <see cref="T:System.Linq.Expressions.Expression" /> to apply the operations on.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-3137">Cria um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa a atribuição da expressão seguida de um decremento subsequente da expressão original em 1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3137">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the assignment of the expression followed by a subsequent decrement by 1 of the original expression.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-3138">Um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa a expressão resultante.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3138">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the resultant expression.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PostDecrementAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression PostDecrementAssign (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression PostDecrementAssign(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PostDecrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ PostDecrementAssign(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member PostDecrementAssign : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.PostDecrementAssign (expression, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">
          <span data-ttu-id="f7da9-3139">Um <see cref="T:System.Linq.Expressions.Expression" /> no qual aplicar as operações.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3139">An <see cref="T:System.Linq.Expressions.Expression" /> to apply the operations on.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="f7da9-3140">Um <see cref="T:System.Reflection.MethodInfo" /> que representa o método de implementação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3140">A <see cref="T:System.Reflection.MethodInfo" /> that represents the implementing method.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-3141">Cria um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa a atribuição da expressão seguida de um decremento subsequente da expressão original em 1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3141">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the assignment of the expression followed by a subsequent decrement by 1 of the original expression.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-3142">Um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa a expressão resultante.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3142">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the resultant expression.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="PostIncrementAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f7da9-3143">Cria um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa a atribuição da expressão seguida de um incremento de 1 à expressão original.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3143">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the assignment of the expression followed by a subsequent increment by 1 of the original expression.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PostIncrementAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression PostIncrementAssign (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression PostIncrementAssign(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PostIncrementAssign(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ PostIncrementAssign(System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member PostIncrementAssign : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.PostIncrementAssign expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression">
          <span data-ttu-id="f7da9-3144">Um <see cref="T:System.Linq.Expressions.Expression" /> no qual aplicar as operações.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3144">An <see cref="T:System.Linq.Expressions.Expression" /> to apply the operations on.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-3145">Cria um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa a atribuição da expressão seguida de um incremento de 1 à expressão original.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3145">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the assignment of the expression followed by a subsequent increment by 1 of the original expression.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-3146">Um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa a expressão resultante.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3146">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the resultant expression.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PostIncrementAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression PostIncrementAssign (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression PostIncrementAssign(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PostIncrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ PostIncrementAssign(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member PostIncrementAssign : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.PostIncrementAssign (expression, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">
          <span data-ttu-id="f7da9-3147">Um <see cref="T:System.Linq.Expressions.Expression" /> no qual aplicar as operações.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3147">An <see cref="T:System.Linq.Expressions.Expression" /> to apply the operations on.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="f7da9-3148">Um <see cref="T:System.Reflection.MethodInfo" /> que representa o método de implementação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3148">A <see cref="T:System.Reflection.MethodInfo" /> that represents the implementing method.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-3149">Cria um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa a atribuição da expressão seguida de um incremento de 1 à expressão original.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3149">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the assignment of the expression followed by a subsequent increment by 1 of the original expression.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-3150">Um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa a expressão resultante.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3150">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the resultant expression.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Power">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f7da9-3151">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa a elevação de um número a uma potência.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3151">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents raising a number to a power.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Power">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Power (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Power(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Power(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Power (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Power(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member Power : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Power (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="f7da9-3152">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3152">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="f7da9-3153">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3153">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-3154">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa a elevação de um número a uma potência.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3154">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents raising a number to a power.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-3155">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Power" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3155">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Power" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-3156">Resultante <xref:System.Linq.Expressions.BinaryExpression> tem o <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriedade definida como o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3156">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="f7da9-3157">O <xref:System.Linq.Expressions.Expression.Type%2A> estiver definida como o tipo de nó.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3157">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="f7da9-3158">Se o nó é elevado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> e <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriedades estiverem `true`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3158">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="f7da9-3159">Caso contrário, eles são `false`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3159">Otherwise, they are `false`.</span></span> <span data-ttu-id="f7da9-3160">A propriedade <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> é `null`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3160">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="f7da9-3161">As informações a seguir descrevem o método de implementação, o tipo de nó, e se um nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3161">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="f7da9-3162">Implementando método</span><span class="sxs-lookup"><span data-stu-id="f7da9-3162">Implementing Method</span></span>  
 <span data-ttu-id="f7da9-3163">As regras a seguir determinam o método de implementação para a operação:</span><span class="sxs-lookup"><span data-stu-id="f7da9-3163">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="f7da9-3164">Se o <xref:System.Linq.Expressions.Expression.Type%2A> propriedade deles `left` ou `right` representa um tipo definido pelo usuário que sobrecarrega o operador de exponenciação, o <xref:System.Reflection.MethodInfo> que representa que o método é o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3164">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the exponentiation operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="f7da9-3165">Caso contrário, se `left`. Tipo e `right`. Tipo são ambos <xref:System.Double>, o método de implementação é <xref:System.Math.Pow%2A>.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3165">Otherwise, if `left`.Type and `right`.Type are both <xref:System.Double>, the implementing method is <xref:System.Math.Pow%2A>.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="f7da9-3166">Tipo de nó e versão com comparação de precisão x sem comparação de precisão</span><span class="sxs-lookup"><span data-stu-id="f7da9-3166">Node Type and Lifted versus Non-Lifted</span></span>  
  
-   <span data-ttu-id="f7da9-3167">Se `left`. Tipo e `right`. Tipo podem ser atribuídos aos tipos de argumento correspondente do método de implementação, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3167">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="f7da9-3168">O tipo do nó é o tipo de retorno do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3168">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="f7da9-3169">Se as duas seguintes condições forem atendidas, o nó é levantado e o tipo de nó é o tipo que permite valor nulo que corresponde ao tipo de retorno do método de implementação:</span><span class="sxs-lookup"><span data-stu-id="f7da9-3169">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="f7da9-3170">`left`. Tipo e `right`. Tipo são os dois tipos de valor de que pelo menos um é anulável e os tipos não anuláveis correspondentes são iguais para os tipos de argumento correspondente do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3170">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="f7da9-3171">O tipo de retorno do método de implementação é um tipo de valor não anulável.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3171">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f7da9-3172">
            <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3172">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f7da9-3173">O operador de exponenciação não está definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3173">The exponentiation operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span>
          </span>
          <span data-ttu-id="f7da9-3174">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3174">-or-</span>
          </span>
          <span data-ttu-id="f7da9-3175">
            <paramref name="left" />.Type e/ou <paramref name="right" />.Type não são <see cref="T:System.Double" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3175">
              <paramref name="left" />.Type and/or <paramref name="right" />.Type are not <see cref="T:System.Double" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Power">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Power (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Power(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Power(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Power (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Power(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member Power : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Power (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="f7da9-3176">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3176">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="f7da9-3177">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3177">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="f7da9-3178">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3178">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-3179">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa a elevação de um número a uma potência.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3179">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents raising a number to a power.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-3180">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Power" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3180">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Power" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-3181">Resultante <xref:System.Linq.Expressions.BinaryExpression> tem o <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriedade definida como o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3181">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="f7da9-3182">O <xref:System.Linq.Expressions.Expression.Type%2A> estiver definida como o tipo de nó.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3182">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="f7da9-3183">Se o nó é elevado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> e <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriedades estiverem `true`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3183">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="f7da9-3184">Caso contrário, eles são `false`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3184">Otherwise, they are `false`.</span></span> <span data-ttu-id="f7da9-3185">A propriedade <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> é `null`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3185">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="f7da9-3186">As informações a seguir descrevem o método de implementação, o tipo de nó, e se um nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3186">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="f7da9-3187">Implementando método</span><span class="sxs-lookup"><span data-stu-id="f7da9-3187">Implementing Method</span></span>  
 <span data-ttu-id="f7da9-3188">As regras a seguir determinam o método de implementação para a operação:</span><span class="sxs-lookup"><span data-stu-id="f7da9-3188">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="f7da9-3189">Se `method` não é `null` e representa um não-nulo, `static` (`Shared` no Visual Basic) método que usa dois argumentos, é o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3189">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method.</span></span>  
  
-   <span data-ttu-id="f7da9-3190">Caso contrário, se o <xref:System.Linq.Expressions.Expression.Type%2A> propriedade deles `left` ou `right` representa um tipo definido pelo usuário que sobrecarrega o operador de exponenciação, o <xref:System.Reflection.MethodInfo> que representa que o método é o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3190">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the exponentiation operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="f7da9-3191">Caso contrário, se `left`. Tipo e `right`. Tipo são ambos <xref:System.Double>, o método de implementação é <xref:System.Math.Pow%2A>.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3191">Otherwise, if `left`.Type and `right`.Type are both <xref:System.Double>, the implementing method is <xref:System.Math.Pow%2A>.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="f7da9-3192">Tipo de nó e versão com comparação de precisão x sem comparação de precisão</span><span class="sxs-lookup"><span data-stu-id="f7da9-3192">Node Type and Lifted versus Non-Lifted</span></span>  
  
-   <span data-ttu-id="f7da9-3193">Se `left`. Tipo e `right`. Tipo podem ser atribuídos aos tipos de argumento correspondente do método de implementação, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3193">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="f7da9-3194">O tipo do nó é o tipo de retorno do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3194">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="f7da9-3195">Se as duas seguintes condições forem atendidas, o nó é levantado e o tipo de nó é o tipo que permite valor nulo que corresponde ao tipo de retorno do método de implementação:</span><span class="sxs-lookup"><span data-stu-id="f7da9-3195">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="f7da9-3196">`left`. Tipo e `right`. Tipo são os dois tipos de valor de que pelo menos um é anulável e os tipos não anuláveis correspondentes são iguais para os tipos de argumento correspondente do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3196">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="f7da9-3197">O tipo de retorno do método de implementação é um tipo de valor não anulável.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3197">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f7da9-3198">
            <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3198">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f7da9-3199">
            <paramref name="method" /> não é <see langword="null" /> e o método que ele representa retorna <see langword="void" />, não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) ou não tem exatamente dois argumentos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3199">
              <paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f7da9-3200">
            <paramref name="method" /> é <see langword="null" /> e o operador de exponenciação não foi definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3200">
              <paramref name="method" /> is <see langword="null" /> and the exponentiation operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span>
          </span>
          <span data-ttu-id="f7da9-3201">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3201">-or-</span>
          </span>
          <span data-ttu-id="f7da9-3202">
            <paramref name="method" /> é <see langword="null" /> e <paramref name="left" />.Type e/ou <paramref name="right" />.Type não são <see cref="T:System.Double" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3202">
              <paramref name="method" /> is <see langword="null" /> and <paramref name="left" />.Type and/or <paramref name="right" />.Type are not <see cref="T:System.Double" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="PowerAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f7da9-3203">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa elevar uma expressão a uma potência e atribuir o resultado de volta à expressão.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3203">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents raising an expression to a power and assigning the result back to the expression.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PowerAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression PowerAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression PowerAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PowerAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function PowerAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ PowerAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member PowerAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.PowerAssign (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="f7da9-3204">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3204">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="f7da9-3205">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3205">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-3206">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa elevar uma expressão a uma potência e atribuir o resultado de volta à expressão.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3206">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents raising an expression to a power and assigning the result back to the expression.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-3207">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.PowerAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3207">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.PowerAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PowerAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression PowerAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression PowerAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PowerAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function PowerAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ PowerAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member PowerAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.PowerAssign (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="f7da9-3208">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3208">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="f7da9-3209">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3209">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="f7da9-3210">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3210">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-3211">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa elevar uma expressão a uma potência e atribuir o resultado de volta à expressão.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3211">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents raising an expression to a power and assigning the result back to the expression.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-3212">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.PowerAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3212">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.PowerAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PowerAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression PowerAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression PowerAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PowerAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function PowerAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ PowerAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member PowerAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.PowerAssign (left, right, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="f7da9-3213">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3213">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="f7da9-3214">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3214">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="f7da9-3215">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3215">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <param name="conversion">
          <span data-ttu-id="f7da9-3216">Um <see cref="T:System.Linq.Expressions.LambdaExpression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3216">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-3217">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa elevar uma expressão a uma potência e atribuir o resultado de volta à expressão.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3217">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents raising an expression to a power and assigning the result back to the expression.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-3218">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.PowerAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3218">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.PowerAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="PreDecrementAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f7da9-3219">Cria um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que decrementa a expressão por 1 e atribui o resultado de volta à expressão.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3219">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that decrements the expression by 1 and assigns the result back to the expression.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PreDecrementAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression PreDecrementAssign (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression PreDecrementAssign(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PreDecrementAssign(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ PreDecrementAssign(System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member PreDecrementAssign : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.PreDecrementAssign expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression">
          <span data-ttu-id="f7da9-3220">Um <see cref="T:System.Linq.Expressions.Expression" /> no qual aplicar as operações.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3220">An <see cref="T:System.Linq.Expressions.Expression" /> to apply the operations on.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-3221">Cria um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que decrementa a expressão por 1 e atribui o resultado de volta à expressão.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3221">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that decrements the expression by 1 and assigns the result back to the expression.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-3222">Um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa a expressão resultante.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3222">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the resultant expression.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreDecrementAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression PreDecrementAssign (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression PreDecrementAssign(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PreDecrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ PreDecrementAssign(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member PreDecrementAssign : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.PreDecrementAssign (expression, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">
          <span data-ttu-id="f7da9-3223">Um <see cref="T:System.Linq.Expressions.Expression" /> no qual aplicar as operações.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3223">An <see cref="T:System.Linq.Expressions.Expression" /> to apply the operations on.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="f7da9-3224">Um <see cref="T:System.Reflection.MethodInfo" /> que representa o método de implementação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3224">A <see cref="T:System.Reflection.MethodInfo" /> that represents the implementing method.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-3225">Cria um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que decrementa a expressão por 1 e atribui o resultado de volta à expressão.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3225">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that decrements the expression by 1 and assigns the result back to the expression.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-3226">Um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa a expressão resultante.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3226">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the resultant expression.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="PreIncrementAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f7da9-3227">Cria um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que incrementa a expressão em 1 e atribui o resultado de volta à expressão.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3227">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that increments the expression by 1 and assigns the result back to the expression.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PreIncrementAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression PreIncrementAssign (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression PreIncrementAssign(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PreIncrementAssign(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ PreIncrementAssign(System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member PreIncrementAssign : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.PreIncrementAssign expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression">
          <span data-ttu-id="f7da9-3228">Um <see cref="T:System.Linq.Expressions.Expression" /> no qual aplicar as operações.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3228">An <see cref="T:System.Linq.Expressions.Expression" /> to apply the operations on.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-3229">Cria um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que incrementa a expressão em 1 e atribui o resultado de volta à expressão.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3229">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that increments the expression by 1 and assigns the result back to the expression.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-3230">Um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa a expressão resultante.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3230">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the resultant expression.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreIncrementAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression PreIncrementAssign (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression PreIncrementAssign(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PreIncrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ PreIncrementAssign(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member PreIncrementAssign : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.PreIncrementAssign (expression, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">
          <span data-ttu-id="f7da9-3231">Um <see cref="T:System.Linq.Expressions.Expression" /> no qual aplicar as operações.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3231">An <see cref="T:System.Linq.Expressions.Expression" /> to apply the operations on.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="f7da9-3232">Um <see cref="T:System.Reflection.MethodInfo" /> que representa o método de implementação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3232">A <see cref="T:System.Reflection.MethodInfo" /> that represents the implementing method.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-3233">Cria um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que incrementa a expressão em 1 e atribui o resultado de volta à expressão.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3233">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that increments the expression by 1 and assigns the result back to the expression.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-3234">Um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa a expressão resultante.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3234">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the resultant expression.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Property">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f7da9-3235">Cria um <see cref="T:System.Linq.Expressions.MemberExpression" /> que representa o acesso a uma propriedade.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3235">Creates a <see cref="T:System.Linq.Expressions.MemberExpression" /> that represents accessing a property.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression Property (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo propertyAccessor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression Property(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo propertyAccessor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberExpression ^ Property(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ propertyAccessor);" />
      <MemberSignature Language="F#" Value="static member Property : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.MemberExpression" Usage="System.Linq.Expressions.Expression.Property (expression, propertyAccessor)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="propertyAccessor" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">
          <span data-ttu-id="f7da9-3236">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3236">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> property equal to.</span>
          </span>
          <span data-ttu-id="f7da9-3237">Pode ser nulo para propriedades estáticas.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3237">This can be null for static properties.</span>
          </span>
        </param>
        <param name="propertyAccessor">
          <span data-ttu-id="f7da9-3238">O <see cref="T:System.Reflection.MethodInfo" /> que representa um método de acessador de propriedade.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3238">The <see cref="T:System.Reflection.MethodInfo" /> that represents a property accessor method.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-3239">Cria um <see cref="T:System.Linq.Expressions.MemberExpression" /> que representa o acesso a uma propriedade usando um método de acessador de propriedade.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3239">Creates a <see cref="T:System.Linq.Expressions.MemberExpression" /> that represents accessing a property by using a property accessor method.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-3240">Um <see cref="T:System.Linq.Expressions.MemberExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, a propriedade <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> definida como <paramref name="expression" /> e a propriedade <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> definida como o <see cref="T:System.Reflection.PropertyInfo" /> que representa a propriedade acessada em <paramref name="propertyAccessor" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3240">A <see cref="T:System.Linq.Expressions.MemberExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, the <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> property set to <paramref name="expression" /> and the <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> property set to the <see cref="T:System.Reflection.PropertyInfo" /> that represents the property accessed in <paramref name="propertyAccessor" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-3241">O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade resultantes <xref:System.Linq.Expressions.MemberExpression> é igual ao <xref:System.Reflection.PropertyInfo.PropertyType%2A> propriedade <xref:System.Linq.Expressions.MemberExpression.Member%2A>.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3241">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.MemberExpression> is equal to the <xref:System.Reflection.PropertyInfo.PropertyType%2A> property of <xref:System.Linq.Expressions.MemberExpression.Member%2A>.</span></span>  
  
 <span data-ttu-id="f7da9-3242">Se o método representado por `propertyAccessor` está `static` (`Shared` no Visual Basic), `expression` pode ser `null`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3242">If the method represented by `propertyAccessor` is `static` (`Shared` in Visual Basic), `expression` can be `null`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f7da9-3243">
            <paramref name="propertyAccessor" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3243">
              <paramref name="propertyAccessor" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="f7da9-3244">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3244">-or-</span>
          </span>
          <span data-ttu-id="f7da9-3245">O método representado por <paramref name="propertyAccessor" /> não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) e <paramref name="expression" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3245">The method that <paramref name="propertyAccessor" /> represents is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic) and <paramref name="expression" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f7da9-3246">
            <paramref name="expression" />. O tipo não é atribuível ao tipo de declaração de método representada pelo <paramref name="propertyAccessor" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3246">
              <paramref name="expression" />.Type is not assignable to the declaring type of the method represented by <paramref name="propertyAccessor" />.</span>
          </span>
          <span data-ttu-id="f7da9-3247">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3247">-or-</span>
          </span>
          <span data-ttu-id="f7da9-3248">O método representado por <paramref name="propertyAccessor" /> não é um método de acessador de propriedade.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3248">The method that <paramref name="propertyAccessor" /> represents is not a property accessor method.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression Property (System.Linq.Expressions.Expression expression, System.Reflection.PropertyInfo property);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression Property(class System.Linq.Expressions.Expression expression, class System.Reflection.PropertyInfo property) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberExpression ^ Property(System::Linq::Expressions::Expression ^ expression, System::Reflection::PropertyInfo ^ property);" />
      <MemberSignature Language="F#" Value="static member Property : System.Linq.Expressions.Expression * System.Reflection.PropertyInfo -&gt; System.Linq.Expressions.MemberExpression" Usage="System.Linq.Expressions.Expression.Property (expression, property)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="property" Type="System.Reflection.PropertyInfo" />
      </Parameters>
      <Docs>
        <param name="expression">
          <span data-ttu-id="f7da9-3249">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3249">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> property equal to.</span>
          </span>
          <span data-ttu-id="f7da9-3250">Pode ser nulo para propriedades estáticas.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3250">This can be null for static properties.</span>
          </span>
        </param>
        <param name="property">
          <span data-ttu-id="f7da9-3251">O <see cref="T:System.Reflection.PropertyInfo" /> com um valor igual ao qual a <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> propriedade será definida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3251">The <see cref="T:System.Reflection.PropertyInfo" /> to set the <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-3252">Cria um <see cref="T:System.Linq.Expressions.MemberExpression" /> que representa o acesso a uma propriedade.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3252">Creates a <see cref="T:System.Linq.Expressions.MemberExpression" /> that represents accessing a property.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-3253">Um <see cref="T:System.Linq.Expressions.MemberExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" /> e as propriedades <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> e <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3253">A <see cref="T:System.Linq.Expressions.MemberExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" /> and the <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> and <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-3254">O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade resultantes <xref:System.Linq.Expressions.MemberExpression> é igual ao <xref:System.Reflection.PropertyInfo.PropertyType%2A> propriedade <xref:System.Linq.Expressions.MemberExpression.Member%2A>.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3254">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.MemberExpression> is equal to the <xref:System.Reflection.PropertyInfo.PropertyType%2A> property of <xref:System.Linq.Expressions.MemberExpression.Member%2A>.</span></span>  
  
 <span data-ttu-id="f7da9-3255">Se a propriedade representada pelo `property` está `static` (`Shared` no Visual Basic), `expression` pode ser `null`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3255">If the property represented by `property` is `static` (`Shared` in Visual Basic), `expression` can be `null`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f7da9-3256">
            <paramref name="property" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3256">
              <paramref name="property" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="f7da9-3257">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3257">-or-</span>
          </span>
          <span data-ttu-id="f7da9-3258">A propriedade que o <paramref name="property" /> representa não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) e o <paramref name="expression" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3258">The property that <paramref name="property" /> represents is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic) and <paramref name="expression" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f7da9-3259">
            <paramref name="expression" />.Type não é atribuível ao tipo de declaração da propriedade que o <paramref name="property" /> representa.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3259">
              <paramref name="expression" />.Type is not assignable to the declaring type of the property that <paramref name="property" /> represents.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression Property (System.Linq.Expressions.Expression expression, string propertyName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression Property(class System.Linq.Expressions.Expression expression, string propertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberExpression ^ Property(System::Linq::Expressions::Expression ^ expression, System::String ^ propertyName);" />
      <MemberSignature Language="F#" Value="static member Property : System.Linq.Expressions.Expression * string -&gt; System.Linq.Expressions.MemberExpression" Usage="System.Linq.Expressions.Expression.Property (expression, propertyName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="propertyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="expression">
          <span data-ttu-id="f7da9-3260">Um <see cref="T:System.Linq.Expressions.Expression" /> cujo <see cref="P:System.Linq.Expressions.Expression.Type" /> contém uma propriedade chamada <paramref name="propertyName" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3260">An <see cref="T:System.Linq.Expressions.Expression" /> whose <see cref="P:System.Linq.Expressions.Expression.Type" /> contains a property named <paramref name="propertyName" />.</span>
          </span>
          <span data-ttu-id="f7da9-3261">Pode ser <see langword="null" /> para propriedades estáticas.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3261">This can be <see langword="null" /> for static properties.</span>
          </span>
        </param>
        <param name="propertyName">
          <span data-ttu-id="f7da9-3262">O nome de uma propriedade a ser acessada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3262">The name of a property to be accessed.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-3263">Cria um <see cref="T:System.Linq.Expressions.MemberExpression" /> que representa o acesso a uma propriedade.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3263">Creates a <see cref="T:System.Linq.Expressions.MemberExpression" /> that represents accessing a property.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-3264">Um <see cref="T:System.Linq.Expressions.MemberExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, a propriedade <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> definida como <paramref name="expression" /> e a propriedade <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> definida como o <see cref="T:System.Reflection.PropertyInfo" /> que representa a propriedade indicada por <paramref name="propertyName" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3264">A <see cref="T:System.Linq.Expressions.MemberExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, the <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> property set to <paramref name="expression" />, and the <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> property set to the <see cref="T:System.Reflection.PropertyInfo" /> that represents the property denoted by <paramref name="propertyName" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-3265">O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade resultantes <xref:System.Linq.Expressions.MemberExpression> é igual ao <xref:System.Reflection.PropertyInfo.PropertyType%2A> propriedade o <xref:System.Reflection.PropertyInfo> que representa a propriedade indicada por `propertyName`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3265">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.MemberExpression> is equal to the <xref:System.Reflection.PropertyInfo.PropertyType%2A> property of the <xref:System.Reflection.PropertyInfo> that represents the property denoted by `propertyName`.</span></span>  
  
 <span data-ttu-id="f7da9-3266">Este método pesquisa `expression`. Tipo e seus tipos base para uma propriedade que tem o nome `propertyName`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3266">This method searches `expression`.Type and its base types for a property that has the name `propertyName`.</span></span> <span data-ttu-id="f7da9-3267">Propriedades públicas terá preferência sobre propriedades não públicas.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3267">Public properties are given preference over non-public properties.</span></span> <span data-ttu-id="f7da9-3268">Se uma propriedade correspondente for encontrada, esse método passa `expression` e o <xref:System.Reflection.PropertyInfo> que representa essa propriedade para <xref:System.Linq.Expressions.Expression.Property%2A>.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3268">If a matching property is found, this method passes `expression` and the <xref:System.Reflection.PropertyInfo> that represents that property to <xref:System.Linq.Expressions.Expression.Property%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f7da9-3269">O exemplo a seguir mostra como criar uma expressão que representa o acesso a uma propriedade.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3269">The following example shows how to create an expression that represents accessing a property.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#38](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#38)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#38](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#38)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f7da9-3270">
            <paramref name="expression" /> ou <paramref name="propertyName" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3270">
              <paramref name="expression" /> or <paramref name="propertyName" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f7da9-3271">Nenhuma propriedade nomeada <paramref name="propertyName" /> é definida no tipo <paramref name="expression" /> ou em seus tipos base.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3271">No property named <paramref name="propertyName" /> is defined in <paramref name="expression" />.Type or its base types.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.IndexExpression Property (System.Linq.Expressions.Expression instance, System.Reflection.PropertyInfo indexer, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.IndexExpression Property(class System.Linq.Expressions.Expression instance, class System.Reflection.PropertyInfo indexer, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Property (instance As Expression, indexer As PropertyInfo, arguments As IEnumerable(Of Expression)) As IndexExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::IndexExpression ^ Property(System::Linq::Expressions::Expression ^ instance, System::Reflection::PropertyInfo ^ indexer, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Property : System.Linq.Expressions.Expression * System.Reflection.PropertyInfo * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.IndexExpression" Usage="System.Linq.Expressions.Expression.Property (instance, indexer, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.IndexExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="indexer" Type="System.Reflection.PropertyInfo" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="instance">
          <span data-ttu-id="f7da9-3272">O objeto ao qual a propriedade pertence.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3272">The object to which the property belongs.</span>
          </span>
          <span data-ttu-id="f7da9-3273">Se a propriedade for estática/compartilhada, ela deverá ser nula.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3273">If the property is static/shared, it must be null.</span>
          </span>
        </param>
        <param name="indexer">
          <span data-ttu-id="f7da9-3274">O <see cref="T:System.Reflection.PropertyInfo" /> que representa a propriedade de índice.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3274">The <see cref="T:System.Reflection.PropertyInfo" /> that represents the property to index.</span>
          </span>
        </param>
        <param name="arguments">
          <span data-ttu-id="f7da9-3275">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> de objetos <see cref="T:System.Linq.Expressions.Expression" /> que são usados para indexar a propriedade.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3275">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:System.Linq.Expressions.Expression" /> objects that are used to index the property.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-3276">Cria um <see cref="T:System.Linq.Expressions.IndexExpression" /> que representa o acesso a uma propriedade indexada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3276">Creates an <see cref="T:System.Linq.Expressions.IndexExpression" /> representing the access to an indexed property.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-3277">O <see cref="T:System.Linq.Expressions.IndexExpression" /> criado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3277">The created <see cref="T:System.Linq.Expressions.IndexExpression" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.IndexExpression Property (System.Linq.Expressions.Expression instance, System.Reflection.PropertyInfo indexer, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.IndexExpression Property(class System.Linq.Expressions.Expression instance, class System.Reflection.PropertyInfo indexer, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Property (instance As Expression, indexer As PropertyInfo, ParamArray arguments As Expression()) As IndexExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::IndexExpression ^ Property(System::Linq::Expressions::Expression ^ instance, System::Reflection::PropertyInfo ^ indexer, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Property : System.Linq.Expressions.Expression * System.Reflection.PropertyInfo * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.IndexExpression" Usage="System.Linq.Expressions.Expression.Property (instance, indexer, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.IndexExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="indexer" Type="System.Reflection.PropertyInfo" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="instance">
          <span data-ttu-id="f7da9-3278">O objeto ao qual a propriedade pertence.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3278">The object to which the property belongs.</span>
          </span>
          <span data-ttu-id="f7da9-3279">Se a propriedade for estática/compartilhada, ela deverá ser nula.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3279">If the property is static/shared, it must be null.</span>
          </span>
        </param>
        <param name="indexer">
          <span data-ttu-id="f7da9-3280">O <see cref="T:System.Reflection.PropertyInfo" /> que representa a propriedade de índice.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3280">The <see cref="T:System.Reflection.PropertyInfo" /> that represents the property to index.</span>
          </span>
        </param>
        <param name="arguments">
          <span data-ttu-id="f7da9-3281">Uma matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> que são usados para a propriedade de índice.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3281">An array of <see cref="T:System.Linq.Expressions.Expression" /> objects that are used to index the property.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-3282">Cria um <see cref="T:System.Linq.Expressions.IndexExpression" /> que representa o acesso a uma propriedade indexada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3282">Creates an <see cref="T:System.Linq.Expressions.IndexExpression" /> representing the access to an indexed property.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-3283">O <see cref="T:System.Linq.Expressions.IndexExpression" /> criado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3283">The created <see cref="T:System.Linq.Expressions.IndexExpression" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.IndexExpression Property (System.Linq.Expressions.Expression instance, string propertyName, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.IndexExpression Property(class System.Linq.Expressions.Expression instance, string propertyName, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.String,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Property (instance As Expression, propertyName As String, ParamArray arguments As Expression()) As IndexExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::IndexExpression ^ Property(System::Linq::Expressions::Expression ^ instance, System::String ^ propertyName, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Property : System.Linq.Expressions.Expression * string * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.IndexExpression" Usage="System.Linq.Expressions.Expression.Property (instance, propertyName, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.IndexExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="propertyName" Type="System.String" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="instance">
          <span data-ttu-id="f7da9-3284">O objeto ao qual a propriedade pertence.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3284">The object to which the property belongs.</span>
          </span>
          <span data-ttu-id="f7da9-3285">Se a propriedade for estática/compartilhada, ela deverá ser nula.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3285">If the property is static/shared, it must be null.</span>
          </span>
        </param>
        <param name="propertyName">
          <span data-ttu-id="f7da9-3286">O nome do indexador.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3286">The name of the indexer.</span>
          </span>
        </param>
        <param name="arguments">
          <span data-ttu-id="f7da9-3287">Uma matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> que são usados para a propriedade de índice.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3287">An array of <see cref="T:System.Linq.Expressions.Expression" /> objects that are used to index the property.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-3288">Cria um <see cref="T:System.Linq.Expressions.IndexExpression" /> que representa o acesso a uma propriedade indexada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3288">Creates an <see cref="T:System.Linq.Expressions.IndexExpression" /> representing the access to an indexed property.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-3289">O <see cref="T:System.Linq.Expressions.IndexExpression" /> criado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3289">The created <see cref="T:System.Linq.Expressions.IndexExpression" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression Property (System.Linq.Expressions.Expression expression, Type type, string propertyName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression Property(class System.Linq.Expressions.Expression expression, class System.Type type, string propertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberExpression ^ Property(System::Linq::Expressions::Expression ^ expression, Type ^ type, System::String ^ propertyName);" />
      <MemberSignature Language="F#" Value="static member Property : System.Linq.Expressions.Expression * Type * string -&gt; System.Linq.Expressions.MemberExpression" Usage="System.Linq.Expressions.Expression.Property (expression, type, propertyName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="propertyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="expression">
          <span data-ttu-id="f7da9-3290">O objeto recipiente da propriedade.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3290">The containing object of the property.</span>
          </span>
          <span data-ttu-id="f7da9-3291">Pode ser nulo para propriedades estáticas.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3291">This can be null for static properties.</span>
          </span>
        </param>
        <param name="type">
          <span data-ttu-id="f7da9-3292">O <see cref="P:System.Linq.Expressions.Expression.Type" /> que contém a propriedade.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3292">The <see cref="P:System.Linq.Expressions.Expression.Type" /> that contains the property.</span>
          </span>
        </param>
        <param name="propertyName">
          <span data-ttu-id="f7da9-3293">A propriedade a ser acessada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3293">The property to be accessed.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-3294">Cria um <see cref="T:System.Linq.Expressions.MemberExpression" /> acessando uma propriedade.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3294">Creates a <see cref="T:System.Linq.Expressions.MemberExpression" /> accessing a property.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-3295">O <see cref="T:System.Linq.Expressions.MemberExpression" /> criado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3295">The created <see cref="T:System.Linq.Expressions.MemberExpression" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PropertyOrField">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression PropertyOrField (System.Linq.Expressions.Expression expression, string propertyOrFieldName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression PropertyOrField(class System.Linq.Expressions.Expression expression, string propertyOrFieldName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PropertyOrField(System.Linq.Expressions.Expression,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberExpression ^ PropertyOrField(System::Linq::Expressions::Expression ^ expression, System::String ^ propertyOrFieldName);" />
      <MemberSignature Language="F#" Value="static member PropertyOrField : System.Linq.Expressions.Expression * string -&gt; System.Linq.Expressions.MemberExpression" Usage="System.Linq.Expressions.Expression.PropertyOrField (expression, propertyOrFieldName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="propertyOrFieldName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="expression">
          <span data-ttu-id="f7da9-3296">Um <see cref="T:System.Linq.Expressions.Expression" /> cujo <see cref="P:System.Linq.Expressions.Expression.Type" /> contém uma propriedade ou campo chamado <paramref name="propertyOrFieldName" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3296">An <see cref="T:System.Linq.Expressions.Expression" /> whose <see cref="P:System.Linq.Expressions.Expression.Type" /> contains a property or field named <paramref name="propertyOrFieldName" />.</span>
          </span>
          <span data-ttu-id="f7da9-3297">Isso pode ser nulo para membros estáticos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3297">This can be null for static members.</span>
          </span>
        </param>
        <param name="propertyOrFieldName">
          <span data-ttu-id="f7da9-3298">O nome de uma propriedade ou campo a ser acessado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3298">The name of a property or field to be accessed.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-3299">Cria um <see cref="T:System.Linq.Expressions.MemberExpression" /> que representa o acesso a uma propriedade ou campo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3299">Creates a <see cref="T:System.Linq.Expressions.MemberExpression" /> that represents accessing a property or field.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-3300">Um <see cref="T:System.Linq.Expressions.MemberExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, a propriedade <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> definida como <paramref name="expression" /> e a propriedade <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> definida como o <see cref="T:System.Reflection.PropertyInfo" /> ou <see cref="T:System.Reflection.FieldInfo" /> que representa a propriedade indicada por <paramref name="propertyOrFieldName" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3300">A <see cref="T:System.Linq.Expressions.MemberExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, the <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> property set to <paramref name="expression" />, and the <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> property set to the <see cref="T:System.Reflection.PropertyInfo" /> or <see cref="T:System.Reflection.FieldInfo" /> that represents the property or field denoted by <paramref name="propertyOrFieldName" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-3301">O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade resultantes <xref:System.Linq.Expressions.MemberExpression> é igual ao <xref:System.Reflection.PropertyInfo.PropertyType%2A> ou <xref:System.Reflection.FieldInfo.FieldType%2A> propriedades do <xref:System.Reflection.PropertyInfo> ou <xref:System.Reflection.FieldInfo>, respectivamente, que representa a propriedade ou campo indicado por `propertyOrFieldName`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3301">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.MemberExpression> is equal to the <xref:System.Reflection.PropertyInfo.PropertyType%2A> or <xref:System.Reflection.FieldInfo.FieldType%2A> properties of the <xref:System.Reflection.PropertyInfo> or <xref:System.Reflection.FieldInfo>, respectively, that represents the property or field denoted by `propertyOrFieldName`.</span></span>  
  
 <span data-ttu-id="f7da9-3302">Este método pesquisa `expression`. Tipo e seus tipos base para uma propriedade ou campo que tem o nome `propertyOrFieldName`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3302">This method searches `expression`.Type and its base types for a property or field that has the name `propertyOrFieldName`.</span></span> <span data-ttu-id="f7da9-3303">Campos e propriedades públicas terá preferência sobre os campos e propriedades não públicas.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3303">Public properties and fields are given preference over non-public properties and fields.</span></span> <span data-ttu-id="f7da9-3304">Além disso, as propriedades terá preferência em relação aos campos.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3304">Also, properties are given preference over fields.</span></span> <span data-ttu-id="f7da9-3305">Se uma propriedade ou campo de correspondência for encontrado, esse método passa `expression` e o <xref:System.Reflection.PropertyInfo> ou <xref:System.Reflection.FieldInfo> que representa essa propriedade ou campo para <xref:System.Linq.Expressions.Expression.Property%2A> ou <xref:System.Linq.Expressions.Expression.Field%2A>, respectivamente.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3305">If a matching property or field is found, this method passes `expression` and the <xref:System.Reflection.PropertyInfo> or <xref:System.Reflection.FieldInfo> that represents that property or field to <xref:System.Linq.Expressions.Expression.Property%2A> or <xref:System.Linq.Expressions.Expression.Field%2A>, respectively.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f7da9-3306">O exemplo a seguir mostra como criar uma expressão que representa o acesso a uma propriedade ou campo.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3306">The following example shows how to create an expression that represents accessing a property or field.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#39](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#39)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#39](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#39)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f7da9-3307">
            <paramref name="expression" /> ou <paramref name="propertyOrFieldName" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3307">
              <paramref name="expression" /> or <paramref name="propertyOrFieldName" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f7da9-3308">Nenhuma propriedade nomeado <paramref name="propertyOrFieldName" /> é definido em <paramref name="expression" />.Type ou em seus tipos base.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3308">No property or field named <paramref name="propertyOrFieldName" /> is defined in <paramref name="expression" />.Type or its base types.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Quote">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Quote (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Quote(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Quote(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Quote(System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member Quote : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Quote expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression">
          <span data-ttu-id="f7da9-3309">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3309">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-3310">Cria uma <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa uma expressão que tem um valor constante do tipo <see cref="T:System.Linq.Expressions.Expression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3310">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents an expression that has a constant value of type <see cref="T:System.Linq.Expressions.Expression" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-3311">Uma <see cref="T:System.Linq.Expressions.UnaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Quote" /> e a propriedade <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> definida para o valor especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3311">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Quote" /> and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property set to the specified value.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-3312">O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade resultantes <xref:System.Linq.Expressions.UnaryExpression> representa o tipo construído <xref:System.Linq.Expressions.Expression%601>, em que o argumento de tipo é o tipo representado por `expression`. Tipo.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3312">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.UnaryExpression> represents the constructed type <xref:System.Linq.Expressions.Expression%601>, where the type argument is the type represented by `expression`.Type.</span></span> <span data-ttu-id="f7da9-3313">A propriedade <xref:System.Linq.Expressions.UnaryExpression.Method%2A> é `null`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3313">The <xref:System.Linq.Expressions.UnaryExpression.Method%2A> property is `null`.</span></span> <span data-ttu-id="f7da9-3314">Ambos <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> e <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> são `false`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3314">Both <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> are `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f7da9-3315">
            <paramref name="expression" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3315">
              <paramref name="expression" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Reduce">
      <MemberSignature Language="C#" Value="public virtual System.Linq.Expressions.Expression Reduce ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Linq.Expressions.Expression Reduce() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Reduce" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Reduce () As Expression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Linq::Expressions::Expression ^ Reduce();" />
      <MemberSignature Language="F#" Value="abstract member Reduce : unit -&gt; System.Linq.Expressions.Expression&#xA;override this.Reduce : unit -&gt; System.Linq.Expressions.Expression" Usage="expression.Reduce " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="f7da9-3316">Reduz esse nó a uma expressão mais simples.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3316">Reduces this node to a simpler expression.</span>
          </span>
          <span data-ttu-id="f7da9-3317">Se CanReduce retornar true, ele deverá retornar uma expressão válida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3317">If CanReduce returns true, this should return a valid expression.</span>
          </span>
          <span data-ttu-id="f7da9-3318">Esse método pode retornar outro nó que também precisa ser reduzido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3318">This method can return another node which itself must be reduced.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-3319">A expressão reduzida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3319">The reduced expression.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReduceAndCheck">
      <MemberSignature Language="C#" Value="public System.Linq.Expressions.Expression ReduceAndCheck ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Linq.Expressions.Expression ReduceAndCheck() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ReduceAndCheck" />
      <MemberSignature Language="VB.NET" Value="Public Function ReduceAndCheck () As Expression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Linq::Expressions::Expression ^ ReduceAndCheck();" />
      <MemberSignature Language="F#" Value="member this.ReduceAndCheck : unit -&gt; System.Linq.Expressions.Expression" Usage="expression.ReduceAndCheck " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="f7da9-3320">Reduz esse nó a uma expressão mais simples.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3320">Reduces this node to a simpler expression.</span>
          </span>
          <span data-ttu-id="f7da9-3321">Se CanReduce retornar true, ele deverá retornar uma expressão válida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3321">If CanReduce returns true, this should return a valid expression.</span>
          </span>
          <span data-ttu-id="f7da9-3322">Esse método pode retornar outro nó que também precisa ser reduzido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3322">This method can return another node which itself must be reduced.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-3323">A expressão reduzida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3323">The reduced expression.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-3324">Ao contrário de redução, esse método verifica que o nó reduzido atende a determinados invariáveis.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3324">Unlike Reduce, this method checks that the reduced node satisfies certain invariants.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReduceExtensions">
      <MemberSignature Language="C#" Value="public System.Linq.Expressions.Expression ReduceExtensions ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Linq.Expressions.Expression ReduceExtensions() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ReduceExtensions" />
      <MemberSignature Language="VB.NET" Value="Public Function ReduceExtensions () As Expression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Linq::Expressions::Expression ^ ReduceExtensions();" />
      <MemberSignature Language="F#" Value="member this.ReduceExtensions : unit -&gt; System.Linq.Expressions.Expression" Usage="expression.ReduceExtensions " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="f7da9-3325">Reduz a expressão a um tipo de nó conhecido (que não é um nó de extensão) ou apenas retorna a expressão se ele já é um tipo conhecido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3325">Reduces the expression to a known node type (that is not an Extension node) or just returns the expression if it is already a known type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-3326">A expressão reduzida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3326">The reduced expression.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReferenceEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ReferenceEqual (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ReferenceEqual(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ReferenceEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReferenceEqual (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ReferenceEqual(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member ReferenceEqual : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.ReferenceEqual (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="f7da9-3327">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3327">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="f7da9-3328">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3328">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-3329">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma comparação de igualdade de referência.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3329">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a reference equality comparison.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-3330">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Equal" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3330">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Equal" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReferenceNotEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ReferenceNotEqual (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ReferenceNotEqual(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ReferenceNotEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReferenceNotEqual (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ReferenceNotEqual(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member ReferenceNotEqual : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.ReferenceNotEqual (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="f7da9-3331">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3331">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="f7da9-3332">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3332">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-3333">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma comparação de desigualdade de referência.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3333">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a reference inequality comparison.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-3334">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.NotEqual" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3334">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.NotEqual" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Rethrow">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f7da9-3335">Cria um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa um relançamento de uma exceção.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3335">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a rethrowing of an exception.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Rethrow">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Rethrow ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Rethrow() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Rethrow" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Rethrow () As UnaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Rethrow();" />
      <MemberSignature Language="F#" Value="static member Rethrow : unit -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Rethrow " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="f7da9-3336">Cria um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa um relançamento de uma exceção.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3336">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a rethrowing of an exception.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-3337">Um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa um relançamento de uma exceção.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3337">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a rethrowing of an exception.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Rethrow">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Rethrow (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Rethrow(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Rethrow(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Rethrow(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Rethrow : Type -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Rethrow type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">
          <span data-ttu-id="f7da9-3338">O novo <see cref="T:System.Type" /> da expressão.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3338">The new <see cref="T:System.Type" /> of the expression.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-3339">Cria um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa um relançamento de uma exceção com um determinado tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3339">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a rethrowing of an exception with a given type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-3340">Um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa um relançamento de uma exceção.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3340">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a rethrowing of an exception.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Return">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f7da9-3341">Cria um <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa um demonstrativo de retorno.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3341">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a return statement.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Return">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Return (System.Linq.Expressions.LabelTarget target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Return(class System.Linq.Expressions.LabelTarget target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Return (target As LabelTarget) As GotoExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Return(System::Linq::Expressions::LabelTarget ^ target);" />
      <MemberSignature Language="F#" Value="static member Return : System.Linq.Expressions.LabelTarget -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.Return target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
      </Parameters>
      <Docs>
        <param name="target">
          <span data-ttu-id="f7da9-3342">O <see cref="T:System.Linq.Expressions.LabelTarget" /> para o qual o <see cref="T:System.Linq.Expressions.GotoExpression" /> irá.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3342">The <see cref="T:System.Linq.Expressions.LabelTarget" /> that the <see cref="T:System.Linq.Expressions.GotoExpression" /> will jump to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-3343">Cria um <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa um demonstrativo de retorno.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3343">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a return statement.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-3344">Um <see cref="T:System.Linq.Expressions.GotoExpression" /> com <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Return, a propriedade <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> definida para <paramref name="target" /> e um valor nulo a ser passado para o rótulo de destino ao saltar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3344">A <see cref="T:System.Linq.Expressions.GotoExpression" /> with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> equal to Return, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> property set to <paramref name="target" />, and a null value to be passed to the target label upon jumping.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Return">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Return (System.Linq.Expressions.LabelTarget target, System.Linq.Expressions.Expression value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Return(class System.Linq.Expressions.LabelTarget target, class System.Linq.Expressions.Expression value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Return (target As LabelTarget, value As Expression) As GotoExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Return(System::Linq::Expressions::LabelTarget ^ target, System::Linq::Expressions::Expression ^ value);" />
      <MemberSignature Language="F#" Value="static member Return : System.Linq.Expressions.LabelTarget * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.Return (target, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="target">
          <span data-ttu-id="f7da9-3345">O <see cref="T:System.Linq.Expressions.LabelTarget" /> para o qual o <see cref="T:System.Linq.Expressions.GotoExpression" /> irá.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3345">The <see cref="T:System.Linq.Expressions.LabelTarget" /> that the <see cref="T:System.Linq.Expressions.GotoExpression" /> will jump to.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="f7da9-3346">O valor que será passado para o rótulo associado ao saltar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3346">The value that will be passed to the associated label upon jumping.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-3347">Cria um <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa um demonstrativo de retorno.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3347">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a return statement.</span>
          </span>
          <span data-ttu-id="f7da9-3348">O valor passado para o rótulo no salto pode ser especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3348">The value passed to the label upon jumping can be specified.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-3349">Um <see cref="T:System.Linq.Expressions.GotoExpression" /> com <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Continuar, a propriedade <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> definida como <paramref name="target" /> e <paramref name="value" /> a ser passado para o rótulo de destino ao saltar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3349">A <see cref="T:System.Linq.Expressions.GotoExpression" /> with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> equal to Continue, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> property set to <paramref name="target" />, and <paramref name="value" /> to be passed to the target label upon jumping.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="f7da9-3350">O exemplo a seguir demonstra como criar uma expressão que contém o <xref:System.Linq.Expressions.Expression.Return%2A> método.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3350">The following example demonstrates how to create an expression that contains the <xref:System.Linq.Expressions.Expression.Return%2A> method.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#43](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#43)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#43](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#43)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Return">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Return (System.Linq.Expressions.LabelTarget target, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Return(class System.Linq.Expressions.LabelTarget target, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Return(System::Linq::Expressions::LabelTarget ^ target, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Return : System.Linq.Expressions.LabelTarget * Type -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.Return (target, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="target">
          <span data-ttu-id="f7da9-3351">O <see cref="T:System.Linq.Expressions.LabelTarget" /> para o qual o <see cref="T:System.Linq.Expressions.GotoExpression" /> irá.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3351">The <see cref="T:System.Linq.Expressions.LabelTarget" /> that the <see cref="T:System.Linq.Expressions.GotoExpression" /> will jump to.</span>
          </span>
        </param>
        <param name="type">
          <span data-ttu-id="f7da9-3352">Um <see cref="T:System.Type" /> para definir a propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3352">An <see cref="T:System.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-3353">Cria um <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa uma instrução return com o tipo especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3353">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a return statement with the specified type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-3354">Um <see cref="T:System.Linq.Expressions.GotoExpression" /> com <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Return, a propriedade <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> definida para <paramref name="target" />, a propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> definida para <paramref name="type" /> e um valor nulo a ser passado para o rótulo de destino ao saltar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3354">A <see cref="T:System.Linq.Expressions.GotoExpression" /> with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> equal to Return, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> property set to <paramref name="target" />, the <see cref="P:System.Linq.Expressions.Expression.Type" /> property set to <paramref name="type" />, and a null value to be passed to the target label upon jumping.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Return">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Return (System.Linq.Expressions.LabelTarget target, System.Linq.Expressions.Expression value, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Return(class System.Linq.Expressions.LabelTarget target, class System.Linq.Expressions.Expression value, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Return(System::Linq::Expressions::LabelTarget ^ target, System::Linq::Expressions::Expression ^ value, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Return : System.Linq.Expressions.LabelTarget * System.Linq.Expressions.Expression * Type -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.Return (target, value, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="target">
          <span data-ttu-id="f7da9-3355">O <see cref="T:System.Linq.Expressions.LabelTarget" /> para o qual o <see cref="T:System.Linq.Expressions.GotoExpression" /> irá.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3355">The <see cref="T:System.Linq.Expressions.LabelTarget" /> that the <see cref="T:System.Linq.Expressions.GotoExpression" /> will jump to.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="f7da9-3356">O valor que será passado para o rótulo associado ao saltar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3356">The value that will be passed to the associated label upon jumping.</span>
          </span>
        </param>
        <param name="type">
          <span data-ttu-id="f7da9-3357">Um <see cref="T:System.Type" /> para definir a propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3357">An <see cref="T:System.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-3358">Cria um <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa uma instrução return com o tipo especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3358">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a return statement with the specified type.</span>
          </span>
          <span data-ttu-id="f7da9-3359">O valor passado para o rótulo no salto pode ser especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3359">The value passed to the label upon jumping can be specified.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-3360">Um <see cref="T:System.Linq.Expressions.GotoExpression" /> com <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Continue, a propriedade <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> definida para <paramref name="target" />, a propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> definida para <paramref name="type" /> e <paramref name="value" /> a ser passado para o rótulo de destino ao saltar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3360">A <see cref="T:System.Linq.Expressions.GotoExpression" /> with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> equal to Continue, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> property set to <paramref name="target" />, the <see cref="P:System.Linq.Expressions.Expression.Type" /> property set to <paramref name="type" />, and <paramref name="value" /> to be passed to the target label upon jumping.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="RightShift">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f7da9-3361">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de deslocamento à direita bit a bit.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3361">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise right-shift operation.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RightShift">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression RightShift (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression RightShift(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.RightShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RightShift (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ RightShift(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member RightShift : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.RightShift (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="f7da9-3362">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3362">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="f7da9-3363">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3363">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-3364">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de deslocamento à direita bit a bit.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3364">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise right-shift operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-3365">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.RightShift" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3365">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.RightShift" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-3366">Resultante <xref:System.Linq.Expressions.BinaryExpression> tem o <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriedade definida como o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3366">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="f7da9-3367">O <xref:System.Linq.Expressions.Expression.Type%2A> estiver definida como o tipo de nó.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3367">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="f7da9-3368">Se o nó é elevado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> e <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriedades estiverem `true`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3368">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="f7da9-3369">Caso contrário, eles são `false`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3369">Otherwise, they are `false`.</span></span> <span data-ttu-id="f7da9-3370">A propriedade <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> é `null`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3370">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="f7da9-3371">As informações a seguir descrevem o método de implementação, o tipo de nó, e se um nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3371">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="f7da9-3372">Implementando método</span><span class="sxs-lookup"><span data-stu-id="f7da9-3372">Implementing Method</span></span>  
 <span data-ttu-id="f7da9-3373">As seguintes regras de determinam o método de implementação selecionado para a operação:</span><span class="sxs-lookup"><span data-stu-id="f7da9-3373">The following rules determine the selected implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="f7da9-3374">Se o <xref:System.Linq.Expressions.Expression.Type%2A> propriedade deles `left` ou `right` representa um tipo definido pelo usuário que sobrecarrega o operador de deslocamento à direita, o <xref:System.Reflection.MethodInfo> que representa que o método é o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3374">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the right-shift operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="f7da9-3375">Caso contrário, se `left`. Tipo é um tipo integral (um dos <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, ou os tipos que permitem valor nulos correspondentes) e `right`. É do tipo <xref:System.Int32>, o método de implementação é `null`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3375">Otherwise, if `left`.Type is an integral type (one of <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, or the corresponding nullable types) and `right`.Type is <xref:System.Int32>, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="f7da9-3376">Tipo de nó e versão com comparação de precisão x sem comparação de precisão</span><span class="sxs-lookup"><span data-stu-id="f7da9-3376">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="f7da9-3377">Se o método de implementação não for `null`:</span><span class="sxs-lookup"><span data-stu-id="f7da9-3377">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="f7da9-3378">Se `left`. Tipo e `right`. Tipo podem ser atribuídos aos tipos de argumento correspondente do método de implementação, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3378">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="f7da9-3379">O tipo do nó é o tipo de retorno do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3379">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="f7da9-3380">Se as duas seguintes condições forem atendidas, o nó é levantado e o tipo de nó é o tipo que permite valor nulo que corresponde ao tipo de retorno do método de implementação:</span><span class="sxs-lookup"><span data-stu-id="f7da9-3380">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="f7da9-3381">`left`. Tipo e `right`. Tipo são os dois tipos de valor de que pelo menos um é anulável e os tipos não anuláveis correspondentes são iguais para os tipos de argumento correspondente do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3381">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="f7da9-3382">O tipo de retorno do método de implementação é um tipo de valor não anulável.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3382">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="f7da9-3383">Se o método de implementação é `null`:</span><span class="sxs-lookup"><span data-stu-id="f7da9-3383">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="f7da9-3384">Se `left`. Tipo e `right`. Tipo são não anuláveis, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3384">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="f7da9-3385">O tipo do nó é o tipo de resultado do operador de deslocamento à direita predefinido.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3385">The type of the node is the result type of the predefined right-shift operator.</span></span>  
  
-   <span data-ttu-id="f7da9-3386">Se `left`. Tipo e `right`. Tipo são anuláveis, o nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3386">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="f7da9-3387">O tipo de nó é o tipo que permite valor nulo que corresponde ao tipo de resultado do operador de deslocamento à direita predefinido.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3387">The type of the node is the nullable type that corresponds to the result type of the predefined right-shift operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f7da9-3388">
            <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3388">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f7da9-3389">O operador de deslocamento à direita não foi definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3389">The right-shift operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="RightShift">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression RightShift (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression RightShift(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.RightShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RightShift (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ RightShift(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member RightShift : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.RightShift (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="f7da9-3390">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3390">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="f7da9-3391">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3391">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="f7da9-3392">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3392">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-3393">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de deslocamento à direita bit a bit.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3393">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise right-shift operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-3394">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.RightShift" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3394">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.RightShift" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-3395">Resultante <xref:System.Linq.Expressions.BinaryExpression> tem o <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriedade definida como o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3395">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="f7da9-3396">O <xref:System.Linq.Expressions.Expression.Type%2A> estiver definida como o tipo de nó.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3396">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="f7da9-3397">Se o nó é elevado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> e <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriedades estiverem `true`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3397">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="f7da9-3398">Caso contrário, eles são `false`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3398">Otherwise, they are `false`.</span></span> <span data-ttu-id="f7da9-3399">A propriedade <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> é `null`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3399">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="f7da9-3400">As informações a seguir descrevem o método de implementação, o tipo de nó, e se um nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3400">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="f7da9-3401">Implementando método</span><span class="sxs-lookup"><span data-stu-id="f7da9-3401">Implementing Method</span></span>  
 <span data-ttu-id="f7da9-3402">As seguintes regras de determinam o método de implementação selecionado para a operação:</span><span class="sxs-lookup"><span data-stu-id="f7da9-3402">The following rules determine the selected implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="f7da9-3403">Se `method` não é `null` e representa um não-nulo, `static` (`Shared` no Visual Basic) método que usa dois argumentos, é o método de implementação para o nó.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3403">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method for the node.</span></span>  
  
-   <span data-ttu-id="f7da9-3404">Caso contrário, se o <xref:System.Linq.Expressions.Expression.Type%2A> propriedade deles `left` ou `right` representa um tipo definido pelo usuário que sobrecarrega o operador de deslocamento à direita, o <xref:System.Reflection.MethodInfo> que representa que o método é o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3404">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the right-shift operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="f7da9-3405">Caso contrário, se `left`. Tipo é um tipo integral (um dos <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, ou os tipos que permitem valor nulos correspondentes) e `right`. É do tipo <xref:System.Int32>, o método de implementação é `null`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3405">Otherwise, if `left`.Type is an integral type (one of <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, or the corresponding nullable types) and `right`.Type is <xref:System.Int32>, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="f7da9-3406">Tipo de nó e versão com comparação de precisão x sem comparação de precisão</span><span class="sxs-lookup"><span data-stu-id="f7da9-3406">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="f7da9-3407">Se o método de implementação não for `null`:</span><span class="sxs-lookup"><span data-stu-id="f7da9-3407">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="f7da9-3408">Se `left`. Tipo e `right`. Tipo podem ser atribuídos aos tipos de argumento correspondente do método de implementação, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3408">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="f7da9-3409">O tipo do nó é o tipo de retorno do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3409">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="f7da9-3410">Se as duas seguintes condições forem atendidas, o nó é levantado e o tipo de nó é o tipo que permite valor nulo que corresponde ao tipo de retorno do método de implementação:</span><span class="sxs-lookup"><span data-stu-id="f7da9-3410">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="f7da9-3411">`left`. Tipo e `right`. Tipo são os dois tipos de valor de que pelo menos um é anulável e os tipos não anuláveis correspondentes são iguais para os tipos de argumento correspondente do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3411">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="f7da9-3412">O tipo de retorno do método de implementação é um tipo de valor não anulável.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3412">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="f7da9-3413">Se o método de implementação é `null`:</span><span class="sxs-lookup"><span data-stu-id="f7da9-3413">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="f7da9-3414">Se `left`. Tipo e `right`. Tipo são não anuláveis, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3414">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="f7da9-3415">O tipo do nó é o tipo de resultado do operador de deslocamento à direita predefinido.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3415">The type of the node is the result type of the predefined right-shift operator.</span></span>  
  
-   <span data-ttu-id="f7da9-3416">Se `left`. Tipo e `right`. Tipo são anuláveis, o nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3416">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="f7da9-3417">O tipo de nó é o tipo que permite valor nulo que corresponde ao tipo de resultado do operador de deslocamento à direita predefinido.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3417">The type of the node is the nullable type that corresponds to the result type of the predefined right-shift operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f7da9-3418">
            <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3418">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f7da9-3419">
            <paramref name="method" /> não é <see langword="null" /> e o método que ele representa retorna <see langword="void" />, não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) ou não tem exatamente dois argumentos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3419">
              <paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f7da9-3420">
            <paramref name="method" /> é <see langword="null" /> e o operador de deslocamento à direita não foi definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3420">
              <paramref name="method" /> is <see langword="null" /> and the right-shift operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="RightShiftAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f7da9-3421">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição de deslocamento à direita bit a bit.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3421">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise right-shift assignment operation.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RightShiftAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression RightShiftAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression RightShiftAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.RightShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RightShiftAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ RightShiftAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member RightShiftAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.RightShiftAssign (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="f7da9-3422">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3422">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="f7da9-3423">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3423">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-3424">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição de deslocamento à direita bit a bit.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3424">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise right-shift assignment operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-3425">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3425">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RightShiftAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression RightShiftAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression RightShiftAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.RightShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RightShiftAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ RightShiftAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member RightShiftAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.RightShiftAssign (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="f7da9-3426">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3426">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="f7da9-3427">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3427">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="f7da9-3428">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3428">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-3429">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição de deslocamento à direita bit a bit.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3429">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise right-shift assignment operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-3430">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3430">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RightShiftAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression RightShiftAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression RightShiftAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.RightShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RightShiftAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ RightShiftAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member RightShiftAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.RightShiftAssign (left, right, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="f7da9-3431">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3431">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="f7da9-3432">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3432">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="f7da9-3433">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3433">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <param name="conversion">
          <span data-ttu-id="f7da9-3434">Um <see cref="T:System.Linq.Expressions.LambdaExpression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3434">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-3435">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição de deslocamento à direita bit a bit.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3435">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise right-shift assignment operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-3436">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3436">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="RuntimeVariables">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f7da9-3437">Cria uma instância de <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3437">Creates an instance of <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RuntimeVariables">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.RuntimeVariablesExpression RuntimeVariables (System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; variables);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.RuntimeVariablesExpression RuntimeVariables(class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; variables) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.RuntimeVariables(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RuntimeVariables (variables As IEnumerable(Of ParameterExpression)) As RuntimeVariablesExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::RuntimeVariablesExpression ^ RuntimeVariables(System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ variables);" />
      <MemberSignature Language="F#" Value="static member RuntimeVariables : seq&lt;System.Linq.Expressions.ParameterExpression&gt; -&gt; System.Linq.Expressions.RuntimeVariablesExpression" Usage="System.Linq.Expressions.Expression.RuntimeVariables variables" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.RuntimeVariablesExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variables" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="variables">
          <span data-ttu-id="f7da9-3438">Uma coleção de objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> a serem usados para popular a coleção de <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3438">A collection of <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-3439">Cria uma instância de <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3439">Creates an instance of <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-3440">Uma instância de <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.RuntimeVariables" /> e a propriedade <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" /> definida para o valor especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3440">An instance of <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.RuntimeVariables" /> and the <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" /> property set to the specified value.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RuntimeVariables">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.RuntimeVariablesExpression RuntimeVariables (params System.Linq.Expressions.ParameterExpression[] variables);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.RuntimeVariablesExpression RuntimeVariables(class System.Linq.Expressions.ParameterExpression[] variables) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.RuntimeVariables(System.Linq.Expressions.ParameterExpression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RuntimeVariables (ParamArray variables As ParameterExpression()) As RuntimeVariablesExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::RuntimeVariablesExpression ^ RuntimeVariables(... cli::array &lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ variables);" />
      <MemberSignature Language="F#" Value="static member RuntimeVariables : System.Linq.Expressions.ParameterExpression[] -&gt; System.Linq.Expressions.RuntimeVariablesExpression" Usage="System.Linq.Expressions.Expression.RuntimeVariables variables" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.RuntimeVariablesExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variables" Type="System.Linq.Expressions.ParameterExpression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="variables">
          <span data-ttu-id="f7da9-3441">Uma matriz de objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> a serem usados para popular a coleção de <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3441">An array of <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" /> collection.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-3442">Cria uma instância de <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3442">Creates an instance of <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-3443">Uma instância de <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.RuntimeVariables" /> e a propriedade <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" /> definida para o valor especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3443">An instance of <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.RuntimeVariables" /> and the <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" /> property set to the specified value.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Subtract">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f7da9-3444">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação aritmética de subtração que não tem verificação de estouro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3444">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic subtraction operation that does not have overflow checking.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Subtract">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Subtract (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Subtract(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Subtract(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Subtract (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Subtract(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member Subtract : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Subtract (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="f7da9-3445">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3445">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="f7da9-3446">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3446">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-3447">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação aritmética de subtração que não tem verificação de estouro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3447">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic subtraction operation that does not have overflow checking.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-3448">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Subtract" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3448">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Subtract" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-3449">Resultante <xref:System.Linq.Expressions.BinaryExpression> tem o <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriedade definida como o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3449">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="f7da9-3450">O <xref:System.Linq.Expressions.Expression.Type%2A> estiver definida como o tipo de nó.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3450">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="f7da9-3451">Se o nó é elevado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> e <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriedades estiverem `true`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3451">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="f7da9-3452">Caso contrário, eles são `false`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3452">Otherwise, they are `false`.</span></span> <span data-ttu-id="f7da9-3453">A propriedade <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> é `null`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3453">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="f7da9-3454">As informações a seguir descrevem o método de implementação, o tipo de nó, e se um nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3454">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="f7da9-3455">Implementando método</span><span class="sxs-lookup"><span data-stu-id="f7da9-3455">Implementing Method</span></span>  
 <span data-ttu-id="f7da9-3456">As seguintes regras de determinam o método de implementação selecionado para a operação:</span><span class="sxs-lookup"><span data-stu-id="f7da9-3456">The following rules determine the selected implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="f7da9-3457">Se o <xref:System.Linq.Expressions.Expression.Type%2A> propriedade deles `left` ou `right` representa um tipo definido pelo usuário que sobrecarrega o operador de subtração, o <xref:System.Reflection.MethodInfo> que representa que o método é o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3457">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the subtraction operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="f7da9-3458">Caso contrário, se `left`. Tipo e `right`. Tipo de tipos numéricos, o método de implementação está `null`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3458">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="f7da9-3459">Tipo de nó e versão com comparação de precisão x sem comparação de precisão</span><span class="sxs-lookup"><span data-stu-id="f7da9-3459">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="f7da9-3460">Se o método de implementação não for `null`:</span><span class="sxs-lookup"><span data-stu-id="f7da9-3460">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="f7da9-3461">Se `left`. Tipo e `right`. Tipo podem ser atribuídos aos tipos de argumento correspondente do método de implementação, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3461">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="f7da9-3462">O tipo do nó é o tipo de retorno do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3462">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="f7da9-3463">Se as duas seguintes condições forem atendidas, o nó é levantado e o tipo de nó é o tipo que permite valor nulo que corresponde ao tipo de retorno do método de implementação:</span><span class="sxs-lookup"><span data-stu-id="f7da9-3463">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="f7da9-3464">`left`. Tipo e `right`. Tipo são os dois tipos de valor de que pelo menos um é anulável e os tipos não anuláveis correspondentes são iguais para os tipos de argumento correspondente do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3464">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="f7da9-3465">O tipo de retorno do método de implementação é um tipo de valor não anulável.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3465">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="f7da9-3466">Se o método de implementação é `null`:</span><span class="sxs-lookup"><span data-stu-id="f7da9-3466">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="f7da9-3467">Se `left`. Tipo e `right`. Tipo são não anuláveis, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3467">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="f7da9-3468">O tipo do nó é o tipo de resultado do operador de subtração predefinidos.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3468">The type of the node is the result type of the predefined subtraction operator.</span></span>  
  
-   <span data-ttu-id="f7da9-3469">Se `left`. Tipo e `right`. Tipo são anuláveis, o nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3469">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="f7da9-3470">O tipo de nó é o tipo que permite valor nulo que corresponde ao tipo de resultado do operador de subtração predefinidos.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3470">The type of the node is the nullable type that corresponds to the result type of the predefined subtraction operator.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f7da9-3471">O exemplo de código a seguir mostra como criar uma expressão que subtrai o argumento do primeiro argumento.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3471">The following code example shows how to create an expression that subtracts the argument from the first argument.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#30](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#30)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#30](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#30)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f7da9-3472">
            <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3472">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f7da9-3473">O operador de subtração não está definido como <paramref name="left" />.Type e <paramref name="right" />.Type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3473">The subtraction operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Subtract">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Subtract (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Subtract(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Subtract(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Subtract (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Subtract(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member Subtract : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Subtract (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="f7da9-3474">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3474">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="f7da9-3475">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3475">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="f7da9-3476">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3476">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-3477">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação aritmética de subtração que não tem verificação de estouro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3477">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic subtraction operation that does not have overflow checking.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-3478">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.Subtract" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3478">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Subtract" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-3479">Resultante <xref:System.Linq.Expressions.BinaryExpression> tem o <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriedade definida como o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3479">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="f7da9-3480">O <xref:System.Linq.Expressions.Expression.Type%2A> estiver definida como o tipo de nó.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3480">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="f7da9-3481">Se o nó é elevado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> e <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriedades estiverem `true`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3481">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="f7da9-3482">Caso contrário, eles são `false`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3482">Otherwise, they are `false`.</span></span> <span data-ttu-id="f7da9-3483">A propriedade <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> é `null`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3483">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="f7da9-3484">As informações a seguir descrevem o método de implementação, o tipo de nó, e se um nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3484">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="f7da9-3485">Implementando método</span><span class="sxs-lookup"><span data-stu-id="f7da9-3485">Implementing Method</span></span>  
 <span data-ttu-id="f7da9-3486">As regras a seguir determinam o método de implementação para a operação:</span><span class="sxs-lookup"><span data-stu-id="f7da9-3486">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="f7da9-3487">Se `method` não é `null` e representa um não-nulo, `static` (`Shared` no Visual Basic) método que usa dois argumentos, é o método de implementação para o nó.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3487">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method for the node.</span></span>  
  
-   <span data-ttu-id="f7da9-3488">Caso contrário, se o <xref:System.Linq.Expressions.Expression.Type%2A> propriedade deles `left` ou `right` representa um tipo definido pelo usuário que sobrecarrega o operador de subtração, o <xref:System.Reflection.MethodInfo> que representa que o método é o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3488">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the subtraction operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="f7da9-3489">Caso contrário, se `left`. Tipo e `right`. Tipo de tipos numéricos, o método de implementação está `null`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3489">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="f7da9-3490">Tipo de nó e versão com comparação de precisão x sem comparação de precisão</span><span class="sxs-lookup"><span data-stu-id="f7da9-3490">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="f7da9-3491">Se o método de implementação não for `null`:</span><span class="sxs-lookup"><span data-stu-id="f7da9-3491">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="f7da9-3492">Se `left`. Tipo e `right`. Tipo podem ser atribuídos aos tipos de argumento correspondente do método de implementação, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3492">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="f7da9-3493">O tipo do nó é o tipo de retorno do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3493">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="f7da9-3494">Se as duas seguintes condições forem atendidas, o nó é levantado e o tipo de nó é o tipo que permite valor nulo que corresponde ao tipo de retorno do método de implementação:</span><span class="sxs-lookup"><span data-stu-id="f7da9-3494">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="f7da9-3495">`left`. Tipo e `right`. Tipo são os dois tipos de valor de que pelo menos um é anulável e os tipos não anuláveis correspondentes são iguais para os tipos de argumento correspondente do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3495">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="f7da9-3496">O tipo de retorno do método de implementação é um tipo de valor não anulável.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3496">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="f7da9-3497">Se o método de implementação é `null`:</span><span class="sxs-lookup"><span data-stu-id="f7da9-3497">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="f7da9-3498">Se `left`. Tipo e `right`. Tipo são não anuláveis, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3498">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="f7da9-3499">O tipo do nó é o tipo de resultado do operador de subtração predefinidos.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3499">The type of the node is the result type of the predefined subtraction operator.</span></span>  
  
-   <span data-ttu-id="f7da9-3500">Se `left`. Tipo e `right`. Tipo são anuláveis, o nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3500">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="f7da9-3501">O tipo de nó é o tipo que permite valor nulo que corresponde ao tipo de resultado do operador de subtração predefinidos.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3501">The type of the node is the nullable type that corresponds to the result type of the predefined subtraction operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f7da9-3502">
            <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3502">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f7da9-3503">
            <paramref name="method" /> não é <see langword="null" /> e o método que ele representa retorna <see langword="void" />, não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) ou não tem exatamente dois argumentos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3503">
              <paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f7da9-3504">
            <paramref name="method" /> é <see langword="null" /> e o operador de subtração não foi definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3504">
              <paramref name="method" /> is <see langword="null" /> and the subtraction operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SubtractAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f7da9-3505">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição de subtração que não tem a verificação de estouro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3505">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a subtraction assignment operation that does not have overflow checking.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SubtractAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression SubtractAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression SubtractAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SubtractAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SubtractAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ SubtractAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member SubtractAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.SubtractAssign (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="f7da9-3506">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3506">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="f7da9-3507">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3507">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-3508">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição de subtração que não tem a verificação de estouro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3508">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a subtraction assignment operation that does not have overflow checking.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-3509">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3509">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SubtractAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression SubtractAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression SubtractAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SubtractAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SubtractAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ SubtractAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member SubtractAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.SubtractAssign (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="f7da9-3510">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3510">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="f7da9-3511">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3511">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="f7da9-3512">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3512">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-3513">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição de subtração que não tem a verificação de estouro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3513">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a subtraction assignment operation that does not have overflow checking.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-3514">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3514">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SubtractAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression SubtractAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression SubtractAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SubtractAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SubtractAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ SubtractAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member SubtractAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.SubtractAssign (left, right, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="f7da9-3515">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3515">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="f7da9-3516">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3516">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="f7da9-3517">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3517">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <param name="conversion">
          <span data-ttu-id="f7da9-3518">Um <see cref="T:System.Linq.Expressions.LambdaExpression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3518">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-3519">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição de subtração que não tem a verificação de estouro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3519">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a subtraction assignment operation that does not have overflow checking.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-3520">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3520">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SubtractAssignChecked">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f7da9-3521">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição de subtração que tem verificação de estouro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3521">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a subtraction assignment operation that has overflow checking.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SubtractAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression SubtractAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression SubtractAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SubtractAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SubtractAssignChecked (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ SubtractAssignChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member SubtractAssignChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.SubtractAssignChecked (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="f7da9-3522">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3522">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="f7da9-3523">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3523">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-3524">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição de subtração que tem verificação de estouro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3524">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a subtraction assignment operation that has overflow checking.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-3525">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3525">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SubtractAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression SubtractAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression SubtractAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SubtractAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SubtractAssignChecked (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ SubtractAssignChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member SubtractAssignChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.SubtractAssignChecked (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="f7da9-3526">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3526">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="f7da9-3527">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3527">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="f7da9-3528">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3528">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-3529">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição de subtração que tem verificação de estouro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3529">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a subtraction assignment operation that has overflow checking.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-3530">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3530">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SubtractAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression SubtractAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression SubtractAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SubtractAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SubtractAssignChecked (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ SubtractAssignChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member SubtractAssignChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.SubtractAssignChecked (left, right, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="f7da9-3531">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3531">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="f7da9-3532">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3532">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="f7da9-3533">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3533">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <param name="conversion">
          <span data-ttu-id="f7da9-3534">Um <see cref="T:System.Linq.Expressions.LambdaExpression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3534">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-3535">Cria uma <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação de atribuição de subtração que tem verificação de estouro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3535">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a subtraction assignment operation that has overflow checking.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-3536">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3536">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SubtractChecked">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f7da9-3537">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação aritmética de subtração que tem verificação de estouro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3537">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic subtraction operation that has overflow checking.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SubtractChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression SubtractChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression SubtractChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SubtractChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SubtractChecked (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ SubtractChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member SubtractChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.SubtractChecked (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="f7da9-3538">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3538">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="f7da9-3539">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3539">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-3540">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação aritmética de subtração que tem verificação de estouro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3540">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic subtraction operation that has overflow checking.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-3541">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.SubtractChecked" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3541">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.SubtractChecked" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-3542">Resultante <xref:System.Linq.Expressions.BinaryExpression> tem o <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriedade definida como o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3542">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="f7da9-3543">O <xref:System.Linq.Expressions.Expression.Type%2A> estiver definida como o tipo de nó.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3543">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="f7da9-3544">Se o nó é elevado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> e <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriedades estiverem `true`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3544">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="f7da9-3545">Caso contrário, eles são `false`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3545">Otherwise, they are `false`.</span></span> <span data-ttu-id="f7da9-3546">A propriedade <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> é `null`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3546">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="f7da9-3547">As informações a seguir descrevem o método de implementação, o tipo de nó, e se um nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3547">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="f7da9-3548">Implementando método</span><span class="sxs-lookup"><span data-stu-id="f7da9-3548">Implementing Method</span></span>  
 <span data-ttu-id="f7da9-3549">As seguintes regras de determinam o método de implementação selecionado para a operação:</span><span class="sxs-lookup"><span data-stu-id="f7da9-3549">The following rules determine the selected implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="f7da9-3550">Se o <xref:System.Linq.Expressions.Expression.Type%2A> propriedade deles `left` ou `right` representa um tipo definido pelo usuário que sobrecarrega o operador de subtração, o <xref:System.Reflection.MethodInfo> que representa que o método é o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3550">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the subtraction operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="f7da9-3551">Caso contrário, se `left`. Tipo e `right`. Tipo de tipos numéricos, o método de implementação está `null`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3551">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="f7da9-3552">Tipo de nó e versão com comparação de precisão x sem comparação de precisão</span><span class="sxs-lookup"><span data-stu-id="f7da9-3552">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="f7da9-3553">Se o método de implementação não for `null`:</span><span class="sxs-lookup"><span data-stu-id="f7da9-3553">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="f7da9-3554">Se `left`. Tipo e `right`. Tipo podem ser atribuídos aos tipos de argumento correspondente do método de implementação, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3554">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="f7da9-3555">O tipo do nó é o tipo de retorno do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3555">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="f7da9-3556">Se as duas seguintes condições forem atendidas, o nó é levantado e o tipo de nó é o tipo que permite valor nulo que corresponde ao tipo de retorno do método de implementação:</span><span class="sxs-lookup"><span data-stu-id="f7da9-3556">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="f7da9-3557">`left`. Tipo e `right`. Tipo são os dois tipos de valor de que pelo menos um é anulável e os tipos não anuláveis correspondentes são iguais para os tipos de argumento correspondente do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3557">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="f7da9-3558">O tipo de retorno do método de implementação é um tipo de valor não anulável.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3558">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="f7da9-3559">Se o método de implementação é `null`:</span><span class="sxs-lookup"><span data-stu-id="f7da9-3559">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="f7da9-3560">Se `left`. Tipo e `right`. Tipo são não anuláveis, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3560">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="f7da9-3561">O tipo do nó é o tipo de resultado do operador de subtração predefinidos.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3561">The type of the node is the result type of the predefined subtraction operator.</span></span>  
  
-   <span data-ttu-id="f7da9-3562">Se `left`. Tipo e `right`. Tipo são anuláveis, o nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3562">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="f7da9-3563">O tipo de nó é o tipo que permite valor nulo que corresponde ao tipo de resultado do operador de subtração predefinidos.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3563">The type of the node is the nullable type that corresponds to the result type of the predefined subtraction operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f7da9-3564">
            <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3564">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f7da9-3565">O operador de subtração não está definido como <paramref name="left" />.Type e <paramref name="right" />.Type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3565">The subtraction operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="SubtractChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression SubtractChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression SubtractChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SubtractChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SubtractChecked (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ SubtractChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member SubtractChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.SubtractChecked (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="f7da9-3566">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3566">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="f7da9-3567">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3567">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="f7da9-3568">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3568">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-3569">Cria um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa uma operação aritmética de subtração que tem verificação de estouro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3569">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic subtraction operation that has overflow checking.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-3570">Um <see cref="T:System.Linq.Expressions.BinaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.SubtractChecked" /> e as propriedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3570">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.SubtractChecked" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-3571">Resultante <xref:System.Linq.Expressions.BinaryExpression> tem o <xref:System.Linq.Expressions.BinaryExpression.Method%2A> propriedade definida como o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3571">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="f7da9-3572">O <xref:System.Linq.Expressions.Expression.Type%2A> estiver definida como o tipo de nó.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3572">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="f7da9-3573">Se o nó é elevado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> e <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriedades estiverem `true`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3573">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="f7da9-3574">Caso contrário, eles são `false`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3574">Otherwise, they are `false`.</span></span> <span data-ttu-id="f7da9-3575">A propriedade <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> é `null`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3575">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="f7da9-3576">As informações a seguir descrevem o método de implementação, o tipo de nó, e se um nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3576">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="f7da9-3577">Implementando método</span><span class="sxs-lookup"><span data-stu-id="f7da9-3577">Implementing Method</span></span>  
 <span data-ttu-id="f7da9-3578">As regras a seguir determinam o método de implementação para a operação:</span><span class="sxs-lookup"><span data-stu-id="f7da9-3578">The following rules determine the implementing method for the operation :</span></span>  
  
-   <span data-ttu-id="f7da9-3579">Se `method` não é `null` e representa um não-nulo, `static` (`Shared` no Visual Basic) método que usa dois argumentos, é o método de implementação para o nó.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3579">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method for the node.</span></span>  
  
-   <span data-ttu-id="f7da9-3580">Caso contrário, se o <xref:System.Linq.Expressions.Expression.Type%2A> propriedade deles `left` ou `right` representa um tipo definido pelo usuário que sobrecarrega o operador de subtração, o <xref:System.Reflection.MethodInfo> que representa que o método é o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3580">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the subtraction operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="f7da9-3581">Caso contrário, se `left`. Tipo e `right`. Tipo de tipos numéricos, o método de implementação está `null`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3581">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="f7da9-3582">Tipo de nó e versão com comparação de precisão x sem comparação de precisão</span><span class="sxs-lookup"><span data-stu-id="f7da9-3582">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="f7da9-3583">Se o método de implementação não for `null`:</span><span class="sxs-lookup"><span data-stu-id="f7da9-3583">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="f7da9-3584">Se `left`. Tipo e `right`. Tipo podem ser atribuídos aos tipos de argumento correspondente do método de implementação, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3584">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="f7da9-3585">O tipo do nó é o tipo de retorno do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3585">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="f7da9-3586">Se as duas seguintes condições forem atendidas, o nó é levantado e o tipo de nó é o tipo que permite valor nulo que corresponde ao tipo de retorno do método de implementação:</span><span class="sxs-lookup"><span data-stu-id="f7da9-3586">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="f7da9-3587">`left`. Tipo e `right`. Tipo são os dois tipos de valor de que pelo menos um é anulável e os tipos não anuláveis correspondentes são iguais para os tipos de argumento correspondente do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3587">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="f7da9-3588">O tipo de retorno do método de implementação é um tipo de valor não anulável.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3588">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="f7da9-3589">Se o método de implementação é `null`:</span><span class="sxs-lookup"><span data-stu-id="f7da9-3589">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="f7da9-3590">Se `left`. Tipo e `right`. Tipo são não anuláveis, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3590">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="f7da9-3591">O tipo do nó é o tipo de resultado do operador de subtração predefinidos.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3591">The type of the node is the result type of the predefined subtraction operator.</span></span>  
  
-   <span data-ttu-id="f7da9-3592">Se `left`. Tipo e `right`. Tipo são anuláveis, o nó é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3592">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="f7da9-3593">O tipo de nó é o tipo que permite valor nulo que corresponde ao tipo de resultado do operador de subtração predefinidos.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3593">The type of the node is the nullable type that corresponds to the result type of the predefined subtraction operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f7da9-3594">
            <paramref name="left" /> ou <paramref name="right" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3594">
              <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f7da9-3595">
            <paramref name="method" /> não é <see langword="null" /> e o método que ele representa retorna <see langword="void" />, não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) ou não tem exatamente dois argumentos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3595">
              <paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f7da9-3596">
            <paramref name="method" /> é <see langword="null" /> e o operador de subtração não foi definido para <paramref name="left" />.Type e <paramref name="right" />.Type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3596">
              <paramref name="method" /> is <see langword="null" /> and the subtraction operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Switch">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f7da9-3597">Cria uma <see cref="T:System.Linq.Expressions.SwitchExpression" /> que representa uma instrução <see langword="switch" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3597">Creates a <see cref="T:System.Linq.Expressions.SwitchExpression" /> that represents a <see langword="switch" /> statement.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SwitchExpression Switch (System.Linq.Expressions.Expression switchValue, params System.Linq.Expressions.SwitchCase[] cases);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SwitchExpression Switch(class System.Linq.Expressions.Expression switchValue, class System.Linq.Expressions.SwitchCase[] cases) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.SwitchCase[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Switch (switchValue As Expression, ParamArray cases As SwitchCase()) As SwitchExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SwitchExpression ^ Switch(System::Linq::Expressions::Expression ^ switchValue, ... cli::array &lt;System::Linq::Expressions::SwitchCase ^&gt; ^ cases);" />
      <MemberSignature Language="F#" Value="static member Switch : System.Linq.Expressions.Expression * System.Linq.Expressions.SwitchCase[] -&gt; System.Linq.Expressions.SwitchExpression" Usage="System.Linq.Expressions.Expression.Switch (switchValue, cases)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SwitchExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="switchValue" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="cases" Type="System.Linq.Expressions.SwitchCase[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="switchValue">
          <span data-ttu-id="f7da9-3598">O valor a ser testado para cada caso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3598">The value to be tested against each case.</span>
          </span>
        </param>
        <param name="cases">
          <span data-ttu-id="f7da9-3599">O conjunto de casos para esta expressão de comutador.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3599">The set of cases for this switch expression.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-3600">Cria uma <see cref="T:System.Linq.Expressions.SwitchExpression" /> que representa uma instrução <see langword="switch" /> sem um caso padrão.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3600">Creates a <see cref="T:System.Linq.Expressions.SwitchExpression" /> that represents a <see langword="switch" /> statement without a default case.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-3601">O <see cref="T:System.Linq.Expressions.SwitchExpression" /> criado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3601">The created <see cref="T:System.Linq.Expressions.SwitchExpression" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-3602">Todos os <xref:System.Linq.Expressions.SwitchCase> objetos em um <xref:System.Linq.Expressions.SwitchExpression> objeto deve ter o mesmo tipo, a menos que o <xref:System.Linq.Expressions.SwitchExpression> tem o tipo `void`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3602">All <xref:System.Linq.Expressions.SwitchCase> objects in a <xref:System.Linq.Expressions.SwitchExpression> object must have the same type, unless the <xref:System.Linq.Expressions.SwitchExpression> has the type `void`.</span></span>  
  
 <span data-ttu-id="f7da9-3603">Cada <xref:System.Linq.Expressions.SwitchCase> objeto tem implícito `break` instrução, o que significa que não há nenhum outono implícito por meio de um rótulo case para outro.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3603">Each <xref:System.Linq.Expressions.SwitchCase> object has an implicit `break` statement, which means that there is no implicit fall through from one case label to another.</span></span>  
  
 <span data-ttu-id="f7da9-3604">Se `switchValue` não corresponde a nenhum dos casos, nenhuma exceção é lançada.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3604">If `switchValue` does not match any of the cases, no exception is thrown.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f7da9-3605">O exemplo a seguir demonstra como criar uma expressão que representa uma instrução de opção /Edit sem um caso padrão.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3605">The following example demonstrates how to create an expression that represents a swtich statement without a default case.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#34](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#34)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#34](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#34)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SwitchExpression Switch (System.Linq.Expressions.Expression switchValue, System.Linq.Expressions.Expression defaultBody, params System.Linq.Expressions.SwitchCase[] cases);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SwitchExpression Switch(class System.Linq.Expressions.Expression switchValue, class System.Linq.Expressions.Expression defaultBody, class System.Linq.Expressions.SwitchCase[] cases) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.SwitchCase[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Switch (switchValue As Expression, defaultBody As Expression, ParamArray cases As SwitchCase()) As SwitchExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SwitchExpression ^ Switch(System::Linq::Expressions::Expression ^ switchValue, System::Linq::Expressions::Expression ^ defaultBody, ... cli::array &lt;System::Linq::Expressions::SwitchCase ^&gt; ^ cases);" />
      <MemberSignature Language="F#" Value="static member Switch : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.SwitchCase[] -&gt; System.Linq.Expressions.SwitchExpression" Usage="System.Linq.Expressions.Expression.Switch (switchValue, defaultBody, cases)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SwitchExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="switchValue" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="defaultBody" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="cases" Type="System.Linq.Expressions.SwitchCase[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="switchValue">
          <span data-ttu-id="f7da9-3606">O valor a ser testado para cada caso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3606">The value to be tested against each case.</span>
          </span>
        </param>
        <param name="defaultBody">
          <span data-ttu-id="f7da9-3607">O resultado da opção se <paramref name="switchValue" /> não corresponde a nenhum dos casos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3607">The result of the switch if <paramref name="switchValue" /> does not match any of the cases.</span>
          </span>
        </param>
        <param name="cases">
          <span data-ttu-id="f7da9-3608">O conjunto de casos para esta expressão de comutador.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3608">The set of cases for this switch expression.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-3609">Cria um <see cref="T:System.Linq.Expressions.SwitchExpression" /> que representa uma instrução <see langword="switch" /> que tem um caso padrão.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3609">Creates a <see cref="T:System.Linq.Expressions.SwitchExpression" /> that represents a <see langword="switch" /> statement that has a default case.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-3610">O <see cref="T:System.Linq.Expressions.SwitchExpression" /> criado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3610">The created <see cref="T:System.Linq.Expressions.SwitchExpression" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-3611">Todos os <xref:System.Linq.Expressions.SwitchCase> objetos em um <xref:System.Linq.Expressions.SwitchExpression> objeto deve ter o mesmo tipo, a menos que o <xref:System.Linq.Expressions.SwitchExpression> tem o tipo `void`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3611">All <xref:System.Linq.Expressions.SwitchCase> objects in a <xref:System.Linq.Expressions.SwitchExpression> object must have the same type, unless the <xref:System.Linq.Expressions.SwitchExpression> has the type `void`.</span></span>  
  
 <span data-ttu-id="f7da9-3612">Cada <xref:System.Linq.Expressions.SwitchCase> objeto tem implícito `break` instrução, o que significa que não há nenhum outono implícito por meio de um rótulo case para outro.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3612">Each <xref:System.Linq.Expressions.SwitchCase> object has an implicit `break` statement, which means that there is no implicit fall through from one case label to another.</span></span>  
  
 <span data-ttu-id="f7da9-3613">Se `switchValue` não corresponde a nenhum dos casos, o caso padrão representado por `defaultBody` é executado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3613">If `switchValue` does not match any of the cases, the default case represented by `defaultBody` is run.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f7da9-3614">O exemplo a seguir demonstra como criar uma expressão que representa uma instrução de opção /Edit que tem um caso padrão.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3614">The following example demonstrates how to create an expression that represents a swtich statement that has a default case.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#35](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#35)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#35](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#35)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SwitchExpression Switch (System.Linq.Expressions.Expression switchValue, System.Linq.Expressions.Expression defaultBody, System.Reflection.MethodInfo comparison, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.SwitchCase&gt; cases);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SwitchExpression Switch(class System.Linq.Expressions.Expression switchValue, class System.Linq.Expressions.Expression defaultBody, class System.Reflection.MethodInfo comparison, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.SwitchCase&gt; cases) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.SwitchCase})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Switch (switchValue As Expression, defaultBody As Expression, comparison As MethodInfo, cases As IEnumerable(Of SwitchCase)) As SwitchExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SwitchExpression ^ Switch(System::Linq::Expressions::Expression ^ switchValue, System::Linq::Expressions::Expression ^ defaultBody, System::Reflection::MethodInfo ^ comparison, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::SwitchCase ^&gt; ^ cases);" />
      <MemberSignature Language="F#" Value="static member Switch : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * seq&lt;System.Linq.Expressions.SwitchCase&gt; -&gt; System.Linq.Expressions.SwitchExpression" Usage="System.Linq.Expressions.Expression.Switch (switchValue, defaultBody, comparison, cases)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SwitchExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="switchValue" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="defaultBody" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="comparison" Type="System.Reflection.MethodInfo" />
        <Parameter Name="cases" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.SwitchCase&gt;" />
      </Parameters>
      <Docs>
        <param name="switchValue">
          <span data-ttu-id="f7da9-3615">O valor a ser testado para cada caso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3615">The value to be tested against each case.</span>
          </span>
        </param>
        <param name="defaultBody">
          <span data-ttu-id="f7da9-3616">O resultado da opção se <paramref name="switchValue" /> não corresponde a nenhum dos casos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3616">The result of the switch if <paramref name="switchValue" /> does not match any of the cases.</span>
          </span>
        </param>
        <param name="comparison">
          <span data-ttu-id="f7da9-3617">O método de comparação de igualdade para usar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3617">The equality comparison method to use.</span>
          </span>
        </param>
        <param name="cases">
          <span data-ttu-id="f7da9-3618">O conjunto de casos para esta expressão de comutador.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3618">The set of cases for this switch expression.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-3619">Cria um <see cref="T:System.Linq.Expressions.SwitchExpression" /> que representa uma instrução <see langword="switch" /> que tem um caso padrão.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3619">Creates a <see cref="T:System.Linq.Expressions.SwitchExpression" /> that represents a <see langword="switch" /> statement that has a default case.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-3620">O <see cref="T:System.Linq.Expressions.SwitchExpression" /> criado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3620">The created <see cref="T:System.Linq.Expressions.SwitchExpression" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SwitchExpression Switch (System.Linq.Expressions.Expression switchValue, System.Linq.Expressions.Expression defaultBody, System.Reflection.MethodInfo comparison, params System.Linq.Expressions.SwitchCase[] cases);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SwitchExpression Switch(class System.Linq.Expressions.Expression switchValue, class System.Linq.Expressions.Expression defaultBody, class System.Reflection.MethodInfo comparison, class System.Linq.Expressions.SwitchCase[] cases) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.SwitchCase[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Switch (switchValue As Expression, defaultBody As Expression, comparison As MethodInfo, ParamArray cases As SwitchCase()) As SwitchExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SwitchExpression ^ Switch(System::Linq::Expressions::Expression ^ switchValue, System::Linq::Expressions::Expression ^ defaultBody, System::Reflection::MethodInfo ^ comparison, ... cli::array &lt;System::Linq::Expressions::SwitchCase ^&gt; ^ cases);" />
      <MemberSignature Language="F#" Value="static member Switch : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.SwitchCase[] -&gt; System.Linq.Expressions.SwitchExpression" Usage="System.Linq.Expressions.Expression.Switch (switchValue, defaultBody, comparison, cases)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SwitchExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="switchValue" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="defaultBody" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="comparison" Type="System.Reflection.MethodInfo" />
        <Parameter Name="cases" Type="System.Linq.Expressions.SwitchCase[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="switchValue">
          <span data-ttu-id="f7da9-3621">O valor a ser testado para cada caso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3621">The value to be tested against each case.</span>
          </span>
        </param>
        <param name="defaultBody">
          <span data-ttu-id="f7da9-3622">O resultado da opção se <paramref name="switchValue" /> não corresponde a nenhum dos casos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3622">The result of the switch if <paramref name="switchValue" /> does not match any of the cases.</span>
          </span>
        </param>
        <param name="comparison">
          <span data-ttu-id="f7da9-3623">O método de comparação de igualdade para usar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3623">The equality comparison method to use.</span>
          </span>
        </param>
        <param name="cases">
          <span data-ttu-id="f7da9-3624">O conjunto de casos para esta expressão de comutador.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3624">The set of cases for this switch expression.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-3625">Cria um <see cref="T:System.Linq.Expressions.SwitchExpression" /> que representa uma instrução <see langword="switch" /> que tem um caso padrão.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3625">Creates a <see cref="T:System.Linq.Expressions.SwitchExpression" /> that represents a <see langword="switch" /> statement that has a default case.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-3626">O <see cref="T:System.Linq.Expressions.SwitchExpression" /> criado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3626">The created <see cref="T:System.Linq.Expressions.SwitchExpression" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SwitchExpression Switch (Type type, System.Linq.Expressions.Expression switchValue, System.Linq.Expressions.Expression defaultBody, System.Reflection.MethodInfo comparison, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.SwitchCase&gt; cases);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SwitchExpression Switch(class System.Type type, class System.Linq.Expressions.Expression switchValue, class System.Linq.Expressions.Expression defaultBody, class System.Reflection.MethodInfo comparison, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.SwitchCase&gt; cases) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Switch(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.SwitchCase})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SwitchExpression ^ Switch(Type ^ type, System::Linq::Expressions::Expression ^ switchValue, System::Linq::Expressions::Expression ^ defaultBody, System::Reflection::MethodInfo ^ comparison, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::SwitchCase ^&gt; ^ cases);" />
      <MemberSignature Language="F#" Value="static member Switch : Type * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * seq&lt;System.Linq.Expressions.SwitchCase&gt; -&gt; System.Linq.Expressions.SwitchExpression" Usage="System.Linq.Expressions.Expression.Switch (type, switchValue, defaultBody, comparison, cases)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SwitchExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="switchValue" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="defaultBody" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="comparison" Type="System.Reflection.MethodInfo" />
        <Parameter Name="cases" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.SwitchCase&gt;" />
      </Parameters>
      <Docs>
        <param name="type">
          <span data-ttu-id="f7da9-3627">O tipo de resultado da opção.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3627">The result type of the switch.</span>
          </span>
        </param>
        <param name="switchValue">
          <span data-ttu-id="f7da9-3628">O valor a ser testado para cada caso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3628">The value to be tested against each case.</span>
          </span>
        </param>
        <param name="defaultBody">
          <span data-ttu-id="f7da9-3629">O resultado da opção se <paramref name="switchValue" /> não corresponde a nenhum dos casos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3629">The result of the switch if <paramref name="switchValue" /> does not match any of the cases.</span>
          </span>
        </param>
        <param name="comparison">
          <span data-ttu-id="f7da9-3630">O método de comparação de igualdade para usar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3630">The equality comparison method to use.</span>
          </span>
        </param>
        <param name="cases">
          <span data-ttu-id="f7da9-3631">O conjunto de casos para esta expressão de comutador.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3631">The set of cases for this switch expression.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-3632">Cria um <see cref="T:System.Linq.Expressions.SwitchExpression" /> que representa uma instrução <see langword="switch" /> que tem um caso padrão.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3632">Creates a <see cref="T:System.Linq.Expressions.SwitchExpression" /> that represents a <see langword="switch" /> statement that has a default case.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-3633">O <see cref="T:System.Linq.Expressions.SwitchExpression" /> criado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3633">The created <see cref="T:System.Linq.Expressions.SwitchExpression" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SwitchExpression Switch (Type type, System.Linq.Expressions.Expression switchValue, System.Linq.Expressions.Expression defaultBody, System.Reflection.MethodInfo comparison, params System.Linq.Expressions.SwitchCase[] cases);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SwitchExpression Switch(class System.Type type, class System.Linq.Expressions.Expression switchValue, class System.Linq.Expressions.Expression defaultBody, class System.Reflection.MethodInfo comparison, class System.Linq.Expressions.SwitchCase[] cases) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Switch(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.SwitchCase[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SwitchExpression ^ Switch(Type ^ type, System::Linq::Expressions::Expression ^ switchValue, System::Linq::Expressions::Expression ^ defaultBody, System::Reflection::MethodInfo ^ comparison, ... cli::array &lt;System::Linq::Expressions::SwitchCase ^&gt; ^ cases);" />
      <MemberSignature Language="F#" Value="static member Switch : Type * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.SwitchCase[] -&gt; System.Linq.Expressions.SwitchExpression" Usage="System.Linq.Expressions.Expression.Switch (type, switchValue, defaultBody, comparison, cases)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SwitchExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="switchValue" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="defaultBody" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="comparison" Type="System.Reflection.MethodInfo" />
        <Parameter Name="cases" Type="System.Linq.Expressions.SwitchCase[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="type">
          <span data-ttu-id="f7da9-3634">O tipo de resultado da opção.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3634">The result type of the switch.</span>
          </span>
        </param>
        <param name="switchValue">
          <span data-ttu-id="f7da9-3635">O valor a ser testado para cada caso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3635">The value to be tested against each case.</span>
          </span>
        </param>
        <param name="defaultBody">
          <span data-ttu-id="f7da9-3636">O resultado da opção se <paramref name="switchValue" /> não corresponde a nenhum dos casos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3636">The result of the switch if <paramref name="switchValue" /> does not match any of the cases.</span>
          </span>
        </param>
        <param name="comparison">
          <span data-ttu-id="f7da9-3637">O método de comparação de igualdade para usar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3637">The equality comparison method to use.</span>
          </span>
        </param>
        <param name="cases">
          <span data-ttu-id="f7da9-3638">O conjunto de casos para esta expressão de comutador.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3638">The set of cases for this switch expression.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-3639">Cria um <see cref="T:System.Linq.Expressions.SwitchExpression" /> que representa uma instrução <see langword="switch" /> que tem um caso padrão.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3639">Creates a <see cref="T:System.Linq.Expressions.SwitchExpression" /> that represents a <see langword="switch" /> statement that has a default case..</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-3640">O <see cref="T:System.Linq.Expressions.SwitchExpression" /> criado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3640">The created <see cref="T:System.Linq.Expressions.SwitchExpression" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SwitchCase">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f7da9-3641">Cria um objeto <see cref="T:System.Linq.Expressions.SwitchCase" /> a ser usado em um objeto <see cref="T:System.Linq.Expressions.SwitchExpression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3641">Creates a <see cref="T:System.Linq.Expressions.SwitchCase" /> object to be used in a <see cref="T:System.Linq.Expressions.SwitchExpression" /> object.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SwitchCase">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SwitchCase SwitchCase (System.Linq.Expressions.Expression body, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; testValues);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SwitchCase SwitchCase(class System.Linq.Expressions.Expression body, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; testValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SwitchCase(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SwitchCase (body As Expression, testValues As IEnumerable(Of Expression)) As SwitchCase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SwitchCase ^ SwitchCase(System::Linq::Expressions::Expression ^ body, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ testValues);" />
      <MemberSignature Language="F#" Value="static member SwitchCase : System.Linq.Expressions.Expression * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.SwitchCase" Usage="System.Linq.Expressions.Expression.SwitchCase (body, testValues)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SwitchCase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="testValues" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="body">
          <span data-ttu-id="f7da9-3642">O corpo do caso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3642">The body of the case.</span>
          </span>
        </param>
        <param name="testValues">
          <span data-ttu-id="f7da9-3643">Os valores de teste do caso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3643">The test values of the case.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-3644">Cria um objeto <see cref="T:System.Linq.Expressions.SwitchCase" /> a ser usado em um objeto <see cref="T:System.Linq.Expressions.SwitchExpression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3644">Creates a <see cref="T:System.Linq.Expressions.SwitchCase" /> object to be used in a <see cref="T:System.Linq.Expressions.SwitchExpression" /> object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-3645">O <see cref="T:System.Linq.Expressions.SwitchCase" /> criado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3645">The created <see cref="T:System.Linq.Expressions.SwitchCase" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-3646">Todos os <xref:System.Linq.Expressions.SwitchCase> objetos em um <xref:System.Linq.Expressions.SwitchExpression> objeto deve ter o mesmo tipo, a menos que o <xref:System.Linq.Expressions.SwitchExpression> tem o tipo `void`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3646">All <xref:System.Linq.Expressions.SwitchCase> objects in a <xref:System.Linq.Expressions.SwitchExpression> object must have the same type, unless the <xref:System.Linq.Expressions.SwitchExpression> has the type `void`.</span></span>  
  
 <span data-ttu-id="f7da9-3647">Cada <xref:System.Linq.Expressions.SwitchCase> objeto tem implícito `break` instrução, o que significa que não há nenhum outono implícito por meio de um rótulo case para outro.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3647">Each <xref:System.Linq.Expressions.SwitchCase> object has an implicit `break` statement, which means that there is no implicit fall through from one case label to another.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f7da9-3648">O exemplo a seguir demonstra como criar uma expressão que representa uma instrução de opção /Edit que tem um caso padrão.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3648">The following example demonstrates how to create an expression that represents a swtich statement that has a default case.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#35](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#35)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#35](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#35)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SwitchCase">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SwitchCase SwitchCase (System.Linq.Expressions.Expression body, params System.Linq.Expressions.Expression[] testValues);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SwitchCase SwitchCase(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.Expression[] testValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SwitchCase(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SwitchCase (body As Expression, ParamArray testValues As Expression()) As SwitchCase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SwitchCase ^ SwitchCase(System::Linq::Expressions::Expression ^ body, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ testValues);" />
      <MemberSignature Language="F#" Value="static member SwitchCase : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.SwitchCase" Usage="System.Linq.Expressions.Expression.SwitchCase (body, testValues)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SwitchCase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="testValues" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="body">
          <span data-ttu-id="f7da9-3649">O corpo do caso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3649">The body of the case.</span>
          </span>
        </param>
        <param name="testValues">
          <span data-ttu-id="f7da9-3650">Os valores de teste do caso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3650">The test values of the case.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-3651">Cria um <see cref="T:System.Linq.Expressions.SwitchCase" /> para uso em um <see cref="T:System.Linq.Expressions.SwitchExpression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3651">Creates a <see cref="T:System.Linq.Expressions.SwitchCase" /> for use in a <see cref="T:System.Linq.Expressions.SwitchExpression" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-3652">O <see cref="T:System.Linq.Expressions.SwitchCase" /> criado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3652">The created <see cref="T:System.Linq.Expressions.SwitchCase" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SymbolDocument">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f7da9-3653">Cria uma instância de <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3653">Creates an instance of <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SymbolDocument">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SymbolDocumentInfo SymbolDocument (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SymbolDocumentInfo SymbolDocument(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SymbolDocument(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SymbolDocument (fileName As String) As SymbolDocumentInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SymbolDocumentInfo ^ SymbolDocument(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="static member SymbolDocument : string -&gt; System.Linq.Expressions.SymbolDocumentInfo" Usage="System.Linq.Expressions.Expression.SymbolDocument fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SymbolDocumentInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">
          <span data-ttu-id="f7da9-3654">Uma <see cref="T:System.String" /> igual à qual definir o <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3654">A <see cref="T:System.String" /> to set the <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-3655">Cria uma instância de <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3655">Creates an instance of <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-3656">Um <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> que tem a propriedade <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> definida para o valor especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3656">A <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> that has the <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> property set to the specified value.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SymbolDocument">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SymbolDocumentInfo SymbolDocument (string fileName, Guid language);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SymbolDocumentInfo SymbolDocument(string fileName, valuetype System.Guid language) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SymbolDocument(System.String,System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SymbolDocument (fileName As String, language As Guid) As SymbolDocumentInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SymbolDocumentInfo ^ SymbolDocument(System::String ^ fileName, Guid language);" />
      <MemberSignature Language="F#" Value="static member SymbolDocument : string * Guid -&gt; System.Linq.Expressions.SymbolDocumentInfo" Usage="System.Linq.Expressions.Expression.SymbolDocument (fileName, language)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SymbolDocumentInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="language" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="fileName">
          <span data-ttu-id="f7da9-3657">Uma <see cref="T:System.String" /> igual à qual definir o <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3657">A <see cref="T:System.String" /> to set the <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> equal to.</span>
          </span>
        </param>
        <param name="language">
          <span data-ttu-id="f7da9-3658">Uma <see cref="T:System.Guid" /> igual à qual definir o <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3658">A <see cref="T:System.Guid" /> to set the <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-3659">Cria uma instância de <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3659">Creates an instance of <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-3660">Um <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> que tem as propriedades <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> e <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> definidas para o valor especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3660">A <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> that has the <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> and <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> properties set to the specified value.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SymbolDocument">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SymbolDocumentInfo SymbolDocument (string fileName, Guid language, Guid languageVendor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SymbolDocumentInfo SymbolDocument(string fileName, valuetype System.Guid language, valuetype System.Guid languageVendor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SymbolDocument(System.String,System.Guid,System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SymbolDocument (fileName As String, language As Guid, languageVendor As Guid) As SymbolDocumentInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SymbolDocumentInfo ^ SymbolDocument(System::String ^ fileName, Guid language, Guid languageVendor);" />
      <MemberSignature Language="F#" Value="static member SymbolDocument : string * Guid * Guid -&gt; System.Linq.Expressions.SymbolDocumentInfo" Usage="System.Linq.Expressions.Expression.SymbolDocument (fileName, language, languageVendor)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SymbolDocumentInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="language" Type="System.Guid" />
        <Parameter Name="languageVendor" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="fileName">
          <span data-ttu-id="f7da9-3661">Uma <see cref="T:System.String" /> igual à qual definir o <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3661">A <see cref="T:System.String" /> to set the <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> equal to.</span>
          </span>
        </param>
        <param name="language">
          <span data-ttu-id="f7da9-3662">Uma <see cref="T:System.Guid" /> igual à qual definir o <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3662">A <see cref="T:System.Guid" /> to set the <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> equal to.</span>
          </span>
        </param>
        <param name="languageVendor">
          <span data-ttu-id="f7da9-3663">Uma <see cref="T:System.Guid" /> igual à qual definir o <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3663">A <see cref="T:System.Guid" /> to set the <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" /> equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-3664">Cria uma instância de <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3664">Creates an instance of <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-3665">Um <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> que tem as propriedades <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />, <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> e <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" /> definidas para o valor especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3665">A <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> that has the <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> and <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> and <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" /> properties set to the specified value.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SymbolDocument">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SymbolDocumentInfo SymbolDocument (string fileName, Guid language, Guid languageVendor, Guid documentType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SymbolDocumentInfo SymbolDocument(string fileName, valuetype System.Guid language, valuetype System.Guid languageVendor, valuetype System.Guid documentType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SymbolDocument(System.String,System.Guid,System.Guid,System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SymbolDocument (fileName As String, language As Guid, languageVendor As Guid, documentType As Guid) As SymbolDocumentInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SymbolDocumentInfo ^ SymbolDocument(System::String ^ fileName, Guid language, Guid languageVendor, Guid documentType);" />
      <MemberSignature Language="F#" Value="static member SymbolDocument : string * Guid * Guid * Guid -&gt; System.Linq.Expressions.SymbolDocumentInfo" Usage="System.Linq.Expressions.Expression.SymbolDocument (fileName, language, languageVendor, documentType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SymbolDocumentInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="language" Type="System.Guid" />
        <Parameter Name="languageVendor" Type="System.Guid" />
        <Parameter Name="documentType" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="fileName">
          <span data-ttu-id="f7da9-3666">Uma <see cref="T:System.String" /> igual à qual definir o <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3666">A <see cref="T:System.String" /> to set the <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> equal to.</span>
          </span>
        </param>
        <param name="language">
          <span data-ttu-id="f7da9-3667">Uma <see cref="T:System.Guid" /> igual à qual definir o <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3667">A <see cref="T:System.Guid" /> to set the <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> equal to.</span>
          </span>
        </param>
        <param name="languageVendor">
          <span data-ttu-id="f7da9-3668">Uma <see cref="T:System.Guid" /> igual à qual definir o <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3668">A <see cref="T:System.Guid" /> to set the <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" /> equal to.</span>
          </span>
        </param>
        <param name="documentType">
          <span data-ttu-id="f7da9-3669">Uma <see cref="T:System.Guid" /> igual à qual definir o <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.DocumentType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3669">A <see cref="T:System.Guid" /> to set the <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.DocumentType" /> equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-3670">Cria uma instância de <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3670">Creates an instance of <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-3671">Um <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> que tem as propriedades <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />, <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" />, <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" /> e <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.DocumentType" /> definidas para o valor especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3671">A <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> that has the <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> and <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> and <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" /> and <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.DocumentType" /> properties set to the specified value.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Throw">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f7da9-3672">Cria um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa uma geração de uma exceção.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3672">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a throwing of an exception.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Throw">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Throw (System.Linq.Expressions.Expression value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Throw(class System.Linq.Expressions.Expression value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Throw(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Throw (value As Expression) As UnaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Throw(System::Linq::Expressions::Expression ^ value);" />
      <MemberSignature Language="F#" Value="static member Throw : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Throw value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="f7da9-3673">Um <see cref="T:System.Linq.Expressions.Expression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3673">An <see cref="T:System.Linq.Expressions.Expression" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-3674">Cria um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa uma geração de uma exceção.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3674">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a throwing of an exception.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-3675">Um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa a exceção.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3675">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the exception.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="f7da9-3676">O exemplo a seguir demonstra como criar uma <xref:System.Linq.Expressions.TryExpression> objeto que usa o <xref:System.Linq.Expressions.Expression.Throw%2A> método.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3676">The following example demonstrates how to create a <xref:System.Linq.Expressions.TryExpression> object that uses the <xref:System.Linq.Expressions.Expression.Throw%2A> method.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#47](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#47)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#47](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#47)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Throw">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Throw (System.Linq.Expressions.Expression value, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Throw(class System.Linq.Expressions.Expression value, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Throw(System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Throw(System::Linq::Expressions::Expression ^ value, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Throw : System.Linq.Expressions.Expression * Type -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Throw (value, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="f7da9-3677">Um <see cref="T:System.Linq.Expressions.Expression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3677">An <see cref="T:System.Linq.Expressions.Expression" />.</span>
          </span>
        </param>
        <param name="type">
          <span data-ttu-id="f7da9-3678">O novo <see cref="T:System.Type" /> da expressão.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3678">The new <see cref="T:System.Type" /> of the expression.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-3679">Cria um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa um lançamento de uma exceção com um determinado tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3679">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a throwing of an exception with a given type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-3680">Um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa a exceção.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3680">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the exception.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="expression.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="f7da9-3681">Retorna uma representação textual de <see cref="T:System.Linq.Expressions.Expression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3681">Returns a textual representation of the <see cref="T:System.Linq.Expressions.Expression" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-3682">Uma representação textual de <see cref="T:System.Linq.Expressions.Expression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3682">A textual representation of the <see cref="T:System.Linq.Expressions.Expression" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryCatch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.TryExpression TryCatch (System.Linq.Expressions.Expression body, params System.Linq.Expressions.CatchBlock[] handlers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.TryExpression TryCatch(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.CatchBlock[] handlers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TryCatch(System.Linq.Expressions.Expression,System.Linq.Expressions.CatchBlock[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryCatch (body As Expression, ParamArray handlers As CatchBlock()) As TryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::TryExpression ^ TryCatch(System::Linq::Expressions::Expression ^ body, ... cli::array &lt;System::Linq::Expressions::CatchBlock ^&gt; ^ handlers);" />
      <MemberSignature Language="F#" Value="static member TryCatch : System.Linq.Expressions.Expression * System.Linq.Expressions.CatchBlock[] -&gt; System.Linq.Expressions.TryExpression" Usage="System.Linq.Expressions.Expression.TryCatch (body, handlers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.TryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="handlers" Type="System.Linq.Expressions.CatchBlock[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="body">
          <span data-ttu-id="f7da9-3683">O corpo do bloco try.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3683">The body of the try block.</span>
          </span>
        </param>
        <param name="handlers">
          <span data-ttu-id="f7da9-3684">A matriz de zero ou mais expressões <see cref="T:System.Linq.Expressions.CatchBlock" /> representando as instruções catch a serem associados com o bloco try.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3684">The array of zero or more <see cref="T:System.Linq.Expressions.CatchBlock" /> expressions representing the catch statements to be associated with the try block.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-3685">Cria um <see cref="T:System.Linq.Expressions.TryExpression" /> representando um bloco try com qualquer número de instruções catch e nem um bloco fault nem finally.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3685">Creates a <see cref="T:System.Linq.Expressions.TryExpression" /> representing a try block with any number of catch statements and neither a fault nor finally block.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-3686">O <see cref="T:System.Linq.Expressions.TryExpression" /> criado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3686">The created <see cref="T:System.Linq.Expressions.TryExpression" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="f7da9-3687">O exemplo a seguir demonstra como criar um <xref:System.Linq.Expressions.TryExpression> objeto que contém uma instrução catch.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3687">The following example demonstrates how to create a <xref:System.Linq.Expressions.TryExpression> object that contains a catch statement.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#47](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#47)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#47](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#47)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryCatchFinally">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.TryExpression TryCatchFinally (System.Linq.Expressions.Expression body, System.Linq.Expressions.Expression finally, params System.Linq.Expressions.CatchBlock[] handlers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.TryExpression TryCatchFinally(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.Expression finally, class System.Linq.Expressions.CatchBlock[] handlers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TryCatchFinally(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.CatchBlock[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryCatchFinally (body As Expression, finally As Expression, ParamArray handlers As CatchBlock()) As TryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::TryExpression ^ TryCatchFinally(System::Linq::Expressions::Expression ^ body, System::Linq::Expressions::Expression ^ finally, ... cli::array &lt;System::Linq::Expressions::CatchBlock ^&gt; ^ handlers);" />
      <MemberSignature Language="F#" Value="static member TryCatchFinally : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.CatchBlock[] -&gt; System.Linq.Expressions.TryExpression" Usage="System.Linq.Expressions.Expression.TryCatchFinally (body, finally, handlers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.TryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="finally" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="handlers" Type="System.Linq.Expressions.CatchBlock[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="body">
          <span data-ttu-id="f7da9-3688">O corpo do bloco try.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3688">The body of the try block.</span>
          </span>
        </param>
        <param name="finally">
          <span data-ttu-id="f7da9-3689">O corpo do bloco finally.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3689">The body of the finally block.</span>
          </span>
        </param>
        <param name="handlers">
          <span data-ttu-id="f7da9-3690">A matriz de zero ou mais expressões <see cref="T:System.Linq.Expressions.CatchBlock" /> representando as instruções catch a serem associados com o bloco try.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3690">The array of zero or more <see cref="T:System.Linq.Expressions.CatchBlock" /> expressions representing the catch statements to be associated with the try block.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-3691">Cria uma <see cref="T:System.Linq.Expressions.TryExpression" /> representando um bloco try com qualquer número de instruções catch e um bloco finally.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3691">Creates a <see cref="T:System.Linq.Expressions.TryExpression" /> representing a try block with any number of catch statements and a finally block.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-3692">O <see cref="T:System.Linq.Expressions.TryExpression" /> criado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3692">The created <see cref="T:System.Linq.Expressions.TryExpression" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="f7da9-3693">O exemplo a seguir demonstra como criar um <xref:System.Linq.Expressions.TryExpression> objeto que contém uma instrução catch e uma instrução finally.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3693">The following example demonstrates how to create a <xref:System.Linq.Expressions.TryExpression> object that contains a catch statement and a finally statement.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#48](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#48)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#48](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#48)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryFault">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.TryExpression TryFault (System.Linq.Expressions.Expression body, System.Linq.Expressions.Expression fault);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.TryExpression TryFault(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.Expression fault) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TryFault(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryFault (body As Expression, fault As Expression) As TryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::TryExpression ^ TryFault(System::Linq::Expressions::Expression ^ body, System::Linq::Expressions::Expression ^ fault);" />
      <MemberSignature Language="F#" Value="static member TryFault : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.TryExpression" Usage="System.Linq.Expressions.Expression.TryFault (body, fault)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.TryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="fault" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="body">
          <span data-ttu-id="f7da9-3694">O corpo do bloco try.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3694">The body of the try block.</span>
          </span>
        </param>
        <param name="fault">
          <span data-ttu-id="f7da9-3695">O corpo do bloco de falha.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3695">The body of the fault block.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-3696">Cria uma <see cref="T:System.Linq.Expressions.TryExpression" /> representando um bloco try com um bloco fault e nenhuma instrução catch.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3696">Creates a <see cref="T:System.Linq.Expressions.TryExpression" /> representing a try block with a fault block and no catch statements.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-3697">O <see cref="T:System.Linq.Expressions.TryExpression" /> criado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3697">The created <see cref="T:System.Linq.Expressions.TryExpression" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryFinally">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.TryExpression TryFinally (System.Linq.Expressions.Expression body, System.Linq.Expressions.Expression finally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.TryExpression TryFinally(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.Expression finally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TryFinally(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryFinally (body As Expression, finally As Expression) As TryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::TryExpression ^ TryFinally(System::Linq::Expressions::Expression ^ body, System::Linq::Expressions::Expression ^ finally);" />
      <MemberSignature Language="F#" Value="static member TryFinally : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.TryExpression" Usage="System.Linq.Expressions.Expression.TryFinally (body, finally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.TryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="finally" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="body">
          <span data-ttu-id="f7da9-3698">O corpo do bloco try.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3698">The body of the try block.</span>
          </span>
        </param>
        <param name="finally">
          <span data-ttu-id="f7da9-3699">O corpo do bloco finally.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3699">The body of the finally block.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-3700">Cria uma <see cref="T:System.Linq.Expressions.TryExpression" /> representando um bloco try com um bloco finally e nenhuma instrução catch.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3700">Creates a <see cref="T:System.Linq.Expressions.TryExpression" /> representing a try block with a finally block and no catch statements.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-3701">O <see cref="T:System.Linq.Expressions.TryExpression" /> criado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3701">The created <see cref="T:System.Linq.Expressions.TryExpression" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetActionType">
      <MemberSignature Language="C#" Value="public static bool TryGetActionType (Type[] typeArgs, out Type actionType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryGetActionType(class System.Type[] typeArgs, [out] class System.Type&amp; actionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TryGetActionType(System.Type[],System.Type@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryGetActionType (typeArgs As Type(), ByRef actionType As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryGetActionType(cli::array &lt;Type ^&gt; ^ typeArgs, [Runtime::InteropServices::Out] Type ^ % actionType);" />
      <MemberSignature Language="F#" Value="static member TryGetActionType : Type[] *  -&gt; bool" Usage="System.Linq.Expressions.Expression.TryGetActionType (typeArgs, actionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArgs" Type="System.Type[]" />
        <Parameter Name="actionType" Type="System.Type" RefType="out" />
      </Parameters>
      <Docs>
        <param name="typeArgs">
          <span data-ttu-id="f7da9-3702">Uma matriz de objetos Type que especifica os argumentos de tipo para o tipo de delegado System.Action.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3702">An array of Type objects that specify the type arguments for the System.Action delegate type.</span>
          </span>
        </param>
        <param name="actionType">
          <span data-ttu-id="f7da9-3703">Quando esse método retorna, ele contém o tipo de delegado genérico System.Action, que tem argumentos de tipo específicos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3703">When this method returns, contains the generic System.Action delegate type that has specific type arguments.</span>
          </span>
          <span data-ttu-id="f7da9-3704">Conterá nulo se não houver nenhum delegado System.Action genérico que corresponda ao <paramref name="typeArgs" />. Esse parâmetro é passado não inicializado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3704">Contains null if there is no generic System.Action delegate that matches the <paramref name="typeArgs" />.This parameter is passed uninitialized.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-3705">Cria um objeto <see cref="P:System.Linq.Expressions.Expression.Type" /> que representa um tipo de delegado genérico System.Action que tem argumentos de tipo específicos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3705">Creates a <see cref="P:System.Linq.Expressions.Expression.Type" /> object that represents a generic System.Action delegate type that has specific type arguments.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-3706">true se o tipo de delegado genérico System.Action foi criado para um <paramref name="typeArgs" /> específico; caso contrário, false.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3706">true if generic System.Action delegate type was created for specific <paramref name="typeArgs" />; false otherwise.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetFuncType">
      <MemberSignature Language="C#" Value="public static bool TryGetFuncType (Type[] typeArgs, out Type funcType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryGetFuncType(class System.Type[] typeArgs, [out] class System.Type&amp; funcType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TryGetFuncType(System.Type[],System.Type@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryGetFuncType (typeArgs As Type(), ByRef funcType As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryGetFuncType(cli::array &lt;Type ^&gt; ^ typeArgs, [Runtime::InteropServices::Out] Type ^ % funcType);" />
      <MemberSignature Language="F#" Value="static member TryGetFuncType : Type[] *  -&gt; bool" Usage="System.Linq.Expressions.Expression.TryGetFuncType (typeArgs, funcType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArgs" Type="System.Type[]" />
        <Parameter Name="funcType" Type="System.Type" RefType="out" />
      </Parameters>
      <Docs>
        <param name="typeArgs">
          <span data-ttu-id="f7da9-3707">Uma matriz de objetos Type que especifica os argumentos de tipo para o tipo de delegado System.Func.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3707">An array of Type objects that specify the type arguments for the System.Func delegate type.</span>
          </span>
        </param>
        <param name="funcType">
          <span data-ttu-id="f7da9-3708">Quando esse método retorna, ele contém o tipo de delegado genérico System.Func, que tem argumentos de tipo específicos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3708">When this method returns, contains the generic System.Func delegate type that has specific type arguments.</span>
          </span>
          <span data-ttu-id="f7da9-3709">Conterá nulo se não houver nenhum delegado System.Func genérico que corresponda ao <paramref name="typeArgs" />. Esse parâmetro é passado não inicializado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3709">Contains null if there is no generic System.Func delegate that matches the <paramref name="typeArgs" />.This parameter is passed uninitialized.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-3710">Cria um objeto <see cref="P:System.Linq.Expressions.Expression.Type" /> que representa um tipo de delegado genérico System.Func, que tem argumentos de tipo específicos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3710">Creates a <see cref="P:System.Linq.Expressions.Expression.Type" /> object that represents a generic System.Func delegate type that has specific type arguments.</span>
          </span>
          <span data-ttu-id="f7da9-3711">O último argumento de tipo especifica o tipo de retorno do delegado criado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3711">The last type argument specifies the return type of the created delegate.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-3712">true se o tipo de delegado genérico System.Func foi criado para um <paramref name="typeArgs" /> específico; caso contrário, false.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3712">true if generic System.Func delegate type was created for specific <paramref name="typeArgs" />; false otherwise.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Type">
      <MemberSignature Language="C#" Value="public virtual Type Type { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type Type" />
      <MemberSignature Language="DocId" Value="P:System.Linq.Expressions.Expression.Type" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Type As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ Type { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Type : Type" Usage="System.Linq.Expressions.Expression.Type" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f7da9-3713">Obtém o tipo estático da expressão que esse <see cref="T:System.Linq.Expressions.Expression" /> representa.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3713">Gets the static type of the expression that this <see cref="T:System.Linq.Expressions.Expression" /> represents.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="f7da9-3714">O <see cref="T:System.Type" /> que representa o tipo estático da expressão.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3714">The <see cref="T:System.Type" /> that represents the static type of the expression.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-3715">O <xref:System.Linq.Expressions.Expression.NodeType%2A> é o tipo de nó de árvore de expressão, enquanto o <xref:System.Linq.Expressions.Expression.Type%2A> representa o estático tipo common language runtime (CLR) da expressão que representa o nó.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3715">The <xref:System.Linq.Expressions.Expression.NodeType%2A> is the type of the expression tree node, whereas the <xref:System.Linq.Expressions.Expression.Type%2A> represents the static common language runtime (CLR) type of the expression that the node represents.</span></span> <span data-ttu-id="f7da9-3716">Por exemplo, dois nós com diferentes tipos de nó podem ter o mesmo <xref:System.Linq.Expressions.Expression.Type%2A>, conforme mostrado no exemplo de código a seguir.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3716">For example, two nodes with different node types can have the same <xref:System.Linq.Expressions.Expression.Type%2A>, as shown in the following code example.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#36](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#36)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#36](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#36)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TypeAs">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression TypeAs (System.Linq.Expressions.Expression expression, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression TypeAs(class System.Linq.Expressions.Expression expression, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TypeAs(System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ TypeAs(System::Linq::Expressions::Expression ^ expression, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member TypeAs : System.Linq.Expressions.Expression * Type -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.TypeAs (expression, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="expression">
          <span data-ttu-id="f7da9-3717">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3717">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to.</span>
          </span>
        </param>
        <param name="type">
          <span data-ttu-id="f7da9-3718">Um <see cref="T:System.Type" /> para definir a propriedade <see cref="P:System.Linq.Expressions.Expression.Type" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3718">A <see cref="T:System.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-3719">Cria um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa uma conversão boxing ou de referência explícita em que <see langword="null" /> será fornecido se a conversão falhar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3719">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents an explicit reference or boxing conversion where <see langword="null" /> is supplied if the conversion fails.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-3720">Um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.TypeAs" /> e as propriedades <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> e <see cref="P:System.Linq.Expressions.Expression.Type" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3720">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.TypeAs" /> and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> and <see cref="P:System.Linq.Expressions.Expression.Type" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-3721">O <xref:System.Linq.Expressions.UnaryExpression.Method%2A> propriedade resultantes <xref:System.Linq.Expressions.UnaryExpression> é `null`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3721">The <xref:System.Linq.Expressions.UnaryExpression.Method%2A> property of the resulting <xref:System.Linq.Expressions.UnaryExpression> is `null`.</span></span> <span data-ttu-id="f7da9-3722">O <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> e <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> propriedades estiverem `false`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3722">The <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> properties are both `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f7da9-3723">O exemplo a seguir demonstra como usar o <xref:System.Linq.Expressions.Expression.TypeAs%28System.Linq.Expressions.Expression%2CSystem.Type%29> método para criar um <xref:System.Linq.Expressions.UnaryExpression> que representa a conversão de referência de uma expressão de inteiro não nulo para o tipo de inteiro que permite valor nulo.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3723">The following example demonstrates how to use the <xref:System.Linq.Expressions.Expression.TypeAs%28System.Linq.Expressions.Expression%2CSystem.Type%29> method to create a <xref:System.Linq.Expressions.UnaryExpression> that represents the reference conversion of a non-nullable integer expression to the nullable integer type.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.Expression#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#11)]
 [!code-vb[System.Linq.Expressions.Expression#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f7da9-3724">
            <paramref name="expression" /> ou <paramref name="type" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3724">
              <paramref name="expression" /> or <paramref name="type" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="TypeEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.TypeBinaryExpression TypeEqual (System.Linq.Expressions.Expression expression, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.TypeBinaryExpression TypeEqual(class System.Linq.Expressions.Expression expression, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TypeEqual(System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::TypeBinaryExpression ^ TypeEqual(System::Linq::Expressions::Expression ^ expression, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member TypeEqual : System.Linq.Expressions.Expression * Type -&gt; System.Linq.Expressions.TypeBinaryExpression" Usage="System.Linq.Expressions.Expression.TypeEqual (expression, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.TypeBinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="expression">
          <span data-ttu-id="f7da9-3725">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="T:System.Linq.Expressions.Expression" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3725">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="T:System.Linq.Expressions.Expression" /> property equal to.</span>
          </span>
        </param>
        <param name="type">
          <span data-ttu-id="f7da9-3726">Um <see cref="P:System.Linq.Expressions.Expression.Type" /> para definir a propriedade <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3726">A <see cref="P:System.Linq.Expressions.Expression.Type" /> to set the <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-3727">Cria uma <see cref="T:System.Linq.Expressions.TypeBinaryExpression" /> que compara a identidade de tipo de tempo de execução.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3727">Creates a <see cref="T:System.Linq.Expressions.TypeBinaryExpression" /> that compares run-time type identity.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-3728">Uma <see cref="T:System.Linq.Expressions.TypeBinaryExpression" /> para a qual a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> é igual a <see cref="M:System.Linq.Expressions.Expression.TypeEqual(System.Linq.Expressions.Expression,System.Type)" /> e para a qual as propriedades <see cref="T:System.Linq.Expressions.Expression" /> e <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" /> estão definidas para os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3728">A <see cref="T:System.Linq.Expressions.TypeBinaryExpression" /> for which the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property is equal to <see cref="M:System.Linq.Expressions.Expression.TypeEqual(System.Linq.Expressions.Expression,System.Type)" /> and for which the <see cref="T:System.Linq.Expressions.Expression" /> and <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" /> properties are set to the specified values.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TypeIs">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.TypeBinaryExpression TypeIs (System.Linq.Expressions.Expression expression, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.TypeBinaryExpression TypeIs(class System.Linq.Expressions.Expression expression, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TypeIs(System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::TypeBinaryExpression ^ TypeIs(System::Linq::Expressions::Expression ^ expression, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member TypeIs : System.Linq.Expressions.Expression * Type -&gt; System.Linq.Expressions.TypeBinaryExpression" Usage="System.Linq.Expressions.Expression.TypeIs (expression, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.TypeBinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="expression">
          <span data-ttu-id="f7da9-3729">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Expression" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3729">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Expression" /> property equal to.</span>
          </span>
        </param>
        <param name="type">
          <span data-ttu-id="f7da9-3730">Um <see cref="P:System.Linq.Expressions.Expression.Type" /> para definir a propriedade <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3730">A <see cref="P:System.Linq.Expressions.Expression.Type" /> to set the <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-3731">Cria um <see cref="T:System.Linq.Expressions.TypeBinaryExpression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3731">Creates a <see cref="T:System.Linq.Expressions.TypeBinaryExpression" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-3732">Uma <see cref="T:System.Linq.Expressions.TypeBinaryExpression" /> para a qual a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> é igual a <see cref="F:System.Linq.Expressions.ExpressionType.TypeIs" /> e para a qual as propriedades <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Expression" /> e <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" /> estão definidas para os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3732">A <see cref="T:System.Linq.Expressions.TypeBinaryExpression" /> for which the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property is equal to <see cref="F:System.Linq.Expressions.ExpressionType.TypeIs" /> and for which the <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Expression" /> and <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" /> properties are set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-3733">O <xref:System.Linq.Expressions.Expression.Type%2A> propriedade resultantes <xref:System.Linq.Expressions.UnaryExpression> representa <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3733">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.UnaryExpression> represents <xref:System.Boolean>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f7da9-3734">O exemplo a seguir demonstra como usar o <xref:System.Linq.Expressions.Expression.TypeIs%28System.Linq.Expressions.Expression%2CSystem.Type%29> método para criar um <xref:System.Linq.Expressions.TypeBinaryExpression> que representa um teste de tipo de um valor de cadeia de caracteres em relação a <xref:System.Int32> tipo.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3734">The following example demonstrates how to use the <xref:System.Linq.Expressions.Expression.TypeIs%28System.Linq.Expressions.Expression%2CSystem.Type%29> method to create a <xref:System.Linq.Expressions.TypeBinaryExpression> that represents a type test of a string value against the <xref:System.Int32> type.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.Expression#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#12)]
 [!code-vb[System.Linq.Expressions.Expression#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f7da9-3735">
            <paramref name="expression" /> ou <paramref name="type" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3735">
              <paramref name="expression" /> or <paramref name="type" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="UnaryPlus">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f7da9-3736">Cria uma <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa uma operação unária de adição.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3736">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a unary plus operation.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="UnaryPlus">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression UnaryPlus (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression UnaryPlus(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.UnaryPlus(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ UnaryPlus(System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member UnaryPlus : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.UnaryPlus expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression">
          <span data-ttu-id="f7da9-3737">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3737">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-3738">Cria uma <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa uma operação unária de adição.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3738">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a unary plus operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-3739">Uma <see cref="T:System.Linq.Expressions.UnaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.UnaryPlus" /> e a propriedade <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> definida para o valor especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3739">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.UnaryPlus" /> and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property set to the specified value.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-3740">O <xref:System.Linq.Expressions.UnaryExpression.Method%2A> propriedade resultantes <xref:System.Linq.Expressions.UnaryExpression> é definido como o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3740">The <xref:System.Linq.Expressions.UnaryExpression.Method%2A> property of the resulting <xref:System.Linq.Expressions.UnaryExpression> is set to the implementing method.</span></span> <span data-ttu-id="f7da9-3741">O <xref:System.Linq.Expressions.Expression.Type%2A> estiver definida como o tipo de nó.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3741">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="f7da9-3742">Se o nó é elevado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> e <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriedades estiverem `true`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3742">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="f7da9-3743">Caso contrário, eles são falsos.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3743">Otherwise, they are false.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="f7da9-3744">Implementando método</span><span class="sxs-lookup"><span data-stu-id="f7da9-3744">Implementing Method</span></span>  
 <span data-ttu-id="f7da9-3745">As regras a seguir determinam o método de implementação para a operação:</span><span class="sxs-lookup"><span data-stu-id="f7da9-3745">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="f7da9-3746">Se `expression`. Tipo é um tipo definido pelo usuário que define o operador unário de adição, o <xref:System.Reflection.MethodInfo> que representa que o método de implementação do operador é.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3746">If `expression`.Type is a user-defined type that defines the unary plus operator, the <xref:System.Reflection.MethodInfo> that represents that operator is the implementing method.</span></span>  
  
-   <span data-ttu-id="f7da9-3747">Caso contrário, se `expression`. Tipo é um tipo numérico, o método de implementação é `null`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3747">Otherwise, if `expression`.Type is a numeric type, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="f7da9-3748">Tipo de nó e versão com comparação de precisão x sem comparação de precisão</span><span class="sxs-lookup"><span data-stu-id="f7da9-3748">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="f7da9-3749">Se o método de implementação não for `null`:</span><span class="sxs-lookup"><span data-stu-id="f7da9-3749">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="f7da9-3750">Se `expression`. O tipo é atribuível ao tipo de argumento do método de implementação, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3750">If `expression`.Type is assignable to the argument type of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="f7da9-3751">O tipo do nó é o tipo de retorno do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3751">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="f7da9-3752">Se as duas seguintes condições forem atendidas, o nó é levantado e o tipo de nó é o tipo que permite valor nulo que corresponde ao tipo de retorno do método de implementação:</span><span class="sxs-lookup"><span data-stu-id="f7da9-3752">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="f7da9-3753">`expression`. É um tipo de valor anulável e o tipo de valor não anulável correspondente é igual ao tipo de argumento do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3753">`expression`.Type is a nullable value type and the corresponding non-nullable value type is equal to the argument type of the implementing method.</span></span>  
  
    -   <span data-ttu-id="f7da9-3754">O tipo de retorno do método de implementação é um tipo de valor não anulável.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3754">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="f7da9-3755">Se for o método de implementação `null`, o tipo de nó é `expression`. Tipo.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3755">If the implementing method is `null`, the type of the node is `expression`.Type.</span></span> <span data-ttu-id="f7da9-3756">Se `expression`. Tipo não anulável, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3756">If `expression`.Type is non-nullable, the node is not lifted.</span></span> <span data-ttu-id="f7da9-3757">Caso contrário, o nó é eliminado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3757">Otherwise, the node is lifted.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f7da9-3758">
            <paramref name="expression" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3758">
              <paramref name="expression" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f7da9-3759">O operador de mais unário não foi definido para <paramref name="expression" />.Type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3759">The unary plus operator is not defined for <paramref name="expression" />.Type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="UnaryPlus">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression UnaryPlus (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression UnaryPlus(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.UnaryPlus(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ UnaryPlus(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member UnaryPlus : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.UnaryPlus (expression, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">
          <span data-ttu-id="f7da9-3760">Um <see cref="T:System.Linq.Expressions.Expression" /> para definir a propriedade <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3760">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="f7da9-3761">Um <see cref="T:System.Reflection.MethodInfo" /> para definir a propriedade <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> igual a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3761">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> property equal to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-3762">Cria uma <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa uma operação unária de adição.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3762">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a unary plus operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-3763">Um <see cref="T:System.Linq.Expressions.UnaryExpression" /> que tem a propriedade <see cref="P:System.Linq.Expressions.Expression.NodeType" /> igual a <see cref="F:System.Linq.Expressions.ExpressionType.UnaryPlus" /> e as propriedades <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> e <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> definidas com os valores especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3763">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.UnaryPlus" /> and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> and <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> properties set to the specified values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-3764">O <xref:System.Linq.Expressions.UnaryExpression.Method%2A> propriedade resultantes <xref:System.Linq.Expressions.UnaryExpression> é definido como o método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3764">The <xref:System.Linq.Expressions.UnaryExpression.Method%2A> property of the resulting <xref:System.Linq.Expressions.UnaryExpression> is set to the implementing method.</span></span> <span data-ttu-id="f7da9-3765">O <xref:System.Linq.Expressions.Expression.Type%2A> estiver definida como o tipo de nó.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3765">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="f7da9-3766">Se o nó é elevado, o <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> e <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> propriedades estiverem `true`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3766">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="f7da9-3767">Caso contrário, eles são falsos.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3767">Otherwise, they are false.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="f7da9-3768">Implementando método</span><span class="sxs-lookup"><span data-stu-id="f7da9-3768">Implementing Method</span></span>  
 <span data-ttu-id="f7da9-3769">As regras a seguir determinam o método de implementação para a operação:</span><span class="sxs-lookup"><span data-stu-id="f7da9-3769">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="f7da9-3770">Se `method` não é `null` e representa um não-nulo, `static` (`Shared` no Visual Basic) método que aceita um argumento, ele é o método de implementação para o nó.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3770">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes one argument, it is the implementing method for the node.</span></span>  
  
-   <span data-ttu-id="f7da9-3771">Se `expression`. Tipo é um tipo definido pelo usuário que define o operador unário de adição, o <xref:System.Reflection.MethodInfo> que representa que o método de implementação do operador é.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3771">If `expression`.Type is a user-defined type that defines the unary plus operator, the <xref:System.Reflection.MethodInfo> that represents that operator is the implementing method.</span></span>  
  
-   <span data-ttu-id="f7da9-3772">Caso contrário, se `expression`. Tipo é um tipo numérico, o método de implementação é `null`.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3772">Otherwise, if `expression`.Type is a numeric type, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="f7da9-3773">Tipo de nó e versão com comparação de precisão x sem comparação de precisão</span><span class="sxs-lookup"><span data-stu-id="f7da9-3773">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="f7da9-3774">Se o método de implementação não for `null`:</span><span class="sxs-lookup"><span data-stu-id="f7da9-3774">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="f7da9-3775">Se `expression`. O tipo é atribuível ao tipo de argumento do método de implementação, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3775">If `expression`.Type is assignable to the argument type of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="f7da9-3776">O tipo do nó é o tipo de retorno do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3776">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="f7da9-3777">Se as duas seguintes condições forem atendidas, o nó é levantado e o tipo de nó é o tipo que permite valor nulo que corresponde ao tipo de retorno do método de implementação:</span><span class="sxs-lookup"><span data-stu-id="f7da9-3777">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="f7da9-3778">`expression`. É um tipo de valor anulável e o tipo de valor não anulável correspondente é igual ao tipo de argumento do método de implementação.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3778">`expression`.Type is a nullable value type and the corresponding non-nullable value type is equal to the argument type of the implementing method.</span></span>  
  
    -   <span data-ttu-id="f7da9-3779">O tipo de retorno do método de implementação é um tipo de valor não anulável.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3779">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="f7da9-3780">Se for o método de implementação `null`, o tipo de nó é `expression`. Tipo.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3780">If the implementing method is `null`, the type of the node is `expression`.Type.</span></span> <span data-ttu-id="f7da9-3781">Se `expression`. Tipo não anulável, o nó não é elevado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3781">If `expression`.Type is non-nullable, the node is not lifted.</span></span> <span data-ttu-id="f7da9-3782">Caso contrário, o nó é eliminado.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3782">Otherwise, the node is lifted.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f7da9-3783">
            <paramref name="expression" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3783">
              <paramref name="expression" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f7da9-3784">
            <paramref name="method" /> não é <see langword="null" /> e o método que ele representa retorna <see langword="void" />, não é <see langword="static" /> (<see langword="Shared" /> no Visual Basic) ou não tem exatamente um argumento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3784">
              <paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly one argument.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f7da9-3785">
            <paramref name="method" /> é <see langword="null" /> e o operador unário de mais de não foi definido para <paramref name="expression" />.Type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3785">
              <paramref name="method" /> is <see langword="null" /> and the unary plus operator is not defined for <paramref name="expression" />.Type.</span>
          </span>
          <span data-ttu-id="f7da9-3786">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3786">-or-</span>
          </span>
          <span data-ttu-id="f7da9-3787">
            <paramref name="expression" />.Type (ou o respectivo tipo que não permite valor nulo correspondente se ele é um tipo que permite valor nulo) não é atribuível ao tipo de argumento do método representado por <paramref name="method" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3787">
              <paramref name="expression" />.Type (or its corresponding non-nullable type if it is a nullable value type) is not assignable to the argument type of the method represented by <paramref name="method" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Unbox">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Unbox (System.Linq.Expressions.Expression expression, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Unbox(class System.Linq.Expressions.Expression expression, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Unbox(System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Unbox(System::Linq::Expressions::Expression ^ expression, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Unbox : System.Linq.Expressions.Expression * Type -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Unbox (expression, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="expression">
          <span data-ttu-id="f7da9-3788">Um <see cref="T:System.Linq.Expressions.Expression" /> para realizar conversão unboxing.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3788">An <see cref="T:System.Linq.Expressions.Expression" /> to unbox.</span>
          </span>
        </param>
        <param name="type">
          <span data-ttu-id="f7da9-3789">O novo <see cref="T:System.Type" /> da expressão.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3789">The new <see cref="T:System.Type" /> of the expression.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-3790">Cria uma <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa uma conversão unboxing explícita.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3790">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents an explicit unboxing.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-3791">Uma instância de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3791">An instance of <see cref="T:System.Linq.Expressions.UnaryExpression" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Variable">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f7da9-3792">Cria um nó de <see cref="T:System.Linq.Expressions.ParameterExpression" /> que pode ser usado para identificar um parâmetro ou uma variável em uma árvore de expressão.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3792">Creates a <see cref="T:System.Linq.Expressions.ParameterExpression" /> node that can be used to identify a parameter or a variable in an expression tree.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Variable">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ParameterExpression Variable (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ParameterExpression Variable(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Variable(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ParameterExpression ^ Variable(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Variable : Type -&gt; System.Linq.Expressions.ParameterExpression" Usage="System.Linq.Expressions.Expression.Variable type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ParameterExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">
          <span data-ttu-id="f7da9-3793">O tipo do parâmetro ou da variável.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3793">The type of the parameter or variable.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-3794">Cria um nó de <see cref="T:System.Linq.Expressions.ParameterExpression" /> que pode ser usado para identificar um parâmetro ou uma variável em uma árvore de expressão.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3794">Creates a <see cref="T:System.Linq.Expressions.ParameterExpression" /> node that can be used to identify a parameter or a variable in an expression tree.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-3795">Um nó de <see cref="T:System.Linq.Expressions.ParameterExpression" /> com o nome e o tipo especificados</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3795">A <see cref="T:System.Linq.Expressions.ParameterExpression" /> node with the specified name and type</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Variable">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ParameterExpression Variable (Type type, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ParameterExpression Variable(class System.Type type, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Variable(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ParameterExpression ^ Variable(Type ^ type, System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member Variable : Type * string -&gt; System.Linq.Expressions.ParameterExpression" Usage="System.Linq.Expressions.Expression.Variable (type, name)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ParameterExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">
          <span data-ttu-id="f7da9-3796">O tipo do parâmetro ou da variável.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3796">The type of the parameter or variable.</span>
          </span>
        </param>
        <param name="name">
          <span data-ttu-id="f7da9-3797">O nome do parâmetro ou da variável.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3797">The name of the parameter or variable.</span>
          </span>
          <span data-ttu-id="f7da9-3798">Esse nome é usado apenas para finalidades de depuração ou de impressão.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3798">This name is used for debugging or printing purpose only.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-3799">Cria um nó de <see cref="T:System.Linq.Expressions.ParameterExpression" /> que pode ser usado para identificar um parâmetro ou uma variável em uma árvore de expressão.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3799">Creates a <see cref="T:System.Linq.Expressions.ParameterExpression" /> node that can be used to identify a parameter or a variable in an expression tree.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-3800">Um nó de <see cref="T:System.Linq.Expressions.ParameterExpression" /> com o nome e tipo especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3800">A <see cref="T:System.Linq.Expressions.ParameterExpression" /> node with the specified name and type.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="VisitChildren">
      <MemberSignature Language="C#" Value="protected internal virtual System.Linq.Expressions.Expression VisitChildren (System.Linq.Expressions.ExpressionVisitor visitor);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.Linq.Expressions.Expression VisitChildren(class System.Linq.Expressions.ExpressionVisitor visitor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.VisitChildren(System.Linq.Expressions.ExpressionVisitor)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function VisitChildren (visitor As ExpressionVisitor) As Expression" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Linq::Expressions::Expression ^ VisitChildren(System::Linq::Expressions::ExpressionVisitor ^ visitor);" />
      <MemberSignature Language="F#" Value="abstract member VisitChildren : System.Linq.Expressions.ExpressionVisitor -&gt; System.Linq.Expressions.Expression&#xA;override this.VisitChildren : System.Linq.Expressions.ExpressionVisitor -&gt; System.Linq.Expressions.Expression" Usage="expression.VisitChildren visitor" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="visitor" Type="System.Linq.Expressions.ExpressionVisitor" />
      </Parameters>
      <Docs>
        <param name="visitor">
          <span data-ttu-id="f7da9-3801">Uma instância de <see cref="T:System.Func`2" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3801">An instance of <see cref="T:System.Func`2" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f7da9-3802">Reduz o nó e, em seguida, chama o delegado visitante na expressão reduzida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3802">Reduces the node and then calls the visitor delegate on the reduced expression.</span>
          </span>
          <span data-ttu-id="f7da9-3803">O método gera uma exceção se o nó não é reduzível.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3803">The method throws an exception if the node is not reducible.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f7da9-3804">A expressão que está sendo visitada ou uma expressão que deve substituí-la na árvore.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f7da9-3804">The expression being visited, or an expression which should replace it in the tree.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f7da9-3805">Substitua este método para fornecer a lógica para percorrer os filhos do nó.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3805">Override this method to provide logic to walk the node's children.</span></span> <span data-ttu-id="f7da9-3806">Uma implementação típica chamará o visitante. Visite em cada um dos seus filhos e se qualquer um dos-los de alteração, deve retornar uma nova cópia de si mesmo com os filhos modificados.</span><span class="sxs-lookup"><span data-stu-id="f7da9-3806">A typical implementation will call visitor.Visit on each of its children, and if any of them change, should return a new copy of itself with the modified children.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>