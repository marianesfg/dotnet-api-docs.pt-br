<Type Name="WorkflowInstance" FullName="System.Activities.Hosting.WorkflowInstance">
  <Metadata><Meta Name="ms.openlocfilehash" Value="5da74134d1504a1f1f2b0e2b06202905984fcf07" /><Meta Name="ms.sourcegitcommit" Value="adc8598fd19d91438cacaa8fa7ce613e28c8218e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pt-BR" /><Meta Name="ms.lasthandoff" Value="12/11/2018" /><Meta Name="ms.locfileid" Value="53227914" /></Metadata><TypeSignature Language="C#" Value="public abstract class WorkflowInstance" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract WorkflowInstance extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Activities.Hosting.WorkflowInstance" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class WorkflowInstance" />
  <TypeSignature Language="C++ CLI" Value="public ref class WorkflowInstance abstract" />
  <TypeSignature Language="F#" Value="type WorkflowInstance = class" />
  <AssemblyInfo>
    <AssemblyName>System.Activities</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary><see cref="T:System.Activities.Hosting.WorkflowInstance" /> é um tempo de execução por instância leve para executar um programa de fluxo de trabalho. Ele pode ser construído para criar uma nova instância de fluxo de trabalho ou de estado da instância existente. As APIs que o <see cref="T:System.Activities.Hosting.WorkflowInstance.WorkflowInstanceControl" /> expõe são o conjunto mínimo de controles de tempo de execução do qual as operações de nível superior podem ser implementadas. Esse conjunto de APIs representa a largura inteira da funcionalidade do tempo de execução. O <see cref="T:System.Activities.Hosting.WorkflowInstance" /> é uma classe abstrata e se baseia na implementação de um host de seus métodos abstratos para fornecer a funcionalidade do host, como sincronização, persistência, acompanhamento e extensões.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Activities.Hosting.WorkflowInstance> é o único thread e pressupõe que o host sincroniza todo o acesso a ele. Uma tentativa de chamar várias APIs simultaneamente resultará em um <xref:System.InvalidOperationException> que está sendo gerada.  
  
 Internamente, uma <xref:System.Activities.Hosting.WorkflowInstance> tem dois estados: Em pausa e em execução. A única maneira de fazer com que o tempo de execução para fazer a transição de em pausa a execução é chamar <xref:System.Activities.Hosting.WorkflowInstance.WorkflowInstanceControl.Run%2A>. Todas as ações (exceto Pausar) só podem ser executadas enquanto o tempo de execução está em pausa. O tempo de execução irá se tornar espontaneamente em pausa nas seguintes situações:  
  
-   Ocorreu um erro fatal no tempo de execução. O host será sinalizado por meio <xref:System.Activities.Hosting.WorkflowInstance.OnRequestAbort%2A> (que não indica uma transição em pausa) e, em seguida, é notificado por meio do <xref:System.Activities.Hosting.WorkflowInstance.OnNotifyPaused%2A>.  
  
-   Uma exceção no fluxo de trabalho foi não identificada e a raiz de escape. O host será notificado por meio de <xref:System.Activities.Hosting.WorkflowInstance.OnNotifyUnhandledException%2A> método.  
  
-   O Agendador está sem itens de trabalho e agora é <xref:System.Activities.Hosting.WorkflowInstanceState.Idle>. O host será notificado por meio de <xref:System.Activities.Hosting.WorkflowInstance.OnNotifyPaused%2A> método. Observe que o Agendador pode ter ficado sem itens de trabalho porque a instância estiver ociosa ou porque a instância for concluída. O <xref:System.Activities.Hosting.WorkflowInstance.WorkflowInstanceControl.State%2A> valor da <xref:System.Activities.Hosting.WorkflowInstance.Controller%2A> propriedade pode ser usada para diferenciar entre os dois.  
  
 O host pode solicitar uma alteração em execução como em pausa, chamando o <xref:System.Activities.Hosting.WorkflowInstance.WorkflowInstanceControl.RequestPause%2A> ou <xref:System.Activities.Hosting.WorkflowInstance.WorkflowInstanceControl.PauseWhenPersistable%2A> métodos da <xref:System.Activities.Hosting.WorkflowInstance.WorkflowInstanceControl> instância retornada pela <xref:System.Activities.Hosting.WorkflowInstance.Controller%2A> propriedade. Esta solicitação não deve ser considerada com uma resposta específica, que significa que o host não deve tentar correlacionar uma OnNotify * ou <xref:System.Activities.Hosting.WorkflowInstance.OnRequestAbort%2A> com uma chamada específica para pausar. Em resposta a uma solicitação de pausa, o tempo de execução pode fazer a transição para pausado e chamada <xref:System.Activities.Hosting.WorkflowInstance.OnNotifyPaused%2A> enquanto o Agendador ainda tem itens de trabalho pendente. O <xref:System.Activities.Hosting.WorkflowInstance.WorkflowInstanceControl.State%2A> valor da <xref:System.Activities.Hosting.WorkflowInstance.Controller%2A> propriedade pode ser usada para determinar se o Agendador não existe mais nada ou foi interrompido por uma solicitação para pausar.  
  
 O <xref:System.Activities.Hosting.WorkflowInstance.WorkflowInstanceControl.RequestPause%2A> método da <xref:System.Activities.Hosting.WorkflowInstance.WorkflowInstanceControl> instância retornada pela <xref:System.Activities.Hosting.WorkflowInstance.Controller%2A> propriedade é o único método que pode ser chamado enquanto o <xref:System.Activities.Hosting.WorkflowInstance> está no estado em execução. Todos os outros métodos lançará um <xref:System.InvalidOperationException> se for chamado. Dadas as regras para como <xref:System.Activities.Hosting.WorkflowInstance> faz a transição de um estado para outro, a noção de pública de execução e em pausa pode ser definida da seguinte maneira:  
  
-   Executando - o estado entre uma chamada para <xref:System.Activities.Hosting.WorkflowInstance.WorkflowInstanceControl.Run%2A> e o próximo WorkflowInstance.OnNotify*.  
  
-   Em pausa - o estado entre a última WorkflowInstance.OnNotify* e a próxima chamada para <xref:System.Activities.Hosting.WorkflowInstance.WorkflowInstanceControl.Run%2A>.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Activities.Hosting.WorkflowInstance" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected WorkflowInstance (System.Activities.Activity workflowDefinition);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Activities.Activity workflowDefinition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.Hosting.WorkflowInstance.#ctor(System.Activities.Activity)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (workflowDefinition As Activity)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; WorkflowInstance(System::Activities::Activity ^ workflowDefinition);" />
      <MemberSignature Language="F#" Value="new System.Activities.Hosting.WorkflowInstance : System.Activities.Activity -&gt; System.Activities.Hosting.WorkflowInstance" Usage="new System.Activities.Hosting.WorkflowInstance workflowDefinition" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="workflowDefinition" Type="System.Activities.Activity" />
      </Parameters>
      <Docs>
        <param name="workflowDefinition">A atividade que define o fluxo de trabalho.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Activities.Hosting.WorkflowInstance" /> com a definição do fluxo de trabalho especificada.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected WorkflowInstance (System.Activities.Activity workflowDefinition, System.Activities.WorkflowIdentity definitionIdentity);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Activities.Activity workflowDefinition, class System.Activities.WorkflowIdentity definitionIdentity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.Hosting.WorkflowInstance.#ctor(System.Activities.Activity,System.Activities.WorkflowIdentity)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (workflowDefinition As Activity, definitionIdentity As WorkflowIdentity)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; WorkflowInstance(System::Activities::Activity ^ workflowDefinition, System::Activities::WorkflowIdentity ^ definitionIdentity);" />
      <MemberSignature Language="F#" Value="new System.Activities.Hosting.WorkflowInstance : System.Activities.Activity * System.Activities.WorkflowIdentity -&gt; System.Activities.Hosting.WorkflowInstance" Usage="new System.Activities.Hosting.WorkflowInstance (workflowDefinition, definitionIdentity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="workflowDefinition" Type="System.Activities.Activity" />
        <Parameter Name="definitionIdentity" Type="System.Activities.WorkflowIdentity" />
      </Parameters>
      <Docs>
        <param name="workflowDefinition">A atividade que define o fluxo de trabalho.</param>
        <param name="definitionIdentity">A identidade da definição.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Activities.Hosting.WorkflowInstance" /> com a definição do fluxo de trabalho e a identidade da definição especificadas.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginFlushTrackingRecords">
      <MemberSignature Language="C#" Value="protected IAsyncResult BeginFlushTrackingRecords (TimeSpan timeout, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance class System.IAsyncResult BeginFlushTrackingRecords(valuetype System.TimeSpan timeout, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.Hosting.WorkflowInstance.BeginFlushTrackingRecords(System.TimeSpan,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Function BeginFlushTrackingRecords (timeout As TimeSpan, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; IAsyncResult ^ BeginFlushTrackingRecords(TimeSpan timeout, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginFlushTrackingRecords : TimeSpan * AsyncCallback * obj -&gt; IAsyncResult" Usage="workflowInstance.BeginFlushTrackingRecords (timeout, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout">O período após o qual anular a tentativa.</param>
        <param name="callback">O método a ser chamado quando a operação de rastreamento for concluída.</param>
        <param name="state">As informações sobre a operação assíncrona.</param>
        <summary>Chamado pelo tempo de execução do fluxo de trabalho para iniciar o envio de registros de acompanhamento pendentes aos participantes de acompanhamento de forma assíncrona.</summary>
        <returns>O status da operação de rastreamento atual.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Controller">
      <MemberSignature Language="C#" Value="protected System.Activities.Hosting.WorkflowInstance.WorkflowInstanceControl Controller { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Activities.Hosting.WorkflowInstance/WorkflowInstanceControl Controller" />
      <MemberSignature Language="DocId" Value="P:System.Activities.Hosting.WorkflowInstance.Controller" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property Controller As WorkflowInstance.WorkflowInstanceControl" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Activities::Hosting::WorkflowInstance::WorkflowInstanceControl Controller { System::Activities::Hosting::WorkflowInstance::WorkflowInstanceControl get(); };" />
      <MemberSignature Language="F#" Value="member this.Controller : System.Activities.Hosting.WorkflowInstance.WorkflowInstanceControl" Usage="System.Activities.Hosting.WorkflowInstance.Controller" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Activities.Hosting.WorkflowInstance+WorkflowInstanceControl</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém a instância <see cref="T:System.Activities.Hosting.WorkflowInstance.WorkflowInstanceControl" /> para este <see cref="T:System.Activities.Hosting.WorkflowInstance" />.</summary>
        <value>A instância do controlador para esta instância de fluxo de trabalho.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefinitionIdentity">
      <MemberSignature Language="C#" Value="public System.Activities.WorkflowIdentity DefinitionIdentity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Activities.WorkflowIdentity DefinitionIdentity" />
      <MemberSignature Language="DocId" Value="P:System.Activities.Hosting.WorkflowInstance.DefinitionIdentity" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DefinitionIdentity As WorkflowIdentity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Activities::WorkflowIdentity ^ DefinitionIdentity { System::Activities::WorkflowIdentity ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DefinitionIdentity : System.Activities.WorkflowIdentity" Usage="System.Activities.Hosting.WorkflowInstance.DefinitionIdentity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Activities.WorkflowIdentity</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define a identidade de definição de <see cref="T:System.Activities.Hosting.WorkflowInstance" />.</summary>
        <value>A identidade de definição de <see cref="T:System.Activities.Hosting.WorkflowInstance" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DisposeExtensions">
      <MemberSignature Language="C#" Value="protected void DisposeExtensions ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void DisposeExtensions() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.Hosting.WorkflowInstance.DisposeExtensions" />
      <MemberSignature Language="VB.NET" Value="Protected Sub DisposeExtensions ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void DisposeExtensions();" />
      <MemberSignature Language="F#" Value="member this.DisposeExtensions : unit -&gt; unit" Usage="workflowInstance.DisposeExtensions " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Chama <see cref="M:System.IDisposable.Dispose" /> em todas as extensões que implementam <see cref="T:System.IDisposable" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndFlushTrackingRecords">
      <MemberSignature Language="C#" Value="protected void EndFlushTrackingRecords (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void EndFlushTrackingRecords(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.Hosting.WorkflowInstance.EndFlushTrackingRecords(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub EndFlushTrackingRecords (result As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void EndFlushTrackingRecords(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="member this.EndFlushTrackingRecords : IAsyncResult -&gt; unit" Usage="workflowInstance.EndFlushTrackingRecords result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">O status da operação assíncrona de rastreamento.</param>
        <summary>Chamado pelo tempo de execução do fluxo de trabalho para encerrar a operação de controle.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FlushTrackingRecords">
      <MemberSignature Language="C#" Value="protected void FlushTrackingRecords (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void FlushTrackingRecords(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.Hosting.WorkflowInstance.FlushTrackingRecords(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub FlushTrackingRecords (timeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void FlushTrackingRecords(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.FlushTrackingRecords : TimeSpan -&gt; unit" Usage="workflowInstance.FlushTrackingRecords timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">O período após o qual anular a tentativa.</param>
        <summary>Chamado pelo tempo de execução do fluxo de trabalho para enviar os registros de acompanhamento pendentes para acompanhar os participantes.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetActivitiesBlockingUpdate">
      <MemberSignature Language="C#" Value="protected static System.Collections.Generic.IList&lt;System.Activities.DynamicUpdate.ActivityBlockingUpdate&gt; GetActivitiesBlockingUpdate (object deserializedRuntimeState, System.Activities.DynamicUpdate.DynamicUpdateMap updateMap);" />
      <MemberSignature Language="ILAsm" Value=".method familystatic hidebysig class System.Collections.Generic.IList`1&lt;class System.Activities.DynamicUpdate.ActivityBlockingUpdate&gt; GetActivitiesBlockingUpdate(object deserializedRuntimeState, class System.Activities.DynamicUpdate.DynamicUpdateMap updateMap) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.Hosting.WorkflowInstance.GetActivitiesBlockingUpdate(System.Object,System.Activities.DynamicUpdate.DynamicUpdateMap)" />
      <MemberSignature Language="VB.NET" Value="Protected Shared Function GetActivitiesBlockingUpdate (deserializedRuntimeState As Object, updateMap As DynamicUpdateMap) As IList(Of ActivityBlockingUpdate)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; static System::Collections::Generic::IList&lt;System::Activities::DynamicUpdate::ActivityBlockingUpdate ^&gt; ^ GetActivitiesBlockingUpdate(System::Object ^ deserializedRuntimeState, System::Activities::DynamicUpdate::DynamicUpdateMap ^ updateMap);" />
      <MemberSignature Language="F#" Value="static member GetActivitiesBlockingUpdate : obj * System.Activities.DynamicUpdate.DynamicUpdateMap -&gt; System.Collections.Generic.IList&lt;System.Activities.DynamicUpdate.ActivityBlockingUpdate&gt;" Usage="System.Activities.Hosting.WorkflowInstance.GetActivitiesBlockingUpdate (deserializedRuntimeState, updateMap)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Activities.DynamicUpdate.ActivityBlockingUpdate&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="deserializedRuntimeState" Type="System.Object" />
        <Parameter Name="updateMap" Type="System.Activities.DynamicUpdate.DynamicUpdateMap" />
      </Parameters>
      <Docs>
        <param name="deserializedRuntimeState">O estado de tempo de execução desserializado.</param>
        <param name="updateMap">O mapa de atualização.</param>
        <summary>Recupera a lista de atividade que está bloqueando a atualização do fluxo de trabalho.</summary>
        <returns>A lista de atividade que está bloqueando a atualização.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetExtension&lt;T&gt;">
      <MemberSignature Language="C#" Value="protected internal T GetExtension&lt;T&gt; () where T : class;" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance !!T GetExtension&lt;class T&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.Hosting.WorkflowInstance.GetExtension``1" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Function GetExtension(Of T As Class) () As T" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA;generic &lt;typename T&gt;&#xA; where T : class T GetExtension();" />
      <MemberSignature Language="F#" Value="member this.GetExtension : unit -&gt; 'T (requires 'T : null)" Usage="workflowInstance.GetExtension " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="T">O tipo de extensão a ser localizada.</typeparam>
        <summary>Retorna uma extensão do tipo especificado.</summary>
        <returns>Uma extensão do tipo especificado.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetExtensions&lt;T&gt;">
      <MemberSignature Language="C#" Value="protected internal System.Collections.Generic.IEnumerable&lt;T&gt; GetExtensions&lt;T&gt; () where T : class;" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; GetExtensions&lt;class T&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.Hosting.WorkflowInstance.GetExtensions``1" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Function GetExtensions(Of T As Class) () As IEnumerable(Of T)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA;generic &lt;typename T&gt;&#xA; where T : class System::Collections::Generic::IEnumerable&lt;T&gt; ^ GetExtensions();" />
      <MemberSignature Language="F#" Value="member this.GetExtensions : unit -&gt; seq&lt;'T (requires 'T : null)&gt; (requires 'T : null)" Usage="workflowInstance.GetExtensions " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="T">O tipo de extensão a ser localizada.</typeparam>
        <summary>Retorna todas as extensões encontradas para o tipo especificado.</summary>
        <returns>Todas as extensões encontradas para o tipo especificado.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HostEnvironment">
      <MemberSignature Language="C#" Value="public System.Activities.LocationReferenceEnvironment HostEnvironment { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Activities.LocationReferenceEnvironment HostEnvironment" />
      <MemberSignature Language="DocId" Value="P:System.Activities.Hosting.WorkflowInstance.HostEnvironment" />
      <MemberSignature Language="VB.NET" Value="Public Property HostEnvironment As LocationReferenceEnvironment" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Activities::LocationReferenceEnvironment ^ HostEnvironment { System::Activities::LocationReferenceEnvironment ^ get(); void set(System::Activities::LocationReferenceEnvironment ^ value); };" />
      <MemberSignature Language="F#" Value="member this.HostEnvironment : System.Activities.LocationReferenceEnvironment with get, set" Usage="System.Activities.Hosting.WorkflowInstance.HostEnvironment" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Activities.LocationReferenceEnvironment</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o ambiente raiz para as variáveis e argumentos da instância de fluxo de trabalho.</summary>
        <value>O ambiente de raiz para os argumentos e variáveis da instância de fluxo de trabalho.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se essa propriedade é definida depois que a instância de fluxo de trabalho é inicializada e <xref:System.Activities.Hosting.WorkflowInstance.IsReadOnly%2A> retorna `true`, um <xref:System.InvalidOperationException> é gerada.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public abstract Guid Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid Id" />
      <MemberSignature Language="DocId" Value="P:System.Activities.Hosting.WorkflowInstance.Id" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Id As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property Guid Id { Guid get(); };" />
      <MemberSignature Language="F#" Value="member this.Id : Guid" Usage="System.Activities.Hosting.WorkflowInstance.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o identificador exclusivo da instância de fluxo de trabalho.</summary>
        <value>O identificador exclusivo para a instância de fluxo de trabalho.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Initialize">
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Chamado pelo host para inicializar a instância de fluxo de trabalho.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Initialize">
      <MemberSignature Language="C#" Value="protected void Initialize (object deserializedRuntimeState);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void Initialize(object deserializedRuntimeState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.Hosting.WorkflowInstance.Initialize(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub Initialize (deserializedRuntimeState As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void Initialize(System::Object ^ deserializedRuntimeState);" />
      <MemberSignature Language="F#" Value="member this.Initialize : obj -&gt; unit" Usage="workflowInstance.Initialize deserializedRuntimeState" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="deserializedRuntimeState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="deserializedRuntimeState">O estado de tempo de execução usado para executar o fluxo de trabalho.</param>
        <summary>Chamado pelo host para inicializar a instância de fluxo de trabalho com o estado de tempo de execução do fluxo de trabalho.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Initialize">
      <MemberSignature Language="C#" Value="protected void Initialize (System.Collections.Generic.IDictionary&lt;string,object&gt; workflowArgumentValues, System.Collections.Generic.IList&lt;System.Activities.Handle&gt; workflowExecutionProperties);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void Initialize(class System.Collections.Generic.IDictionary`2&lt;string, object&gt; workflowArgumentValues, class System.Collections.Generic.IList`1&lt;class System.Activities.Handle&gt; workflowExecutionProperties) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.Hosting.WorkflowInstance.Initialize(System.Collections.Generic.IDictionary{System.String,System.Object},System.Collections.Generic.IList{System.Activities.Handle})" />
      <MemberSignature Language="VB.NET" Value="Protected Sub Initialize (workflowArgumentValues As IDictionary(Of String, Object), workflowExecutionProperties As IList(Of Handle))" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void Initialize(System::Collections::Generic::IDictionary&lt;System::String ^, System::Object ^&gt; ^ workflowArgumentValues, System::Collections::Generic::IList&lt;System::Activities::Handle ^&gt; ^ workflowExecutionProperties);" />
      <MemberSignature Language="F#" Value="member this.Initialize : System.Collections.Generic.IDictionary&lt;string, obj&gt; * System.Collections.Generic.IList&lt;System.Activities.Handle&gt; -&gt; unit" Usage="workflowInstance.Initialize (workflowArgumentValues, workflowExecutionProperties)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workflowArgumentValues" Type="System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;" />
        <Parameter Name="workflowExecutionProperties" Type="System.Collections.Generic.IList&lt;System.Activities.Handle&gt;" />
      </Parameters>
      <Docs>
        <param name="workflowArgumentValues">Os parâmetros de entrada para o fluxo de trabalho, inseridos por nome de argumento.</param>
        <param name="workflowExecutionProperties">A lista de propriedades de execução do fluxo de trabalho.</param>
        <summary>Chamado pelo host para inicializar a instância de fluxo de trabalho com os valores de argumento e as propriedades de execução.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Initialize">
      <MemberSignature Language="C#" Value="protected void Initialize (object deserializedRuntimeState, System.Activities.DynamicUpdate.DynamicUpdateMap updateMap);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void Initialize(object deserializedRuntimeState, class System.Activities.DynamicUpdate.DynamicUpdateMap updateMap) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.Hosting.WorkflowInstance.Initialize(System.Object,System.Activities.DynamicUpdate.DynamicUpdateMap)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub Initialize (deserializedRuntimeState As Object, updateMap As DynamicUpdateMap)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void Initialize(System::Object ^ deserializedRuntimeState, System::Activities::DynamicUpdate::DynamicUpdateMap ^ updateMap);" />
      <MemberSignature Language="F#" Value="member this.Initialize : obj * System.Activities.DynamicUpdate.DynamicUpdateMap -&gt; unit" Usage="workflowInstance.Initialize (deserializedRuntimeState, updateMap)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="deserializedRuntimeState" Type="System.Object" />
        <Parameter Name="updateMap" Type="System.Activities.DynamicUpdate.DynamicUpdateMap" />
      </Parameters>
      <Docs>
        <param name="deserializedRuntimeState">O estado de tempo de execução usado para executar o fluxo de trabalho.</param>
        <param name="updateMap">O mapa de atualização.</param>
        <summary>Chamado pelo host para inicializar a instância de fluxo de trabalho com o estado de tempo de execução do fluxo de trabalho e o mapa de atualização.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="protected bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Activities.Hosting.WorkflowInstance.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadOnly : bool" Usage="System.Activities.Hosting.WorkflowInstance.IsReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se a instância do fluxo de trabalho foi inicializada.</summary>
        <value><see langword="true" /> Se a instância de fluxo de trabalho tiver sido inicializada; Caso contrário, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnBeginAssociateKeys">
      <MemberSignature Language="C#" Value="protected internal abstract IAsyncResult OnBeginAssociateKeys (System.Collections.Generic.ICollection&lt;System.Runtime.DurableInstancing.InstanceKey&gt; keys, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.IAsyncResult OnBeginAssociateKeys(class System.Collections.Generic.ICollection`1&lt;class System.Runtime.DurableInstancing.InstanceKey&gt; keys, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.Hosting.WorkflowInstance.OnBeginAssociateKeys(System.Collections.Generic.ICollection{System.Runtime.DurableInstancing.InstanceKey},System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend MustOverride Function OnBeginAssociateKeys (keys As ICollection(Of InstanceKey), callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; abstract IAsyncResult ^ OnBeginAssociateKeys(System::Collections::Generic::ICollection&lt;System::Runtime::DurableInstancing::InstanceKey ^&gt; ^ keys, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member OnBeginAssociateKeys : System.Collections.Generic.ICollection&lt;System.Runtime.DurableInstancing.InstanceKey&gt; * AsyncCallback * obj -&gt; IAsyncResult" Usage="workflowInstance.OnBeginAssociateKeys (keys, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Collections.Generic.ICollection&lt;System.Runtime.DurableInstancing.InstanceKey&gt;" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="keys">As chaves de instância para associar a esta instância de fluxo de trabalho.</param>
        <param name="callback">O método a ser chamado quando a operação é concluída.</param>
        <param name="state">Um objeto específico do aplicativo opcional que contém informações sobre a operação assíncrona.</param>
        <summary>Chamado pelo tempo de execução de fluxo de trabalho para notificar o host de que novas chaves de instância devem ser associadas esta instância.</summary>
        <returns>Uma referência à operação de associação de chaves assíncrona.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnBeginFlushTrackingRecords">
      <MemberSignature Language="C#" Value="protected virtual IAsyncResult OnBeginFlushTrackingRecords (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IAsyncResult OnBeginFlushTrackingRecords(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.Hosting.WorkflowInstance.OnBeginFlushTrackingRecords(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function OnBeginFlushTrackingRecords (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual IAsyncResult ^ OnBeginFlushTrackingRecords(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member OnBeginFlushTrackingRecords : AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.OnBeginFlushTrackingRecords : AsyncCallback * obj -&gt; IAsyncResult" Usage="workflowInstance.OnBeginFlushTrackingRecords (callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">O método a ser chamado quando a operação de rastreamento for concluída.</param>
        <param name="state">As informações sobre a operação assíncrona.</param>
        <summary>Chamada assíncrona para solicitar que o host libere os registros de acompanhamento pendentes para os participantes do acompanhamento.</summary>
        <returns>O status da operação de rastreamento atual.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnBeginPersist">
      <MemberSignature Language="C#" Value="protected internal abstract IAsyncResult OnBeginPersist (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.IAsyncResult OnBeginPersist(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.Hosting.WorkflowInstance.OnBeginPersist(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend MustOverride Function OnBeginPersist (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; abstract IAsyncResult ^ OnBeginPersist(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member OnBeginPersist : AsyncCallback * obj -&gt; IAsyncResult" Usage="workflowInstance.OnBeginPersist (callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">O método a ser chamado quando a operação de persistência for concluída.</param>
        <param name="state">Um objeto específico do aplicativo opcional que contém informações sobre a operação assíncrona.</param>
        <summary>Chamada assíncrona para solicitar que o host mantenha o fluxo de trabalho.</summary>
        <returns>Uma referência à operação de persistência atual.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnBeginResumeBookmark">
      <MemberSignature Language="C#" Value="protected internal abstract IAsyncResult OnBeginResumeBookmark (System.Activities.Bookmark bookmark, object value, TimeSpan timeout, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.IAsyncResult OnBeginResumeBookmark(class System.Activities.Bookmark bookmark, object value, valuetype System.TimeSpan timeout, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.Hosting.WorkflowInstance.OnBeginResumeBookmark(System.Activities.Bookmark,System.Object,System.TimeSpan,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; abstract IAsyncResult ^ OnBeginResumeBookmark(System::Activities::Bookmark ^ bookmark, System::Object ^ value, TimeSpan timeout, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member OnBeginResumeBookmark : System.Activities.Bookmark * obj * TimeSpan * AsyncCallback * obj -&gt; IAsyncResult" Usage="workflowInstance.OnBeginResumeBookmark (bookmark, value, timeout, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bookmark" Type="System.Activities.Bookmark" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="bookmark">O indicador a ser retomado.</param>
        <param name="value">Os dados a serem passados para a atividade que criou o <see cref="T:System.Activities.Bookmark" />.</param>
        <param name="timeout">O intervalo no qual a operação de retomada deve ser concluída antes que a operação seja cancelada e uma <see cref="T:System.TimeoutException" /> seja gerada.</param>
        <param name="callback">O método a ser chamado quando a operação de retomada for concluída.</param>
        <param name="state">Um objeto específico do aplicativo opcional que contém informações sobre a operação assíncrona.</param>
        <summary>Chamado pelo tempo de execução de fluxo de trabalho para notificar o host de que uma operação de retomada de indicador está começando.</summary>
        <returns>Uma referência à operação de retomada assíncrona.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnDisassociateKeys">
      <MemberSignature Language="C#" Value="protected internal abstract void OnDisassociateKeys (System.Collections.Generic.ICollection&lt;System.Runtime.DurableInstancing.InstanceKey&gt; keys);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnDisassociateKeys(class System.Collections.Generic.ICollection`1&lt;class System.Runtime.DurableInstancing.InstanceKey&gt; keys) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.Hosting.WorkflowInstance.OnDisassociateKeys(System.Collections.Generic.ICollection{System.Runtime.DurableInstancing.InstanceKey})" />
      <MemberSignature Language="VB.NET" Value="Protected Friend MustOverride Sub OnDisassociateKeys (keys As ICollection(Of InstanceKey))" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; abstract void OnDisassociateKeys(System::Collections::Generic::ICollection&lt;System::Runtime::DurableInstancing::InstanceKey ^&gt; ^ keys);" />
      <MemberSignature Language="F#" Value="abstract member OnDisassociateKeys : System.Collections.Generic.ICollection&lt;System.Runtime.DurableInstancing.InstanceKey&gt; -&gt; unit" Usage="workflowInstance.OnDisassociateKeys keys" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Collections.Generic.ICollection&lt;System.Runtime.DurableInstancing.InstanceKey&gt;" />
      </Parameters>
      <Docs>
        <param name="keys">A lista de chaves a serem dissociadas.</param>
        <summary>Chamado pelo tempo de execução de fluxo de trabalho para notificar o host de que um determinado conjunto de chaves de instância não deve mais ser associado a esta instância.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnEndAssociateKeys">
      <MemberSignature Language="C#" Value="protected internal abstract void OnEndAssociateKeys (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnEndAssociateKeys(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.Hosting.WorkflowInstance.OnEndAssociateKeys(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend MustOverride Sub OnEndAssociateKeys (result As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; abstract void OnEndAssociateKeys(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member OnEndAssociateKeys : IAsyncResult -&gt; unit" Usage="workflowInstance.OnEndAssociateKeys result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">A referência à operação de associação de chaves assíncrona.</param>
        <summary>Chamado pelo tempo de execução de fluxo de trabalho para notificar o host de que uma operação de associação de chaves está concluída.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnEndFlushTrackingRecords">
      <MemberSignature Language="C#" Value="protected virtual void OnEndFlushTrackingRecords (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnEndFlushTrackingRecords(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.Hosting.WorkflowInstance.OnEndFlushTrackingRecords(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnEndFlushTrackingRecords (result As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnEndFlushTrackingRecords(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member OnEndFlushTrackingRecords : IAsyncResult -&gt; unit&#xA;override this.OnEndFlushTrackingRecords : IAsyncResult -&gt; unit" Usage="workflowInstance.OnEndFlushTrackingRecords result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">O status da operação de limpeza de registros de acompanhamento assíncrona.</param>
        <summary>Chamado pelo tempo de execução de fluxo de trabalho para notificar o host quando a operação de limpeza de registros de acompanhamento é concluída.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnEndPersist">
      <MemberSignature Language="C#" Value="protected internal abstract void OnEndPersist (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnEndPersist(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.Hosting.WorkflowInstance.OnEndPersist(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend MustOverride Sub OnEndPersist (result As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; abstract void OnEndPersist(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member OnEndPersist : IAsyncResult -&gt; unit" Usage="workflowInstance.OnEndPersist result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">A referência à operação de persistência assíncrona.</param>
        <summary>Chamado pelo tempo de execução de fluxo de trabalho para notificar o host de que uma operação persistência está concluída.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnEndResumeBookmark">
      <MemberSignature Language="C#" Value="protected internal abstract System.Activities.BookmarkResumptionResult OnEndResumeBookmark (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance valuetype System.Activities.BookmarkResumptionResult OnEndResumeBookmark(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.Hosting.WorkflowInstance.OnEndResumeBookmark(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend MustOverride Function OnEndResumeBookmark (result As IAsyncResult) As BookmarkResumptionResult" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; abstract System::Activities::BookmarkResumptionResult OnEndResumeBookmark(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member OnEndResumeBookmark : IAsyncResult -&gt; System.Activities.BookmarkResumptionResult" Usage="workflowInstance.OnEndResumeBookmark result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Activities.BookmarkResumptionResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">A referência à operação de retomada do indicador assíncrona.</param>
        <summary>Chamado pelo tempo de execução de fluxo de trabalho para notificar o host de que uma operação de retomada de indicador está concluída.</summary>
        <returns>Um dos valores de enumeração que indica o resultado de uma operação de retomada de <see cref="T:System.Activities.Bookmark" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnNotifyPaused">
      <MemberSignature Language="C#" Value="protected abstract void OnNotifyPaused ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnNotifyPaused() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.Hosting.WorkflowInstance.OnNotifyPaused" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Sub OnNotifyPaused ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void OnNotifyPaused();" />
      <MemberSignature Language="F#" Value="abstract member OnNotifyPaused : unit -&gt; unit" Usage="workflowInstance.OnNotifyPaused " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Chamado pelo tempo de execução de fluxo de trabalho para notificar o host de que a instância do fluxo de trabalho passou do estado de execução para o estado em pausa.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnNotifyUnhandledException">
      <MemberSignature Language="C#" Value="protected abstract void OnNotifyUnhandledException (Exception exception, System.Activities.Activity source, string sourceInstanceId);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnNotifyUnhandledException(class System.Exception exception, class System.Activities.Activity source, string sourceInstanceId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.Hosting.WorkflowInstance.OnNotifyUnhandledException(System.Exception,System.Activities.Activity,System.String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void OnNotifyUnhandledException(Exception ^ exception, System::Activities::Activity ^ source, System::String ^ sourceInstanceId);" />
      <MemberSignature Language="F#" Value="abstract member OnNotifyUnhandledException : Exception * System.Activities.Activity * string -&gt; unit" Usage="workflowInstance.OnNotifyUnhandledException (exception, source, sourceInstanceId)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="exception" Type="System.Exception" />
        <Parameter Name="source" Type="System.Activities.Activity" />
        <Parameter Name="sourceInstanceId" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="exception">A exceção sem tratamento.</param>
        <param name="source">A atividade que lançou a exceção.</param>
        <param name="sourceInstanceId">O identificador exclusivo do <see cref="T:System.Activities.ActivityInstance" /> que representa a atividade que lançou a exceção.</param>
        <summary>Chamado pelo tempo de execução de fluxo de trabalho para notificar o host de que ocorreu uma exceção sem tratamento na instância do fluxo de trabalho.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnRequestAbort">
      <MemberSignature Language="C#" Value="protected internal abstract void OnRequestAbort (Exception reason);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnRequestAbort(class System.Exception reason) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.Hosting.WorkflowInstance.OnRequestAbort(System.Exception)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend MustOverride Sub OnRequestAbort (reason As Exception)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; abstract void OnRequestAbort(Exception ^ reason);" />
      <MemberSignature Language="F#" Value="abstract member OnRequestAbort : Exception -&gt; unit" Usage="workflowInstance.OnRequestAbort reason" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reason" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="reason">O motivo para anular a instância de fluxo de trabalho.</param>
        <summary>Chamado pelo tempo de execução de fluxo de trabalho para notificar o host de que foi solicitada uma operação de anulação para a instância de fluxo de trabalho.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uma vez <xref:System.Activities.Hosting.WorkflowInstance.OnRequestAbort%2A> é chamado, a maioria <xref:System.Activities.Hosting.WorkflowInstance.WorkflowInstanceControl> APIs exceto <xref:System.Activities.Hosting.WorkflowInstance.WorkflowInstanceControl.Abort%2A> lançará um <xref:System.InvalidOperationException>. Espera-se que, depois <xref:System.Activities.Hosting.WorkflowInstance.OnRequestAbort%2A> é chamado de um host será de tendência em direção a um estado em que ele pode atender a anulação.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterExtensionManager">
      <MemberSignature Language="C#" Value="protected void RegisterExtensionManager (System.Activities.Hosting.WorkflowInstanceExtensionManager extensionManager);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void RegisterExtensionManager(class System.Activities.Hosting.WorkflowInstanceExtensionManager extensionManager) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.Hosting.WorkflowInstance.RegisterExtensionManager(System.Activities.Hosting.WorkflowInstanceExtensionManager)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub RegisterExtensionManager (extensionManager As WorkflowInstanceExtensionManager)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void RegisterExtensionManager(System::Activities::Hosting::WorkflowInstanceExtensionManager ^ extensionManager);" />
      <MemberSignature Language="F#" Value="member this.RegisterExtensionManager : System.Activities.Hosting.WorkflowInstanceExtensionManager -&gt; unit" Usage="workflowInstance.RegisterExtensionManager extensionManager" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="extensionManager" Type="System.Activities.Hosting.WorkflowInstanceExtensionManager" />
      </Parameters>
      <Docs>
        <param name="extensionManager">O gerenciador de extensão a ser registrado.</param>
        <summary>Chamado pelo host para registrar o gerenciador de extensão especificado, validar que todas as extensões necessárias estão presentes e inicializar a coleção de extensões a serem usadas.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Extensões são criptografadas pelo tipo e um host fornecida de extensão sempre será usada se fornecido. Extensões adicionadas por meio de <xref:System.Activities.Hosting.WorkflowInstanceExtensionManager.Add%2A> usar o tipo de tempo de execução do objeto como a chave de tipo. Provedores de extensões adicionadas por meio <xref:System.Activities.Hosting.WorkflowInstanceExtensionManager.Add%2A> usar o tipo decared T de Func\<T > como a chave de tipo. Provedores de extensão contribuídos por atividades através de vários métodos *ActivityMetadata.AddDefaultExtensionProvider serão descartadas se uma extensão do host existe para o tipo declarado ou se há um tipo mais amplo, fornecido por meio de AddDefaultExtensionProvider (por exemplo Se Func\<StreamWriter > é fornecido e Func\<TextWriter > for fornecido, somente Func\<StreamWriter > será mantido). Se uma extensão não existe na coleção que é exigida por uma atividade (expresso chamando * ActivityMetadata.RequireExtension) um <xref:System.Activities.ValidationException> é gerada.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SupportsInstanceKeys">
      <MemberSignature Language="C#" Value="protected internal abstract bool SupportsInstanceKeys { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SupportsInstanceKeys" />
      <MemberSignature Language="DocId" Value="P:System.Activities.Hosting.WorkflowInstance.SupportsInstanceKeys" />
      <MemberSignature Language="VB.NET" Value="Protected Friend MustOverride ReadOnly Property SupportsInstanceKeys As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; abstract property bool SupportsInstanceKeys { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.SupportsInstanceKeys : bool" Usage="System.Activities.Hosting.WorkflowInstance.SupportsInstanceKeys" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o host dá suporte à associação de <see cref="P:System.Runtime.DurableInstancing.InstanceView.InstanceKeys" /> a uma instância de tempo de execução.</summary>
        <value><see langword="true" /> Se o host oferece suporte a associação de <see cref="P:System.Runtime.DurableInstancing.InstanceView.InstanceKeys" /> com uma instância de fluxo de trabalho; caso contrário, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SynchronizationContext">
      <MemberSignature Language="C#" Value="public System.Threading.SynchronizationContext SynchronizationContext { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Threading.SynchronizationContext SynchronizationContext" />
      <MemberSignature Language="DocId" Value="P:System.Activities.Hosting.WorkflowInstance.SynchronizationContext" />
      <MemberSignature Language="VB.NET" Value="Public Property SynchronizationContext As SynchronizationContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::SynchronizationContext ^ SynchronizationContext { System::Threading::SynchronizationContext ^ get(); void set(System::Threading::SynchronizationContext ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SynchronizationContext : System.Threading.SynchronizationContext with get, set" Usage="System.Activities.Hosting.WorkflowInstance.SynchronizationContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.SynchronizationContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o <see cref="T:System.Threading.SynchronizationContext" /> usado para agendar a instância de fluxo de trabalho.</summary>
        <value>O contexto de sincronização usado para agendar a instância de fluxo de trabalho.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se essa propriedade é definida depois que a instância de fluxo de trabalho é inicializada e <xref:System.Activities.Hosting.WorkflowInstance.IsReadOnly%2A> retorna `true`, um <xref:System.InvalidOperationException> é gerada.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ThrowIfReadOnly">
      <MemberSignature Language="C#" Value="protected void ThrowIfReadOnly ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ThrowIfReadOnly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.Hosting.WorkflowInstance.ThrowIfReadOnly" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ThrowIfReadOnly ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ThrowIfReadOnly();" />
      <MemberSignature Language="F#" Value="member this.ThrowIfReadOnly : unit -&gt; unit" Usage="workflowInstance.ThrowIfReadOnly " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gera um <see cref="T:System.InvalidOperationException" /> se a instância de fluxo de trabalho foi inicializada, conforme determinado por <see cref="P:System.Activities.Hosting.WorkflowInstance.IsReadOnly" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se <xref:System.Activities.Hosting.WorkflowInstance.IsReadOnly%2A> retorna `true`, então um <xref:System.InvalidOperationException> é gerada.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WorkflowDefinition">
      <MemberSignature Language="C#" Value="public System.Activities.Activity WorkflowDefinition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Activities.Activity WorkflowDefinition" />
      <MemberSignature Language="DocId" Value="P:System.Activities.Hosting.WorkflowInstance.WorkflowDefinition" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WorkflowDefinition As Activity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Activities::Activity ^ WorkflowDefinition { System::Activities::Activity ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.WorkflowDefinition : System.Activities.Activity" Usage="System.Activities.Hosting.WorkflowInstance.WorkflowDefinition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Activities.Activity</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém a definição de fluxo de trabalho da instância de fluxo de trabalho.</summary>
        <value>A definição de fluxo de trabalho da instância do fluxo de trabalho.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>