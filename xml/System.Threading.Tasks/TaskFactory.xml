<Type Name="TaskFactory" FullName="System.Threading.Tasks.TaskFactory">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="84c9e628662a23559efb05ea15ab3842669fa340" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="pt-BR" />
    <Meta Name="ms.lasthandoff" Value="08/24/2018" />
    <Meta Name="ms.locfileid" Value="36408261" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class TaskFactory" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit TaskFactory extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Tasks.TaskFactory" />
  <TypeSignature Language="VB.NET" Value="Public Class TaskFactory" />
  <TypeSignature Language="C++ CLI" Value="public ref class TaskFactory" />
  <TypeSignature Language="F#" Value="type TaskFactory = class" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Tasks</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Fornece suporte para criação e agendamento de objetos <see cref="T:System.Threading.Tasks.Task" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O .NET Framework fornece duas fábricas para criar e agendar tarefas:  
  
-   O <xref:System.Threading.Tasks.TaskFactory> classe, que cria <xref:System.Threading.Tasks.Task> e <xref:System.Threading.Tasks.Task%601> objetos. Você pode chamar as sobrecargas desse método para criar e executar uma tarefa que requer argumentos não padrão.  
  
    > [!WARNING]
    >  Começando com o [!INCLUDE[net_v45](~/includes/net-v45-md.md)], o <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> método fornece a maneira mais fácil de criar uma tarefa padrão valores de configuração e inicie-o imediatamente.  
  
-   O <xref:System.Threading.Tasks.TaskFactory%601> classe, que cria <xref:System.Threading.Tasks.Task%601> objetos.  
  
 O <xref:System.Threading.Tasks.TaskFactory> classe permite que você faça o seguinte:  
  
-   Criar uma tarefa e iniciá-lo imediatamente, chamando o <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> método.  
  
    > [!WARNING]
    >  Começando com o [!INCLUDE[net_v45](~/includes/net-v45-md.md)], o <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> método fornece a maneira mais fácil de criar uma tarefa padrão valores de configuração e inicie-o imediatamente.  
  
-   Criar uma tarefa que começa quando qualquer uma das tarefas em uma matriz é concluído chamando o <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAny%2A> método.  
  
-   Criar uma tarefa que é iniciado quando todas as tarefas em uma matriz concluiu chamando o <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A> método.  
  
 Estático <xref:System.Threading.Tasks.Task%601.Factory%2A?displayProperty=nameWithType> propriedade retorna um padrão <xref:System.Threading.Tasks.TaskFactory%601> objeto. Você também pode chamar um dos <xref:System.Threading.Tasks.TaskFactory> classe construtores para configurar o <xref:System.Threading.Tasks.Task> objetos que o <xref:System.Threading.Tasks.TaskFactory> classe cria. O exemplo a seguir configura um novo <xref:System.Threading.Tasks.TaskFactory> objeto para criar tarefas que têm um token de cancelamento especificado, as opções de criação de tarefa, opções de continuação e um agendador de tarefas personalizado.  
  
 [!code-csharp[TPL_Factories#1](~/samples/snippets/csharp/VS_Snippets_Misc/tpl_factories/cs/program.cs#1)]
 [!code-vb[TPL_Factories#1](~/samples/snippets/visualbasic/VS_Snippets_Misc/tpl_factories/vb/factories_vb.vb#1)]  
  
 Na maioria dos casos, você não precisa criar um novo <xref:System.Threading.Tasks.TaskFactory> instância. Em vez disso, você pode usar o <xref:System.Threading.Tasks.Task.Factory%2A?displayProperty=nameWithType> propriedade, que retorna um objeto de fábrica que usa valores padrão. Em seguida, você pode chamar seus métodos para iniciar novas tarefas ou definir continuações de tarefa. Para obter uma ilustração, consulte o exemplo.  
  
   
  
## Examples  
 O exemplo a seguir usa estático <xref:System.Threading.Tasks.Task.Factory%2A> propriedade para fazer duas chamadas para o <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> método. A primeira preenche uma matriz com os nomes dos arquivos no diretório de Meus documentos do usuário, enquanto o segundo preenche uma matriz com os nomes dos subdiretórios do diretório MyDocuments do usuário. Em seguida, ele chama o <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%28System.Threading.Tasks.Task%5B%5D%2CSystem.Action%7BSystem.Threading.Tasks.Task%5B%5D%7D%29?displayProperty=nameWithType> método, que exibe informações sobre o número de arquivos e diretórios em duas matrizes depois que as duas primeiras tarefas sejam completadas.  
  
 [!code-csharp[System.Threading.Tasks.Task.Factory#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.factory/cs/factory1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Factory#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.factory/vb/factory1.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Todos os membros públicos e protegidos da <see cref="T:System.Threading.Tasks.TaskFactory" /> são thread-safe e podem ser usados simultaneamente de vários threads.</threadsafe>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Threading.Tasks.TaskFactory" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TaskFactory ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TaskFactory();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa uma instância de <see cref="T:System.Threading.Tasks.TaskFactory" /> com a configuração padrão.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este construtor cria um <xref:System.Threading.Tasks.TaskFactory> instância com uma configuração padrão. O <xref:System.Threading.Tasks.TaskCreationOptions> propriedade é inicializada para <xref:System.Threading.Tasks.TaskCreationOptions.None>, o <xref:System.Threading.Tasks.TaskContinuationOptions> propriedade é inicializada para <xref:System.Threading.Tasks.TaskContinuationOptions.None>e o <xref:System.Threading.Tasks.TaskScheduler> propriedade é inicializada para o Agendador atual (consulte <xref:System.Threading.Tasks.TaskScheduler.Current%2A>).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TaskFactory (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.#ctor(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TaskFactory(System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.TaskFactory : System.Threading.CancellationToken -&gt; System.Threading.Tasks.TaskFactory" Usage="new System.Threading.Tasks.TaskFactory cancellationToken" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">O <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> que será atribuído às tarefas criadas por este <see cref="T:System.Threading.Tasks.TaskFactory" />, a menos que outro CancellationToken seja especificado explicitamente ao chamar os métodos de fábrica.</param>
        <summary>Inicializa uma instância <see cref="T:System.Threading.Tasks.TaskFactory" /> com a configuração especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este construtor cria um <xref:System.Threading.Tasks.TaskFactory> instância com uma configuração padrão. O <xref:System.Threading.Tasks.TaskCreationOptions> propriedade é inicializada para <xref:System.Threading.Tasks.TaskCreationOptions.None>, o <xref:System.Threading.Tasks.TaskContinuationOptions> propriedade é inicializada para <xref:System.Threading.Tasks.TaskContinuationOptions.None>e o <xref:System.Threading.Tasks.TaskScheduler> propriedade é inicializada para o Agendador atual (consulte <xref:System.Threading.Tasks.TaskScheduler.Current%2A>).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TaskFactory (System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.#ctor(System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (scheduler As TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TaskFactory(System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.TaskFactory : System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.TaskFactory" Usage="new System.Threading.Tasks.TaskFactory scheduler" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="scheduler">O <see cref="T:System.Threading.Tasks.TaskScheduler" /> a ser usado para agendar tarefas criadas com esse TaskFactory. Um valor nulo indica que o TaskScheduler atual deve ser usado.</param>
        <summary>Inicializa uma instância <see cref="T:System.Threading.Tasks.TaskFactory" /> com a configuração especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Com esse construtor, o <xref:System.Threading.Tasks.TaskCreationOptions> propriedade é inicializada para <xref:System.Threading.Tasks.TaskCreationOptions.None>, o <xref:System.Threading.Tasks.TaskContinuationOptions> propriedade é inicializada para <xref:System.Threading.Tasks.TaskContinuationOptions.None>e o <xref:System.Threading.Tasks.TaskScheduler> propriedade é inicializada para `scheduler`, a menos que ele for nulo, caso em que o propriedade é inicializada para o Agendador atual (consulte <xref:System.Threading.Tasks.TaskScheduler.Current%2A>).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TaskFactory (System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Threading.Tasks.TaskCreationOptions creationOptions, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.#ctor(System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (creationOptions As TaskCreationOptions, continuationOptions As TaskContinuationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TaskFactory(System::Threading::Tasks::TaskCreationOptions creationOptions, System::Threading::Tasks::TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.TaskFactory : System.Threading.Tasks.TaskCreationOptions * System.Threading.Tasks.TaskContinuationOptions -&gt; System.Threading.Tasks.TaskFactory" Usage="new System.Threading.Tasks.TaskFactory (creationOptions, continuationOptions)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <param name="creationOptions">O <see cref="T:System.Threading.Tasks.TaskCreationOptions" /> padrão a ser usado ao criar tarefas com essa TaskFactory.</param>
        <param name="continuationOptions">O <see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> padrão a ser usado ao criar tarefas de continuação com essa TaskFactory.</param>
        <summary>Inicializa uma instância <see cref="T:System.Threading.Tasks.TaskFactory" /> com a configuração especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Com esse construtor, o <xref:System.Threading.Tasks.TaskCreationOptions> propriedade é inicializada para `creationOptions`, o <xref:System.Threading.Tasks.TaskContinuationOptions> propriedade é inicializada para `continuationOptions`e o <xref:System.Threading.Tasks.TaskScheduler> propriedade é inicializada para o Agendador atual (consulte <xref:System.Threading.Tasks.TaskScheduler.Current%2A>).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">O argumento <paramref name="creationOptions" /> especifica um valor <see cref="T:System.Threading.Tasks.TaskCreationOptions" /> inválido. Para obter mais informações, consulte os Comentários sobre <see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" />.  
  
- ou - 
O argumento <paramref name="continuationOptions" /> especifica um valor inválido.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TaskFactory (System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.#ctor(System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TaskFactory(System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskCreationOptions creationOptions, System::Threading::Tasks::TaskContinuationOptions continuationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.TaskFactory : System.Threading.CancellationToken * System.Threading.Tasks.TaskCreationOptions * System.Threading.Tasks.TaskContinuationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.TaskFactory" Usage="new System.Threading.Tasks.TaskFactory (cancellationToken, creationOptions, continuationOptions, scheduler)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">O padrão <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> que serão atribuídos às tarefas criadas por este <see cref="T:System.Threading.Tasks.TaskFactory" />, a menos que outro CancellationToken seja especificado explicitamente ao chamar os métodos de fábrica.</param>
        <param name="creationOptions">O <see cref="T:System.Threading.Tasks.TaskCreationOptions" /> padrão a ser usado ao criar tarefas com essa TaskFactory.</param>
        <param name="continuationOptions">O <see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> padrão a ser usado ao criar tarefas de continuação com essa TaskFactory.</param>
        <param name="scheduler">O <see cref="T:System.Threading.Tasks.TaskScheduler" /> padrão a ser usado para agendar as Tasks criadas com esta TaskFactory. Um valor nulo indica que o TaskScheduler.Current deve ser usado.</param>
        <summary>Inicializa uma instância <see cref="T:System.Threading.Tasks.TaskFactory" /> com a configuração especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Com esse construtor, o <xref:System.Threading.Tasks.TaskCreationOptions> propriedade é inicializada para `creationOptions`, o <xref:System.Threading.Tasks.TaskContinuationOptions> propriedade é inicializada para `continuationOptions`e o <xref:System.Threading.Tasks.TaskScheduler> propriedade é inicializada para `scheduler`, a menos que ele for nulo, caso em que o propriedade é inicializada para o Agendador atual (consulte <xref:System.Threading.Tasks.TaskScheduler.Current%2A>).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">O argumento <paramref name="creationOptions" /> especifica um valor <see cref="T:System.Threading.Tasks.TaskCreationOptions" /> inválido. Para obter mais informações, consulte os Comentários sobre <see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" />.  
  
- ou - 
O argumento <paramref name="continuationOptions" /> especifica um valor inválido.</exception>
      </Docs>
    </Member>
    <Member MemberName="CancellationToken">
      <MemberSignature Language="C#" Value="public System.Threading.CancellationToken CancellationToken { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.CancellationToken CancellationToken" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskFactory.CancellationToken" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CancellationToken As CancellationToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::CancellationToken CancellationToken { System::Threading::CancellationToken get(); };" />
      <MemberSignature Language="F#" Value="member this.CancellationToken : System.Threading.CancellationToken" Usage="System.Threading.Tasks.TaskFactory.CancellationToken" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.CancellationToken</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o token de cancelamento padrão desta fábrica de tarefas.</summary>
        <value>O token de cancelamento de tarefas padrão desta fábrica de tarefas.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa propriedade retorna o padrão <xref:System.Threading.CancellationToken> que será atribuído a todas as tarefas criadas por essa fábrica, a menos que outro <xref:System.Threading.CancellationToken> valor for especificado explicitamente durante a chamada para os métodos de fábrica.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContinuationOptions">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.TaskContinuationOptions ContinuationOptions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.Tasks.TaskContinuationOptions ContinuationOptions" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskFactory.ContinuationOptions" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ContinuationOptions As TaskContinuationOptions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::Tasks::TaskContinuationOptions ContinuationOptions { System::Threading::Tasks::TaskContinuationOptions get(); };" />
      <MemberSignature Language="F#" Value="member this.ContinuationOptions : System.Threading.Tasks.TaskContinuationOptions" Usage="System.Threading.Tasks.TaskFactory.ContinuationOptions" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskContinuationOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém as opções de continuação de tarefas padrão dessa fábrica de tarefas.</summary>
        <value>As opções de continuação de tarefas padrão dessa fábrica de tarefas.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor da propriedade é usado para criar todas as tarefas de continuação, a menos que outras opções são especificadas explicitamente durante as chamadas para métodos dessa fábrica.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ContinueWhenAll">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Cria uma tarefa de continuação que começa quando um conjunto de tarefas especificadas foi concluído.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ContinueWhenAll">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWhenAll (System.Threading.Tasks.Task[] tasks, Action&lt;System.Threading.Tasks.Task[]&gt; continuationAction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWhenAll(class System.Threading.Tasks.Task[] tasks, class System.Action`1&lt;class System.Threading.Tasks.Task[]&gt; continuationAction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll(System.Threading.Tasks.Task[],System.Action{System.Threading.Tasks.Task[]})" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWhenAll (tasks As Task(), continuationAction As Action(Of Task())) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWhenAll(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, Action&lt;cli::array &lt;System::Threading::Tasks::Task ^&gt; ^&gt; ^ continuationAction);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAll : System.Threading.Tasks.Task[] * Action&lt;System.Threading.Tasks.Task[]&gt; -&gt; System.Threading.Tasks.Task" Usage="taskFactory.ContinueWhenAll (tasks, continuationAction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task[]&gt;" />
      </Parameters>
      <Docs>
        <param name="tasks">A matriz de tarefas da qual continuar.</param>
        <param name="continuationAction">O representante de ação a ser executado quando todas as tarefas na matriz <c>tasks</c> forem concluídas.</param>
        <summary>Cria uma tarefa de continuação que começa quando um conjunto de tarefas especificadas foi concluído.</summary>
        <returns>A nova tarefa de continuação.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A> método executa o `continuationAction` delegado quando todas as tarefas no `tasks` matriz tiver concluído, independentemente de seu status de conclusão.  
  
 As exceções geradas por tarefas no `tasks` matriz não estão disponíveis para a tarefa de continuação por meio de manipulação de exceção estruturada. Você pode determinar quais exceções foram lançadas, examinando os <xref:System.Threading.Tasks.Task.Exception%2A?displayProperty=nameWithType> propriedade de cada tarefa no `tasks` matriz. Para usar a estruturadas tratamento de exceções para manipular exceções lançadas por tarefas na `tasks` matriz, chame o <xref:System.Threading.Tasks.Task.WaitAll%28System.Threading.Tasks.Task%5B%5D%29?displayProperty=nameWithType> método.  
  
   
  
## Examples  
 O exemplo a seguir inicia tarefas separadas que usam uma expressão regular para contar o número de palavras em um conjunto de arquivos de texto. O <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A> método é usado para iniciar uma tarefa que exibe a contagem total de palavras quando todas as tarefas antecessoras forem concluídas.  
  
 [!code-csharp[System.Threading.Tasks.Task.ContinueWhenAll#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.continuewhenall/cs/continuewhenall1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.ContinueWhenAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.continuewhenall/vb/continuewhenall1.vb#1)]  
  
 A chamada para a tarefa de continuação <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> método não permitem manipular exceções lançadas por tarefas antecedentes, portanto, o exemplo examina a <xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType> propriedade de cada tarefa antecedente para determinar se a tarefa foi bem-sucedida.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Um elemento na matriz do <paramref name="tasks" /> foi descartado.</exception>
        <exception cref="T:System.ArgumentNullException">A matriz do <paramref name="tasks" /> é <see langword="null" />.  
  
- ou - 
O argumento <paramref name="continuationAction" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">A matriz do <paramref name="tasks" /> está vazia ou contém um valor nulo.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAll">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWhenAll (System.Threading.Tasks.Task[] tasks, Action&lt;System.Threading.Tasks.Task[]&gt; continuationAction, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWhenAll(class System.Threading.Tasks.Task[] tasks, class System.Action`1&lt;class System.Threading.Tasks.Task[]&gt; continuationAction, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll(System.Threading.Tasks.Task[],System.Action{System.Threading.Tasks.Task[]},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWhenAll(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, Action&lt;cli::array &lt;System::Threading::Tasks::Task ^&gt; ^&gt; ^ continuationAction, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAll : System.Threading.Tasks.Task[] * Action&lt;System.Threading.Tasks.Task[]&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="taskFactory.ContinueWhenAll (tasks, continuationAction, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task[]&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="tasks">A matriz de tarefas da qual continuar.</param>
        <param name="continuationAction">O representante de ação a ser executado quando todas as tarefas na matriz <c>tasks</c> forem concluídas.</param>
        <param name="cancellationToken">O token de cancelamento a ser atribuído à nova tarefa de continuação.</param>
        <summary>Cria uma tarefa de continuação que começa quando um conjunto de tarefas especificadas foi concluído.</summary>
        <returns>A nova tarefa de continuação.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O [\], ação (tarefa\<xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%28System.Threading.Tasks.Task%5B%5D%2CSystem.Action%7BSystem.Threading.Tasks.Task%5B%5D%7D% 2CSystem.Threading.CancellationToken%29 > método executa o `continuationAction` delegado quando todas as tarefas no `tasks` matriz tiver concluído, independentemente de seu status de conclusão.  
  
   
  
## Examples  
 O exemplo a seguir cria um token de cancelamento, ele passa para separar as tarefas que usam uma expressão regular para contar o número de palavras em um conjunto de arquivos de texto. O token de cancelamento será definido se um arquivo não pode ser encontrado. O [\], ação (tarefa\<XRef:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A > método é usado para iniciar uma tarefa que exibe a contagem total de palavras quando todas as tarefas antecessoras forem concluídas. Se o token de cancelamento for definido, que indica que uma ou mais tarefas tiverem sido canceladas, ele trata a <xref:System.AggregateException> exceção e exibe uma mensagem de erro.  
  
 [!code-csharp[System.Threading.Tasks.Task.ContinueWhenAll#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.continuewhenall/cs/continuewhenall2.cs#2)]
 [!code-vb[System.Threading.Tasks.Task.ContinueWhenAll#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.continuewhenall/vb/continuewhenall2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Um elemento na matriz do <paramref name="tasks" /> foi descartado.  
  
- ou - 
O <see cref="T:System.Threading.CancellationTokenSource" /> que criou <paramref name="cancellationToken" /> já foi descartado.</exception>
        <exception cref="T:System.ArgumentNullException">A matriz do <paramref name="tasks" /> é <see langword="null" />.  
  
- ou - 
O argumento <paramref name="continuationAction" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">A matriz do <paramref name="tasks" /> está vazia ou contém um valor nulo.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAll">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWhenAll (System.Threading.Tasks.Task[] tasks, Action&lt;System.Threading.Tasks.Task[]&gt; continuationAction, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWhenAll(class System.Threading.Tasks.Task[] tasks, class System.Action`1&lt;class System.Threading.Tasks.Task[]&gt; continuationAction, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll(System.Threading.Tasks.Task[],System.Action{System.Threading.Tasks.Task[]},System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWhenAll (tasks As Task(), continuationAction As Action(Of Task()), continuationOptions As TaskContinuationOptions) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWhenAll(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, Action&lt;cli::array &lt;System::Threading::Tasks::Task ^&gt; ^&gt; ^ continuationAction, System::Threading::Tasks::TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAll : System.Threading.Tasks.Task[] * Action&lt;System.Threading.Tasks.Task[]&gt; * System.Threading.Tasks.TaskContinuationOptions -&gt; System.Threading.Tasks.Task" Usage="taskFactory.ContinueWhenAll (tasks, continuationAction, continuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task[]&gt;" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <param name="tasks">A matriz de tarefas da qual continuar.</param>
        <param name="continuationAction">O representante de ação a ser executado quando todas as tarefas na matriz <c>tasks</c> forem concluídas.</param>
        <param name="continuationOptions">Uma combinação bit a bit dos valores de enumeração que controlam o comportamento da nova tarefa de continuação. Não há suporte para os membros NotOn* e OnlyOn*.</param>
        <summary>Cria uma tarefa de continuação que começa quando um conjunto de tarefas especificadas foi concluído.</summary>
        <returns>A nova tarefa de continuação.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Um elemento na matriz do <paramref name="tasks" /> foi descartado.</exception>
        <exception cref="T:System.ArgumentNullException">A matriz do <paramref name="tasks" /> é <see langword="null" />.  
  
- ou - 
O argumento <paramref name="continuationAction" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">O argumento <paramref name="continuationOptions" /> especifica um valor inválido.</exception>
        <exception cref="T:System.ArgumentException">A matriz do <paramref name="tasks" /> está vazia ou contém um valor nulo.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAll">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWhenAll (System.Threading.Tasks.Task[] tasks, Action&lt;System.Threading.Tasks.Task[]&gt; continuationAction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWhenAll(class System.Threading.Tasks.Task[] tasks, class System.Action`1&lt;class System.Threading.Tasks.Task[]&gt; continuationAction, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll(System.Threading.Tasks.Task[],System.Action{System.Threading.Tasks.Task[]},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWhenAll(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, Action&lt;cli::array &lt;System::Threading::Tasks::Task ^&gt; ^&gt; ^ continuationAction, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskContinuationOptions continuationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAll : System.Threading.Tasks.Task[] * Action&lt;System.Threading.Tasks.Task[]&gt; * System.Threading.CancellationToken * System.Threading.Tasks.TaskContinuationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task" Usage="taskFactory.ContinueWhenAll (tasks, continuationAction, cancellationToken, continuationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task[]&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="tasks">A matriz de tarefas da qual continuar.</param>
        <param name="continuationAction">O representante de ação a ser executado quando todas as tarefas na matriz <c>tasks</c> forem concluídas.</param>
        <param name="cancellationToken">O token de cancelamento a ser atribuído à nova tarefa de continuação.</param>
        <param name="continuationOptions">Uma combinação bit a bit dos valores de enumeração que controlam o comportamento da nova tarefa de continuação.</param>
        <param name="scheduler">O objeto que é usado para agendar a nova tarefa de continuação.</param>
        <summary>Cria uma tarefa de continuação que começa quando um conjunto de tarefas especificadas foi concluído.</summary>
        <returns>A nova tarefa de continuação.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">A matriz do <paramref name="tasks" /> é <see langword="null" />.  
  
- ou - 
O argumento <paramref name="continuationAction" /> é <see langword="null" />.  
  
- ou - 
O argumento <paramref name="scheduler" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">A matriz do <paramref name="tasks" /> está vazia ou contém um valor nulo.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAll&lt;TAntecedentResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWhenAll&lt;TAntecedentResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Action&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]&gt; continuationAction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWhenAll&lt;TAntecedentResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Action`1&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[]&gt; continuationAction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``1(System.Threading.Tasks.Task{``0}[],System.Action{System.Threading.Tasks.Task{``0}[]})" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWhenAll(Of TAntecedentResult) (tasks As Task(Of TAntecedentResult)(), continuationAction As Action(Of Task(Of TAntecedentResult)())) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TAntecedentResult&gt;&#xA; System::Threading::Tasks::Task ^ ContinueWhenAll(cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^ tasks, Action&lt;cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^&gt; ^ continuationAction);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAll : System.Threading.Tasks.Task&lt;'AntecedentResult&gt;[] * Action&lt;System.Threading.Tasks.Task&lt;'AntecedentResult&gt;[]&gt; -&gt; System.Threading.Tasks.Task" Usage="taskFactory.ContinueWhenAll (tasks, continuationAction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">O tipo do resultado da antecessora <c>tarefas</c>.</typeparam>
        <param name="tasks">A matriz de tarefas da qual continuar.</param>
        <param name="continuationAction">O representante de ação a ser executado quando todas as tarefas na matriz <c>tasks</c> forem concluídas.</param>
        <summary>Cria uma tarefa de continuação que começa quando um conjunto de tarefas especificadas foi concluído.</summary>
        <returns>A nova tarefa de continuação.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Um elemento na matriz do <paramref name="tasks" /> foi descartado.</exception>
        <exception cref="T:System.ArgumentNullException">A matriz do <paramref name="tasks" /> é <see langword="null" />.  
  
- ou - 
O argumento <paramref name="continuationAction" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">A matriz do <paramref name="tasks" /> está vazia ou contém um valor nulo.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAll&lt;TAntecedentResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWhenAll&lt;TAntecedentResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Action&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]&gt; continuationAction, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWhenAll&lt;TAntecedentResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Action`1&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[]&gt; continuationAction, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``1(System.Threading.Tasks.Task{``0}[],System.Action{System.Threading.Tasks.Task{``0}[]},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TAntecedentResult&gt;&#xA; System::Threading::Tasks::Task ^ ContinueWhenAll(cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^ tasks, Action&lt;cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^&gt; ^ continuationAction, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAll : System.Threading.Tasks.Task&lt;'AntecedentResult&gt;[] * Action&lt;System.Threading.Tasks.Task&lt;'AntecedentResult&gt;[]&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="taskFactory.ContinueWhenAll (tasks, continuationAction, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">O tipo do resultado da antecessora <c>tarefas</c>.</typeparam>
        <param name="tasks">A matriz de tarefas da qual continuar.</param>
        <param name="continuationAction">O representante de ação a ser executado quando todas as tarefas na matriz <c>tasks</c> forem concluídas.</param>
        <param name="cancellationToken">O token de cancelamento a ser atribuído à nova tarefa de continuação.</param>
        <summary>Cria uma tarefa de continuação que começa quando um conjunto de tarefas especificadas foi concluído.</summary>
        <returns>A nova tarefa de continuação.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Um elemento na matriz do <paramref name="tasks" /> foi descartado.  
  
- ou - 
O <see cref="T:System.Threading.CancellationTokenSource" /> que criou <paramref name="cancellationToken" /> já foi descartado.</exception>
        <exception cref="T:System.ArgumentNullException">A matriz do <paramref name="tasks" /> é <see langword="null" />.  
  
- ou - 
O argumento <paramref name="continuationAction" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">A matriz do <paramref name="tasks" /> está vazia ou contém um valor nulo.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAll&lt;TAntecedentResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWhenAll&lt;TAntecedentResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Action&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]&gt; continuationAction, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWhenAll&lt;TAntecedentResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Action`1&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[]&gt; continuationAction, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``1(System.Threading.Tasks.Task{``0}[],System.Action{System.Threading.Tasks.Task{``0}[]},System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWhenAll(Of TAntecedentResult) (tasks As Task(Of TAntecedentResult)(), continuationAction As Action(Of Task(Of TAntecedentResult)()), continuationOptions As TaskContinuationOptions) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TAntecedentResult&gt;&#xA; System::Threading::Tasks::Task ^ ContinueWhenAll(cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^ tasks, Action&lt;cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^&gt; ^ continuationAction, System::Threading::Tasks::TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAll : System.Threading.Tasks.Task&lt;'AntecedentResult&gt;[] * Action&lt;System.Threading.Tasks.Task&lt;'AntecedentResult&gt;[]&gt; * System.Threading.Tasks.TaskContinuationOptions -&gt; System.Threading.Tasks.Task" Usage="taskFactory.ContinueWhenAll (tasks, continuationAction, continuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]&gt;" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">O tipo do resultado da antecessora <c>tarefas</c>.</typeparam>
        <param name="tasks">A matriz de tarefas da qual continuar.</param>
        <param name="continuationAction">O representante de ação a ser executado quando todas as tarefas na matriz <c>tasks</c> forem concluídas.</param>
        <param name="continuationOptions">Uma combinação bit a bit dos valores de enumeração que controlam o comportamento da nova tarefa de continuação. Não há suporte para os membros NotOn* e OnlyOn*.</param>
        <summary>Cria uma tarefa de continuação que começa quando um conjunto de tarefas especificadas foi concluído.</summary>
        <returns>A nova tarefa de continuação.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Um elemento na matriz do <paramref name="tasks" /> foi descartado.</exception>
        <exception cref="T:System.ArgumentNullException">A matriz do <paramref name="tasks" /> é <see langword="null" />.  
  
- ou - 
O argumento <paramref name="continuationAction" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">O argumento <paramref name="continuationOptions" /> especifica um valor inválido.</exception>
        <exception cref="T:System.ArgumentException">A matriz do <paramref name="tasks" /> está vazia ou contém um valor nulo.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAll&lt;TAntecedentResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWhenAll&lt;TAntecedentResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Action&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]&gt; continuationAction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWhenAll&lt;TAntecedentResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Action`1&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[]&gt; continuationAction, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``1(System.Threading.Tasks.Task{``0}[],System.Action{System.Threading.Tasks.Task{``0}[]},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TAntecedentResult&gt;&#xA; System::Threading::Tasks::Task ^ ContinueWhenAll(cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^ tasks, Action&lt;cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^&gt; ^ continuationAction, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskContinuationOptions continuationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAll : System.Threading.Tasks.Task&lt;'AntecedentResult&gt;[] * Action&lt;System.Threading.Tasks.Task&lt;'AntecedentResult&gt;[]&gt; * System.Threading.CancellationToken * System.Threading.Tasks.TaskContinuationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task" Usage="taskFactory.ContinueWhenAll (tasks, continuationAction, cancellationToken, continuationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">O tipo do resultado da antecessora <c>tarefas</c>.</typeparam>
        <param name="tasks">A matriz de tarefas da qual continuar.</param>
        <param name="continuationAction">O representante de ação a ser executado quando todas as tarefas na matriz <c>tasks</c> forem concluídas.</param>
        <param name="cancellationToken">O token de cancelamento a ser atribuído à nova tarefa de continuação.</param>
        <param name="continuationOptions">Uma combinação bit a bit dos valores de enumeração que controlam o comportamento da nova tarefa de continuação. Não há suporte para os membros NotOn* e OnlyOn*.</param>
        <param name="scheduler">O objeto que é usado para agendar a nova tarefa de continuação.</param>
        <summary>Cria uma tarefa de continuação que começa quando um conjunto de tarefas especificadas foi concluído.</summary>
        <returns>A nova tarefa de continuação.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">A matriz do <paramref name="tasks" /> é <see langword="null" />.  
  
- ou - 
O argumento <paramref name="continuationAction" /> é <see langword="null" />.  
  
- ou - 
O argumento <paramref name="scheduler" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">A matriz do <paramref name="tasks" /> está vazia ou contém um valor nulo.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAll&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAll&lt;TResult&gt; (System.Threading.Tasks.Task[] tasks, Func&lt;System.Threading.Tasks.Task[],TResult&gt; continuationFunction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWhenAll&lt;TResult&gt;(class System.Threading.Tasks.Task[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task[], !!TResult&gt; continuationFunction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``1(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task[],``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWhenAll(Of TResult) (tasks As Task(), continuationFunction As Func(Of Task(), TResult)) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWhenAll(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, Func&lt;cli::array &lt;System::Threading::Tasks::Task ^&gt; ^, TResult&gt; ^ continuationFunction);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAll : System.Threading.Tasks.Task[] * Func&lt;System.Threading.Tasks.Task[], 'Result&gt; -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.ContinueWhenAll (tasks, continuationFunction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task[],TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">O tipo de resultado retornado pela <c>continuationFunction</c> delegar e associado com a tarefa criada.</typeparam>
        <param name="tasks">A matriz de tarefas da qual continuar.</param>
        <param name="continuationFunction">O representante de função a ser executado de forma assíncrona quando todas as tarefas na matriz <c>tasks</c> forem concluídas.</param>
        <summary>Cria uma tarefa de continuação que começa quando um conjunto de tarefas especificadas foi concluído.</summary>
        <returns>A nova tarefa de continuação.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Um elemento na matriz do <paramref name="tasks" /> foi descartado.</exception>
        <exception cref="T:System.ArgumentNullException">A matriz do <paramref name="tasks" /> é <see langword="null" />.  
  
- ou - 
O argumento <paramref name="continuationFunction" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">A matriz do <paramref name="tasks" /> está vazia ou contém um valor nulo.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAll&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAll&lt;TResult&gt; (System.Threading.Tasks.Task[] tasks, Func&lt;System.Threading.Tasks.Task[],TResult&gt; continuationFunction, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWhenAll&lt;TResult&gt;(class System.Threading.Tasks.Task[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task[], !!TResult&gt; continuationFunction, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``1(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task[],``0},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWhenAll(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, Func&lt;cli::array &lt;System::Threading::Tasks::Task ^&gt; ^, TResult&gt; ^ continuationFunction, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAll : System.Threading.Tasks.Task[] * Func&lt;System.Threading.Tasks.Task[], 'Result&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.ContinueWhenAll (tasks, continuationFunction, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task[],TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">O tipo de resultado retornado pela <c>continuationFunction</c> delegar e associado com a tarefa criada.</typeparam>
        <param name="tasks">A matriz de tarefas da qual continuar.</param>
        <param name="continuationFunction">O representante de função a ser executado de forma assíncrona quando todas as tarefas na matriz <c>tasks</c> forem concluídas.</param>
        <param name="cancellationToken">O token de cancelamento a ser atribuído à nova tarefa de continuação.</param>
        <summary>Cria uma tarefa de continuação que começa quando um conjunto de tarefas especificadas foi concluído.</summary>
        <returns>A nova tarefa de continuação.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Um elemento na matriz do <paramref name="tasks" /> foi descartado.  
  
- ou - 
O <see cref="T:System.Threading.CancellationTokenSource" /> que criou <paramref name="cancellationToken" /> já foi descartado.</exception>
        <exception cref="T:System.ArgumentNullException">A matriz do <paramref name="tasks" /> é <see langword="null" />.  
  
- ou - 
O argumento <paramref name="continuationFunction" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">A matriz do <paramref name="tasks" /> está vazia ou contém um valor nulo.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAll&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAll&lt;TResult&gt; (System.Threading.Tasks.Task[] tasks, Func&lt;System.Threading.Tasks.Task[],TResult&gt; continuationFunction, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWhenAll&lt;TResult&gt;(class System.Threading.Tasks.Task[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task[], !!TResult&gt; continuationFunction, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``1(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task[],``0},System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWhenAll(Of TResult) (tasks As Task(), continuationFunction As Func(Of Task(), TResult), continuationOptions As TaskContinuationOptions) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWhenAll(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, Func&lt;cli::array &lt;System::Threading::Tasks::Task ^&gt; ^, TResult&gt; ^ continuationFunction, System::Threading::Tasks::TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAll : System.Threading.Tasks.Task[] * Func&lt;System.Threading.Tasks.Task[], 'Result&gt; * System.Threading.Tasks.TaskContinuationOptions -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.ContinueWhenAll (tasks, continuationFunction, continuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task[],TResult&gt;" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">O tipo de resultado retornado pela <c>continuationFunction</c> delegar e associado com a tarefa criada.</typeparam>
        <param name="tasks">A matriz de tarefas da qual continuar.</param>
        <param name="continuationFunction">O representante de função a ser executado de forma assíncrona quando todas as tarefas na matriz <c>tasks</c> forem concluídas.</param>
        <param name="continuationOptions">Uma combinação bit a bit dos valores de enumeração que controlam o comportamento da nova tarefa de continuação. Não há suporte para os membros NotOn* e OnlyOn*.</param>
        <summary>Cria uma tarefa de continuação que começa quando um conjunto de tarefas especificadas foi concluído.</summary>
        <returns>A nova tarefa de continuação.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Um elemento na matriz do <paramref name="tasks" /> foi descartado.</exception>
        <exception cref="T:System.ArgumentNullException">A matriz do <paramref name="tasks" /> é <see langword="null" />.  
  
- ou - 
O argumento <paramref name="continuationFunction" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">O argumento <paramref name="continuationOptions" /> especifica um valor inválido.</exception>
        <exception cref="T:System.ArgumentException">A matriz do <paramref name="tasks" /> está vazia ou contém um valor nulo.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAll&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAll&lt;TResult&gt; (System.Threading.Tasks.Task[] tasks, Func&lt;System.Threading.Tasks.Task[],TResult&gt; continuationFunction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWhenAll&lt;TResult&gt;(class System.Threading.Tasks.Task[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task[], !!TResult&gt; continuationFunction, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``1(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task[],``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWhenAll(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, Func&lt;cli::array &lt;System::Threading::Tasks::Task ^&gt; ^, TResult&gt; ^ continuationFunction, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskContinuationOptions continuationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAll : System.Threading.Tasks.Task[] * Func&lt;System.Threading.Tasks.Task[], 'Result&gt; * System.Threading.CancellationToken * System.Threading.Tasks.TaskContinuationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.ContinueWhenAll (tasks, continuationFunction, cancellationToken, continuationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task[],TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">O tipo de resultado retornado pela <c>continuationFunction</c> delegar e associado com a tarefa criada.</typeparam>
        <param name="tasks">A matriz de tarefas da qual continuar.</param>
        <param name="continuationFunction">O representante de função a ser executado de forma assíncrona quando todas as tarefas na matriz <c>tasks</c> forem concluídas.</param>
        <param name="cancellationToken">O token de cancelamento a ser atribuído à nova tarefa de continuação.</param>
        <param name="continuationOptions">Uma combinação bit a bit dos valores de enumeração que controlam o comportamento da nova tarefa de continuação. Não há suporte para os membros NotOn* e OnlyOn*.</param>
        <param name="scheduler">O objeto que é usado para agendar a nova tarefa de continuação.</param>
        <summary>Cria uma tarefa de continuação que começa quando um conjunto de tarefas especificadas foi concluído.</summary>
        <returns>A nova tarefa de continuação.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">A matriz do <paramref name="tasks" /> é <see langword="null" />.  
  
- ou - 
O argumento <paramref name="continuationFunction" /> é <see langword="null" />.  
  
- ou - 
O argumento <paramref name="scheduler" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">A matriz do <paramref name="tasks" /> está vazia ou contém um valor nulo.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAll&lt;TAntecedentResult,TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAll&lt;TAntecedentResult,TResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[],TResult&gt; continuationFunction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWhenAll&lt;TAntecedentResult, TResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[], !!TResult&gt; continuationFunction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0}[],``1})" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWhenAll(Of TAntecedentResult, TResult) (tasks As Task(Of TAntecedentResult)(), continuationFunction As Func(Of Task(Of TAntecedentResult)(), TResult)) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TAntecedentResult, typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWhenAll(cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^ tasks, Func&lt;cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^, TResult&gt; ^ continuationFunction);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAll : System.Threading.Tasks.Task&lt;'AntecedentResult&gt;[] * Func&lt;System.Threading.Tasks.Task&lt;'AntecedentResult&gt;[], 'Result&gt; -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.ContinueWhenAll (tasks, continuationFunction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[],TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">O tipo do resultado da antecessora <c>tarefas</c>.</typeparam>
        <typeparam name="TResult">O tipo de resultado retornado pela <c>continuationFunction</c> delegar e associado com a tarefa criada.</typeparam>
        <param name="tasks">A matriz de tarefas da qual continuar.</param>
        <param name="continuationFunction">O representante de função a ser executado de forma assíncrona quando todas as tarefas na matriz <c>tasks</c> forem concluídas.</param>
        <summary>Cria uma tarefa de continuação que começa quando um conjunto de tarefas especificadas foi concluído.</summary>
        <returns>A nova tarefa de continuação.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Um elemento na matriz do <paramref name="tasks" /> foi descartado.</exception>
        <exception cref="T:System.ArgumentNullException">A matriz do <paramref name="tasks" /> é <see langword="null" />.  
  
- ou - 
O argumento <paramref name="continuationFunction" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">A matriz do <paramref name="tasks" /> está vazia ou contém um valor nulo.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAll&lt;TAntecedentResult,TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAll&lt;TAntecedentResult,TResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[],TResult&gt; continuationFunction, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWhenAll&lt;TAntecedentResult, TResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[], !!TResult&gt; continuationFunction, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0}[],``1},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TAntecedentResult, typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWhenAll(cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^ tasks, Func&lt;cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^, TResult&gt; ^ continuationFunction, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAll : System.Threading.Tasks.Task&lt;'AntecedentResult&gt;[] * Func&lt;System.Threading.Tasks.Task&lt;'AntecedentResult&gt;[], 'Result&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.ContinueWhenAll (tasks, continuationFunction, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[],TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">O tipo do resultado da antecessora <c>tarefas</c>.</typeparam>
        <typeparam name="TResult">O tipo de resultado retornado pela <c>continuationFunction</c> delegar e associado com a tarefa criada.</typeparam>
        <param name="tasks">A matriz de tarefas da qual continuar.</param>
        <param name="continuationFunction">O representante de função a ser executado de forma assíncrona quando todas as tarefas na matriz <c>tasks</c> forem concluídas.</param>
        <param name="cancellationToken">O token de cancelamento a ser atribuído à nova tarefa de continuação.</param>
        <summary>Cria uma tarefa de continuação que começa quando um conjunto de tarefas especificadas foi concluído.</summary>
        <returns>A nova tarefa de continuação.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Um elemento na matriz do <paramref name="tasks" /> foi descartado.  
  
- ou - 
O <see cref="T:System.Threading.CancellationTokenSource" /> que criou <paramref name="cancellationToken" /> já foi descartado.</exception>
        <exception cref="T:System.ArgumentNullException">A matriz do <paramref name="tasks" /> é <see langword="null" />.  
  
- ou - 
O argumento <paramref name="continuationFunction" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">A matriz do <paramref name="tasks" /> está vazia ou contém um valor nulo.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAll&lt;TAntecedentResult,TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAll&lt;TAntecedentResult,TResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[],TResult&gt; continuationFunction, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWhenAll&lt;TAntecedentResult, TResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[], !!TResult&gt; continuationFunction, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0}[],``1},System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWhenAll(Of TAntecedentResult, TResult) (tasks As Task(Of TAntecedentResult)(), continuationFunction As Func(Of Task(Of TAntecedentResult)(), TResult), continuationOptions As TaskContinuationOptions) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TAntecedentResult, typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWhenAll(cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^ tasks, Func&lt;cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^, TResult&gt; ^ continuationFunction, System::Threading::Tasks::TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAll : System.Threading.Tasks.Task&lt;'AntecedentResult&gt;[] * Func&lt;System.Threading.Tasks.Task&lt;'AntecedentResult&gt;[], 'Result&gt; * System.Threading.Tasks.TaskContinuationOptions -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.ContinueWhenAll (tasks, continuationFunction, continuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[],TResult&gt;" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">O tipo do resultado da antecessora <c>tarefas</c>.</typeparam>
        <typeparam name="TResult">O tipo de resultado retornado pela <c>continuationFunction</c> delegar e associado com a tarefa criada.</typeparam>
        <param name="tasks">A matriz de tarefas da qual continuar.</param>
        <param name="continuationFunction">O representante de função a ser executado de forma assíncrona quando todas as tarefas na matriz <c>tasks</c> forem concluídas.</param>
        <param name="continuationOptions">Uma combinação bit a bit dos valores de enumeração que controlam o comportamento da nova tarefa de continuação. Não há suporte para os membros NotOn* e OnlyOn*.</param>
        <summary>Cria uma tarefa de continuação que começa quando um conjunto de tarefas especificadas foi concluído.</summary>
        <returns>A nova tarefa de continuação.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Um elemento na matriz do <paramref name="tasks" /> foi descartado.</exception>
        <exception cref="T:System.ArgumentNullException">A matriz do <paramref name="tasks" /> é <see langword="null" />.  
  
- ou - 
O argumento <paramref name="continuationFunction" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">O argumento <paramref name="continuationOptions" /> especifica um valor inválido.</exception>
        <exception cref="T:System.ArgumentException">A matriz do <paramref name="tasks" /> está vazia ou contém um valor nulo.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAll&lt;TAntecedentResult,TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAll&lt;TAntecedentResult,TResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[],TResult&gt; continuationFunction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWhenAll&lt;TAntecedentResult, TResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[], !!TResult&gt; continuationFunction, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0}[],``1},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TAntecedentResult, typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWhenAll(cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^ tasks, Func&lt;cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^, TResult&gt; ^ continuationFunction, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskContinuationOptions continuationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAll : System.Threading.Tasks.Task&lt;'AntecedentResult&gt;[] * Func&lt;System.Threading.Tasks.Task&lt;'AntecedentResult&gt;[], 'Result&gt; * System.Threading.CancellationToken * System.Threading.Tasks.TaskContinuationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.ContinueWhenAll (tasks, continuationFunction, cancellationToken, continuationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[],TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">O tipo do resultado da antecessora <c>tarefas</c>.</typeparam>
        <typeparam name="TResult">O tipo de resultado retornado pela <c>continuationFunction</c> delegar e associado com a tarefa criada.</typeparam>
        <param name="tasks">A matriz de tarefas da qual continuar.</param>
        <param name="continuationFunction">O representante de função a ser executado de forma assíncrona quando todas as tarefas na matriz <c>tasks</c> forem concluídas.</param>
        <param name="cancellationToken">O token de cancelamento a ser atribuído à nova tarefa de continuação.</param>
        <param name="continuationOptions">Uma combinação bit a bit dos valores de enumeração que controlam o comportamento da nova tarefa de continuação. Não há suporte para os membros NotOn* e OnlyOn*.</param>
        <param name="scheduler">O objeto que é usado para agendar a nova tarefa de continuação.</param>
        <summary>Cria uma tarefa de continuação que começa quando um conjunto de tarefas especificadas foi concluído.</summary>
        <returns>A nova tarefa de continuação.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">A matriz do <paramref name="tasks" /> é <see langword="null" />.  
  
- ou - 
O argumento <paramref name="continuationFunction" /> é <see langword="null" />.  
  
- ou - 
O argumento <paramref name="scheduler" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">A matriz do <paramref name="tasks" /> está vazia ou contém um valor nulo.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">O argumento <paramref name="continuationOptions" /> especifica um valor inválido.</exception>
        <exception cref="T:System.ObjectDisposedException">Um elemento na matriz do <paramref name="tasks" /> foi descartado.  
  
- ou - 
O <see cref="T:System.Threading.CancellationTokenSource" /> que criou <paramref name="cancellationToken" /> já foi descartado.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ContinueWhenAny">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Cria um <see cref="T:System.Threading.Tasks.Task" /> de continuação que será iniciado mediante a conclusão de qualquer Tarefa no conjunto fornecido.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ContinueWhenAny">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWhenAny (System.Threading.Tasks.Task[] tasks, Action&lt;System.Threading.Tasks.Task&gt; continuationAction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWhenAny(class System.Threading.Tasks.Task[] tasks, class System.Action`1&lt;class System.Threading.Tasks.Task&gt; continuationAction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny(System.Threading.Tasks.Task[],System.Action{System.Threading.Tasks.Task})" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWhenAny (tasks As Task(), continuationAction As Action(Of Task)) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWhenAny(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, Action&lt;System::Threading::Tasks::Task ^&gt; ^ continuationAction);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAny : System.Threading.Tasks.Task[] * Action&lt;System.Threading.Tasks.Task&gt; -&gt; System.Threading.Tasks.Task" Usage="taskFactory.ContinueWhenAny (tasks, continuationAction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&gt;" />
      </Parameters>
      <Docs>
        <param name="tasks">A matriz de tarefas da qual continuar quando uma tarefa for concluída.</param>
        <param name="continuationAction">O representante de ação a ser executado quando uma tarefa na matriz <c>tasks</c> for concluída.</param>
        <summary>Cria um <see cref="T:System.Threading.Tasks.Task" /> de continuação que será iniciado mediante a conclusão de qualquer Tarefa no conjunto fornecido.</summary>
        <returns>O novo <see cref="T:System.Threading.Tasks.Task" /> de continuação.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir mostra como usar `ContinueWhenAny` e `ContinueWhenAll`:  
  
 [!code-csharp[System.Threading.Tasks.Task#05](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/continuewhenmulti.cs#05)]
 [!code-vb[System.Threading.Tasks.Task#05](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/continuewhenmulti.vb#05)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Um dos elementos na matriz <paramref name="tasks" /> foi descartado.</exception>
        <exception cref="T:System.ArgumentNullException">A matriz do <paramref name="tasks" /> é <see langword="null" />.  
  
- ou - 
O argumento <paramref name="continuationAction" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">A matriz <paramref name="tasks" /> contém um valor <see langword="null" />.  
  
- ou - 
A matriz <paramref name="tasks" /> está vazia.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAny">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWhenAny (System.Threading.Tasks.Task[] tasks, Action&lt;System.Threading.Tasks.Task&gt; continuationAction, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWhenAny(class System.Threading.Tasks.Task[] tasks, class System.Action`1&lt;class System.Threading.Tasks.Task&gt; continuationAction, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny(System.Threading.Tasks.Task[],System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWhenAny(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, Action&lt;System::Threading::Tasks::Task ^&gt; ^ continuationAction, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAny : System.Threading.Tasks.Task[] * Action&lt;System.Threading.Tasks.Task&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="taskFactory.ContinueWhenAny (tasks, continuationAction, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="tasks">A matriz de tarefas da qual continuar quando uma tarefa for concluída.</param>
        <param name="continuationAction">O representante de ação a ser executado quando uma tarefa na matriz <c>tasks</c> for concluída.</param>
        <param name="cancellationToken">O <see cref="T:System.Threading.CancellationToken" /> que será atribuído à nova tarefa de continuação.</param>
        <summary>Cria um <see cref="T:System.Threading.Tasks.Task" /> de continuação que será iniciado mediante a conclusão de qualquer Tarefa no conjunto fornecido.</summary>
        <returns>O novo <see cref="T:System.Threading.Tasks.Task" /> de continuação.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Um dos elementos na matriz <paramref name="tasks" /> foi descartado.  
  
- ou - 
 <paramref name="cancellationToken" /> já foi descartado.</exception>
        <exception cref="T:System.ArgumentNullException">A matriz do <paramref name="tasks" /> é <see langword="null" />.  
  
- ou - 
O argumento <paramref name="continuationAction" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">A matriz <paramref name="tasks" /> contém um valor <see langword="null" />.  
  
- ou - 
A matriz <paramref name="tasks" /> está vazia.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAny">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWhenAny (System.Threading.Tasks.Task[] tasks, Action&lt;System.Threading.Tasks.Task&gt; continuationAction, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWhenAny(class System.Threading.Tasks.Task[] tasks, class System.Action`1&lt;class System.Threading.Tasks.Task&gt; continuationAction, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny(System.Threading.Tasks.Task[],System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWhenAny (tasks As Task(), continuationAction As Action(Of Task), continuationOptions As TaskContinuationOptions) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWhenAny(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, Action&lt;System::Threading::Tasks::Task ^&gt; ^ continuationAction, System::Threading::Tasks::TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAny : System.Threading.Tasks.Task[] * Action&lt;System.Threading.Tasks.Task&gt; * System.Threading.Tasks.TaskContinuationOptions -&gt; System.Threading.Tasks.Task" Usage="taskFactory.ContinueWhenAny (tasks, continuationAction, continuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&gt;" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <param name="tasks">A matriz de tarefas da qual continuar quando uma tarefa for concluída.</param>
        <param name="continuationAction">O representante de ação a ser executado quando uma tarefa na matriz <c>tasks</c> for concluída.</param>
        <param name="continuationOptions">O valor <see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> que controla o comportamento da <see cref="T:System.Threading.Tasks.Task" /> de continuação criada.</param>
        <summary>Cria um <see cref="T:System.Threading.Tasks.Task" /> de continuação que será iniciado mediante a conclusão de qualquer Tarefa no conjunto fornecido.</summary>
        <returns>O novo <see cref="T:System.Threading.Tasks.Task" /> de continuação.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O NotOn * e OnlyOn * <xref:System.Threading.Tasks.TaskContinuationOptions>, que restringir para as quais <xref:System.Threading.Tasks.TaskStatus> uma continuação será executada, os estados são ilegais com ContinueWhenAny.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">A exceção gerada quando um dos elementos na matriz <paramref name="tasks" /> foi descartado.</exception>
        <exception cref="T:System.ArgumentNullException">A exceção gerada quando a matriz <paramref name="tasks" /> é nula.  
  
- ou - 
A exceção lançada quando o argumento <paramref name="continuationAction" /> é nulo.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">A exceção gerada quando o argumento <paramref name="continuationOptions" /> especifica um valor de TaskContinuationOptions inválido.</exception>
        <exception cref="T:System.ArgumentException">A exceção gerada quando a matriz <paramref name="tasks" /> contém um valor nulo.  
  
- ou - 
A exceção gerada quando a matriz <paramref name="tasks" /> está vazia.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAny">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWhenAny (System.Threading.Tasks.Task[] tasks, Action&lt;System.Threading.Tasks.Task&gt; continuationAction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWhenAny(class System.Threading.Tasks.Task[] tasks, class System.Action`1&lt;class System.Threading.Tasks.Task&gt; continuationAction, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny(System.Threading.Tasks.Task[],System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWhenAny(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, Action&lt;System::Threading::Tasks::Task ^&gt; ^ continuationAction, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskContinuationOptions continuationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAny : System.Threading.Tasks.Task[] * Action&lt;System.Threading.Tasks.Task&gt; * System.Threading.CancellationToken * System.Threading.Tasks.TaskContinuationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task" Usage="taskFactory.ContinueWhenAny (tasks, continuationAction, cancellationToken, continuationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="tasks">A matriz de tarefas da qual continuar quando uma tarefa for concluída.</param>
        <param name="continuationAction">O representante de ação a ser executado quando uma tarefa na matriz <c>tasks</c> for concluída.</param>
        <param name="cancellationToken">O <see cref="T:System.Threading.CancellationToken" /> que será atribuído à nova tarefa de continuação.</param>
        <param name="continuationOptions">O valor <see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> que controla o comportamento da <see cref="T:System.Threading.Tasks.Task" /> de continuação criada.</param>
        <param name="scheduler">O <see cref="T:System.Threading.Tasks.TaskScheduler" /> usado para agendar a <see cref="T:System.Threading.Tasks.Task" /> de continuação criada.</param>
        <summary>Cria um <see cref="T:System.Threading.Tasks.Task" /> de continuação que será iniciado mediante a conclusão de qualquer Tarefa no conjunto fornecido.</summary>
        <returns>O novo <see cref="T:System.Threading.Tasks.Task" /> de continuação.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">A exceção gerada quando a matriz <paramref name="tasks" /> é nula.  
  
- ou - 
A exceção lançada quando o argumento <paramref name="continuationAction" /> é nulo.  
  
- ou - 
A exceção lançada quando o argumento <paramref name="scheduler" /> é nulo.</exception>
        <exception cref="T:System.ArgumentException">A exceção gerada quando a matriz <paramref name="tasks" /> contém um valor nulo.  
  
- ou - 
A exceção gerada quando a matriz <paramref name="tasks" /> está vazia.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAny&lt;TAntecedentResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWhenAny&lt;TAntecedentResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Action&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;&gt; continuationAction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWhenAny&lt;TAntecedentResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Action`1&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;&gt; continuationAction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``1(System.Threading.Tasks.Task{``0}[],System.Action{System.Threading.Tasks.Task{``0}})" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWhenAny(Of TAntecedentResult) (tasks As Task(Of TAntecedentResult)(), continuationAction As Action(Of Task(Of TAntecedentResult))) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TAntecedentResult&gt;&#xA; System::Threading::Tasks::Task ^ ContinueWhenAny(cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^ tasks, Action&lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^ continuationAction);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAny : System.Threading.Tasks.Task&lt;'AntecedentResult&gt;[] * Action&lt;System.Threading.Tasks.Task&lt;'AntecedentResult&gt;&gt; -&gt; System.Threading.Tasks.Task" Usage="taskFactory.ContinueWhenAny (tasks, continuationAction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">O tipo do resultado da antecessora <c>tarefas</c>.</typeparam>
        <param name="tasks">A matriz de tarefas da qual continuar quando uma tarefa for concluída.</param>
        <param name="continuationAction">O representante de ação a ser executado quando uma tarefa na matriz <c>tasks</c> for concluída.</param>
        <summary>Cria um <see cref="T:System.Threading.Tasks.Task" /> de continuação que será iniciado mediante a conclusão de qualquer Tarefa no conjunto fornecido.</summary>
        <returns>O novo <see cref="T:System.Threading.Tasks.Task" /> de continuação.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">A exceção gerada quando um dos elementos na matriz <paramref name="tasks" /> foi descartado.</exception>
        <exception cref="T:System.ArgumentNullException">A exceção gerada quando a matriz <paramref name="tasks" /> é nula.  
  
- ou - 
A exceção lançada quando o argumento <paramref name="continuationAction" /> é nulo.</exception>
        <exception cref="T:System.ArgumentException">A exceção gerada quando a matriz <paramref name="tasks" /> contém um valor nulo.  
  
- ou - 
A exceção gerada quando a matriz <paramref name="tasks" /> está vazia.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAny&lt;TAntecedentResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWhenAny&lt;TAntecedentResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Action&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;&gt; continuationAction, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWhenAny&lt;TAntecedentResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Action`1&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;&gt; continuationAction, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``1(System.Threading.Tasks.Task{``0}[],System.Action{System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TAntecedentResult&gt;&#xA; System::Threading::Tasks::Task ^ ContinueWhenAny(cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^ tasks, Action&lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^ continuationAction, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAny : System.Threading.Tasks.Task&lt;'AntecedentResult&gt;[] * Action&lt;System.Threading.Tasks.Task&lt;'AntecedentResult&gt;&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="taskFactory.ContinueWhenAny (tasks, continuationAction, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">O tipo do resultado da antecessora <c>tarefas</c>.</typeparam>
        <param name="tasks">A matriz de tarefas da qual continuar quando uma tarefa for concluída.</param>
        <param name="continuationAction">O representante de ação a ser executado quando uma tarefa na matriz <c>tasks</c> for concluída.</param>
        <param name="cancellationToken">O <see cref="T:System.Threading.CancellationToken" /> que será atribuído à nova tarefa de continuação.</param>
        <summary>Cria um <see cref="T:System.Threading.Tasks.Task" /> de continuação que será iniciado mediante a conclusão de qualquer Tarefa no conjunto fornecido.</summary>
        <returns>O novo <see cref="T:System.Threading.Tasks.Task" /> de continuação.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">A exceção gerada quando um dos elementos na matriz <paramref name="tasks" /> foi descartado.  
  
- ou - 
O <see cref="T:System.Threading.CancellationToken" /> fornecido já foi descartado.</exception>
        <exception cref="T:System.ArgumentNullException">A exceção gerada quando a matriz <paramref name="tasks" /> é nula.  
  
- ou - 
A exceção lançada quando o argumento <paramref name="continuationAction" /> é nulo.</exception>
        <exception cref="T:System.ArgumentException">A exceção gerada quando a matriz <paramref name="tasks" /> contém um valor nulo.  
  
- ou - 
A exceção gerada quando a matriz <paramref name="tasks" /> está vazia.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAny&lt;TAntecedentResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWhenAny&lt;TAntecedentResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Action&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;&gt; continuationAction, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWhenAny&lt;TAntecedentResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Action`1&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;&gt; continuationAction, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``1(System.Threading.Tasks.Task{``0}[],System.Action{System.Threading.Tasks.Task{``0}},System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWhenAny(Of TAntecedentResult) (tasks As Task(Of TAntecedentResult)(), continuationAction As Action(Of Task(Of TAntecedentResult)), continuationOptions As TaskContinuationOptions) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TAntecedentResult&gt;&#xA; System::Threading::Tasks::Task ^ ContinueWhenAny(cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^ tasks, Action&lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^ continuationAction, System::Threading::Tasks::TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAny : System.Threading.Tasks.Task&lt;'AntecedentResult&gt;[] * Action&lt;System.Threading.Tasks.Task&lt;'AntecedentResult&gt;&gt; * System.Threading.Tasks.TaskContinuationOptions -&gt; System.Threading.Tasks.Task" Usage="taskFactory.ContinueWhenAny (tasks, continuationAction, continuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;&gt;" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">O tipo do resultado da antecessora <c>tarefas</c>.</typeparam>
        <param name="tasks">A matriz de tarefas da qual continuar quando uma tarefa for concluída.</param>
        <param name="continuationAction">O representante de ação a ser executado quando uma tarefa na matriz <c>tasks</c> for concluída.</param>
        <param name="continuationOptions">O valor <see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> que controla o comportamento da <see cref="T:System.Threading.Tasks.Task" /> de continuação criada.</param>
        <summary>Cria um <see cref="T:System.Threading.Tasks.Task" /> de continuação que será iniciado mediante a conclusão de qualquer Tarefa no conjunto fornecido.</summary>
        <returns>O novo <see cref="T:System.Threading.Tasks.Task" /> de continuação.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O NotOn * e OnlyOn * <xref:System.Threading.Tasks.TaskContinuationOptions>, que restringir para as quais <xref:System.Threading.Tasks.TaskStatus> uma continuação será executada, os estados são ilegais com ContinueWhenAny.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">A exceção gerada quando um dos elementos na matriz <paramref name="tasks" /> foi descartado.</exception>
        <exception cref="T:System.ArgumentNullException">A exceção gerada quando a matriz <paramref name="tasks" /> é nula.  
  
- ou - 
A exceção lançada quando o argumento <paramref name="continuationAction" /> é nulo.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">A exceção gerada quando o argumento <paramref name="continuationOptions" /> especifica um valor de TaskContinuationOptions inválido.</exception>
        <exception cref="T:System.ArgumentException">A exceção gerada quando a matriz <paramref name="tasks" /> contém um valor nulo.  
  
- ou - 
A exceção gerada quando a matriz <paramref name="tasks" /> está vazia.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAny&lt;TAntecedentResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWhenAny&lt;TAntecedentResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Action&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;&gt; continuationAction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWhenAny&lt;TAntecedentResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Action`1&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;&gt; continuationAction, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``1(System.Threading.Tasks.Task{``0}[],System.Action{System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TAntecedentResult&gt;&#xA; System::Threading::Tasks::Task ^ ContinueWhenAny(cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^ tasks, Action&lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^ continuationAction, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskContinuationOptions continuationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAny : System.Threading.Tasks.Task&lt;'AntecedentResult&gt;[] * Action&lt;System.Threading.Tasks.Task&lt;'AntecedentResult&gt;&gt; * System.Threading.CancellationToken * System.Threading.Tasks.TaskContinuationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task" Usage="taskFactory.ContinueWhenAny (tasks, continuationAction, cancellationToken, continuationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">O tipo do resultado da antecessora <c>tarefas</c>.</typeparam>
        <param name="tasks">A matriz de tarefas da qual continuar quando uma tarefa for concluída.</param>
        <param name="continuationAction">O representante de ação a ser executado quando uma tarefa na matriz <c>tasks</c> for concluída.</param>
        <param name="cancellationToken">O <see cref="T:System.Threading.CancellationToken" /> que será atribuído à nova tarefa de continuação.</param>
        <param name="continuationOptions">O valor <see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> que controla o comportamento da <see cref="T:System.Threading.Tasks.Task" /> de continuação criada.</param>
        <param name="scheduler">O <see cref="T:System.Threading.Tasks.TaskScheduler" /> usado para agendar a <see cref="T:System.Threading.Tasks.Task`1" /> de continuação criada.</param>
        <summary>Cria um <see cref="T:System.Threading.Tasks.Task" /> de continuação que será iniciado mediante a conclusão de qualquer Tarefa no conjunto fornecido.</summary>
        <returns>O novo <see cref="T:System.Threading.Tasks.Task" /> de continuação.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O NotOn * e OnlyOn * <xref:System.Threading.Tasks.TaskContinuationOptions>, que restringir para as quais <xref:System.Threading.Tasks.TaskStatus> uma continuação será executada, os estados são ilegais com ContinueWhenAny.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">A exceção gerada quando a matriz <paramref name="tasks" /> é nula.  
  
- ou - 
A exceção lançada quando o argumento <paramref name="continuationAction" /> é nulo.  
  
- ou - 
A exceção lançada quando o argumento <paramref name="scheduler" /> é nulo.</exception>
        <exception cref="T:System.ArgumentException">A exceção gerada quando a matriz <paramref name="tasks" /> contém um valor nulo.  
  
- ou - 
A exceção gerada quando a matriz <paramref name="tasks" /> está vazia.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAny&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAny&lt;TResult&gt; (System.Threading.Tasks.Task[] tasks, Func&lt;System.Threading.Tasks.Task,TResult&gt; continuationFunction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWhenAny&lt;TResult&gt;(class System.Threading.Tasks.Task[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task, !!TResult&gt; continuationFunction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``1(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task,``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWhenAny(Of TResult) (tasks As Task(), continuationFunction As Func(Of Task, TResult)) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWhenAny(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, Func&lt;System::Threading::Tasks::Task ^, TResult&gt; ^ continuationFunction);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAny : System.Threading.Tasks.Task[] * Func&lt;System.Threading.Tasks.Task, 'Result&gt; -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.ContinueWhenAny (tasks, continuationFunction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">O tipo de resultado retornado pela <c>continuationFunction</c> delegar e associado com o criado <see cref="T:System.Threading.Tasks.Task`1" />.</typeparam>
        <param name="tasks">A matriz de tarefas da qual continuar quando uma tarefa for concluída.</param>
        <param name="continuationFunction">O representante de função a ser executado de forma assíncrona quando uma tarefa na matriz <c>tasks</c> for concluída.</param>
        <summary>Cria um <see cref="T:System.Threading.Tasks.Task`1" /> de continuação que será iniciado mediante a conclusão de qualquer Tarefa no conjunto fornecido.</summary>
        <returns>O novo <see cref="T:System.Threading.Tasks.Task`1" /> de continuação.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">A exceção gerada quando um dos elementos na matriz <paramref name="tasks" /> foi descartado.</exception>
        <exception cref="T:System.ArgumentNullException">A exceção gerada quando a matriz <paramref name="tasks" /> é nula.  
  
- ou - 
A exceção lançada quando o argumento <paramref name="continuationFunction" /> é nulo.</exception>
        <exception cref="T:System.ArgumentException">A exceção gerada quando a matriz <paramref name="tasks" /> contém um valor nulo.  
  
- ou - 
A exceção gerada quando a matriz <paramref name="tasks" /> está vazia.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAny&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAny&lt;TResult&gt; (System.Threading.Tasks.Task[] tasks, Func&lt;System.Threading.Tasks.Task,TResult&gt; continuationFunction, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWhenAny&lt;TResult&gt;(class System.Threading.Tasks.Task[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task, !!TResult&gt; continuationFunction, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``1(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWhenAny(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, Func&lt;System::Threading::Tasks::Task ^, TResult&gt; ^ continuationFunction, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAny : System.Threading.Tasks.Task[] * Func&lt;System.Threading.Tasks.Task, 'Result&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.ContinueWhenAny (tasks, continuationFunction, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">O tipo de resultado retornado pela <c>continuationFunction</c> delegar e associado com o criado <see cref="T:System.Threading.Tasks.Task`1" />.</typeparam>
        <param name="tasks">A matriz de tarefas da qual continuar quando uma tarefa for concluída.</param>
        <param name="continuationFunction">O representante de função a ser executado de forma assíncrona quando uma tarefa na matriz <c>tasks</c> for concluída.</param>
        <param name="cancellationToken">O <see cref="T:System.Threading.CancellationToken" /> que será atribuído à nova tarefa de continuação.</param>
        <summary>Cria um <see cref="T:System.Threading.Tasks.Task`1" /> de continuação que será iniciado mediante a conclusão de qualquer Tarefa no conjunto fornecido.</summary>
        <returns>O novo <see cref="T:System.Threading.Tasks.Task`1" /> de continuação.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">A exceção gerada quando um dos elementos na matriz <paramref name="tasks" /> foi descartado.  
  
- ou - 
O <see cref="T:System.Threading.CancellationToken" /> fornecido já foi descartado.</exception>
        <exception cref="T:System.ArgumentNullException">A exceção gerada quando a matriz <paramref name="tasks" /> é nula.  
  
- ou - 
A exceção lançada quando o argumento <paramref name="continuationFunction" /> é nulo.</exception>
        <exception cref="T:System.ArgumentException">A exceção gerada quando a matriz <paramref name="tasks" /> contém um valor nulo.  
  
- ou - 
A exceção gerada quando a matriz <paramref name="tasks" /> está vazia.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAny&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAny&lt;TResult&gt; (System.Threading.Tasks.Task[] tasks, Func&lt;System.Threading.Tasks.Task,TResult&gt; continuationFunction, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWhenAny&lt;TResult&gt;(class System.Threading.Tasks.Task[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task, !!TResult&gt; continuationFunction, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``1(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWhenAny(Of TResult) (tasks As Task(), continuationFunction As Func(Of Task, TResult), continuationOptions As TaskContinuationOptions) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWhenAny(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, Func&lt;System::Threading::Tasks::Task ^, TResult&gt; ^ continuationFunction, System::Threading::Tasks::TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAny : System.Threading.Tasks.Task[] * Func&lt;System.Threading.Tasks.Task, 'Result&gt; * System.Threading.Tasks.TaskContinuationOptions -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.ContinueWhenAny (tasks, continuationFunction, continuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,TResult&gt;" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">O tipo de resultado retornado pela <c>continuationFunction</c> delegar e associado com o criado <see cref="T:System.Threading.Tasks.Task`1" />.</typeparam>
        <param name="tasks">A matriz de tarefas da qual continuar quando uma tarefa for concluída.</param>
        <param name="continuationFunction">O representante de função a ser executado de forma assíncrona quando uma tarefa na matriz <c>tasks</c> for concluída.</param>
        <param name="continuationOptions">O valor <see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> que controla o comportamento da <see cref="T:System.Threading.Tasks.Task`1" /> de continuação criada.</param>
        <summary>Cria um <see cref="T:System.Threading.Tasks.Task`1" /> de continuação que será iniciado mediante a conclusão de qualquer Tarefa no conjunto fornecido.</summary>
        <returns>O novo <see cref="T:System.Threading.Tasks.Task`1" /> de continuação.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O NotOn * e OnlyOn * <xref:System.Threading.Tasks.TaskContinuationOptions>, que restringir para as quais <xref:System.Threading.Tasks.TaskStatus> uma continuação será executada, os estados são ilegais com ContinueWhenAny.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">A exceção gerada quando um dos elementos na matriz <paramref name="tasks" /> foi descartado.</exception>
        <exception cref="T:System.ArgumentNullException">A exceção gerada quando a matriz <paramref name="tasks" /> é nula.  
  
- ou - 
A exceção lançada quando o argumento <paramref name="continuationFunction" /> é nulo.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">A exceção gerada quando o argumento <paramref name="continuationOptions" /> especifica um valor de TaskContinuationOptions inválido.</exception>
        <exception cref="T:System.ArgumentException">A exceção gerada quando a matriz <paramref name="tasks" /> contém um valor nulo.  
  
- ou - 
A exceção gerada quando a matriz <paramref name="tasks" /> está vazia.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAny&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAny&lt;TResult&gt; (System.Threading.Tasks.Task[] tasks, Func&lt;System.Threading.Tasks.Task,TResult&gt; continuationFunction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWhenAny&lt;TResult&gt;(class System.Threading.Tasks.Task[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task, !!TResult&gt; continuationFunction, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``1(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWhenAny(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, Func&lt;System::Threading::Tasks::Task ^, TResult&gt; ^ continuationFunction, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskContinuationOptions continuationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAny : System.Threading.Tasks.Task[] * Func&lt;System.Threading.Tasks.Task, 'Result&gt; * System.Threading.CancellationToken * System.Threading.Tasks.TaskContinuationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.ContinueWhenAny (tasks, continuationFunction, cancellationToken, continuationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">O tipo de resultado retornado pela <c>continuationFunction</c> delegar e associado com o criado <see cref="T:System.Threading.Tasks.Task`1" />.</typeparam>
        <param name="tasks">A matriz de tarefas da qual continuar quando uma tarefa for concluída.</param>
        <param name="continuationFunction">O representante de função a ser executado de forma assíncrona quando uma tarefa na matriz <c>tasks</c> for concluída.</param>
        <param name="cancellationToken">O <see cref="T:System.Threading.CancellationToken" /> que será atribuído à nova tarefa de continuação.</param>
        <param name="continuationOptions">O valor <see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> que controla o comportamento da <see cref="T:System.Threading.Tasks.Task`1" /> de continuação criada.</param>
        <param name="scheduler">O <see cref="T:System.Threading.Tasks.TaskScheduler" /> usado para agendar a <see cref="T:System.Threading.Tasks.Task`1" /> de continuação criada.</param>
        <summary>Cria um <see cref="T:System.Threading.Tasks.Task`1" /> de continuação que será iniciado mediante a conclusão de qualquer Tarefa no conjunto fornecido.</summary>
        <returns>O novo <see cref="T:System.Threading.Tasks.Task`1" /> de continuação.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O NotOn * e OnlyOn * <xref:System.Threading.Tasks.TaskContinuationOptions>, que restringir para as quais <xref:System.Threading.Tasks.TaskStatus> uma continuação será executada, os estados são ilegais com ContinueWhenAny.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">A exceção gerada quando a matriz <paramref name="tasks" /> é nula.  
  
- ou - 
A exceção lançada quando o argumento <paramref name="continuationFunction" /> é nulo.  
  
- ou - 
A exceção lançada quando o argumento <paramref name="scheduler" /> é nulo.</exception>
        <exception cref="T:System.ArgumentException">A exceção gerada quando a matriz <paramref name="tasks" /> contém um valor nulo.  
  
- ou - 
A exceção gerada quando a matriz <paramref name="tasks" /> está vazia.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAny&lt;TAntecedentResult,TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAny&lt;TAntecedentResult,TResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;,TResult&gt; continuationFunction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWhenAny&lt;TAntecedentResult, TResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;, !!TResult&gt; continuationFunction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0},``1})" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWhenAny(Of TAntecedentResult, TResult) (tasks As Task(Of TAntecedentResult)(), continuationFunction As Func(Of Task(Of TAntecedentResult), TResult)) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TAntecedentResult, typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWhenAny(cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^ tasks, Func&lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^, TResult&gt; ^ continuationFunction);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAny : System.Threading.Tasks.Task&lt;'AntecedentResult&gt;[] * Func&lt;System.Threading.Tasks.Task&lt;'AntecedentResult&gt;, 'Result&gt; -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.ContinueWhenAny (tasks, continuationFunction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">O tipo do resultado da antecessora <c>tarefas</c>.</typeparam>
        <typeparam name="TResult">O tipo de resultado retornado pela <c>continuationFunction</c> delegar e associado com o criado <see cref="T:System.Threading.Tasks.Task`1" />.</typeparam>
        <param name="tasks">A matriz de tarefas da qual continuar quando uma tarefa for concluída.</param>
        <param name="continuationFunction">O representante de função a ser executado de forma assíncrona quando uma tarefa na matriz <c>tasks</c> for concluída.</param>
        <summary>Cria um <see cref="T:System.Threading.Tasks.Task`1" /> de continuação que será iniciado mediante a conclusão de qualquer Tarefa no conjunto fornecido.</summary>
        <returns>O novo <see cref="T:System.Threading.Tasks.Task`1" /> de continuação.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">A exceção gerada quando um dos elementos na matriz <paramref name="tasks" /> foi descartado.</exception>
        <exception cref="T:System.ArgumentNullException">A exceção gerada quando a matriz <paramref name="tasks" /> é nula.  
  
- ou - 
A exceção lançada quando o argumento <paramref name="continuationFunction" /> é nulo.</exception>
        <exception cref="T:System.ArgumentException">A exceção gerada quando a matriz <paramref name="tasks" /> contém um valor nulo.  
  
- ou - 
A exceção gerada quando a matriz <paramref name="tasks" /> está vazia.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAny&lt;TAntecedentResult,TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAny&lt;TAntecedentResult,TResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;,TResult&gt; continuationFunction, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWhenAny&lt;TAntecedentResult, TResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;, !!TResult&gt; continuationFunction, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0},``1},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TAntecedentResult, typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWhenAny(cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^ tasks, Func&lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^, TResult&gt; ^ continuationFunction, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAny : System.Threading.Tasks.Task&lt;'AntecedentResult&gt;[] * Func&lt;System.Threading.Tasks.Task&lt;'AntecedentResult&gt;, 'Result&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.ContinueWhenAny (tasks, continuationFunction, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;,TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">O tipo do resultado da antecessora <c>tarefas</c>.</typeparam>
        <typeparam name="TResult">O tipo de resultado retornado pela <c>continuationFunction</c> delegar e associado com o criado <see cref="T:System.Threading.Tasks.Task`1" />.</typeparam>
        <param name="tasks">A matriz de tarefas da qual continuar quando uma tarefa for concluída.</param>
        <param name="continuationFunction">O representante de função a ser executado de forma assíncrona quando uma tarefa na matriz <c>tasks</c> for concluída.</param>
        <param name="cancellationToken">O <see cref="T:System.Threading.CancellationToken" /> que será atribuído à nova tarefa de continuação.</param>
        <summary>Cria um <see cref="T:System.Threading.Tasks.Task`1" /> de continuação que será iniciado mediante a conclusão de qualquer Tarefa no conjunto fornecido.</summary>
        <returns>O novo <see cref="T:System.Threading.Tasks.Task`1" /> de continuação.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">A exceção gerada quando um dos elementos na matriz <paramref name="tasks" /> foi descartado.  
  
- ou - 
O <see cref="T:System.Threading.CancellationToken" /> fornecido já foi descartado.</exception>
        <exception cref="T:System.ArgumentNullException">A exceção gerada quando a matriz <paramref name="tasks" /> é nula.  
  
- ou - 
A exceção lançada quando o argumento <paramref name="continuationFunction" /> é nulo.</exception>
        <exception cref="T:System.ArgumentException">A exceção gerada quando a matriz <paramref name="tasks" /> contém um valor nulo.  
  
- ou - 
A exceção gerada quando a matriz <paramref name="tasks" /> está vazia.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAny&lt;TAntecedentResult,TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAny&lt;TAntecedentResult,TResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;,TResult&gt; continuationFunction, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWhenAny&lt;TAntecedentResult, TResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;, !!TResult&gt; continuationFunction, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0},``1},System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWhenAny(Of TAntecedentResult, TResult) (tasks As Task(Of TAntecedentResult)(), continuationFunction As Func(Of Task(Of TAntecedentResult), TResult), continuationOptions As TaskContinuationOptions) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TAntecedentResult, typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWhenAny(cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^ tasks, Func&lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^, TResult&gt; ^ continuationFunction, System::Threading::Tasks::TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAny : System.Threading.Tasks.Task&lt;'AntecedentResult&gt;[] * Func&lt;System.Threading.Tasks.Task&lt;'AntecedentResult&gt;, 'Result&gt; * System.Threading.Tasks.TaskContinuationOptions -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.ContinueWhenAny (tasks, continuationFunction, continuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;,TResult&gt;" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">O tipo do resultado da antecessora <c>tarefas</c>.</typeparam>
        <typeparam name="TResult">O tipo de resultado retornado pela <c>continuationFunction</c> delegar e associado com o criado <see cref="T:System.Threading.Tasks.Task`1" />.</typeparam>
        <param name="tasks">A matriz de tarefas da qual continuar quando uma tarefa for concluída.</param>
        <param name="continuationFunction">O representante de função a ser executado de forma assíncrona quando uma tarefa na matriz <c>tasks</c> for concluída.</param>
        <param name="continuationOptions">O valor <see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> que controla o comportamento da <see cref="T:System.Threading.Tasks.Task`1" /> de continuação criada.</param>
        <summary>Cria um <see cref="T:System.Threading.Tasks.Task`1" /> de continuação que será iniciado mediante a conclusão de qualquer Tarefa no conjunto fornecido.</summary>
        <returns>O novo <see cref="T:System.Threading.Tasks.Task`1" /> de continuação.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O NotOn * e OnlyOn * <xref:System.Threading.Tasks.TaskContinuationOptions>, que restringir para as quais <xref:System.Threading.Tasks.TaskStatus> uma continuação será executada, os estados são ilegais com ContinueWhenAny.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">A exceção gerada quando um dos elementos na matriz <paramref name="tasks" /> foi descartado.</exception>
        <exception cref="T:System.ArgumentNullException">A exceção gerada quando a matriz <paramref name="tasks" /> é nula.  
  
- ou - 
A exceção lançada quando o argumento <paramref name="continuationFunction" /> é nulo.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">A exceção gerada quando o argumento <paramref name="continuationOptions" /> especifica um valor de TaskContinuationOptions inválido.</exception>
        <exception cref="T:System.ArgumentException">A exceção gerada quando a matriz <paramref name="tasks" /> contém um valor nulo.  
  
- ou - 
A exceção gerada quando a matriz <paramref name="tasks" /> está vazia.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAny&lt;TAntecedentResult,TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAny&lt;TAntecedentResult,TResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;,TResult&gt; continuationFunction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWhenAny&lt;TAntecedentResult, TResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;, !!TResult&gt; continuationFunction, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0},``1},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TAntecedentResult, typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWhenAny(cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^ tasks, Func&lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^, TResult&gt; ^ continuationFunction, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskContinuationOptions continuationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAny : System.Threading.Tasks.Task&lt;'AntecedentResult&gt;[] * Func&lt;System.Threading.Tasks.Task&lt;'AntecedentResult&gt;, 'Result&gt; * System.Threading.CancellationToken * System.Threading.Tasks.TaskContinuationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.ContinueWhenAny (tasks, continuationFunction, cancellationToken, continuationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;,TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">O tipo do resultado da antecessora <c>tarefas</c>.</typeparam>
        <typeparam name="TResult">O tipo de resultado retornado pela <c>continuationFunction</c> delegar e associado com o criado <see cref="T:System.Threading.Tasks.Task`1" />.</typeparam>
        <param name="tasks">A matriz de tarefas da qual continuar quando uma tarefa for concluída.</param>
        <param name="continuationFunction">O representante de função a ser executado de forma assíncrona quando uma tarefa na matriz <c>tasks</c> for concluída.</param>
        <param name="cancellationToken">O <see cref="T:System.Threading.CancellationToken" /> que será atribuído à nova tarefa de continuação.</param>
        <param name="continuationOptions">O valor <see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> que controla o comportamento da <see cref="T:System.Threading.Tasks.Task`1" /> de continuação criada.</param>
        <param name="scheduler">O <see cref="T:System.Threading.Tasks.TaskScheduler" /> usado para agendar a <see cref="T:System.Threading.Tasks.Task`1" /> de continuação criada.</param>
        <summary>Cria um <see cref="T:System.Threading.Tasks.Task`1" /> de continuação que será iniciado mediante a conclusão de qualquer Tarefa no conjunto fornecido.</summary>
        <returns>O novo <see cref="T:System.Threading.Tasks.Task`1" /> de continuação.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O NotOn * e OnlyOn * <xref:System.Threading.Tasks.TaskContinuationOptions>, que restringir para as quais <xref:System.Threading.Tasks.TaskStatus> uma continuação será executada, os estados são ilegais com ContinueWhenAny.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">A exceção gerada quando a matriz <paramref name="tasks" /> é nula.  
  
- ou - 
A exceção lançada quando o argumento <paramref name="continuationFunction" /> é nulo.  
  
- ou - 
A exceção lançada quando o argumento <paramref name="scheduler" /> é nulo.</exception>
        <exception cref="T:System.ArgumentException">A exceção gerada quando a matriz <paramref name="tasks" /> contém um valor nulo.  
  
- ou - 
A exceção gerada quando a matriz <paramref name="tasks" /> está vazia.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreationOptions">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.TaskCreationOptions CreationOptions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.Tasks.TaskCreationOptions CreationOptions" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskFactory.CreationOptions" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CreationOptions As TaskCreationOptions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::Tasks::TaskCreationOptions CreationOptions { System::Threading::Tasks::TaskCreationOptions get(); };" />
      <MemberSignature Language="F#" Value="member this.CreationOptions : System.Threading.Tasks.TaskCreationOptions" Usage="System.Threading.Tasks.TaskFactory.CreationOptions" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskCreationOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém as opções de criação de tarefa padrão para essa fábrica de tarefas.</summary>
        <value>As opções de criação de tarefa padrão para essa fábrica de tarefas.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor da propriedade é usado para criar todas as tarefas, a menos que outras opções são especificadas explicitamente durante as chamadas para métodos dessa fábrica.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="FromAsync">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Cria um <see cref="T:System.Threading.Tasks.Task" /> que representa um par de métodos begin e end que estão em conformidade com o padrão do Modelo de Programação Assíncrona.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FromAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task FromAsync (IAsyncResult asyncResult, Action&lt;IAsyncResult&gt; endMethod);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task FromAsync(class System.IAsyncResult asyncResult, class System.Action`1&lt;class System.IAsyncResult&gt; endMethod) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync(System.IAsyncResult,System.Action{System.IAsyncResult})" />
      <MemberSignature Language="VB.NET" Value="Public Function FromAsync (asyncResult As IAsyncResult, endMethod As Action(Of IAsyncResult)) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ FromAsync(IAsyncResult ^ asyncResult, Action&lt;IAsyncResult ^&gt; ^ endMethod);" />
      <MemberSignature Language="F#" Value="member this.FromAsync : IAsyncResult * Action&lt;IAsyncResult&gt; -&gt; System.Threading.Tasks.Task" Usage="taskFactory.FromAsync (asyncResult, endMethod)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
        <Parameter Name="endMethod" Type="System.Action&lt;System.IAsyncResult&gt;" />
      </Parameters>
      <Docs>
        <param name="asyncResult">O IAsyncResult cuja conclusão deve disparar o processamento do <c>endMethod</c>.</param>
        <param name="endMethod">O representante de ação que processa o <c>asyncResult</c> concluído.</param>
        <summary>Cria um <see cref="T:System.Threading.Tasks.Task" /> que executa uma ação do método de encerramento quando um <see cref="T:System.IAsyncResult" /> especificado é concluído.</summary>
        <returns>Um <see cref="T:System.Threading.Tasks.Task" /> que representa a operação assíncrona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!TIP]
>  O <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> sobrecargas que aceitam uma `asyncResult` parâmetro não são tão eficientes como as sobrecargas que usam um `beginMethod` parâmetro. Se o desempenho for um problema, use as sobrecargas que fornecem a `beginMethod` / `endMethod` padrão.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">A exceção lançada quando o argumento <paramref name="asyncResult" /> é nulo.  
  
- ou - 
A exceção lançada quando o argumento <paramref name="endMethod" /> é nulo.</exception>
      </Docs>
    </Member>
    <Member MemberName="FromAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task FromAsync (Func&lt;AsyncCallback,object,IAsyncResult&gt; beginMethod, Action&lt;IAsyncResult&gt; endMethod, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task FromAsync(class System.Func`3&lt;class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Action`1&lt;class System.IAsyncResult&gt; endMethod, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function FromAsync (beginMethod As Func(Of AsyncCallback, Object, IAsyncResult), endMethod As Action(Of IAsyncResult), state As Object) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ FromAsync(Func&lt;AsyncCallback ^, System::Object ^, IAsyncResult ^&gt; ^ beginMethod, Action&lt;IAsyncResult ^&gt; ^ endMethod, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.FromAsync : Func&lt;AsyncCallback, obj, IAsyncResult&gt; * Action&lt;IAsyncResult&gt; * obj -&gt; System.Threading.Tasks.Task" Usage="taskFactory.FromAsync (beginMethod, endMethod, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Action&lt;System.IAsyncResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="beginMethod">O delegado que inicia a operação assíncrona.</param>
        <param name="endMethod">O delegado que finaliza a operação assíncrona.</param>
        <param name="state">Um objeto que contém dados a serem usados pelo representante <c>beginMethod</c>.</param>
        <summary>Cria um <see cref="T:System.Threading.Tasks.Task" /> que representa um par de métodos begin e end que estão em conformidade com o padrão do Modelo de Programação Assíncrona.</summary>
        <returns>O <see cref="T:System.Threading.Tasks.Task" /> criado que representa a operação assíncrona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `beginMethod` delegado é iniciado no thread que <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> está em execução no.  Esse método gera as exceções geradas pelo `beginMethod`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">A exceção lançada quando o argumento <paramref name="beginMethod" /> é nulo.  
  
- ou - 
A exceção lançada quando o argumento <paramref name="endMethod" /> é nulo.</exception>
      </Docs>
    </Member>
    <Member MemberName="FromAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task FromAsync (IAsyncResult asyncResult, Action&lt;IAsyncResult&gt; endMethod, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task FromAsync(class System.IAsyncResult asyncResult, class System.Action`1&lt;class System.IAsyncResult&gt; endMethod, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync(System.IAsyncResult,System.Action{System.IAsyncResult},System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function FromAsync (asyncResult As IAsyncResult, endMethod As Action(Of IAsyncResult), creationOptions As TaskCreationOptions) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ FromAsync(IAsyncResult ^ asyncResult, Action&lt;IAsyncResult ^&gt; ^ endMethod, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="member this.FromAsync : IAsyncResult * Action&lt;IAsyncResult&gt; * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task" Usage="taskFactory.FromAsync (asyncResult, endMethod, creationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
        <Parameter Name="endMethod" Type="System.Action&lt;System.IAsyncResult&gt;" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="asyncResult">O IAsyncResult cuja conclusão deve disparar o processamento do <c>endMethod</c>.</param>
        <param name="endMethod">O representante de ação que processa o <c>asyncResult</c> concluído.</param>
        <param name="creationOptions">O valor de TaskCreationOptions que controla o comportamento do <see cref="T:System.Threading.Tasks.Task" /> criado.</param>
        <summary>Cria um <see cref="T:System.Threading.Tasks.Task" /> que executa uma ação do método de encerramento quando um <see cref="T:System.IAsyncResult" /> especificado é concluído.</summary>
        <returns>Um <see cref="T:System.Threading.Tasks.Task" /> que representa a operação assíncrona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!TIP]
>  O <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> sobrecargas que aceitam uma `asyncResult` parâmetro não são tão eficientes como as sobrecargas que usam um `beginMethod` parâmetro. Se o desempenho for um problema, use as sobrecargas que fornecem a `beginMethod` / `endMethod` padrão.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">A exceção lançada quando o argumento <paramref name="asyncResult" /> é nulo.  
  
- ou - 
A exceção lançada quando o argumento <paramref name="endMethod" /> é nulo.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">A exceção lançada quando o argumento <paramref name="creationOptions" /> especifica um valor de TaskCreationOptions inválido. Para obter mais informações, consulte as Observações para <see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" /></exception>
      </Docs>
    </Member>
    <Member MemberName="FromAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task FromAsync (Func&lt;AsyncCallback,object,IAsyncResult&gt; beginMethod, Action&lt;IAsyncResult&gt; endMethod, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task FromAsync(class System.Func`3&lt;class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Action`1&lt;class System.IAsyncResult&gt; endMethod, object state, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function FromAsync (beginMethod As Func(Of AsyncCallback, Object, IAsyncResult), endMethod As Action(Of IAsyncResult), state As Object, creationOptions As TaskCreationOptions) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ FromAsync(Func&lt;AsyncCallback ^, System::Object ^, IAsyncResult ^&gt; ^ beginMethod, Action&lt;IAsyncResult ^&gt; ^ endMethod, System::Object ^ state, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="member this.FromAsync : Func&lt;AsyncCallback, obj, IAsyncResult&gt; * Action&lt;IAsyncResult&gt; * obj * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task" Usage="taskFactory.FromAsync (beginMethod, endMethod, state, creationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Action&lt;System.IAsyncResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="beginMethod">O delegado que inicia a operação assíncrona.</param>
        <param name="endMethod">O delegado que finaliza a operação assíncrona.</param>
        <param name="state">Um objeto que contém dados a serem usados pelo representante <c>beginMethod</c>.</param>
        <param name="creationOptions">O valor de TaskCreationOptions que controla o comportamento do <see cref="T:System.Threading.Tasks.Task" /> criado.</param>
        <summary>Cria um <see cref="T:System.Threading.Tasks.Task" /> que representa um par de métodos begin e end que estão em conformidade com o padrão do Modelo de Programação Assíncrona.</summary>
        <returns>O <see cref="T:System.Threading.Tasks.Task" /> criado que representa a operação assíncrona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `beginMethod` delegado é iniciado no thread que <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> está em execução no. Esse método gera as exceções geradas pelo `beginMethod`. O <xref:System.Threading.Tasks.TaskCreationOptions> valores <xref:System.Threading.Tasks.TaskCreationOptions.PreferFairness>, <xref:System.Threading.Tasks.TaskCreationOptions.LongRunning> e <xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent> são mutuamente exclusivos. Nos métodos FromAsync, tanto `LongRunning` ou `AttachedToParent` por si só fará com que um <xref:System.ArgumentOutOfRangeException> seja lançada.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">A exceção lançada quando o argumento <paramref name="beginMethod" /> é nulo.  
  
- ou - 
A exceção lançada quando o argumento <paramref name="endMethod" /> é nulo.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">A exceção lançada quando o argumento <paramref name="creationOptions" /> especifica um valor de TaskCreationOptions inválido.</exception>
      </Docs>
    </Member>
    <Member MemberName="FromAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task FromAsync (IAsyncResult asyncResult, Action&lt;IAsyncResult&gt; endMethod, System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task FromAsync(class System.IAsyncResult asyncResult, class System.Action`1&lt;class System.IAsyncResult&gt; endMethod, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync(System.IAsyncResult,System.Action{System.IAsyncResult},System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Function FromAsync (asyncResult As IAsyncResult, endMethod As Action(Of IAsyncResult), creationOptions As TaskCreationOptions, scheduler As TaskScheduler) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ FromAsync(IAsyncResult ^ asyncResult, Action&lt;IAsyncResult ^&gt; ^ endMethod, System::Threading::Tasks::TaskCreationOptions creationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.FromAsync : IAsyncResult * Action&lt;IAsyncResult&gt; * System.Threading.Tasks.TaskCreationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task" Usage="taskFactory.FromAsync (asyncResult, endMethod, creationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
        <Parameter Name="endMethod" Type="System.Action&lt;System.IAsyncResult&gt;" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="asyncResult">O IAsyncResult cuja conclusão deve disparar o processamento do <c>endMethod</c>.</param>
        <param name="endMethod">O representante de ação que processa o <c>asyncResult</c> concluído.</param>
        <param name="creationOptions">O valor de TaskCreationOptions que controla o comportamento do <see cref="T:System.Threading.Tasks.Task" /> criado.</param>
        <param name="scheduler">O <see cref="T:System.Threading.Tasks.TaskScheduler" /> usado para agendar a tarefa que executa o método de encerramento.</param>
        <summary>Cria um <see cref="T:System.Threading.Tasks.Task" /> que executa uma ação do método de encerramento quando um <see cref="T:System.IAsyncResult" /> especificado é concluído.</summary>
        <returns>O <see cref="T:System.Threading.Tasks.Task" /> criado que representa a operação assíncrona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!TIP]
>  O <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> sobrecargas que aceitam uma `asyncResult` parâmetro não são tão eficientes como as sobrecargas que usam um `beginMethod` parâmetro. Se o desempenho for um problema, use as sobrecargas que fornecem a `beginMethod` / `endMethod` padrão.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">A exceção lançada quando o argumento <paramref name="asyncResult" /> é nulo.  
  
- ou - 
A exceção lançada quando o argumento <paramref name="endMethod" /> é nulo.  
  
- ou - 
A exceção lançada quando o argumento <paramref name="scheduler" /> é nulo.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">A exceção lançada quando o argumento <paramref name="creationOptions" /> especifica um valor de TaskCreationOptions inválido. A exceção lançada quando o argumento <paramref name="creationOptions" /> especifica um valor de TaskCreationOptions inválido. Para obter mais informações, consulte as Observações para <see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" /></exception>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TArg1&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task FromAsync&lt;TArg1&gt; (Func&lt;TArg1,AsyncCallback,object,IAsyncResult&gt; beginMethod, Action&lt;IAsyncResult&gt; endMethod, TArg1 arg1, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task FromAsync&lt;TArg1&gt;(class System.Func`4&lt;!!TArg1, class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Action`1&lt;class System.IAsyncResult&gt; endMethod, !!TArg1 arg1, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync``1(System.Func{``0,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},``0,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function FromAsync(Of TArg1) (beginMethod As Func(Of TArg1, AsyncCallback, Object, IAsyncResult), endMethod As Action(Of IAsyncResult), arg1 As TArg1, state As Object) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TArg1&gt;&#xA; System::Threading::Tasks::Task ^ FromAsync(Func&lt;TArg1, AsyncCallback ^, System::Object ^, IAsyncResult ^&gt; ^ beginMethod, Action&lt;IAsyncResult ^&gt; ^ endMethod, TArg1 arg1, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.FromAsync : Func&lt;'TArg1, AsyncCallback, obj, IAsyncResult&gt; * Action&lt;IAsyncResult&gt; * 'TArg1 * obj -&gt; System.Threading.Tasks.Task" Usage="taskFactory.FromAsync (beginMethod, endMethod, arg1, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TArg1" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;TArg1,System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Action&lt;System.IAsyncResult&gt;" />
        <Parameter Name="arg1" Type="TArg1" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <typeparam name="TArg1">O tipo do primeiro argumento passado para o <c>beginMethod</c> delegar.</typeparam>
        <param name="beginMethod">O delegado que inicia a operação assíncrona.</param>
        <param name="endMethod">O delegado que finaliza a operação assíncrona.</param>
        <param name="arg1">O primeiro argumento passado para o representante <c>beginMethod</c>.</param>
        <param name="state">Um objeto que contém dados a serem usados pelo representante <c>beginMethod</c>.</param>
        <summary>Cria um <see cref="T:System.Threading.Tasks.Task" /> que representa um par de métodos begin e end que estão em conformidade com o padrão do Modelo de Programação Assíncrona.</summary>
        <returns>O <see cref="T:System.Threading.Tasks.Task" /> criado que representa a operação assíncrona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `beginMethod` delegado é iniciado no thread que <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> está em execução no. Esse método gera as exceções geradas pelo `beginMethod`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">A exceção lançada quando o argumento <paramref name="beginMethod" /> é nulo.  
  
- ou - 
A exceção lançada quando o argumento <paramref name="endMethod" /> é nulo.</exception>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TArg1&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task FromAsync&lt;TArg1&gt; (Func&lt;TArg1,AsyncCallback,object,IAsyncResult&gt; beginMethod, Action&lt;IAsyncResult&gt; endMethod, TArg1 arg1, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task FromAsync&lt;TArg1&gt;(class System.Func`4&lt;!!TArg1, class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Action`1&lt;class System.IAsyncResult&gt; endMethod, !!TArg1 arg1, object state, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync``1(System.Func{``0,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},``0,System.Object,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function FromAsync(Of TArg1) (beginMethod As Func(Of TArg1, AsyncCallback, Object, IAsyncResult), endMethod As Action(Of IAsyncResult), arg1 As TArg1, state As Object, creationOptions As TaskCreationOptions) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TArg1&gt;&#xA; System::Threading::Tasks::Task ^ FromAsync(Func&lt;TArg1, AsyncCallback ^, System::Object ^, IAsyncResult ^&gt; ^ beginMethod, Action&lt;IAsyncResult ^&gt; ^ endMethod, TArg1 arg1, System::Object ^ state, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="member this.FromAsync : Func&lt;'TArg1, AsyncCallback, obj, IAsyncResult&gt; * Action&lt;IAsyncResult&gt; * 'TArg1 * obj * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task" Usage="taskFactory.FromAsync (beginMethod, endMethod, arg1, state, creationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TArg1" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;TArg1,System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Action&lt;System.IAsyncResult&gt;" />
        <Parameter Name="arg1" Type="TArg1" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TArg1">O tipo do primeiro argumento passado para o <c>beginMethod</c> delegar.</typeparam>
        <param name="beginMethod">O delegado que inicia a operação assíncrona.</param>
        <param name="endMethod">O delegado que finaliza a operação assíncrona.</param>
        <param name="arg1">O primeiro argumento passado para o representante <c>beginMethod</c>.</param>
        <param name="state">Um objeto que contém dados a serem usados pelo representante <c>beginMethod</c>.</param>
        <param name="creationOptions">O valor de TaskCreationOptions que controla o comportamento do <see cref="T:System.Threading.Tasks.Task" /> criado.</param>
        <summary>Cria um <see cref="T:System.Threading.Tasks.Task" /> que representa um par de métodos begin e end que estão em conformidade com o padrão do Modelo de Programação Assíncrona.</summary>
        <returns>O <see cref="T:System.Threading.Tasks.Task" /> criado que representa a operação assíncrona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `beginMethod` delegado é iniciado no thread que <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> está em execução no. Esse método gera as exceções geradas pelo `beginMethod`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">A exceção lançada quando o argumento <paramref name="beginMethod" /> é nulo.  
  
- ou - 
A exceção lançada quando o argumento <paramref name="endMethod" /> é nulo.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">A exceção lançada quando o argumento <paramref name="creationOptions" /> especifica um valor de TaskCreationOptions inválido. A exceção lançada quando o argumento <paramref name="creationOptions" /> especifica um valor de TaskCreationOptions inválido. Para obter mais informações, consulte as Observações para <see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" /></exception>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; FromAsync&lt;TResult&gt; (IAsyncResult asyncResult, Func&lt;IAsyncResult,TResult&gt; endMethod);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromAsync&lt;TResult&gt;(class System.IAsyncResult asyncResult, class System.Func`2&lt;class System.IAsyncResult, !!TResult&gt; endMethod) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync``1(System.IAsyncResult,System.Func{System.IAsyncResult,``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FromAsync(Of TResult) (asyncResult As IAsyncResult, endMethod As Func(Of IAsyncResult, TResult)) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ FromAsync(IAsyncResult ^ asyncResult, Func&lt;IAsyncResult ^, TResult&gt; ^ endMethod);" />
      <MemberSignature Language="F#" Value="member this.FromAsync : IAsyncResult * Func&lt;IAsyncResult, 'Result&gt; -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.FromAsync (asyncResult, endMethod)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
        <Parameter Name="endMethod" Type="System.Func&lt;System.IAsyncResult,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">O tipo de resultado disponível por meio de <see cref="T:System.Threading.Tasks.Task`1" />.</typeparam>
        <param name="asyncResult">O IAsyncResult cuja conclusão deve disparar o processamento do <c>endMethod</c>.</param>
        <param name="endMethod">O representante de função que processa o <c>asyncResult</c> concluído.</param>
        <summary>Cria uma <see cref="T:System.Threading.Tasks.Task`1" /> que executa uma função do método de encerramento quando um <see cref="T:System.IAsyncResult" /> especificado é concluído.</summary>
        <returns>Um <see cref="T:System.Threading.Tasks.Task`1" /> que representa a operação assíncrona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!TIP]
>  O <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> sobrecargas que aceitam uma `asyncResult` parâmetro não são tão eficientes como as sobrecargas que usam um `beginMethod` parâmetro. Se o desempenho for um problema, use as sobrecargas que fornecem a `beginMethod` / `endMethod` padrão.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">A exceção lançada quando o argumento <paramref name="asyncResult" /> é nulo.  
  
- ou - 
A exceção lançada quando o argumento <paramref name="endMethod" /> é nulo.</exception>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; FromAsync&lt;TResult&gt; (Func&lt;AsyncCallback,object,IAsyncResult&gt; beginMethod, Func&lt;IAsyncResult,TResult&gt; endMethod, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromAsync&lt;TResult&gt;(class System.Func`3&lt;class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Func`2&lt;class System.IAsyncResult, !!TResult&gt; endMethod, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync``1(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``0},System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function FromAsync(Of TResult) (beginMethod As Func(Of AsyncCallback, Object, IAsyncResult), endMethod As Func(Of IAsyncResult, TResult), state As Object) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ FromAsync(Func&lt;AsyncCallback ^, System::Object ^, IAsyncResult ^&gt; ^ beginMethod, Func&lt;IAsyncResult ^, TResult&gt; ^ endMethod, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.FromAsync : Func&lt;AsyncCallback, obj, IAsyncResult&gt; * Func&lt;IAsyncResult, 'Result&gt; * obj -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.FromAsync (beginMethod, endMethod, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Func&lt;System.IAsyncResult,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">O tipo de resultado disponível por meio de <see cref="T:System.Threading.Tasks.Task`1" />.</typeparam>
        <param name="beginMethod">O delegado que inicia a operação assíncrona.</param>
        <param name="endMethod">O delegado que finaliza a operação assíncrona.</param>
        <param name="state">Um objeto que contém dados a serem usados pelo representante <c>beginMethod</c>.</param>
        <summary>Cria um <see cref="T:System.Threading.Tasks.Task`1" /> que representa um par de métodos begin e end que estão em conformidade com o padrão do Modelo de Programação Assíncrona.</summary>
        <returns>O <see cref="T:System.Threading.Tasks.Task`1" /> criado que representa a operação assíncrona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método gera as exceções geradas pelo `beginMethod`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">A exceção lançada quando o argumento <paramref name="beginMethod" /> é nulo.  
  
- ou - 
A exceção lançada quando o argumento <paramref name="endMethod" /> é nulo.</exception>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; FromAsync&lt;TResult&gt; (IAsyncResult asyncResult, Func&lt;IAsyncResult,TResult&gt; endMethod, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromAsync&lt;TResult&gt;(class System.IAsyncResult asyncResult, class System.Func`2&lt;class System.IAsyncResult, !!TResult&gt; endMethod, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync``1(System.IAsyncResult,System.Func{System.IAsyncResult,``0},System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function FromAsync(Of TResult) (asyncResult As IAsyncResult, endMethod As Func(Of IAsyncResult, TResult), creationOptions As TaskCreationOptions) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ FromAsync(IAsyncResult ^ asyncResult, Func&lt;IAsyncResult ^, TResult&gt; ^ endMethod, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="member this.FromAsync : IAsyncResult * Func&lt;IAsyncResult, 'Result&gt; * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.FromAsync (asyncResult, endMethod, creationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
        <Parameter Name="endMethod" Type="System.Func&lt;System.IAsyncResult,TResult&gt;" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">O tipo de resultado disponível por meio de <see cref="T:System.Threading.Tasks.Task`1" />.</typeparam>
        <param name="asyncResult">O IAsyncResult cuja conclusão deve disparar o processamento do <c>endMethod</c>.</param>
        <param name="endMethod">O representante de função que processa o <c>asyncResult</c> concluído.</param>
        <param name="creationOptions">O valor de TaskCreationOptions que controla o comportamento do <see cref="T:System.Threading.Tasks.Task`1" /> criado.</param>
        <summary>Cria uma <see cref="T:System.Threading.Tasks.Task`1" /> que executa uma função do método de encerramento quando um <see cref="T:System.IAsyncResult" /> especificado é concluído.</summary>
        <returns>Um <see cref="T:System.Threading.Tasks.Task`1" /> que representa a operação assíncrona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!TIP]
>  O <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> sobrecargas que aceitam uma `asyncResult` parâmetro não são tão eficientes como as sobrecargas que usam um `beginMethod` parâmetro. Se o desempenho for um problema, use as sobrecargas que fornecem a `beginMethod` / `endMethod` padrão.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">A exceção lançada quando o argumento <paramref name="asyncResult" /> é nulo.  
  
- ou - 
A exceção lançada quando o argumento <paramref name="endMethod" /> é nulo.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">A exceção lançada quando o argumento <paramref name="creationOptions" /> especifica um valor de TaskCreationOptions inválido. A exceção lançada quando o argumento <paramref name="creationOptions" /> especifica um valor de TaskCreationOptions inválido. Para obter mais informações, consulte as Observações para <see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" /></exception>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; FromAsync&lt;TResult&gt; (Func&lt;AsyncCallback,object,IAsyncResult&gt; beginMethod, Func&lt;IAsyncResult,TResult&gt; endMethod, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromAsync&lt;TResult&gt;(class System.Func`3&lt;class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Func`2&lt;class System.IAsyncResult, !!TResult&gt; endMethod, object state, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync``1(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``0},System.Object,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function FromAsync(Of TResult) (beginMethod As Func(Of AsyncCallback, Object, IAsyncResult), endMethod As Func(Of IAsyncResult, TResult), state As Object, creationOptions As TaskCreationOptions) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ FromAsync(Func&lt;AsyncCallback ^, System::Object ^, IAsyncResult ^&gt; ^ beginMethod, Func&lt;IAsyncResult ^, TResult&gt; ^ endMethod, System::Object ^ state, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="member this.FromAsync : Func&lt;AsyncCallback, obj, IAsyncResult&gt; * Func&lt;IAsyncResult, 'Result&gt; * obj * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.FromAsync (beginMethod, endMethod, state, creationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Func&lt;System.IAsyncResult,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">O tipo de resultado disponível por meio de <see cref="T:System.Threading.Tasks.Task`1" />.</typeparam>
        <param name="beginMethod">O delegado que inicia a operação assíncrona.</param>
        <param name="endMethod">O delegado que finaliza a operação assíncrona.</param>
        <param name="state">Um objeto que contém dados a serem usados pelo representante <c>beginMethod</c>.</param>
        <param name="creationOptions">O valor de TaskCreationOptions que controla o comportamento do <see cref="T:System.Threading.Tasks.Task`1" /> criado.</param>
        <summary>Cria um <see cref="T:System.Threading.Tasks.Task`1" /> que representa um par de métodos begin e end que estão em conformidade com o padrão do Modelo de Programação Assíncrona.</summary>
        <returns>O <see cref="T:System.Threading.Tasks.Task`1" /> criado que representa a operação assíncrona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método gera as exceções geradas pelo `beginMethod`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">A exceção lançada quando o argumento <paramref name="beginMethod" /> é nulo.  
  
- ou - 
A exceção lançada quando o argumento <paramref name="endMethod" /> é nulo.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">A exceção lançada quando o argumento <paramref name="creationOptions" /> especifica um valor de TaskCreationOptions inválido. A exceção lançada quando o argumento <paramref name="creationOptions" /> especifica um valor de TaskCreationOptions inválido. Para obter mais informações, consulte as Observações para <see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" /></exception>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; FromAsync&lt;TResult&gt; (IAsyncResult asyncResult, Func&lt;IAsyncResult,TResult&gt; endMethod, System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromAsync&lt;TResult&gt;(class System.IAsyncResult asyncResult, class System.Func`2&lt;class System.IAsyncResult, !!TResult&gt; endMethod, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync``1(System.IAsyncResult,System.Func{System.IAsyncResult,``0},System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Function FromAsync(Of TResult) (asyncResult As IAsyncResult, endMethod As Func(Of IAsyncResult, TResult), creationOptions As TaskCreationOptions, scheduler As TaskScheduler) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ FromAsync(IAsyncResult ^ asyncResult, Func&lt;IAsyncResult ^, TResult&gt; ^ endMethod, System::Threading::Tasks::TaskCreationOptions creationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.FromAsync : IAsyncResult * Func&lt;IAsyncResult, 'Result&gt; * System.Threading.Tasks.TaskCreationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.FromAsync (asyncResult, endMethod, creationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
        <Parameter Name="endMethod" Type="System.Func&lt;System.IAsyncResult,TResult&gt;" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">O tipo de resultado disponível por meio de <see cref="T:System.Threading.Tasks.Task`1" />.</typeparam>
        <param name="asyncResult">O IAsyncResult cuja conclusão deve disparar o processamento do <c>endMethod</c>.</param>
        <param name="endMethod">O representante de função que processa o <c>asyncResult</c> concluído.</param>
        <param name="creationOptions">O valor de TaskCreationOptions que controla o comportamento do <see cref="T:System.Threading.Tasks.Task`1" /> criado.</param>
        <param name="scheduler">O <see cref="T:System.Threading.Tasks.TaskScheduler" /> usado para agendar a tarefa que executa o método de encerramento.</param>
        <summary>Cria uma <see cref="T:System.Threading.Tasks.Task`1" /> que executa uma função do método de encerramento quando um <see cref="T:System.IAsyncResult" /> especificado é concluído.</summary>
        <returns>Um <see cref="T:System.Threading.Tasks.Task`1" /> que representa a operação assíncrona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!TIP]
>  O <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> sobrecargas que aceitam uma `asyncResult` parâmetro não são tão eficientes como as sobrecargas que usam um `beginMethod` parâmetro. Se o desempenho for um problema, use as sobrecargas que fornecem a `beginMethod` / `endMethod` padrão.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">A exceção lançada quando o argumento <paramref name="asyncResult" /> é nulo.  
  
- ou - 
A exceção lançada quando o argumento <paramref name="endMethod" /> é nulo.  
  
- ou - 
A exceção lançada quando o argumento <paramref name="scheduler" /> é nulo.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">A exceção lançada quando o argumento <paramref name="creationOptions" /> especifica um valor de TaskCreationOptions inválido. A exceção lançada quando o argumento <paramref name="creationOptions" /> especifica um valor de TaskCreationOptions inválido. Para obter mais informações, consulte as Observações para <see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" /></exception>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TArg1,TArg2&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task FromAsync&lt;TArg1,TArg2&gt; (Func&lt;TArg1,TArg2,AsyncCallback,object,IAsyncResult&gt; beginMethod, Action&lt;IAsyncResult&gt; endMethod, TArg1 arg1, TArg2 arg2, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task FromAsync&lt;TArg1, TArg2&gt;(class System.Func`5&lt;!!TArg1, !!TArg2, class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Action`1&lt;class System.IAsyncResult&gt; endMethod, !!TArg1 arg1, !!TArg2 arg2, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync``2(System.Func{``0,``1,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},``0,``1,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function FromAsync(Of TArg1, TArg2) (beginMethod As Func(Of TArg1, TArg2, AsyncCallback, Object, IAsyncResult), endMethod As Action(Of IAsyncResult), arg1 As TArg1, arg2 As TArg2, state As Object) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TArg1, typename TArg2&gt;&#xA; System::Threading::Tasks::Task ^ FromAsync(Func&lt;TArg1, TArg2, AsyncCallback ^, System::Object ^, IAsyncResult ^&gt; ^ beginMethod, Action&lt;IAsyncResult ^&gt; ^ endMethod, TArg1 arg1, TArg2 arg2, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.FromAsync : Func&lt;'TArg1, 'TArg2, AsyncCallback, obj, IAsyncResult&gt; * Action&lt;IAsyncResult&gt; * 'TArg1 * 'TArg2 * obj -&gt; System.Threading.Tasks.Task" Usage="taskFactory.FromAsync (beginMethod, endMethod, arg1, arg2, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TArg1" />
        <TypeParameter Name="TArg2" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;TArg1,TArg2,System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Action&lt;System.IAsyncResult&gt;" />
        <Parameter Name="arg1" Type="TArg1" />
        <Parameter Name="arg2" Type="TArg2" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <typeparam name="TArg1">O tipo do segundo argumento passado para <c>beginMethod</c> delegar.</typeparam>
        <typeparam name="TArg2">O tipo do primeiro argumento passado para o <c>beginMethod</c> delegar.</typeparam>
        <param name="beginMethod">O delegado que inicia a operação assíncrona.</param>
        <param name="endMethod">O delegado que finaliza a operação assíncrona.</param>
        <param name="arg1">O primeiro argumento passado para o representante <c>beginMethod</c>.</param>
        <param name="arg2">O segundo argumento passado para o representante <c>beginMethod</c>.</param>
        <param name="state">Um objeto que contém dados a serem usados pelo representante <c>beginMethod</c>.</param>
        <summary>Cria um <see cref="T:System.Threading.Tasks.Task" /> que representa um par de métodos begin e end que estão em conformidade com o padrão do Modelo de Programação Assíncrona.</summary>
        <returns>O <see cref="T:System.Threading.Tasks.Task" /> criado que representa a operação assíncrona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `beginMethod` delegado é iniciado no thread que <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> está em execução no. Esse método gera as exceções geradas pelo `beginMethod`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">A exceção lançada quando o argumento <paramref name="beginMethod" /> é nulo.  
  
- ou - 
A exceção lançada quando o argumento <paramref name="endMethod" /> é nulo.</exception>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TArg1,TArg2&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task FromAsync&lt;TArg1,TArg2&gt; (Func&lt;TArg1,TArg2,AsyncCallback,object,IAsyncResult&gt; beginMethod, Action&lt;IAsyncResult&gt; endMethod, TArg1 arg1, TArg2 arg2, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task FromAsync&lt;TArg1, TArg2&gt;(class System.Func`5&lt;!!TArg1, !!TArg2, class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Action`1&lt;class System.IAsyncResult&gt; endMethod, !!TArg1 arg1, !!TArg2 arg2, object state, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync``2(System.Func{``0,``1,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},``0,``1,System.Object,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function FromAsync(Of TArg1, TArg2) (beginMethod As Func(Of TArg1, TArg2, AsyncCallback, Object, IAsyncResult), endMethod As Action(Of IAsyncResult), arg1 As TArg1, arg2 As TArg2, state As Object, creationOptions As TaskCreationOptions) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TArg1, typename TArg2&gt;&#xA; System::Threading::Tasks::Task ^ FromAsync(Func&lt;TArg1, TArg2, AsyncCallback ^, System::Object ^, IAsyncResult ^&gt; ^ beginMethod, Action&lt;IAsyncResult ^&gt; ^ endMethod, TArg1 arg1, TArg2 arg2, System::Object ^ state, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="member this.FromAsync : Func&lt;'TArg1, 'TArg2, AsyncCallback, obj, IAsyncResult&gt; * Action&lt;IAsyncResult&gt; * 'TArg1 * 'TArg2 * obj * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task" Usage="taskFactory.FromAsync (beginMethod, endMethod, arg1, arg2, state, creationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TArg1" />
        <TypeParameter Name="TArg2" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;TArg1,TArg2,System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Action&lt;System.IAsyncResult&gt;" />
        <Parameter Name="arg1" Type="TArg1" />
        <Parameter Name="arg2" Type="TArg2" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TArg1">O tipo do segundo argumento passado para <c>beginMethod</c> delegar.</typeparam>
        <typeparam name="TArg2">O tipo do primeiro argumento passado para o <c>beginMethod</c> delegar.</typeparam>
        <param name="beginMethod">O delegado que inicia a operação assíncrona.</param>
        <param name="endMethod">O delegado que finaliza a operação assíncrona.</param>
        <param name="arg1">O primeiro argumento passado para o representante <c>beginMethod</c>.</param>
        <param name="arg2">O segundo argumento passado para o representante <c>beginMethod</c>.</param>
        <param name="state">Um objeto que contém dados a serem usados pelo representante <c>beginMethod</c>.</param>
        <param name="creationOptions">O valor de TaskCreationOptions que controla o comportamento do <see cref="T:System.Threading.Tasks.Task" /> criado.</param>
        <summary>Cria um <see cref="T:System.Threading.Tasks.Task" /> que representa um par de métodos begin e end que estão em conformidade com o padrão do Modelo de Programação Assíncrona.</summary>
        <returns>O <see cref="T:System.Threading.Tasks.Task" /> criado que representa a operação assíncrona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `beginMethod` delegado é iniciado no thread que <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> está em execução no. Esse método gera as exceções geradas pelo `beginMethod`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">A exceção lançada quando o argumento <paramref name="beginMethod" /> é nulo.  
  
- ou - 
A exceção lançada quando o argumento <paramref name="endMethod" /> é nulo.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">A exceção lançada quando o argumento <paramref name="creationOptions" /> especifica um valor de TaskCreationOptions inválido. A exceção lançada quando o argumento <paramref name="creationOptions" /> especifica um valor de TaskCreationOptions inválido. Para obter mais informações, consulte as Observações para <see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" /></exception>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TArg1,TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; FromAsync&lt;TArg1,TResult&gt; (Func&lt;TArg1,AsyncCallback,object,IAsyncResult&gt; beginMethod, Func&lt;IAsyncResult,TResult&gt; endMethod, TArg1 arg1, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromAsync&lt;TArg1, TResult&gt;(class System.Func`4&lt;!!TArg1, class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Func`2&lt;class System.IAsyncResult, !!TResult&gt; endMethod, !!TArg1 arg1, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync``2(System.Func{``0,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``1},``0,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function FromAsync(Of TArg1, TResult) (beginMethod As Func(Of TArg1, AsyncCallback, Object, IAsyncResult), endMethod As Func(Of IAsyncResult, TResult), arg1 As TArg1, state As Object) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TArg1, typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ FromAsync(Func&lt;TArg1, AsyncCallback ^, System::Object ^, IAsyncResult ^&gt; ^ beginMethod, Func&lt;IAsyncResult ^, TResult&gt; ^ endMethod, TArg1 arg1, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.FromAsync : Func&lt;'TArg1, AsyncCallback, obj, IAsyncResult&gt; * Func&lt;IAsyncResult, 'Result&gt; * 'TArg1 * obj -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.FromAsync (beginMethod, endMethod, arg1, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TArg1" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;TArg1,System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Func&lt;System.IAsyncResult,TResult&gt;" />
        <Parameter Name="arg1" Type="TArg1" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <typeparam name="TArg1">O tipo do primeiro argumento passado para o <c>beginMethod</c> delegar.</typeparam>
        <typeparam name="TResult">O tipo de resultado disponível por meio de <see cref="T:System.Threading.Tasks.Task`1" />.</typeparam>
        <param name="beginMethod">O delegado que inicia a operação assíncrona.</param>
        <param name="endMethod">O delegado que finaliza a operação assíncrona.</param>
        <param name="arg1">O primeiro argumento passado para o representante <c>beginMethod</c>.</param>
        <param name="state">Um objeto que contém dados a serem usados pelo representante <c>beginMethod</c>.</param>
        <summary>Cria um <see cref="T:System.Threading.Tasks.Task`1" /> que representa um par de métodos begin e end que estão em conformidade com o padrão do Modelo de Programação Assíncrona.</summary>
        <returns>O <see cref="T:System.Threading.Tasks.Task`1" /> criado que representa a operação assíncrona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `beginMethod` delegado é iniciado no thread que <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> está em execução no. Esse método gera as exceções geradas pelo `beginMethod`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">A exceção lançada quando o argumento <paramref name="beginMethod" /> é nulo.  
  
- ou - 
A exceção lançada quando o argumento <paramref name="endMethod" /> é nulo.</exception>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TArg1,TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; FromAsync&lt;TArg1,TResult&gt; (Func&lt;TArg1,AsyncCallback,object,IAsyncResult&gt; beginMethod, Func&lt;IAsyncResult,TResult&gt; endMethod, TArg1 arg1, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromAsync&lt;TArg1, TResult&gt;(class System.Func`4&lt;!!TArg1, class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Func`2&lt;class System.IAsyncResult, !!TResult&gt; endMethod, !!TArg1 arg1, object state, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync``2(System.Func{``0,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``1},``0,System.Object,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function FromAsync(Of TArg1, TResult) (beginMethod As Func(Of TArg1, AsyncCallback, Object, IAsyncResult), endMethod As Func(Of IAsyncResult, TResult), arg1 As TArg1, state As Object, creationOptions As TaskCreationOptions) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TArg1, typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ FromAsync(Func&lt;TArg1, AsyncCallback ^, System::Object ^, IAsyncResult ^&gt; ^ beginMethod, Func&lt;IAsyncResult ^, TResult&gt; ^ endMethod, TArg1 arg1, System::Object ^ state, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="member this.FromAsync : Func&lt;'TArg1, AsyncCallback, obj, IAsyncResult&gt; * Func&lt;IAsyncResult, 'Result&gt; * 'TArg1 * obj * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.FromAsync (beginMethod, endMethod, arg1, state, creationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TArg1" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;TArg1,System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Func&lt;System.IAsyncResult,TResult&gt;" />
        <Parameter Name="arg1" Type="TArg1" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TArg1">O tipo do primeiro argumento passado para o <c>beginMethod</c> delegar.</typeparam>
        <typeparam name="TResult">O tipo de resultado disponível por meio de <see cref="T:System.Threading.Tasks.Task`1" />.</typeparam>
        <param name="beginMethod">O delegado que inicia a operação assíncrona.</param>
        <param name="endMethod">O delegado que finaliza a operação assíncrona.</param>
        <param name="arg1">O primeiro argumento passado para o representante <c>beginMethod</c>.</param>
        <param name="state">Um objeto que contém dados a serem usados pelo representante <c>beginMethod</c>.</param>
        <param name="creationOptions">O valor de TaskCreationOptions que controla o comportamento do <see cref="T:System.Threading.Tasks.Task`1" /> criado.</param>
        <summary>Cria um <see cref="T:System.Threading.Tasks.Task`1" /> que representa um par de métodos begin e end que estão em conformidade com o padrão do Modelo de Programação Assíncrona.</summary>
        <returns>O <see cref="T:System.Threading.Tasks.Task`1" /> criado que representa a operação assíncrona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `beginMethod` delegado é iniciado no thread que <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> está em execução no. Esse método gera as exceções geradas pelo `beginMethod`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">A exceção lançada quando o argumento <paramref name="beginMethod" /> é nulo.  
  
- ou - 
A exceção lançada quando o argumento <paramref name="endMethod" /> é nulo.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">A exceção lançada quando o argumento <paramref name="creationOptions" /> especifica um valor de TaskCreationOptions inválido. A exceção lançada quando o argumento <paramref name="creationOptions" /> especifica um valor de TaskCreationOptions inválido. Para obter mais informações, consulte as Observações para <see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" /></exception>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TArg1,TArg2,TArg3&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task FromAsync&lt;TArg1,TArg2,TArg3&gt; (Func&lt;TArg1,TArg2,TArg3,AsyncCallback,object,IAsyncResult&gt; beginMethod, Action&lt;IAsyncResult&gt; endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task FromAsync&lt;TArg1, TArg2, TArg3&gt;(class System.Func`6&lt;!!TArg1, !!TArg2, !!TArg3, class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Action`1&lt;class System.IAsyncResult&gt; endMethod, !!TArg1 arg1, !!TArg2 arg2, !!TArg3 arg3, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync``3(System.Func{``0,``1,``2,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},``0,``1,``2,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function FromAsync(Of TArg1, TArg2, TArg3) (beginMethod As Func(Of TArg1, TArg2, TArg3, AsyncCallback, Object, IAsyncResult), endMethod As Action(Of IAsyncResult), arg1 As TArg1, arg2 As TArg2, arg3 As TArg3, state As Object) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TArg1, typename TArg2, typename TArg3&gt;&#xA; System::Threading::Tasks::Task ^ FromAsync(Func&lt;TArg1, TArg2, TArg3, AsyncCallback ^, System::Object ^, IAsyncResult ^&gt; ^ beginMethod, Action&lt;IAsyncResult ^&gt; ^ endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.FromAsync : Func&lt;'TArg1, 'TArg2, 'TArg3, AsyncCallback, obj, IAsyncResult&gt; * Action&lt;IAsyncResult&gt; * 'TArg1 * 'TArg2 * 'TArg3 * obj -&gt; System.Threading.Tasks.Task" Usage="taskFactory.FromAsync (beginMethod, endMethod, arg1, arg2, arg3, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TArg1" />
        <TypeParameter Name="TArg2" />
        <TypeParameter Name="TArg3" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;TArg1,TArg2,TArg3,System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Action&lt;System.IAsyncResult&gt;" />
        <Parameter Name="arg1" Type="TArg1" />
        <Parameter Name="arg2" Type="TArg2" />
        <Parameter Name="arg3" Type="TArg3" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <typeparam name="TArg1">O tipo do segundo argumento passado para <c>beginMethod</c> delegar.</typeparam>
        <typeparam name="TArg2">O tipo do terceiro argumento passado para <c>beginMethod</c> delegar.</typeparam>
        <typeparam name="TArg3">O tipo do primeiro argumento passado para o <c>beginMethod</c> delegar.</typeparam>
        <param name="beginMethod">O delegado que inicia a operação assíncrona.</param>
        <param name="endMethod">O delegado que finaliza a operação assíncrona.</param>
        <param name="arg1">O primeiro argumento passado para o representante <c>beginMethod</c>.</param>
        <param name="arg2">O segundo argumento passado para o representante <c>beginMethod</c>.</param>
        <param name="arg3">O terceiro argumento passado para o representante <c>beginMethod</c>.</param>
        <param name="state">Um objeto que contém dados a serem usados pelo representante <c>beginMethod</c>.</param>
        <summary>Cria um <see cref="T:System.Threading.Tasks.Task" /> que representa um par de métodos begin e end que estão em conformidade com o padrão do Modelo de Programação Assíncrona.</summary>
        <returns>O <see cref="T:System.Threading.Tasks.Task" /> criado que representa a operação assíncrona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `beginMethod` delegado é iniciado no thread que <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> está em execução no. Esse método gera as exceções geradas pelo `beginMethod`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">A exceção lançada quando o argumento <paramref name="beginMethod" /> é nulo.  
  
- ou - 
A exceção lançada quando o argumento <paramref name="endMethod" /> é nulo.</exception>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TArg1,TArg2,TArg3&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task FromAsync&lt;TArg1,TArg2,TArg3&gt; (Func&lt;TArg1,TArg2,TArg3,AsyncCallback,object,IAsyncResult&gt; beginMethod, Action&lt;IAsyncResult&gt; endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task FromAsync&lt;TArg1, TArg2, TArg3&gt;(class System.Func`6&lt;!!TArg1, !!TArg2, !!TArg3, class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Action`1&lt;class System.IAsyncResult&gt; endMethod, !!TArg1 arg1, !!TArg2 arg2, !!TArg3 arg3, object state, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync``3(System.Func{``0,``1,``2,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},``0,``1,``2,System.Object,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function FromAsync(Of TArg1, TArg2, TArg3) (beginMethod As Func(Of TArg1, TArg2, TArg3, AsyncCallback, Object, IAsyncResult), endMethod As Action(Of IAsyncResult), arg1 As TArg1, arg2 As TArg2, arg3 As TArg3, state As Object, creationOptions As TaskCreationOptions) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TArg1, typename TArg2, typename TArg3&gt;&#xA; System::Threading::Tasks::Task ^ FromAsync(Func&lt;TArg1, TArg2, TArg3, AsyncCallback ^, System::Object ^, IAsyncResult ^&gt; ^ beginMethod, Action&lt;IAsyncResult ^&gt; ^ endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, System::Object ^ state, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="member this.FromAsync : Func&lt;'TArg1, 'TArg2, 'TArg3, AsyncCallback, obj, IAsyncResult&gt; * Action&lt;IAsyncResult&gt; * 'TArg1 * 'TArg2 * 'TArg3 * obj * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task" Usage="taskFactory.FromAsync (beginMethod, endMethod, arg1, arg2, arg3, state, creationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TArg1" />
        <TypeParameter Name="TArg2" />
        <TypeParameter Name="TArg3" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;TArg1,TArg2,TArg3,System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Action&lt;System.IAsyncResult&gt;" />
        <Parameter Name="arg1" Type="TArg1" />
        <Parameter Name="arg2" Type="TArg2" />
        <Parameter Name="arg3" Type="TArg3" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TArg1">O tipo do segundo argumento passado para <c>beginMethod</c> delegar.</typeparam>
        <typeparam name="TArg2">O tipo do terceiro argumento passado para <c>beginMethod</c> delegar.</typeparam>
        <typeparam name="TArg3">O tipo do primeiro argumento passado para o <c>beginMethod</c> delegar.</typeparam>
        <param name="beginMethod">O delegado que inicia a operação assíncrona.</param>
        <param name="endMethod">O delegado que finaliza a operação assíncrona.</param>
        <param name="arg1">O primeiro argumento passado para o representante <c>beginMethod</c>.</param>
        <param name="arg2">O segundo argumento passado para o representante <c>beginMethod</c>.</param>
        <param name="arg3">O terceiro argumento passado para o representante <c>beginMethod</c>.</param>
        <param name="state">Um objeto que contém dados a serem usados pelo representante <c>beginMethod</c>.</param>
        <param name="creationOptions">O valor de TaskCreationOptions que controla o comportamento do <see cref="T:System.Threading.Tasks.Task" /> criado.</param>
        <summary>Cria um <see cref="T:System.Threading.Tasks.Task" /> que representa um par de métodos begin e end que estão em conformidade com o padrão do Modelo de Programação Assíncrona.</summary>
        <returns>O <see cref="T:System.Threading.Tasks.Task" /> criado que representa a operação assíncrona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `beginMethod` delegado é iniciado no thread que <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> está em execução no. Esse método gera as exceções geradas pelo `beginMethod`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">A exceção lançada quando o argumento <paramref name="beginMethod" /> é nulo.  
  
- ou - 
A exceção lançada quando o argumento <paramref name="endMethod" /> é nulo.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">A exceção lançada quando o argumento <paramref name="creationOptions" /> especifica um valor de TaskCreationOptions inválido. A exceção lançada quando o argumento <paramref name="creationOptions" /> especifica um valor de TaskCreationOptions inválido. Para obter mais informações, consulte as Observações para <see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" /></exception>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TArg1,TArg2,TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; FromAsync&lt;TArg1,TArg2,TResult&gt; (Func&lt;TArg1,TArg2,AsyncCallback,object,IAsyncResult&gt; beginMethod, Func&lt;IAsyncResult,TResult&gt; endMethod, TArg1 arg1, TArg2 arg2, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromAsync&lt;TArg1, TArg2, TResult&gt;(class System.Func`5&lt;!!TArg1, !!TArg2, class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Func`2&lt;class System.IAsyncResult, !!TResult&gt; endMethod, !!TArg1 arg1, !!TArg2 arg2, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync``3(System.Func{``0,``1,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``2},``0,``1,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function FromAsync(Of TArg1, TArg2, TResult) (beginMethod As Func(Of TArg1, TArg2, AsyncCallback, Object, IAsyncResult), endMethod As Func(Of IAsyncResult, TResult), arg1 As TArg1, arg2 As TArg2, state As Object) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TArg1, typename TArg2, typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ FromAsync(Func&lt;TArg1, TArg2, AsyncCallback ^, System::Object ^, IAsyncResult ^&gt; ^ beginMethod, Func&lt;IAsyncResult ^, TResult&gt; ^ endMethod, TArg1 arg1, TArg2 arg2, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.FromAsync : Func&lt;'TArg1, 'TArg2, AsyncCallback, obj, IAsyncResult&gt; * Func&lt;IAsyncResult, 'Result&gt; * 'TArg1 * 'TArg2 * obj -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.FromAsync (beginMethod, endMethod, arg1, arg2, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TArg1" />
        <TypeParameter Name="TArg2" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;TArg1,TArg2,System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Func&lt;System.IAsyncResult,TResult&gt;" />
        <Parameter Name="arg1" Type="TArg1" />
        <Parameter Name="arg2" Type="TArg2" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <typeparam name="TArg1">O tipo do segundo argumento passado para <c>beginMethod</c> delegar.</typeparam>
        <typeparam name="TArg2">O tipo do primeiro argumento passado para o <c>beginMethod</c> delegar.</typeparam>
        <typeparam name="TResult">O tipo de resultado disponível por meio de <see cref="T:System.Threading.Tasks.Task`1" />.</typeparam>
        <param name="beginMethod">O delegado que inicia a operação assíncrona.</param>
        <param name="endMethod">O delegado que finaliza a operação assíncrona.</param>
        <param name="arg1">O primeiro argumento passado para o representante <c>beginMethod</c>.</param>
        <param name="arg2">O segundo argumento passado para o representante <c>beginMethod</c>.</param>
        <param name="state">Um objeto que contém dados a serem usados pelo representante <c>beginMethod</c>.</param>
        <summary>Cria um <see cref="T:System.Threading.Tasks.Task`1" /> que representa um par de métodos begin e end que estão em conformidade com o padrão do Modelo de Programação Assíncrona.</summary>
        <returns>O <see cref="T:System.Threading.Tasks.Task`1" /> criado que representa a operação assíncrona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `beginMethod` delegado é iniciado no thread que <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> está em execução no. Esse método gera as exceções geradas pelo `beginMethod`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">A exceção lançada quando o argumento <paramref name="beginMethod" /> é nulo.  
  
- ou - 
A exceção lançada quando o argumento <paramref name="endMethod" /> é nulo.</exception>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TArg1,TArg2,TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; FromAsync&lt;TArg1,TArg2,TResult&gt; (Func&lt;TArg1,TArg2,AsyncCallback,object,IAsyncResult&gt; beginMethod, Func&lt;IAsyncResult,TResult&gt; endMethod, TArg1 arg1, TArg2 arg2, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromAsync&lt;TArg1, TArg2, TResult&gt;(class System.Func`5&lt;!!TArg1, !!TArg2, class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Func`2&lt;class System.IAsyncResult, !!TResult&gt; endMethod, !!TArg1 arg1, !!TArg2 arg2, object state, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync``3(System.Func{``0,``1,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``2},``0,``1,System.Object,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function FromAsync(Of TArg1, TArg2, TResult) (beginMethod As Func(Of TArg1, TArg2, AsyncCallback, Object, IAsyncResult), endMethod As Func(Of IAsyncResult, TResult), arg1 As TArg1, arg2 As TArg2, state As Object, creationOptions As TaskCreationOptions) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TArg1, typename TArg2, typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ FromAsync(Func&lt;TArg1, TArg2, AsyncCallback ^, System::Object ^, IAsyncResult ^&gt; ^ beginMethod, Func&lt;IAsyncResult ^, TResult&gt; ^ endMethod, TArg1 arg1, TArg2 arg2, System::Object ^ state, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="member this.FromAsync : Func&lt;'TArg1, 'TArg2, AsyncCallback, obj, IAsyncResult&gt; * Func&lt;IAsyncResult, 'Result&gt; * 'TArg1 * 'TArg2 * obj * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.FromAsync (beginMethod, endMethod, arg1, arg2, state, creationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TArg1" />
        <TypeParameter Name="TArg2" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;TArg1,TArg2,System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Func&lt;System.IAsyncResult,TResult&gt;" />
        <Parameter Name="arg1" Type="TArg1" />
        <Parameter Name="arg2" Type="TArg2" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TArg1">O tipo do segundo argumento passado para <c>beginMethod</c> delegar.</typeparam>
        <typeparam name="TArg2">O tipo do primeiro argumento passado para o <c>beginMethod</c> delegar.</typeparam>
        <typeparam name="TResult">O tipo de resultado disponível por meio de <see cref="T:System.Threading.Tasks.Task`1" />.</typeparam>
        <param name="beginMethod">O delegado que inicia a operação assíncrona.</param>
        <param name="endMethod">O delegado que finaliza a operação assíncrona.</param>
        <param name="arg1">O primeiro argumento passado para o representante <c>beginMethod</c>.</param>
        <param name="arg2">O segundo argumento passado para o representante <c>beginMethod</c>.</param>
        <param name="state">Um objeto que contém dados a serem usados pelo representante <c>beginMethod</c>.</param>
        <param name="creationOptions">O valor de TaskCreationOptions que controla o comportamento do <see cref="T:System.Threading.Tasks.Task`1" /> criado.</param>
        <summary>Cria um <see cref="T:System.Threading.Tasks.Task`1" /> que representa um par de métodos begin e end que estão em conformidade com o padrão do Modelo de Programação Assíncrona.</summary>
        <returns>O <see cref="T:System.Threading.Tasks.Task`1" /> criado que representa a operação assíncrona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `beginMethod` delegado é iniciado no thread que <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> está em execução no. Esse método gera as exceções geradas pelo `beginMethod`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">A exceção lançada quando o argumento <paramref name="beginMethod" /> é nulo.  
  
- ou - 
A exceção lançada quando o argumento <paramref name="endMethod" /> é nulo.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">A exceção lançada quando o argumento <paramref name="creationOptions" /> especifica um valor de TaskCreationOptions inválido. A exceção lançada quando o argumento <paramref name="creationOptions" /> especifica um valor de TaskCreationOptions inválido. Para obter mais informações, consulte as Observações para <see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" /></exception>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TArg1,TArg2,TArg3,TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; FromAsync&lt;TArg1,TArg2,TArg3,TResult&gt; (Func&lt;TArg1,TArg2,TArg3,AsyncCallback,object,IAsyncResult&gt; beginMethod, Func&lt;IAsyncResult,TResult&gt; endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromAsync&lt;TArg1, TArg2, TArg3, TResult&gt;(class System.Func`6&lt;!!TArg1, !!TArg2, !!TArg3, class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Func`2&lt;class System.IAsyncResult, !!TResult&gt; endMethod, !!TArg1 arg1, !!TArg2 arg2, !!TArg3 arg3, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync``4(System.Func{``0,``1,``2,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``3},``0,``1,``2,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function FromAsync(Of TArg1, TArg2, TArg3, TResult) (beginMethod As Func(Of TArg1, TArg2, TArg3, AsyncCallback, Object, IAsyncResult), endMethod As Func(Of IAsyncResult, TResult), arg1 As TArg1, arg2 As TArg2, arg3 As TArg3, state As Object) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TArg1, typename TArg2, typename TArg3, typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ FromAsync(Func&lt;TArg1, TArg2, TArg3, AsyncCallback ^, System::Object ^, IAsyncResult ^&gt; ^ beginMethod, Func&lt;IAsyncResult ^, TResult&gt; ^ endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.FromAsync : Func&lt;'TArg1, 'TArg2, 'TArg3, AsyncCallback, obj, IAsyncResult&gt; * Func&lt;IAsyncResult, 'Result&gt; * 'TArg1 * 'TArg2 * 'TArg3 * obj -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.FromAsync (beginMethod, endMethod, arg1, arg2, arg3, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TArg1" />
        <TypeParameter Name="TArg2" />
        <TypeParameter Name="TArg3" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;TArg1,TArg2,TArg3,System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Func&lt;System.IAsyncResult,TResult&gt;" />
        <Parameter Name="arg1" Type="TArg1" />
        <Parameter Name="arg2" Type="TArg2" />
        <Parameter Name="arg3" Type="TArg3" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <typeparam name="TArg1">O tipo do segundo argumento passado para <c>beginMethod</c> delegar.</typeparam>
        <typeparam name="TArg2">O tipo do terceiro argumento passado para <c>beginMethod</c> delegar.</typeparam>
        <typeparam name="TArg3">O tipo do primeiro argumento passado para o <c>beginMethod</c> delegar.</typeparam>
        <typeparam name="TResult">O tipo de resultado disponível por meio de <see cref="T:System.Threading.Tasks.Task`1" />.</typeparam>
        <param name="beginMethod">O delegado que inicia a operação assíncrona.</param>
        <param name="endMethod">O delegado que finaliza a operação assíncrona.</param>
        <param name="arg1">O primeiro argumento passado para o representante <c>beginMethod</c>.</param>
        <param name="arg2">O segundo argumento passado para o representante <c>beginMethod</c>.</param>
        <param name="arg3">O terceiro argumento passado para o representante <c>beginMethod</c>.</param>
        <param name="state">Um objeto que contém dados a serem usados pelo representante <c>beginMethod</c>.</param>
        <summary>Cria um <see cref="T:System.Threading.Tasks.Task`1" /> que representa um par de métodos begin e end que estão em conformidade com o padrão do Modelo de Programação Assíncrona.</summary>
        <returns>O <see cref="T:System.Threading.Tasks.Task`1" /> criado que representa a operação assíncrona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `beginMethod` delegado é iniciado no thread que <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> está em execução no. Esse método gera as exceções geradas pelo `beginMethod`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">A exceção lançada quando o argumento <paramref name="beginMethod" /> é nulo.  
  
- ou - 
A exceção lançada quando o argumento <paramref name="endMethod" /> é nulo.</exception>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TArg1,TArg2,TArg3,TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; FromAsync&lt;TArg1,TArg2,TArg3,TResult&gt; (Func&lt;TArg1,TArg2,TArg3,AsyncCallback,object,IAsyncResult&gt; beginMethod, Func&lt;IAsyncResult,TResult&gt; endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromAsync&lt;TArg1, TArg2, TArg3, TResult&gt;(class System.Func`6&lt;!!TArg1, !!TArg2, !!TArg3, class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Func`2&lt;class System.IAsyncResult, !!TResult&gt; endMethod, !!TArg1 arg1, !!TArg2 arg2, !!TArg3 arg3, object state, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync``4(System.Func{``0,``1,``2,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``3},``0,``1,``2,System.Object,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function FromAsync(Of TArg1, TArg2, TArg3, TResult) (beginMethod As Func(Of TArg1, TArg2, TArg3, AsyncCallback, Object, IAsyncResult), endMethod As Func(Of IAsyncResult, TResult), arg1 As TArg1, arg2 As TArg2, arg3 As TArg3, state As Object, creationOptions As TaskCreationOptions) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TArg1, typename TArg2, typename TArg3, typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ FromAsync(Func&lt;TArg1, TArg2, TArg3, AsyncCallback ^, System::Object ^, IAsyncResult ^&gt; ^ beginMethod, Func&lt;IAsyncResult ^, TResult&gt; ^ endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, System::Object ^ state, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="member this.FromAsync : Func&lt;'TArg1, 'TArg2, 'TArg3, AsyncCallback, obj, IAsyncResult&gt; * Func&lt;IAsyncResult, 'Result&gt; * 'TArg1 * 'TArg2 * 'TArg3 * obj * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.FromAsync (beginMethod, endMethod, arg1, arg2, arg3, state, creationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TArg1" />
        <TypeParameter Name="TArg2" />
        <TypeParameter Name="TArg3" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;TArg1,TArg2,TArg3,System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Func&lt;System.IAsyncResult,TResult&gt;" />
        <Parameter Name="arg1" Type="TArg1" />
        <Parameter Name="arg2" Type="TArg2" />
        <Parameter Name="arg3" Type="TArg3" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TArg1">O tipo do segundo argumento passado para <c>beginMethod</c> delegar.</typeparam>
        <typeparam name="TArg2">O tipo do terceiro argumento passado para <c>beginMethod</c> delegar.</typeparam>
        <typeparam name="TArg3">O tipo do primeiro argumento passado para o <c>beginMethod</c> delegar.</typeparam>
        <typeparam name="TResult">O tipo de resultado disponível por meio de <see cref="T:System.Threading.Tasks.Task`1" />.</typeparam>
        <param name="beginMethod">O delegado que inicia a operação assíncrona.</param>
        <param name="endMethod">O delegado que finaliza a operação assíncrona.</param>
        <param name="arg1">O primeiro argumento passado para o representante <c>beginMethod</c>.</param>
        <param name="arg2">O segundo argumento passado para o representante <c>beginMethod</c>.</param>
        <param name="arg3">O terceiro argumento passado para o representante <c>beginMethod</c>.</param>
        <param name="state">Um objeto que contém dados a serem usados pelo representante <c>beginMethod</c>.</param>
        <param name="creationOptions">O valor de TaskCreationOptions que controla o comportamento do <see cref="T:System.Threading.Tasks.Task`1" /> criado.</param>
        <summary>Cria um <see cref="T:System.Threading.Tasks.Task`1" /> que representa um par de métodos begin e end que estão em conformidade com o padrão do Modelo de Programação Assíncrona.</summary>
        <returns>O <see cref="T:System.Threading.Tasks.Task`1" /> criado que representa a operação assíncrona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `beginMethod` delegado é iniciado no thread que <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> está em execução no. Esse método gera as exceções geradas pelo `beginMethod`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">A exceção lançada quando o argumento <paramref name="beginMethod" /> é nulo.  
  
- ou - 
A exceção lançada quando o argumento <paramref name="endMethod" /> é nulo.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">A exceção lançada quando o argumento <paramref name="creationOptions" /> especifica um valor de TaskCreationOptions inválido. A exceção lançada quando o argumento <paramref name="creationOptions" /> especifica um valor de TaskCreationOptions inválido. Para obter mais informações, consulte as Observações para <see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" /></exception>
      </Docs>
    </Member>
    <Member MemberName="Scheduler">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.TaskScheduler Scheduler { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Threading.Tasks.TaskScheduler Scheduler" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskFactory.Scheduler" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Scheduler As TaskScheduler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::Tasks::TaskScheduler ^ Scheduler { System::Threading::Tasks::TaskScheduler ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Scheduler : System.Threading.Tasks.TaskScheduler" Usage="System.Threading.Tasks.TaskFactory.Scheduler" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskScheduler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o agendador de tarefas padrão para esta fábrica de tarefas.</summary>
        <value>O agendador de tarefas padrão para esta fábrica de tarefas.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor da propriedade é usado para agendar todas as tarefas, a menos que outro Agendador é explicitamente especificado durante as chamadas para métodos dessa fábrica.  
  
 Se o valor dessa propriedade é `null`, o valor da <xref:System.Threading.Tasks.TaskScheduler.Current%2A> propriedade é usada.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="StartNew">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Cria e inicia um <see cref="T:System.Threading.Tasks.Task" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Começando com o [!INCLUDE[net_v45](~/includes/net-v45-md.md)], o <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> método é a maneira recomendada para iniciar uma tarefa associada ao cálculo. Use o <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> método somente quando você precisar de um controle refinado para uma tarefa de execução longa e associadas ao cálculo. Isso inclui cenários em que você deseja controlar o seguinte:  
  
-   Opções de criação de tarefas. As tarefas criadas pela <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> método por padrão são criados com o <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType> opção. Para substituir esse comportamento, ou fornecer outros <xref:System.Threading.Tasks.TaskCreationOptions> opções, chame um <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> de sobrecarga.  
  
-   Passagem de parâmetro. As sobrecargas de <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> método permite que você passe um parâmetro para o delegado da tarefa. Sobrecargas do <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> método faz.  
  
-   O Agendador de tarefas. As sobrecargas de <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> método usar o Agendador de tarefas padrão. Para controlar o Agendador de tarefas, chamar um <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> sobrecarga com um `scheduler` parâmetro. Para obter mais informações, consulte.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="StartNew">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task StartNew (Action action);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task StartNew(class System.Action action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.StartNew(System.Action)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ StartNew(Action ^ action);" />
      <MemberSignature Language="F#" Value="member this.StartNew : Action -&gt; System.Threading.Tasks.Task" Usage="taskFactory.StartNew action" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Action" />
      </Parameters>
      <Docs>
        <param name="action">O delegado da ação a ser executado de forma assíncrona.</param>
        <summary>Cria e inicia uma tarefa.</summary>
        <returns>A tarefa iniciada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chamando <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> é funcionalmente equivalente à criação de uma tarefa usando um dos seus construtores e, em seguida, chamar o <xref:System.Threading.Tasks.Task.Start%2A?displayProperty=nameWithType> método para agendar a tarefa para execução.  
  
 Começando com o [!INCLUDE[net_v45](~/includes/net-v45-md.md)], você pode usar o <xref:System.Threading.Tasks.Task.Run%28System.Action%29?displayProperty=nameWithType> o método como uma maneira rápida de chamar <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%29> com parâmetros padrão. No entanto, observe que há uma diferença no comportamento entre os dois métodos em relação ao: <xref:System.Threading.Tasks.Task.Run%28System.Action%29?displayProperty=nameWithType> por padrão não permite filho tarefas iniciadas com o <xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent?displayProperty=nameWithType> opção de anexar à atual <xref:System.Threading.Tasks.Task> da instância, ao passo que <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%29> faz. Para obter mais informações e exemplos de código, consulte [Task. Run vs Task.Factory.StartNew](http://blogs.msdn.com/b/pfxteam/archive/2011/10/24/10229468.aspx) na programação paralela no blog do .NET.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%29> método a ser invocado repetidamente um <xref:System.Action> delegado que gera um número aleatório, interpreta como um ponto de código Unicode, converte-o em uma unidade de código UTF16 codificado e exibe informações sobre resultante caractere ou caracteres.  
  
 [!code-csharp[System.Threading.Tasks.TaskFactory.StartNew#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.taskfactory.startnew/cs/startnew1.cs#1)]
 [!code-vb[System.Threading.Tasks.TaskFactory.StartNew#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.taskfactory.startnew/vb/startnew1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O argumento <paramref name="action" /> é nulo.</exception>
      </Docs>
    </Member>
    <Member MemberName="StartNew">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task StartNew (Action action, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task StartNew(class System.Action action, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.StartNew(System.Action,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ StartNew(Action ^ action, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.StartNew : Action * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="taskFactory.StartNew (action, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Action" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="action">O delegado da ação a ser executado de forma assíncrona.</param>
        <param name="cancellationToken">O <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> que será atribuído a nova tarefa.</param>
        <summary>Cria e inicia um <see cref="T:System.Threading.Tasks.Task" />.</summary>
        <returns>O <see cref="T:System.Threading.Tasks.Task" /> iniciado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chamando `StartNew` é funcionalmente equivalente à criação de uma tarefa usando um dos seus construtores e em seguida, chamando <xref:System.Threading.Tasks.Task.Start%2A> agendá-lo para execução.  
  
 Começando com o [!INCLUDE[net_v45](~/includes/net-v45-md.md)], você pode usar o <xref:System.Threading.Tasks.Task.Run%28System.Action%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType> o método como uma maneira rápida de chamar <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.CancellationToken%29> com parâmetros padrão. No entanto, observe que há uma diferença no comportamento entre os dois métodos em relação ao: <xref:System.Threading.Tasks.Task.Run%28System.Action%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType> por padrão não permite filho tarefas iniciadas com o <xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent?displayProperty=nameWithType> opção de anexar à atual <xref:System.Threading.Tasks.Task> da instância, ao passo que <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.CancellationToken%29> faz. Para obter mais informações e exemplos de código, consulte [Task. Run vs Task.Factory.StartNew](http://blogs.msdn.com/b/pfxteam/archive/2011/10/24/10229468.aspx) na programação paralela no blog do .NET.  
  
   
  
## Examples  
 A exemplo a seguir chama o <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.CancellationToken%29> método para criar uma tarefa que itera os arquivos no diretório C:\Windows\System32. A expressão de lambda chama o <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> método para adicionar informações sobre cada arquivo a um <xref:System.Collections.Generic.List%601> objeto. Cada desanexado tarefa aninhada invocada pelo <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> loop verifica o estado do token de cancelamento e, se for solicitado um cancelamento, chama o <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> método. O <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> método lança um <xref:System.OperationCanceledException> exceção que é tratada em um `catch` bloquear quando o thread de chamada chama o <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> método.  
  
 [!code-csharp[System.Threading.Tasks.TaskFactory.StartNew#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.taskfactory.startnew/cs/startnew2.cs#2)]
 [!code-vb[System.Threading.Tasks.TaskFactory.StartNew#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.taskfactory.startnew/vb/startnew2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Threading.CancellationToken" /> fornecido já foi descartado.</exception>
        <exception cref="T:System.ArgumentNullException">A exceção lançada quando o argumento <paramref name="action" /> é nulo.</exception>
      </Docs>
    </Member>
    <Member MemberName="StartNew">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task StartNew (Action action, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task StartNew(class System.Action action, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.StartNew(System.Action,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ StartNew(Action ^ action, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="member this.StartNew : Action * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task" Usage="taskFactory.StartNew (action, creationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Action" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="action">O delegado da ação a ser executado de forma assíncrona.</param>
        <param name="creationOptions">Um valor de TaskCreationOptions que controla o comportamento do <see cref="T:System.Threading.Tasks.Task" /> criado</param>
        <summary>Cria e inicia um <see cref="T:System.Threading.Tasks.Task" />.</summary>
        <returns>O <see cref="T:System.Threading.Tasks.Task" /> iniciado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chamar StartNew é funcionalmente equivalente à criação de uma tarefa usando um dos seus construtores e em seguida, chamando <xref:System.Threading.Tasks.Task.Start%2A> agendá-lo para execução.  
  
 Começando com o [!INCLUDE[net_v45](~/includes/net-v45-md.md)], você pode usar o <xref:System.Threading.Tasks.Task.Run%2A> método com um <xref:System.Action> objeto como uma maneira rápida para chamar <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> com parâmetros padrão. Para obter mais informações e exemplos de código, consulte [Task. Run vs Task.Factory.StartNew](http://blogs.msdn.com/b/pfxteam/archive/2011/10/24/10229468.aspx) na programação paralela no blog do .NET.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">A exceção lançada quando o argumento <paramref name="action" /> é nulo.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">A exceção lançada quando o argumento <paramref name="creationOptions" /> especifica um valor de TaskCreationOptions inválido.</exception>
      </Docs>
    </Member>
    <Member MemberName="StartNew">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task StartNew (Action&lt;object&gt; action, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task StartNew(class System.Action`1&lt;object&gt; action, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.StartNew(System.Action{System.Object},System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartNew (action As Action(Of Object), state As Object) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ StartNew(Action&lt;System::Object ^&gt; ^ action, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.StartNew : Action&lt;obj&gt; * obj -&gt; System.Threading.Tasks.Task" Usage="taskFactory.StartNew (action, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Action&lt;System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="action">O delegado da ação a ser executado de forma assíncrona.</param>
        <param name="state">Um objeto que contém dados a serem usados pelo representante de <c>action</c>.</param>
        <summary>Cria e inicia um <see cref="T:System.Threading.Tasks.Task" />.</summary>
        <returns>O <see cref="T:System.Threading.Tasks.Task" /> iniciado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chamando <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> é funcionalmente equivalente à criação de um <xref:System.Threading.Tasks.Task> usando um dos seus construtores e, em seguida, chamar o <xref:System.Threading.Tasks.Task.Start%2A> método agendá-lo para execução.  
  
 Começando com o [!INCLUDE[net_v45](~/includes/net-v45-md.md)], você pode usar o <xref:System.Threading.Tasks.Task.Run%2A> método com um <xref:System.Action> objeto como uma maneira rápida para chamar <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> com parâmetros padrão. Para obter mais informações e exemplos de código, consulte [Task. Run vs Task.Factory.StartNew](http://blogs.msdn.com/b/pfxteam/archive/2011/10/24/10229468.aspx) na programação paralela no blog do .NET.  
  
   
  
## Examples  
 O exemplo a seguir define uma matriz de palavras de letras de 6. Cada palavra é então passada para um <xref:System.Action%601> delegado, que embaralha a palavra e exibe a palavra original e sua versão embaralhado.  
  
 [!code-csharp[System.Threading.Tasks.TaskFactory.StartNew#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.taskfactory.startnew/cs/startnew3.cs#3)]
 [!code-vb[System.Threading.Tasks.TaskFactory.StartNew#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.taskfactory.startnew/vb/startnew3.vb#3)]  
  
 Observe que o exemplo inicializa um único número aleatório, que é protegido por um bloqueio. Para a necessidade de um bloqueio, consulte "A Random classe e o thread de segurança" no <xref:System.Random> tópico da classe.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O argumento <paramref name="action" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="StartNew">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task StartNew (Action&lt;object&gt; action, object state, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task StartNew(class System.Action`1&lt;object&gt; action, object state, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.StartNew(System.Action{System.Object},System.Object,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ StartNew(Action&lt;System::Object ^&gt; ^ action, System::Object ^ state, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.StartNew : Action&lt;obj&gt; * obj * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="taskFactory.StartNew (action, state, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Action&lt;System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="action">O delegado da ação a ser executado de forma assíncrona.</param>
        <param name="state">Um objeto que contém dados a serem usados pelo representante de <c>action</c>.</param>
        <param name="cancellationToken">O <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> que será atribuído ao novo <see cref="T:System.Threading.Tasks.Task" /></param>
        <summary>Cria e inicia um <see cref="T:System.Threading.Tasks.Task" />.</summary>
        <returns>O <see cref="T:System.Threading.Tasks.Task" /> iniciado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chamar StartNew é funcionalmente equivalente à criação de uma tarefa usando um dos seus construtores e em seguida, chamando <xref:System.Threading.Tasks.Task.Start%2A> agendá-lo para execução.  
  
 Começando com o [!INCLUDE[net_v45](~/includes/net-v45-md.md)], você pode usar o <xref:System.Threading.Tasks.Task.Run%2A> método com um <xref:System.Action> objeto como uma maneira rápida para chamar <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> com parâmetros padrão. Para obter mais informações e exemplos de código, consulte [Task. Run vs Task.Factory.StartNew](http://blogs.msdn.com/b/pfxteam/archive/2011/10/24/10229468.aspx) na programação paralela no blog do .NET.  
  
   
  
## Examples  
 O exemplo a seguir define uma matriz de palavras de letras de 6. Cada palavra é então passada para um <xref:System.Action%601> delegado, que embaralha a palavra e exibe a palavra original e sua versão embaralhado.  
  
 [!code-csharp[System.Threading.Tasks.TaskFactory.StartNew#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.taskfactory.startnew/cs/startnew4.cs#4)]
 [!code-vb[System.Threading.Tasks.TaskFactory.StartNew#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.taskfactory.startnew/vb/startnew4.vb#4)]  
  
 Observe que o exemplo inicializa um único número aleatório, que é protegido por um bloqueio. Para a necessidade de um bloqueio, consulte "A Random classe e o thread de segurança" no <xref:System.Random> tópico da classe. Para lidar com a possibilidade de corrupção do gerador de número aleatório, um token de cancelamento é passado para a tarefa. Se dois números aleatórios igual a zero, o método pressupõe que o gerador de número aleatório está corrompido e define o token de cancelamento. Antes de classificar o `chars` matriz que contém os seis caracteres de palavra, as chamadas de método de <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> método para lançar um <xref:System.OperationCanceledException> se o token foi cancelado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Threading.CancellationToken" /> fornecido já foi descartado.</exception>
        <exception cref="T:System.ArgumentNullException">A exceção lançada quando o argumento <paramref name="action" /> é nulo.</exception>
      </Docs>
    </Member>
    <Member MemberName="StartNew">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task StartNew (Action&lt;object&gt; action, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task StartNew(class System.Action`1&lt;object&gt; action, object state, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.StartNew(System.Action{System.Object},System.Object,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartNew (action As Action(Of Object), state As Object, creationOptions As TaskCreationOptions) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ StartNew(Action&lt;System::Object ^&gt; ^ action, System::Object ^ state, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="member this.StartNew : Action&lt;obj&gt; * obj * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task" Usage="taskFactory.StartNew (action, state, creationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Action&lt;System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="action">O delegado da ação a ser executado de forma assíncrona.</param>
        <param name="state">Um objeto que contém dados a serem usados pelo representante de <c>action</c>.</param>
        <param name="creationOptions">Um valor de TaskCreationOptions que controla o comportamento do <see cref="T:System.Threading.Tasks.Task" /> criado</param>
        <summary>Cria e inicia um <see cref="T:System.Threading.Tasks.Task" />.</summary>
        <returns>O <see cref="T:System.Threading.Tasks.Task" /> iniciado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chamar StartNew é funcionalmente equivalente à criação de uma tarefa usando um dos seus construtores e em seguida, chamando <xref:System.Threading.Tasks.Task.Start%2A> agendá-lo para execução.  
  
 Começando com o [!INCLUDE[net_v45](~/includes/net-v45-md.md)], você pode usar o <xref:System.Threading.Tasks.Task.Run%2A> método com um <xref:System.Action> objeto como uma maneira rápida para chamar <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> com parâmetros padrão. Para obter mais informações e exemplos de código, consulte [Task. Run vs Task.Factory.StartNew](http://blogs.msdn.com/b/pfxteam/archive/2011/10/24/10229468.aspx) na programação paralela no blog do .NET.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">A exceção lançada quando o argumento <paramref name="action" /> é nulo.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">A exceção lançada quando o argumento <paramref name="creationOptions" /> especifica um valor de TaskCreationOptions inválido.</exception>
      </Docs>
    </Member>
    <Member MemberName="StartNew">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task StartNew (Action action, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task StartNew(class System.Action action, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.StartNew(System.Action,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ StartNew(Action ^ action, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskCreationOptions creationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.StartNew : Action * System.Threading.CancellationToken * System.Threading.Tasks.TaskCreationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task" Usage="taskFactory.StartNew (action, cancellationToken, creationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Action" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="action">O delegado da ação a ser executado de forma assíncrona.</param>
        <param name="cancellationToken">O <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> que será atribuído ao novo <see cref="T:System.Threading.Tasks.Task" /></param>
        <param name="creationOptions">Um valor de TaskCreationOptions que controla o comportamento do <see cref="T:System.Threading.Tasks.Task" /> criado</param>
        <param name="scheduler">O <see cref="T:System.Threading.Tasks.TaskScheduler" /> usado para agendar o <see cref="T:System.Threading.Tasks.Task" /> criado.</param>
        <summary>Cria e inicia um <see cref="T:System.Threading.Tasks.Task" />.</summary>
        <returns>O <see cref="T:System.Threading.Tasks.Task" /> iniciado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chamar StartNew é funcionalmente equivalente à criação de uma tarefa usando um dos seus construtores e em seguida, chamando <xref:System.Threading.Tasks.Task.Start%2A> agendá-lo para execução.  
  
 Começando com o [!INCLUDE[net_v45](~/includes/net-v45-md.md)], você pode usar o <xref:System.Threading.Tasks.Task.Run%2A> método com um <xref:System.Action> objeto como uma maneira rápida para chamar <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> com parâmetros padrão. Para obter mais informações e exemplos de código, consulte [Task. Run vs Task.Factory.StartNew](http://blogs.msdn.com/b/pfxteam/archive/2011/10/24/10229468.aspx) na programação paralela no blog do .NET.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Threading.CancellationToken" /> fornecido já foi descartado.</exception>
        <exception cref="T:System.ArgumentNullException">A exceção lançada quando o argumento <paramref name="action" /> é nulo.  
  
- ou - 
A exceção lançada quando o argumento <paramref name="scheduler" /> é nulo.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">A exceção lançada quando o argumento <paramref name="creationOptions" /> especifica um valor de TaskCreationOptions inválido. A exceção lançada quando o argumento <paramref name="creationOptions" /> especifica um valor de TaskCreationOptions inválido. Para obter mais informações, consulte as Observações para <see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" /></exception>
      </Docs>
    </Member>
    <Member MemberName="StartNew">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task StartNew (Action&lt;object&gt; action, object state, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task StartNew(class System.Action`1&lt;object&gt; action, object state, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.StartNew(System.Action{System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ StartNew(Action&lt;System::Object ^&gt; ^ action, System::Object ^ state, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskCreationOptions creationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.StartNew : Action&lt;obj&gt; * obj * System.Threading.CancellationToken * System.Threading.Tasks.TaskCreationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task" Usage="taskFactory.StartNew (action, state, cancellationToken, creationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Action&lt;System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="action">O delegado da ação a ser executado de forma assíncrona.</param>
        <param name="state">Um objeto que contém dados a serem usados pelo representante de <c>action</c>.</param>
        <param name="cancellationToken">O <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> que será atribuído a nova tarefa.</param>
        <param name="creationOptions">Um valor de TaskCreationOptions que controla o comportamento do <see cref="T:System.Threading.Tasks.Task" /> criado</param>
        <param name="scheduler">O <see cref="T:System.Threading.Tasks.TaskScheduler" /> usado para agendar o <see cref="T:System.Threading.Tasks.Task" /> criado.</param>
        <summary>Cria e inicia um <see cref="T:System.Threading.Tasks.Task" />.</summary>
        <returns>O <see cref="T:System.Threading.Tasks.Task" /> iniciado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chamar StartNew é funcionalmente equivalente à criação de uma tarefa usando um dos seus construtores e em seguida, chamando <xref:System.Threading.Tasks.Task.Start%2A> agendá-lo para execução.  
  
 Começando com o [!INCLUDE[net_v45](~/includes/net-v45-md.md)], você pode usar o <xref:System.Threading.Tasks.Task.Run%2A> método com um <xref:System.Action> objeto como uma maneira rápida para chamar <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> com parâmetros padrão. Para obter mais informações e exemplos de código, consulte [Task. Run vs Task.Factory.StartNew](http://blogs.msdn.com/b/pfxteam/archive/2011/10/24/10229468.aspx) na programação paralela no blog do .NET.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Threading.CancellationToken" /> fornecido já foi descartado.</exception>
        <exception cref="T:System.ArgumentNullException">A exceção lançada quando o argumento <paramref name="action" /> é nulo.  
  
- ou - 
A exceção lançada quando o argumento <paramref name="scheduler" /> é nulo.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">A exceção lançada quando o argumento <paramref name="creationOptions" /> especifica um valor de TaskCreationOptions inválido. A exceção lançada quando o argumento <paramref name="creationOptions" /> especifica um valor de TaskCreationOptions inválido. Para obter mais informações, consulte as Observações para <see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" /></exception>
      </Docs>
    </Member>
    <Member MemberName="StartNew&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; StartNew&lt;TResult&gt; (Func&lt;TResult&gt; function);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; StartNew&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; function) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.StartNew``1(System.Func{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function StartNew(Of TResult) (function As Func(Of TResult)) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ StartNew(Func&lt;TResult&gt; ^ function);" />
      <MemberSignature Language="F#" Value="member this.StartNew : Func&lt;'Result&gt; -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.StartNew function" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">O tipo de resultado disponível por meio de <see cref="T:System.Threading.Tasks.Task`1" />.</typeparam>
        <param name="function">Um delegado de função que retorna o resultado futuro que estará disponível por meio do <see cref="T:System.Threading.Tasks.Task`1" />.</param>
        <summary>Cria e inicia um <see cref="T:System.Threading.Tasks.Task`1" />.</summary>
        <returns>O <see cref="T:System.Threading.Tasks.Task`1" /> iniciado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chamando <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> é funcionalmente equivalente à criação de um <xref:System.Threading.Tasks.Task%601> usando um dos seus construtores e, em seguida, chamar <xref:System.Threading.Tasks.Task.Start%2A> agendá-lo para execução.  
  
 Começando com o [!INCLUDE[net_v45](~/includes/net-v45-md.md)], você pode chamar o <xref:System.Threading.Tasks.Task.Run%60%601%28System.Func%7B%60%600%7D%29?displayProperty=nameWithType> o método como uma maneira rápida de chamar <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> com parâmetros padrão. No entanto, observe que há uma diferença no comportamento entre os dois métodos em relação ao: <xref:System.Threading.Tasks.Task.Run%60%601%28System.Func%7B%60%600%7D%29?displayProperty=nameWithType> por padrão não permite filho tarefas iniciadas com o <xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent?displayProperty=nameWithType> opção de anexar à atual <xref:System.Threading.Tasks.Task%601> da instância, ao passo que <xref:System.Threading.Tasks.TaskFactory.StartNew%60%601%28System.Func%7B%60%600%7D%29> faz. Para obter mais informações e exemplos de código, consulte a entrada [Task. Run vs. Task.Factory.StartNew](http://blogs.msdn.com/b/pfxteam/archive/2011/10/24/10229468.aspx) na programação paralela no blog do .NET.  
  
   
  
## Examples  
 O exemplo a seguir é um aplicativo de adição simples que gera dois números aleatórios e solicita que o usuário insira sua soma. Em seguida, indica se a resposta está correta ou, se a resposta do usuário não é um número válido, solicita que o usuário insira novamente um número válido. O <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> é usado para criar o <xref:System.Threading.Tasks.Task%601> objetos que retornam os números aleatórios para adicionar.  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/run5.cs#5)]
 [!code-vb[System.Threading.Tasks.Task.Run#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/run5.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O argumento <paramref name="function" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="StartNew&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; StartNew&lt;TResult&gt; (Func&lt;object,TResult&gt; function, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; StartNew&lt;TResult&gt;(class System.Func`2&lt;object, !!TResult&gt; function, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.StartNew``1(System.Func{System.Object,``0},System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartNew(Of TResult) (function As Func(Of Object, TResult), state As Object) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ StartNew(Func&lt;System::Object ^, TResult&gt; ^ function, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.StartNew : Func&lt;obj, 'Result&gt; * obj -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.StartNew (function, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Object,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">O tipo de resultado disponível por meio de <see cref="T:System.Threading.Tasks.Task`1" />.</typeparam>
        <param name="function">Um delegado de função que retorna o resultado futuro que estará disponível por meio do <see cref="T:System.Threading.Tasks.Task`1" />.</param>
        <param name="state">Um objeto que contém dados a serem usados pelo representante de <c>function</c>.</param>
        <summary>Cria e inicia um <see cref="T:System.Threading.Tasks.Task`1" />.</summary>
        <returns>O <see cref="T:System.Threading.Tasks.Task`1" /> iniciado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chamar StartNew é funcionalmente equivalente à criação de um <xref:System.Threading.Tasks.Task%601> usando um dos seus construtores e, em seguida, chamar <xref:System.Threading.Tasks.Task.Start%2A> agendá-lo para execução.  
  
 Começando com o [!INCLUDE[net_v45](~/includes/net-v45-md.md)], você pode usar o <xref:System.Threading.Tasks.Task.Run%2A> método com um <xref:System.Action> objeto como uma maneira rápida para chamar <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> com parâmetros padrão. Para obter mais informações e exemplos de código, consulte a entrada [Task. Run vs. Task.Factory.StartNew](http://blogs.msdn.com/b/pfxteam/archive/2011/10/24/10229468.aspx) na programação paralela no blog do .NET.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">A exceção lançada quando o argumento <paramref name="function" /> é nulo.</exception>
      </Docs>
    </Member>
    <Member MemberName="StartNew&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; StartNew&lt;TResult&gt; (Func&lt;TResult&gt; function, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; StartNew&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; function, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.StartNew``1(System.Func{``0},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ StartNew(Func&lt;TResult&gt; ^ function, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.StartNew : Func&lt;'Result&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.StartNew (function, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">O tipo de resultado disponível por meio de <see cref="T:System.Threading.Tasks.Task`1" />.</typeparam>
        <param name="function">Um delegado de função que retorna o resultado futuro que estará disponível por meio do <see cref="T:System.Threading.Tasks.Task`1" />.</param>
        <param name="cancellationToken">O <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> que será atribuído ao novo <see cref="T:System.Threading.Tasks.Task" /></param>
        <summary>Cria e inicia um <see cref="T:System.Threading.Tasks.Task`1" />.</summary>
        <returns>O <see cref="T:System.Threading.Tasks.Task`1" /> iniciado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chamando <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> é funcionalmente equivalente à criação de um <xref:System.Threading.Tasks.Task%601> usando um dos seus construtores e, em seguida, chamar <xref:System.Threading.Tasks.Task.Start%2A> agendá-lo para execução.  
  
 Começando com o [!INCLUDE[net_v45](~/includes/net-v45-md.md)], você pode usar o <xref:System.Threading.Tasks.Task.Run%60%601%28System.Func%7B%60%600%7D%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType> o método como uma maneira rápida de chamar <xref:System.Threading.Tasks.TaskFactory.StartNew%60%601%28System.Func%7B%60%600%7D%2CSystem.Threading.CancellationToken%29> com parâmetros padrão. No entanto, observe que há uma diferença no comportamento entre os dois métodos em relação ao: <xref:System.Threading.Tasks.Task.Run%60%601%28System.Func%7B%60%600%7D%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType> por padrão não permite filho tarefas iniciadas com o <xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent?displayProperty=nameWithType> opção de anexar à atual <xref:System.Threading.Tasks.Task%601> da instância, ao passo que <xref:System.Threading.Tasks.TaskFactory.StartNew%60%601%28System.Func%7B%60%600%7D%2CSystem.Threading.CancellationToken%29> faz. Para obter mais informações e exemplos de código, consulte a entrada [Task. Run vs. Task.Factory.StartNew](http://blogs.msdn.com/b/pfxteam/archive/2011/10/24/10229468.aspx) na programação paralela no blog do .NET.  
  
   
  
## Examples  
 O exemplo a seguir usa duas tarefas para computar a sequência de Fibonacci terminando em F100 = F100 1 + 2 F100 com valores de semente F1 = 1, F2 = 1 e F1 = 0, F2 = 1. Aproximadamente metade do tempo, um token de cancelamento é definido como executar as operações. A saída do exemplo mostra o resultado se as duas tarefas concluídas com êxito e se o token for cancelado.  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/Run9.cs#9)]
 [!code-vb[System.Threading.Tasks.Task.Run#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/Run9.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Threading.CancellationToken" /> fornecido já foi descartado.</exception>
        <exception cref="T:System.ArgumentNullException">A exceção lançada quando o argumento <paramref name="function" /> é nulo.</exception>
      </Docs>
    </Member>
    <Member MemberName="StartNew&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; StartNew&lt;TResult&gt; (Func&lt;TResult&gt; function, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; StartNew&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; function, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.StartNew``1(System.Func{``0},System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartNew(Of TResult) (function As Func(Of TResult), creationOptions As TaskCreationOptions) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ StartNew(Func&lt;TResult&gt; ^ function, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="member this.StartNew : Func&lt;'Result&gt; * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.StartNew (function, creationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;TResult&gt;" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">O tipo de resultado disponível por meio de <see cref="T:System.Threading.Tasks.Task`1" />.</typeparam>
        <param name="function">Um delegado de função que retorna o resultado futuro que estará disponível por meio do <see cref="T:System.Threading.Tasks.Task`1" />.</param>
        <param name="creationOptions">Um valor de TaskCreationOptions que controla o comportamento do <see cref="T:System.Threading.Tasks.Task`1" /> criado.</param>
        <summary>Cria e inicia um <see cref="T:System.Threading.Tasks.Task`1" />.</summary>
        <returns>O <see cref="T:System.Threading.Tasks.Task`1" /> iniciado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chamar StartNew é funcionalmente equivalente à criação de um <xref:System.Threading.Tasks.Task%601> usando um dos seus construtores e, em seguida, chamar <xref:System.Threading.Tasks.Task.Start%2A> agendá-lo para execução.  
  
 Começando com o [!INCLUDE[net_v45](~/includes/net-v45-md.md)], você pode usar o <xref:System.Threading.Tasks.Task.Run%2A> método com um <xref:System.Action> objeto como uma maneira rápida para chamar <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> com parâmetros padrão. Para obter mais informações e exemplos de código, consulte a entrada [Task. Run vs. Task.Factory.StartNew](http://blogs.msdn.com/b/pfxteam/archive/2011/10/24/10229468.aspx) na programação paralela no blog do .NET.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">A exceção lançada quando o argumento <paramref name="function" /> é nulo.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">A exceção lançada quando o argumento <paramref name="creationOptions" /> especifica um valor de TaskCreationOptions inválido. A exceção lançada quando o argumento <paramref name="creationOptions" /> especifica um valor de TaskCreationOptions inválido. Para obter mais informações, consulte as Observações para <see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" /></exception>
      </Docs>
    </Member>
    <Member MemberName="StartNew&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; StartNew&lt;TResult&gt; (Func&lt;object,TResult&gt; function, object state, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; StartNew&lt;TResult&gt;(class System.Func`2&lt;object, !!TResult&gt; function, object state, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.StartNew``1(System.Func{System.Object,``0},System.Object,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ StartNew(Func&lt;System::Object ^, TResult&gt; ^ function, System::Object ^ state, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.StartNew : Func&lt;obj, 'Result&gt; * obj * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.StartNew (function, state, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Object,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">O tipo de resultado disponível por meio de <see cref="T:System.Threading.Tasks.Task`1" />.</typeparam>
        <param name="function">Um delegado de função que retorna o resultado futuro que estará disponível por meio do <see cref="T:System.Threading.Tasks.Task`1" />.</param>
        <param name="state">Um objeto que contém dados a serem usados pelo representante de <c>function</c>.</param>
        <param name="cancellationToken">O <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> que será atribuído ao novo <see cref="T:System.Threading.Tasks.Task" /></param>
        <summary>Cria e inicia um <see cref="T:System.Threading.Tasks.Task`1" />.</summary>
        <returns>O <see cref="T:System.Threading.Tasks.Task`1" /> iniciado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chamar StartNew é funcionalmente equivalente à criação de um <xref:System.Threading.Tasks.Task%601> usando um dos seus construtores e, em seguida, chamar <xref:System.Threading.Tasks.Task.Start%2A> agendá-lo para execução.  
  
 Começando com o [!INCLUDE[net_v45](~/includes/net-v45-md.md)], você pode usar o <xref:System.Threading.Tasks.Task.Run%2A> método com um <xref:System.Action> objeto como uma maneira rápida para chamar <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> com parâmetros padrão. Para obter mais informações e exemplos de código, consulte a entrada [Task. Run vs. Task.Factory.StartNew](http://blogs.msdn.com/b/pfxteam/archive/2011/10/24/10229468.aspx) na programação paralela no blog do .NET.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Threading.CancellationToken" /> fornecido já foi descartado.</exception>
        <exception cref="T:System.ArgumentNullException">A exceção lançada quando o argumento <paramref name="function" /> é nulo.</exception>
      </Docs>
    </Member>
    <Member MemberName="StartNew&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; StartNew&lt;TResult&gt; (Func&lt;object,TResult&gt; function, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; StartNew&lt;TResult&gt;(class System.Func`2&lt;object, !!TResult&gt; function, object state, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.StartNew``1(System.Func{System.Object,``0},System.Object,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartNew(Of TResult) (function As Func(Of Object, TResult), state As Object, creationOptions As TaskCreationOptions) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ StartNew(Func&lt;System::Object ^, TResult&gt; ^ function, System::Object ^ state, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="member this.StartNew : Func&lt;obj, 'Result&gt; * obj * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.StartNew (function, state, creationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Object,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">O tipo de resultado disponível por meio de <see cref="T:System.Threading.Tasks.Task`1" />.</typeparam>
        <param name="function">Um delegado de função que retorna o resultado futuro que estará disponível por meio do <see cref="T:System.Threading.Tasks.Task`1" />.</param>
        <param name="state">Um objeto que contém dados a serem usados pelo representante de <c>function</c>.</param>
        <param name="creationOptions">Um valor de TaskCreationOptions que controla o comportamento do <see cref="T:System.Threading.Tasks.Task`1" /> criado.</param>
        <summary>Cria e inicia um <see cref="T:System.Threading.Tasks.Task`1" />.</summary>
        <returns>O <see cref="T:System.Threading.Tasks.Task`1" /> iniciado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chamar StartNew é funcionalmente equivalente à criação de um <xref:System.Threading.Tasks.Task%601> usando um dos seus construtores e, em seguida, chamar <xref:System.Threading.Tasks.Task.Start%2A> agendá-lo para execução.  
  
 Começando com o [!INCLUDE[net_v45](~/includes/net-v45-md.md)], você pode usar o <xref:System.Threading.Tasks.Task.Run%2A> método com um <xref:System.Action> objeto como uma maneira rápida para chamar <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> com parâmetros padrão. Para obter mais informações e exemplos de código, consulte a entrada [Task. Run vs. Task.Factory.StartNew](http://blogs.msdn.com/b/pfxteam/archive/2011/10/24/10229468.aspx) na programação paralela no blog do .NET.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">A exceção lançada quando o argumento <paramref name="function" /> é nulo.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">A exceção lançada quando o argumento <paramref name="creationOptions" /> especifica um valor de TaskCreationOptions inválido. A exceção lançada quando o argumento <paramref name="creationOptions" /> especifica um valor de TaskCreationOptions inválido. Para obter mais informações, consulte as Observações para <see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" /></exception>
      </Docs>
    </Member>
    <Member MemberName="StartNew&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; StartNew&lt;TResult&gt; (Func&lt;TResult&gt; function, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; StartNew&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; function, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.StartNew``1(System.Func{``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ StartNew(Func&lt;TResult&gt; ^ function, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskCreationOptions creationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.StartNew : Func&lt;'Result&gt; * System.Threading.CancellationToken * System.Threading.Tasks.TaskCreationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.StartNew (function, cancellationToken, creationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">O tipo de resultado disponível por meio de <see cref="T:System.Threading.Tasks.Task`1" />.</typeparam>
        <param name="function">Um delegado de função que retorna o resultado futuro que estará disponível por meio do <see cref="T:System.Threading.Tasks.Task`1" />.</param>
        <param name="cancellationToken">O <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> que será atribuído a nova tarefa.</param>
        <param name="creationOptions">Um valor de TaskCreationOptions que controla o comportamento do <see cref="T:System.Threading.Tasks.Task`1" /> criado.</param>
        <param name="scheduler">O <see cref="T:System.Threading.Tasks.TaskScheduler" /> usado para agendar o <see cref="T:System.Threading.Tasks.Task`1" /> criado.</param>
        <summary>Cria e inicia um <see cref="T:System.Threading.Tasks.Task`1" />.</summary>
        <returns>O <see cref="T:System.Threading.Tasks.Task`1" /> iniciado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chamar StartNew é funcionalmente equivalente à criação de um <xref:System.Threading.Tasks.Task%601> usando um dos seus construtores e, em seguida, chamar <xref:System.Threading.Tasks.Task.Start%2A> agendá-lo para execução.  
  
 Começando com o [!INCLUDE[net_v45](~/includes/net-v45-md.md)], você pode usar o <xref:System.Threading.Tasks.Task.Run%2A> método com um <xref:System.Action> objeto como uma maneira rápida para chamar <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> com parâmetros padrão. Para obter mais informações e exemplos de código, consulte a entrada [Task. Run vs. Task.Factory.StartNew](http://blogs.msdn.com/b/pfxteam/archive/2011/10/24/10229468.aspx) na programação paralela no blog do .NET.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Threading.CancellationToken" /> fornecido já foi descartado.</exception>
        <exception cref="T:System.ArgumentNullException">A exceção lançada quando o argumento <paramref name="function" /> é nulo.  
  
- ou - 
A exceção lançada quando o argumento <paramref name="scheduler" /> é nulo.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">A exceção lançada quando o argumento <paramref name="creationOptions" /> especifica um valor de TaskCreationOptions inválido. A exceção lançada quando o argumento <paramref name="creationOptions" /> especifica um valor de TaskCreationOptions inválido. Para obter mais informações, consulte as Observações para <see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" /></exception>
      </Docs>
    </Member>
    <Member MemberName="StartNew&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; StartNew&lt;TResult&gt; (Func&lt;object,TResult&gt; function, object state, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; StartNew&lt;TResult&gt;(class System.Func`2&lt;object, !!TResult&gt; function, object state, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.StartNew``1(System.Func{System.Object,``0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ StartNew(Func&lt;System::Object ^, TResult&gt; ^ function, System::Object ^ state, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskCreationOptions creationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.StartNew : Func&lt;obj, 'Result&gt; * obj * System.Threading.CancellationToken * System.Threading.Tasks.TaskCreationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.StartNew (function, state, cancellationToken, creationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Object,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">O tipo de resultado disponível por meio de <see cref="T:System.Threading.Tasks.Task`1" />.</typeparam>
        <param name="function">Um delegado de função que retorna o resultado futuro que estará disponível por meio do <see cref="T:System.Threading.Tasks.Task`1" />.</param>
        <param name="state">Um objeto que contém dados a serem usados pelo representante de <c>function</c>.</param>
        <param name="cancellationToken">O <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> que será atribuído a nova tarefa.</param>
        <param name="creationOptions">Um valor de TaskCreationOptions que controla o comportamento do <see cref="T:System.Threading.Tasks.Task`1" /> criado.</param>
        <param name="scheduler">O <see cref="T:System.Threading.Tasks.TaskScheduler" /> usado para agendar o <see cref="T:System.Threading.Tasks.Task`1" /> criado.</param>
        <summary>Cria e inicia um <see cref="T:System.Threading.Tasks.Task`1" />.</summary>
        <returns>O <see cref="T:System.Threading.Tasks.Task`1" /> iniciado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chamar StartNew é funcionalmente equivalente à criação de um <xref:System.Threading.Tasks.Task%601> usando um dos seus construtores e, em seguida, chamar <xref:System.Threading.Tasks.Task.Start%2A> agendá-lo para execução.  
  
 Começando com o [!INCLUDE[net_v45](~/includes/net-v45-md.md)], você pode usar o <xref:System.Threading.Tasks.Task.Run%2A> método com um <xref:System.Action> objeto como uma maneira rápida para chamar <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> com parâmetros padrão. Para obter mais informações e exemplos de código, consulte a entrada [Task. Run vs. Task.Factory.StartNew](http://blogs.msdn.com/b/pfxteam/archive/2011/10/24/10229468.aspx) na programação paralela no blog do .NET.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Threading.CancellationToken" /> fornecido já foi descartado.</exception>
        <exception cref="T:System.ArgumentNullException">A exceção lançada quando o argumento <paramref name="function" /> é nulo.  
  
- ou - 
A exceção lançada quando o argumento <paramref name="scheduler" /> é nulo.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">A exceção lançada quando o argumento <paramref name="creationOptions" /> especifica um valor de TaskCreationOptions inválido. A exceção lançada quando o argumento <paramref name="creationOptions" /> especifica um valor de TaskCreationOptions inválido. Para obter mais informações, consulte as Observações para <see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" /></exception>
      </Docs>
    </Member>
  </Members>
</Type>