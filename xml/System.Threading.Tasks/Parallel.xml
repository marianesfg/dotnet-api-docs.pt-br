<Type Name="Parallel" FullName="System.Threading.Tasks.Parallel">
  <Metadata><Meta Name="ms.openlocfilehash" Value="6caf939ebdc8ec314d0fb3089516e2cac677b839" /><Meta Name="ms.sourcegitcommit" Value="d2dc7b29150110865ef8f199ee7463d9568fc696" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pt-BR" /><Meta Name="ms.lasthandoff" Value="03/25/2019" /><Meta Name="ms.locfileid" Value="58414236" /></Metadata><TypeSignature Language="C#" Value="public static class Parallel" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Parallel extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Tasks.Parallel" />
  <TypeSignature Language="VB.NET" Value="Public Class Parallel" />
  <TypeSignature Language="C++ CLI" Value="public ref class Parallel abstract sealed" />
  <TypeSignature Language="F#" Value="type Parallel = class" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.3.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary><span data-ttu-id="5c9d5-101">Fornece suporte para regiões e loops paralelos.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-101">Provides support for parallel loops and regions.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c9d5-102">O <xref:System.Threading.Tasks.Parallel> classe fornece substituições paralela de dados com base na biblioteca para operações comuns como no caso de loops, para cada loops e execução de um conjunto de instruções.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-102">The <xref:System.Threading.Tasks.Parallel> class provides library-based data parallel replacements for common operations such as for loops, for each loops, and execution of a set of statements.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5c9d5-103">Este exemplo demonstra várias abordagens para implementar um loop paralelo usando várias construções de linguagem.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-103">This example demonstrates several approaches to implementing a parallel loop using multiple language constructs.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Parallel#07](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/parallelintro.cs#07)]
 [!code-vb[System.Threading.Tasks.Parallel#07](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/parallelintro.vb#07)]  
  
 ]]></format>
    </remarks>
    <threadsafe><span data-ttu-id="5c9d5-104">Todos os membros públicos e protegidos da <see cref="T:System.Threading.Tasks.Parallel" /> são thread-safe e podem ser usados simultaneamente de vários threads.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-104">All public and protected members of <see cref="T:System.Threading.Tasks.Parallel" /> are thread-safe and may be used concurrently from multiple threads.</span></span></threadsafe>
    <related type="Article" href="~/docs/standard/parallel-programming/data-parallelism-task-parallel-library.md"><span data-ttu-id="5c9d5-105">Paralelismo de dados (biblioteca de tarefas paralelas)</span><span class="sxs-lookup"><span data-stu-id="5c9d5-105">Data Parallelism (Task Parallel Library)</span></span></related>
    <related type="ExternalDocumentation" href="https://code.msdn.microsoft.com/Samples-for-Parallel-b4b76364"><span data-ttu-id="5c9d5-106">Exemplos de programação paralela com o .NET Framework</span><span class="sxs-lookup"><span data-stu-id="5c9d5-106">Samples for Parallel Programming with the .NET Framework</span></span></related>
  </Docs>
  <Members>
    <MemberGroup MemberName="For">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="5c9d5-107">Executa um loop <see langword="for" /> no qual as iterações podem ser executadas em paralelo.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-107">Executes a <see langword="for" /> loop in which iterations may run in parallel.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (int fromInclusive, int toExclusive, Action&lt;int,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int32 fromInclusive, int32 toExclusive, class System.Action`2&lt;int32, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int32,System.Int32,System.Action{System.Int32,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function For (fromInclusive As Integer, toExclusive As Integer, body As Action(Of Integer, ParallelLoopState)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(int fromInclusive, int toExclusive, Action&lt;int, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int * int * Action&lt;int, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="body" Type="System.Action&lt;System.Int32,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive"><span data-ttu-id="5c9d5-108">O índice inicial, inclusivo.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-108">The start index, inclusive.</span></span></param>
        <param name="toExclusive"><span data-ttu-id="5c9d5-109">O índice final, exclusivo.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-109">The end index, exclusive.</span></span></param>
        <param name="body"><span data-ttu-id="5c9d5-110">O delegado invocado uma vez por iteração.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-110">The delegate that is invoked once per iteration.</span></span></param>
        <summary><span data-ttu-id="5c9d5-111">Executa um loop <see langword="for" /> no qual as iterações podem ser executadas em paralelo e o estado do loop pode ser monitorado e manipulado.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-111">Executes a <see langword="for" /> loop in which iterations may run in parallel and the state of the loop can be monitored and manipulated.</span></span></summary>
        <returns><span data-ttu-id="5c9d5-112">Uma estrutura que contém informações sobre qual parte do loop foi concluída.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-112">A  structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c9d5-113">O `body` delegado é invocado uma vez para cada valor no intervalo de iteração (`fromInclusive`, `toExclusive`).</span><span class="sxs-lookup"><span data-stu-id="5c9d5-113">The `body` delegate is invoked once for each value in the iteration range (`fromInclusive`, `toExclusive`).</span></span> <span data-ttu-id="5c9d5-114">Ele é fornecido com dois argumentos:</span><span class="sxs-lookup"><span data-stu-id="5c9d5-114">It is provided with two arguments:</span></span>  
  
-   <span data-ttu-id="5c9d5-115">Um <xref:System.Int32> valor que representa a contagem de iteração.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-115">An <xref:System.Int32> value that represents the iteration count.</span></span>  
  
-   <span data-ttu-id="5c9d5-116">Um <xref:System.Threading.Tasks.ParallelLoopState> instância que pode ser usada para interromper o loop prematuramente.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-116">A <xref:System.Threading.Tasks.ParallelLoopState> instance that can be used to break out of the loop prematurely.</span></span> <span data-ttu-id="5c9d5-117">O <xref:System.Threading.Tasks.ParallelLoopState> objeto é criado pelo compilador; ele não pode ser instanciado no código do usuário.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-117">The <xref:System.Threading.Tasks.ParallelLoopState> object is created by the compiler; it cannot be instantiated in user code.</span></span>  
  
 <span data-ttu-id="5c9d5-118">Chamar o <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> método informa o `for` operação que não é necessário executar iterações depois do atual.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-118">Calling the <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> method informs the `for` operation that iterations after the current one don't have to execute.</span></span> <span data-ttu-id="5c9d5-119">No entanto, todas as iterações antes atual um ainda terá a ser executada se eles ainda não fez isso.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-119">However, all iterations before the current one will still have to be executed if they haven't already.</span></span>  
  
 <span data-ttu-id="5c9d5-120">Portanto, chamar <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> é semelhante ao uso de uma operação de interrupção dentro de um convencional `for` loop em uma linguagem como C#, mas não é um substituto perfeito: Por exemplo, não há nenhuma garantia de que iterações depois atual definitivamente não será executado.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-120">Therefore, calling <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> is similar to using a break operation within a conventional `for` loop in a language like C#, but it is not a perfect substitute: For example, there is no guarantee that iterations after the current one will definitely not execute.</span></span>  
  
 <span data-ttu-id="5c9d5-121">Se a execução de todas as iterações antes atual não é necessário, use o <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> método em vez de usar <xref:System.Threading.Tasks.ParallelLoopState.Break%2A>.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-121">If executing all iterations before the current one is not necessary, use the <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> method instead of using <xref:System.Threading.Tasks.ParallelLoopState.Break%2A>.</span></span> <span data-ttu-id="5c9d5-122">Chamando <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> informa o `for` loop que ele pode abandonar restantes de todas as iterações, independentemente se eles estão antes ou após a iteração atual, porque todos os necessário trabalho será já tenha sido concluído.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-122">Calling <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> informs the `for` loop that it may abandon all remaining iterations, regardless of whether they're before or after the current iteration, because all required work will have already been completed.</span></span> <span data-ttu-id="5c9d5-123">No entanto, como com <xref:System.Threading.Tasks.ParallelLoopState.Break%2A>, há nenhuma garantia em relação a quais outras iterações não serão executado.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-123">However, as with <xref:System.Threading.Tasks.ParallelLoopState.Break%2A>, there are no guarantees regarding which other iterations will not execute.</span></span>  
  
 <span data-ttu-id="5c9d5-124">Se um loop é encerrado prematuramente, o <xref:System.Threading.Tasks.ParallelLoopResult> estrutura que é retornada conterá informações relevantes sobre a conclusão do loop.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-124">If a loop is ended prematurely, the <xref:System.Threading.Tasks.ParallelLoopResult> structure that is returned will contain relevant information about the loop's completion.</span></span>  
  
 <span data-ttu-id="5c9d5-125">Se `fromInclusive` é maior que ou igual a `toExclusive`, o método retornará imediatamente sem executar qualquer iterações.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-125">If `fromInclusive` is greater than or equal to `toExclusive`, the method returns immediately without performing any iterations.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5c9d5-126">O exemplo a seguir executa até 100 iterações de um loop em paralelo.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-126">The following example executes up to 100 iterations of a loop in parallel.</span></span> <span data-ttu-id="5c9d5-127">Cada iteração pausa por um intervalo aleatório de 1 a 1.000 milissegundos.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-127">Each iteration pauses for a random interval from 1 to 1,000 milliseconds.</span></span> <span data-ttu-id="5c9d5-128">Um valor gerado aleatoriamente determina em qual iteração do loop de <xref:System.Threading.Tasks.ParallelLoopState.Break%2A?displayProperty=nameWithType> método é chamado.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-128">A randomly generated value determines on which iteration of the loop the <xref:System.Threading.Tasks.ParallelLoopState.Break%2A?displayProperty=nameWithType> method is called.</span></span> <span data-ttu-id="5c9d5-129">Como a saída do exemplo mostra, nenhuma iteração cujo índice é maior que o <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A?displayProperty=nameWithType> início do valor de propriedade após a chamada para o <xref:System.Threading.Tasks.ParallelLoopState.Break%2A?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-129">As the output from the example shows, no iterations whose index is greater than the <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A?displayProperty=nameWithType> property value start after the call to the <xref:System.Threading.Tasks.ParallelLoopState.Break%2A?displayProperty=nameWithType> method.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.ParallelLoopState#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallelloopstate/cs/break1.cs#2)]
 [!code-vb[System.Threading.Tasks.ParallelLoopState#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallelloopstate/vb/break1.vb#2)]  
  
 <span data-ttu-id="5c9d5-130">Como as iterações do loop são ainda podem estar em execução quando o <xref:System.Threading.Tasks.ParallelLoopState.Break%2A?displayProperty=nameWithType> método é chamado, as chamadas de cada iteração a <xref:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration%2A?displayProperty=nameWithType> propriedade para verificar se a outra iteração tiver chamado o <xref:System.Threading.Tasks.ParallelLoopState.Break%2A?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-130">Because iterations of the loop are still likely to be executing when the <xref:System.Threading.Tasks.ParallelLoopState.Break%2A?displayProperty=nameWithType> method is called, each iteration calls the <xref:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration%2A?displayProperty=nameWithType> property to check whether another iteration has called the <xref:System.Threading.Tasks.ParallelLoopState.Break%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="5c9d5-131">Se o valor da propriedade for `true`, a iteração verifica o valor da <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A?displayProperty=nameWithType> propriedade e, se ele for maior que o valor de índice da iteração atual, retorna imediatamente.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-131">If  the property value is `true`, the iteration checks the value of the <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A?displayProperty=nameWithType> property and, if it is greater than the current iteration's index value, returns immediately.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="5c9d5-132">O argumento <paramref name="body" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-132">The <paramref name="body" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="5c9d5-133">A exceção que contém todas as exceções individuais lançadas em todos os threads.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-133">The exception that contains all the individual exceptions thrown on all threads.</span></span></exception>
        <altmember cref="T:System.Threading.Tasks.ParallelLoopState" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="5c9d5-134">Loops paralelos</span><span class="sxs-lookup"><span data-stu-id="5c9d5-134">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (int fromInclusive, int toExclusive, Action&lt;int&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int32 fromInclusive, int32 toExclusive, class System.Action`1&lt;int32&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int32,System.Int32,System.Action{System.Int32})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function For (fromInclusive As Integer, toExclusive As Integer, body As Action(Of Integer)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(int fromInclusive, int toExclusive, Action&lt;int&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int * int * Action&lt;int&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="body" Type="System.Action&lt;System.Int32&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive"><span data-ttu-id="5c9d5-135">O índice inicial, inclusivo.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-135">The start index, inclusive.</span></span></param>
        <param name="toExclusive"><span data-ttu-id="5c9d5-136">O índice final, exclusivo.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-136">The end index, exclusive.</span></span></param>
        <param name="body"><span data-ttu-id="5c9d5-137">O delegado invocado uma vez por iteração.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-137">The delegate that is invoked once per iteration.</span></span></param>
        <summary><span data-ttu-id="5c9d5-138">Executa um loop <see langword="for" /> no qual as iterações podem ser executadas em paralelo.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-138">Executes a <see langword="for" /> loop in which iterations may run in parallel.</span></span></summary>
        <returns><span data-ttu-id="5c9d5-139">Uma estrutura que contém informações sobre qual parte do loop foi concluída.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-139">A structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c9d5-140">O `body` delegado é invocado uma vez para cada valor no intervalo de iteração (`fromInclusive`, `toExclusive`).</span><span class="sxs-lookup"><span data-stu-id="5c9d5-140">The `body` delegate is invoked once for each value in the iteration range (`fromInclusive`, `toExclusive`).</span></span> <span data-ttu-id="5c9d5-141">Ele é fornecido com a contagem de iteração (<xref:System.Int32>) como um parâmetro.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-141">It is provided with the iteration count (<xref:System.Int32>) as a parameter.</span></span>  
  
 <span data-ttu-id="5c9d5-142">Se `fromInclusive` é maior que ou igual a `toExclusive`, o método retornará imediatamente sem executar qualquer iterações.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-142">If `fromInclusive` is greater than or equal to `toExclusive`, the method returns immediately without performing any iterations.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5c9d5-143">O exemplo a seguir usa o <xref:System.Threading.Tasks.Parallel.For%2A> método 100 invocações de um delegado que gera bytes aleatórios de valores e computa sua soma.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-143">The following example uses the <xref:System.Threading.Tasks.Parallel.For%2A> method for 100 invocations of a delegate that generates random byte values and computes their sum.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Parallel.For#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel.for/cs/for1.cs#1)]
 [!code-vb[System.Threading.Tasks.Parallel.For#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel.for/vb/for1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="5c9d5-144">O argumento <paramref name="body" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-144">The <paramref name="body" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="5c9d5-145">A exceção que contém todas as exceções individuais lançadas em todos os threads.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-145">The exception that contains all the individual exceptions thrown on all threads.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="5c9d5-146">Loops paralelos</span><span class="sxs-lookup"><span data-stu-id="5c9d5-146">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (long fromInclusive, long toExclusive, Action&lt;long,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int64 fromInclusive, int64 toExclusive, class System.Action`2&lt;int64, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int64,System.Int64,System.Action{System.Int64,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function For (fromInclusive As Long, toExclusive As Long, body As Action(Of Long, ParallelLoopState)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(long fromInclusive, long toExclusive, Action&lt;long, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int64 * int64 * Action&lt;int64, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int64" />
        <Parameter Name="toExclusive" Type="System.Int64" />
        <Parameter Name="body" Type="System.Action&lt;System.Int64,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive"><span data-ttu-id="5c9d5-147">O índice inicial, inclusivo.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-147">The start index, inclusive.</span></span></param>
        <param name="toExclusive"><span data-ttu-id="5c9d5-148">O índice final, exclusivo.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-148">The end index, exclusive.</span></span></param>
        <param name="body"><span data-ttu-id="5c9d5-149">O delegado invocado uma vez por iteração.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-149">The delegate that is invoked once per iteration.</span></span></param>
        <summary><span data-ttu-id="5c9d5-150">Executa um loop <see langword="for" /> com índices de 64 bits no qual as iterações podem ser executadas em paralelo e o estado do loop pode ser monitorado e manipulado.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-150">Executes a <see langword="for" /> loop with 64-bit indexes in which iterations may run in parallel and the state of the loop can be monitored and manipulated.</span></span></summary>
        <returns><span data-ttu-id="5c9d5-151">Uma estrutura <see cref="T:System.Threading.Tasks.ParallelLoopResult" /> que contém informações sobre qual parte do loop foi concluída.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-151">A <see cref="T:System.Threading.Tasks.ParallelLoopResult" /> structure that contains information on what portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c9d5-152">O `body` delegado é invocado uma vez para cada valor no intervalo de iteração (`fromInclusive`, `toExclusive`).</span><span class="sxs-lookup"><span data-stu-id="5c9d5-152">The `body` delegate is invoked once for each value in the iteration range (`fromInclusive`, `toExclusive`).</span></span> <span data-ttu-id="5c9d5-153">Ele é fornecido com os seguintes parâmetros: a contagem de iteração (<xref:System.Int64>) e um <xref:System.Threading.Tasks.ParallelLoopState> instância que pode ser usada para interromper o loop prematuramente.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-153">It is provided with the following parameters: the iteration count (<xref:System.Int64>), and a <xref:System.Threading.Tasks.ParallelLoopState> instance that may be used to break out of the loop prematurely.</span></span>  
  
 <span data-ttu-id="5c9d5-154">Chamar o <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> método informa o `for` operação que iterações depois do atual não tem a serem executadas, mas fazer todas as iterações antes do atual.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-154">Calling the <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> method informs the `for` operation that iterations after the current one don't have to be executed, but all iterations before the current one do.</span></span>  
  
 <span data-ttu-id="5c9d5-155">Portanto, chamar quebra é semelhante ao uso de uma operação de interrupção dentro de um convencional `for` loop em uma linguagem como C#, mas não é um substituto perfeito: Por exemplo, não há nenhuma garantia de que iterações depois atual definitivamente não será executado.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-155">Therefore, calling Break is similar to using a break operation within a conventional `for` loop in a language like C#, but it is not a perfect substitute: For example, there is no guarantee that iterations after the current one will definitely not execute.</span></span>  
  
 <span data-ttu-id="5c9d5-156">Se a execução de todas as iterações antes atual não é necessário, use o <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> método em vez de usar <xref:System.Threading.Tasks.ParallelLoopState.Break%2A>.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-156">If executing all iterations before the current one is not necessary, use the <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> method instead of using <xref:System.Threading.Tasks.ParallelLoopState.Break%2A>.</span></span> <span data-ttu-id="5c9d5-157">Chamando <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> informa o `for` loop que ele pode abandonar restantes de todas as iterações, independentemente se eles estão antes ou após a iteração atual, porque todos os necessário trabalho será já tenha sido concluído.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-157">Calling <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> informs the `for` loop that it may abandon all remaining iterations, regardless of whether they're before or after the current iteration, because all required work will have already been completed.</span></span> <span data-ttu-id="5c9d5-158">No entanto, como com <xref:System.Threading.Tasks.ParallelLoopState.Break%2A>, há nenhuma garantia em relação a quais outras iterações não serão executado.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-158">However, as with <xref:System.Threading.Tasks.ParallelLoopState.Break%2A>, there are no guarantees regarding which other iterations will not execute.</span></span>  
  
 <span data-ttu-id="5c9d5-159">Se um loop é encerrado prematuramente, o <xref:System.Threading.Tasks.ParallelLoopResult> estrutura que é retornada conterá informações relevantes sobre a conclusão do loop.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-159">If a loop is ended prematurely, the <xref:System.Threading.Tasks.ParallelLoopResult> structure that is returned will contain relevant information about the loop's completion.</span></span>  
  
 <span data-ttu-id="5c9d5-160">Se `fromInclusive` é maior que ou igual a `toExclusive`, em seguida, o método retornará imediatamente sem executar qualquer iterações.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-160">If `fromInclusive` is greater than or equal to `toExclusive`, then the method returns immediately without performing any iterations.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="5c9d5-161">O argumento <paramref name="body" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-161">The <paramref name="body" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="5c9d5-162">A exceção que contém todas as exceções individuais lançadas em todos os threads.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-162">The exception that contains all the individual exceptions thrown on all threads.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="5c9d5-163">Loops paralelos</span><span class="sxs-lookup"><span data-stu-id="5c9d5-163">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (long fromInclusive, long toExclusive, Action&lt;long&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int64 fromInclusive, int64 toExclusive, class System.Action`1&lt;int64&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int64,System.Int64,System.Action{System.Int64})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function For (fromInclusive As Long, toExclusive As Long, body As Action(Of Long)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(long fromInclusive, long toExclusive, Action&lt;long&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int64 * int64 * Action&lt;int64&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int64" />
        <Parameter Name="toExclusive" Type="System.Int64" />
        <Parameter Name="body" Type="System.Action&lt;System.Int64&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive"><span data-ttu-id="5c9d5-164">O índice inicial, inclusivo.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-164">The start index, inclusive.</span></span></param>
        <param name="toExclusive"><span data-ttu-id="5c9d5-165">O índice final, exclusivo.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-165">The end index, exclusive.</span></span></param>
        <param name="body"><span data-ttu-id="5c9d5-166">O delegado invocado uma vez por iteração.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-166">The delegate that is invoked once per iteration.</span></span></param>
        <summary><span data-ttu-id="5c9d5-167">Executa um loop <see langword="for" /> com índices de 64 bits no qual as iterações podem ser executadas em paralelo.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-167">Executes a <see langword="for" /> loop with 64-bit indexes in which iterations may run in parallel.</span></span></summary>
        <returns><span data-ttu-id="5c9d5-168">Uma estrutura que contém informações sobre qual parte do loop foi concluída.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-168">A structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c9d5-169">O `body` delegado é invocado uma vez para cada valor no intervalo de iteração (`fromInclusive`, `toExclusive`).</span><span class="sxs-lookup"><span data-stu-id="5c9d5-169">The `body` delegate is invoked once for each value in the iteration range (`fromInclusive`, `toExclusive`).</span></span> <span data-ttu-id="5c9d5-170">Ele é fornecido com a contagem de iteração (<xref:System.Int64>) como um parâmetro.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-170">It is provided with the iteration count (<xref:System.Int64>) as a parameter.</span></span>  
  
 <span data-ttu-id="5c9d5-171">Se `fromInclusive` é maior que ou igual a `toExclusive`, o método retornará imediatamente sem executar qualquer iterações.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-171">If `fromInclusive` is greater than or equal to `toExclusive`, the method returns immediately without performing any iterations.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="5c9d5-172">O argumento <paramref name="body" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-172">The <paramref name="body" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="5c9d5-173">A exceção que contém todas as exceções individuais lançadas em todos os threads.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-173">The exception that contains all the individual exceptions thrown on all threads.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="5c9d5-174">Loops paralelos</span><span class="sxs-lookup"><span data-stu-id="5c9d5-174">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (int fromInclusive, int toExclusive, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;int,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int32 fromInclusive, int32 toExclusive, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`2&lt;int32, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int32,System.Int32,System.Threading.Tasks.ParallelOptions,System.Action{System.Int32,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(int fromInclusive, int toExclusive, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;int, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int * int * System.Threading.Tasks.ParallelOptions * Action&lt;int, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;System.Int32,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive"><span data-ttu-id="5c9d5-175">O índice inicial, inclusivo.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-175">The start index, inclusive.</span></span></param>
        <param name="toExclusive"><span data-ttu-id="5c9d5-176">O índice final, exclusivo.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-176">The end index, exclusive.</span></span></param>
        <param name="parallelOptions"><span data-ttu-id="5c9d5-177">Um objeto que configura o comportamento dessa operação.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-177">An object that configures the behavior of this operation.</span></span></param>
        <param name="body"><span data-ttu-id="5c9d5-178">O delegado invocado uma vez por iteração.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-178">The delegate that is invoked once per iteration.</span></span></param>
        <summary><span data-ttu-id="5c9d5-179">Executa um loop <see langword="for" /> no qual as iterações podem ser executadas em paralelo, as opções do loop podem ser configuradas e o estado do loop pode ser monitorado e manipulado.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-179">Executes a <see langword="for" /> loop in which iterations may run in parallel, loop options can be configured, and the state of the loop can be monitored and manipulated.</span></span></summary>
        <returns><span data-ttu-id="5c9d5-180">Uma estrutura que contém informações sobre qual parte do loop foi concluída.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-180">A structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c9d5-181">O `body` delegado é invocado uma vez para cada valor no intervalo de iteração (`fromInclusive`, `toExclusive`).</span><span class="sxs-lookup"><span data-stu-id="5c9d5-181">The `body` delegate is invoked once for each value in the iteration range (`fromInclusive`, `toExclusive`).</span></span> <span data-ttu-id="5c9d5-182">Ele é fornecido com os seguintes parâmetros: a contagem de iteração (<xref:System.Int32>) e um <xref:System.Threading.Tasks.ParallelLoopState> instância que pode ser usada para interromper o loop prematuramente.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-182">It is provided with the following parameters: the iteration count (<xref:System.Int32>), and a <xref:System.Threading.Tasks.ParallelLoopState> instance that may be used to break out of the loop prematurely.</span></span>  
  
 <span data-ttu-id="5c9d5-183">Se `fromInclusive` é maior que ou igual a `toExclusive`, o método retornará imediatamente sem executar qualquer iterações.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-183">If `fromInclusive` is greater than or equal to `toExclusive`, the method returns immediately without performing any iterations.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException"><span data-ttu-id="5c9d5-184">O <see cref="T:System.Threading.CancellationToken" /> no argumento <paramref name="parallelOptions" /> foi cancelado.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-184">The <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> argument is canceled.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="5c9d5-185">O argumento <paramref name="body" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-185">The <paramref name="body" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="5c9d5-186">- ou -</span><span class="sxs-lookup"><span data-stu-id="5c9d5-186">-or-</span></span> 
<span data-ttu-id="5c9d5-187">O argumento <paramref name="parallelOptions" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-187">The <paramref name="parallelOptions" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="5c9d5-188">A exceção que contém todas as exceções individuais lançadas em todos os threads.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-188">The exception that contains all the individual exceptions thrown on all threads.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="5c9d5-189">O <see cref="T:System.Threading.CancellationTokenSource" /> associado ao <see cref="T:System.Threading.CancellationToken" /> no <paramref name="parallelOptions" /> foi descartado.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-189">The <see cref="T:System.Threading.CancellationTokenSource" /> associated with the <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> has been disposed.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="5c9d5-190">Loops paralelos</span><span class="sxs-lookup"><span data-stu-id="5c9d5-190">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (int fromInclusive, int toExclusive, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;int&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int32 fromInclusive, int32 toExclusive, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`1&lt;int32&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int32,System.Int32,System.Threading.Tasks.ParallelOptions,System.Action{System.Int32})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(int fromInclusive, int toExclusive, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;int&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int * int * System.Threading.Tasks.ParallelOptions * Action&lt;int&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;System.Int32&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive"><span data-ttu-id="5c9d5-191">O índice inicial, inclusivo.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-191">The start index, inclusive.</span></span></param>
        <param name="toExclusive"><span data-ttu-id="5c9d5-192">O índice final, exclusivo.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-192">The end index, exclusive.</span></span></param>
        <param name="parallelOptions"><span data-ttu-id="5c9d5-193">Um objeto que configura o comportamento dessa operação.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-193">An object that configures the behavior of this operation.</span></span></param>
        <param name="body"><span data-ttu-id="5c9d5-194">O delegado invocado uma vez por iteração.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-194">The delegate that is invoked once per iteration.</span></span></param>
        <summary><span data-ttu-id="5c9d5-195">Executa um loop <see langword="for" /> em que as iterações podem ser executadas em paralelo e as opções de loop podem ser configuradas.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-195">Executes a <see langword="for" /> loop in which iterations may run in parallel and loop options can be configured.</span></span></summary>
        <returns><span data-ttu-id="5c9d5-196">Uma estrutura que contém informações sobre qual parte do loop foi concluída.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-196">A  structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c9d5-197">O `body` delegado é invocado uma vez para cada valor no intervalo de iteração (`fromInclusive`, `toExclusive`).</span><span class="sxs-lookup"><span data-stu-id="5c9d5-197">The `body` delegate is invoked once for each value in the iteration range (`fromInclusive`, `toExclusive`).</span></span> <span data-ttu-id="5c9d5-198">Ele é fornecido com a contagem de iteração (<xref:System.Int32>) como um parâmetro.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-198">It is provided with the iteration count (<xref:System.Int32>) as a parameter.</span></span>  
  
 <span data-ttu-id="5c9d5-199">Se `fromInclusive` é maior que ou igual a `toExclusive`, em seguida, o método retornará imediatamente sem executar qualquer iterações.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-199">If `fromInclusive` is greater than or equal to `toExclusive`, then the method returns immediately without performing any iterations.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5c9d5-200">O exemplo a seguir mostra como cancelar um loop paralelo:</span><span class="sxs-lookup"><span data-stu-id="5c9d5-200">The following example shows how to cancel a parallel loop:</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Parallel#05](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/parallelforcancel.cs#05)]
 [!code-vb[System.Threading.Tasks.Parallel#05](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/parallelforcancel.vb#05)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException"><span data-ttu-id="5c9d5-201">O <see cref="T:System.Threading.CancellationToken" /> no argumento <paramref name="parallelOptions" /> foi cancelado.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-201">The <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> argument is canceled.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="5c9d5-202">O argumento <paramref name="body" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-202">The <paramref name="body" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="5c9d5-203">- ou -</span><span class="sxs-lookup"><span data-stu-id="5c9d5-203">-or-</span></span> 
<span data-ttu-id="5c9d5-204">O argumento <paramref name="parallelOptions" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-204">The <paramref name="parallelOptions" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="5c9d5-205">A exceção que contém todas as exceções individuais lançadas em todos os threads.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-205">The exception that contains all the individual exceptions thrown on all threads.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="5c9d5-206">O <see cref="T:System.Threading.CancellationTokenSource" /> associado ao <see cref="T:System.Threading.CancellationToken" /> no <paramref name="parallelOptions" /> foi descartado.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-206">The <see cref="T:System.Threading.CancellationTokenSource" /> associated with the <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> has been disposed.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="5c9d5-207">Loops paralelos</span><span class="sxs-lookup"><span data-stu-id="5c9d5-207">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (long fromInclusive, long toExclusive, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;long,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int64 fromInclusive, int64 toExclusive, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`2&lt;int64, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int64,System.Int64,System.Threading.Tasks.ParallelOptions,System.Action{System.Int64,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(long fromInclusive, long toExclusive, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;long, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int64 * int64 * System.Threading.Tasks.ParallelOptions * Action&lt;int64, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int64" />
        <Parameter Name="toExclusive" Type="System.Int64" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;System.Int64,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive"><span data-ttu-id="5c9d5-208">O índice inicial, inclusivo.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-208">The start index, inclusive.</span></span></param>
        <param name="toExclusive"><span data-ttu-id="5c9d5-209">O índice final, exclusivo.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-209">The end index, exclusive.</span></span></param>
        <param name="parallelOptions"><span data-ttu-id="5c9d5-210">Um objeto que configura o comportamento dessa operação.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-210">An object that configures the behavior of this operation.</span></span></param>
        <param name="body"><span data-ttu-id="5c9d5-211">O delegado invocado uma vez por iteração.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-211">The delegate that is invoked once per iteration.</span></span></param>
        <summary><span data-ttu-id="5c9d5-212">Executa um loop <see langword="for" /> com índices de 64 bits no qual iterações podem ser executadas em paralelo, opções de loop podem ser configuradas e o estado de loop pode ser monitorado e manipulado.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-212">Executes a <see langword="for" /> loop with 64-bit indexes in which iterations may run in parallel, loop options can be configured, and the state of the loop can be monitored and manipulated.</span></span></summary>
        <returns><span data-ttu-id="5c9d5-213">Uma estrutura que contém informações sobre qual parte do loop foi concluída.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-213">A structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c9d5-214">O `body` delegado é invocado uma vez para cada valor no intervalo de iteração (`fromInclusive`, `toExclusive`).</span><span class="sxs-lookup"><span data-stu-id="5c9d5-214">The `body` delegate is invoked once for each value in the iteration range (`fromInclusive`, `toExclusive`).</span></span> <span data-ttu-id="5c9d5-215">Ele é fornecido com os seguintes parâmetros: a contagem de iteração (<xref:System.Int64>) e um <xref:System.Threading.Tasks.ParallelLoopState> instância que pode ser usada para interromper o loop prematuramente.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-215">It is provided with the following parameters: the iteration count (<xref:System.Int64>), and a <xref:System.Threading.Tasks.ParallelLoopState> instance that may be used to break out of the loop prematurely.</span></span>  
  
 <span data-ttu-id="5c9d5-216">Se `fromInclusive` é maior que ou igual a `toExclusive`, o método retornará imediatamente sem executar qualquer iterações.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-216">If `fromInclusive` is greater than or equal to `toExclusive`, the method returns immediately without performing any iterations.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5c9d5-217">O exemplo a seguir mostra como usar o <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> método com um <xref:System.Threading.Tasks.ParallelOptions> objeto:</span><span class="sxs-lookup"><span data-stu-id="5c9d5-217">The following example shows how to use the <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> method with a <xref:System.Threading.Tasks.ParallelOptions> object:</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Parallel#03](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/parallelfor.cs#03)]
 [!code-vb[System.Threading.Tasks.Parallel#03](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/parallelfor.vb#03)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException"><span data-ttu-id="5c9d5-218">O <see cref="T:System.Threading.CancellationToken" /> no argumento <paramref name="parallelOptions" /> foi cancelado.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-218">The <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> argument is canceled.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="5c9d5-219">O argumento <paramref name="body" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-219">The <paramref name="body" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="5c9d5-220">- ou -</span><span class="sxs-lookup"><span data-stu-id="5c9d5-220">-or-</span></span> 
<span data-ttu-id="5c9d5-221">O argumento <paramref name="parallelOptions" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-221">The <paramref name="parallelOptions" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="5c9d5-222">A exceção que contém todas as exceções individuais lançadas em todos os threads.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-222">The exception that contains all the individual exceptions thrown on all threads.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="5c9d5-223">O <see cref="T:System.Threading.CancellationTokenSource" /> associado ao <see cref="T:System.Threading.CancellationToken" /> no <paramref name="parallelOptions" /> foi descartado.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-223">The <see cref="T:System.Threading.CancellationTokenSource" /> associated with the <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> has been disposed.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="5c9d5-224">Loops paralelos</span><span class="sxs-lookup"><span data-stu-id="5c9d5-224">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (long fromInclusive, long toExclusive, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;long&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int64 fromInclusive, int64 toExclusive, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`1&lt;int64&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int64,System.Int64,System.Threading.Tasks.ParallelOptions,System.Action{System.Int64})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(long fromInclusive, long toExclusive, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;long&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int64 * int64 * System.Threading.Tasks.ParallelOptions * Action&lt;int64&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int64" />
        <Parameter Name="toExclusive" Type="System.Int64" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;System.Int64&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive"><span data-ttu-id="5c9d5-225">O índice inicial, inclusivo.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-225">The start index, inclusive.</span></span></param>
        <param name="toExclusive"><span data-ttu-id="5c9d5-226">O índice final, exclusivo.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-226">The end index, exclusive.</span></span></param>
        <param name="parallelOptions"><span data-ttu-id="5c9d5-227">Um objeto que configura o comportamento dessa operação.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-227">An object that configures the behavior of this operation.</span></span></param>
        <param name="body"><span data-ttu-id="5c9d5-228">O delegado invocado uma vez por iteração.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-228">The delegate that is invoked once per iteration.</span></span></param>
        <summary><span data-ttu-id="5c9d5-229">Executa um loop <see langword="for" /> com índices de 64 bits no qual as iterações podem ser executadas em paralelo e opções de loop podem ser configuradas.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-229">Executes a <see langword="for" /> loop with 64-bit indexes in which iterations may run in parallel and loop options can be configured.</span></span></summary>
        <returns><span data-ttu-id="5c9d5-230">Uma estrutura que contém informações sobre qual parte do loop foi concluída.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-230">A structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c9d5-231">Dá suporte a índices de 64 bits.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-231">Supports 64-bit indexes.</span></span> <span data-ttu-id="5c9d5-232">O `body` delegado é invocado uma vez para cada valor no intervalo de iteração (`fromInclusive`, `toExclusive`).</span><span class="sxs-lookup"><span data-stu-id="5c9d5-232">The `body` delegate is invoked once for each value in the iteration range (`fromInclusive`, `toExclusive`).</span></span> <span data-ttu-id="5c9d5-233">Ele é fornecido com a contagem de iteração (<xref:System.Int64>) como um parâmetro.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-233">It is provided with the iteration count (<xref:System.Int64>) as a parameter.</span></span>  
  
 <span data-ttu-id="5c9d5-234">Se `fromInclusive` é maior que ou igual a `toExclusive`, em seguida, o método retornará imediatamente sem executar qualquer iterações.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-234">If `fromInclusive` is greater than or equal to `toExclusive`, then the method returns immediately without performing any iterations.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5c9d5-235">O exemplo a seguir mostra como usar <xref:System.Threading.Tasks.ParallelOptions> para especificar um agendador de tarefas personalizados:</span><span class="sxs-lookup"><span data-stu-id="5c9d5-235">The following example shows how to use <xref:System.Threading.Tasks.ParallelOptions> to specify a custom task scheduler:</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Parallel#06](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/parallelforwithscheduler.cs#06)]
 [!code-vb[System.Threading.Tasks.Parallel#06](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/parallelforwithscheduler.vb#06)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException"><span data-ttu-id="5c9d5-236">O <see cref="T:System.Threading.CancellationToken" /> no argumento <paramref name="parallelOptions" /> foi cancelado.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-236">The <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> argument is canceled.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="5c9d5-237">O argumento <paramref name="body" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-237">The <paramref name="body" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="5c9d5-238">- ou -</span><span class="sxs-lookup"><span data-stu-id="5c9d5-238">-or-</span></span> 
<span data-ttu-id="5c9d5-239">O argumento <paramref name="parallelOptions" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-239">The <paramref name="parallelOptions" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="5c9d5-240">A exceção que contém todas as exceções individuais lançadas em todos os threads.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-240">The exception that contains all the individual exceptions thrown on all threads.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="5c9d5-241">O <see cref="T:System.Threading.CancellationTokenSource" /> associado ao <see cref="T:System.Threading.CancellationToken" /> no <paramref name="parallelOptions" /> foi descartado.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-241">The <see cref="T:System.Threading.CancellationTokenSource" /> associated with the <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> has been disposed.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="5c9d5-242">Loops paralelos</span><span class="sxs-lookup"><span data-stu-id="5c9d5-242">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="For&lt;TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt; (int fromInclusive, int toExclusive, Func&lt;TLocal&gt; localInit, Func&lt;int,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt;(int32 fromInclusive, int32 toExclusive, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;int32, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For``1(System.Int32,System.Int32,System.Func{``0},System.Func{System.Int32,System.Threading.Tasks.ParallelLoopState,``0,``0},System.Action{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function For(Of TLocal) (fromInclusive As Integer, toExclusive As Integer, localInit As Func(Of TLocal), body As Func(Of Integer, ParallelLoopState, TLocal, TLocal), localFinally As Action(Of TLocal)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult For(int fromInclusive, int toExclusive, Func&lt;TLocal&gt; ^ localInit, Func&lt;int, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member For : int * int * Func&lt;'Local&gt; * Func&lt;int, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;System.Int32,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TLocal"><span data-ttu-id="5c9d5-243">O tipo dos dados locais do thread.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-243">The type of the thread-local data.</span></span></typeparam>
        <param name="fromInclusive"><span data-ttu-id="5c9d5-244">O índice inicial, inclusivo.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-244">The start index, inclusive.</span></span></param>
        <param name="toExclusive"><span data-ttu-id="5c9d5-245">O índice final, exclusivo.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-245">The end index, exclusive.</span></span></param>
        <param name="localInit"><span data-ttu-id="5c9d5-246">O delegado da função que retorna o estado inicial dos dados locais para cada tarefa.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-246">The function delegate that returns the initial state of the local data for each task.</span></span></param>
        <param name="body"><span data-ttu-id="5c9d5-247">O delegado invocado uma vez por iteração.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-247">The delegate that is invoked once per iteration.</span></span></param>
        <param name="localFinally"><span data-ttu-id="5c9d5-248">O delegado que executa uma ação final no estado local de cada tarefa.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-248">The delegate that performs a final action on the local state of each task.</span></span></param>
        <summary><span data-ttu-id="5c9d5-249">Executa um loop <see langword="for" /> com os dados locais de thread no qual as iterações podem ser executadas em paralelo e o estado do loop pode ser monitorado e manipulado.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-249">Executes a <see langword="for" /> loop with thread-local data in which iterations may run in parallel, and the state of the loop can be monitored and manipulated.</span></span></summary>
        <returns><span data-ttu-id="5c9d5-250">Uma estrutura que contém informações sobre qual parte do loop foi concluída.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-250">A  structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c9d5-251">O `body` delegado é invocado uma vez para cada valor no intervalo de iteração (`fromInclusive`, `toExclusive`).</span><span class="sxs-lookup"><span data-stu-id="5c9d5-251">The `body` delegate is invoked once for each value in the iteration range (`fromInclusive`, `toExclusive`).</span></span> <span data-ttu-id="5c9d5-252">Ele é fornecido com os seguintes parâmetros: a contagem de iteração (<xref:System.Int32>), um <xref:System.Threading.Tasks.ParallelLoopState> instância que pode ser usada para interromper o loop prematuramente e alguns estados de locais que podem ser compartilhados entre as iterações que executam no mesmo thread.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-252">It is provided with the following parameters: the iteration count (<xref:System.Int32>), a <xref:System.Threading.Tasks.ParallelLoopState> instance that may be used to break out of the loop prematurely, and some local state that may be shared amongst iterations that execute on the same thread.</span></span>  
  
 <span data-ttu-id="5c9d5-253">O `localInit` delegado é invocado uma vez para cada tarefa que participa de execução do loop e retorna o estado local inicial para cada uma dessas tarefas.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-253">The `localInit` delegate is invoked once for each task that participates in the loop's execution and returns the initial local state for each of those tasks.</span></span> <span data-ttu-id="5c9d5-254">Esses estados iniciais são passados para o primeiro `body` invocações em cada tarefa.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-254">These initial states are passed to the first `body` invocations on each task.</span></span> <span data-ttu-id="5c9d5-255">Em seguida, cada invocação subsequente corpo retorna um valor de estado possivelmente modificado que é passado para a próxima invocação de corpo.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-255">Then, every subsequent body invocation returns a possibly modified state value that is passed to the next body invocation.</span></span> <span data-ttu-id="5c9d5-256">Por fim, a última chamada do corpo em cada tarefa retorna um valor de estado que é passado para o `localFinally` delegar.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-256">Finally, the last body invocation on each task returns a state value that is passed to the `localFinally` delegate.</span></span> <span data-ttu-id="5c9d5-257">O `localFinally` delegado é invocado uma vez por tarefa para executar uma ação final no estado local de cada tarefa.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-257">The `localFinally` delegate is invoked once per task to perform a final action on each task's local state.</span></span> <span data-ttu-id="5c9d5-258">Esse delegado pode ser invocado simultaneamente em várias tarefas; Portanto, você deve sincronizar o acesso a quaisquer variáveis compartilhadas.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-258">This delegate might be invoked concurrently on multiple tasks; therefore, you must synchronize access to any shared variables.</span></span>  
  
 <span data-ttu-id="5c9d5-259">O <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> método pode usar tarefas mais do que os threads durante a vida útil de sua execução, como as tarefas existentes são concluídas e são substituídas por novas tarefas.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-259">The <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> method may use more tasks than threads over the lifetime of its execution, as existing tasks complete and are replaced by new tasks.</span></span> <span data-ttu-id="5c9d5-260">Isso proporciona subjacente <xref:System.Threading.Tasks.TaskScheduler> do objeto a chance de adicionar, alterar ou remover threads que o loop de serviço.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-260">This gives the underlying <xref:System.Threading.Tasks.TaskScheduler> object the chance to add, change, or remove threads that service the loop.</span></span>  
  
 <span data-ttu-id="5c9d5-261">Se `fromInclusive` é maior que ou igual a `toExclusive`, em seguida, o método retornará imediatamente sem executar qualquer iterações.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-261">If `fromInclusive` is greater than or equal to `toExclusive`, then the method returns immediately without performing any iterations.</span></span>  
  
 <span data-ttu-id="5c9d5-262">Para obter um exemplo que usa esse método, consulte [como: Gravar um loop Parallel.For com variáveis locais de thread](~/docs/standard/parallel-programming/how-to-write-a-parallel-for-loop-with-thread-local-variables.md).</span><span class="sxs-lookup"><span data-stu-id="5c9d5-262">For an example that uses this method, see [How to: Write a Parallel.For Loop with Thread-Local Variables](~/docs/standard/parallel-programming/how-to-write-a-parallel-for-loop-with-thread-local-variables.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="5c9d5-263">O argumento <paramref name="body" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-263">The <paramref name="body" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="5c9d5-264">- ou -</span><span class="sxs-lookup"><span data-stu-id="5c9d5-264">-or-</span></span> 
<span data-ttu-id="5c9d5-265">O argumento <paramref name="localInit" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-265">The <paramref name="localInit" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="5c9d5-266">- ou -</span><span class="sxs-lookup"><span data-stu-id="5c9d5-266">-or-</span></span> 
<span data-ttu-id="5c9d5-267">O argumento <paramref name="localFinally" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-267">The <paramref name="localFinally" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="5c9d5-268">A exceção que contém todas as exceções individuais lançadas em todos os threads.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-268">The exception that contains all the individual exceptions thrown on all threads.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="5c9d5-269">Loops paralelos</span><span class="sxs-lookup"><span data-stu-id="5c9d5-269">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="For&lt;TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt; (long fromInclusive, long toExclusive, Func&lt;TLocal&gt; localInit, Func&lt;long,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt;(int64 fromInclusive, int64 toExclusive, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;int64, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For``1(System.Int64,System.Int64,System.Func{``0},System.Func{System.Int64,System.Threading.Tasks.ParallelLoopState,``0,``0},System.Action{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function For(Of TLocal) (fromInclusive As Long, toExclusive As Long, localInit As Func(Of TLocal), body As Func(Of Long, ParallelLoopState, TLocal, TLocal), localFinally As Action(Of TLocal)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult For(long fromInclusive, long toExclusive, Func&lt;TLocal&gt; ^ localInit, Func&lt;long, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member For : int64 * int64 * Func&lt;'Local&gt; * Func&lt;int64, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int64" />
        <Parameter Name="toExclusive" Type="System.Int64" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;System.Int64,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TLocal"><span data-ttu-id="5c9d5-270">O tipo dos dados locais do thread.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-270">The type of the thread-local data.</span></span></typeparam>
        <param name="fromInclusive"><span data-ttu-id="5c9d5-271">O índice inicial, inclusivo.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-271">The start index, inclusive.</span></span></param>
        <param name="toExclusive"><span data-ttu-id="5c9d5-272">O índice final, exclusivo.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-272">The end index, exclusive.</span></span></param>
        <param name="localInit"><span data-ttu-id="5c9d5-273">O delegado da função que retorna o estado inicial dos dados locais para cada tarefa.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-273">The function delegate that returns the initial state of the local data for each task.</span></span></param>
        <param name="body"><span data-ttu-id="5c9d5-274">O delegado invocado uma vez por iteração.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-274">The delegate that is invoked once per iteration.</span></span></param>
        <param name="localFinally"><span data-ttu-id="5c9d5-275">O delegado que executa uma ação final no estado local de cada tarefa.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-275">The delegate that performs a final action on the local state of each task.</span></span></param>
        <summary><span data-ttu-id="5c9d5-276">Executa um loop <see langword="for" /> com índices de 64 bits e dados locais de thread no qual as iterações podem ser executadas em paralelo e o estado do loop pode ser monitorado e manipulado.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-276">Executes a <see langword="for" /> loop with 64-bit indexes and thread-local data in which iterations may run in parallel, and the state of the loop can be monitored and manipulated.</span></span></summary>
        <returns><span data-ttu-id="5c9d5-277">Uma estrutura que contém informações sobre qual parte do loop foi concluída.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-277">A structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c9d5-278">O `body` delegado é invocado uma vez para cada valor no intervalo de iteração (`fromInclusive`, `toExclusive`).</span><span class="sxs-lookup"><span data-stu-id="5c9d5-278">The `body` delegate is invoked once for each value in the iteration range (`fromInclusive`, `toExclusive`).</span></span> <span data-ttu-id="5c9d5-279">Ele é fornecido com os seguintes parâmetros: a contagem de iteração (<xref:System.Int64>), um <xref:System.Threading.Tasks.ParallelLoopState> instância que pode ser usada para interromper o loop prematuramente e alguns estados de locais que podem ser compartilhados entre as iterações que são executados na mesma tarefa.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-279">It is provided with the following parameters: the iteration count (<xref:System.Int64>), a <xref:System.Threading.Tasks.ParallelLoopState> instance that may be used to break out of the loop prematurely, and some local state that may be shared amongst iterations that execute on the same task.</span></span>  
  
 <span data-ttu-id="5c9d5-280">O `localInit` delegado é invocado uma vez para cada tarefa que participa de execução do loop e retorna o estado local inicial para cada uma dessas tarefas.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-280">The `localInit` delegate is invoked once for each task that participates in the loop's execution and returns the initial local state for each of those tasks.</span></span> <span data-ttu-id="5c9d5-281">Esses estados iniciais são passados para o primeiro `body` invocações em cada tarefa.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-281">These initial states are passed to the first `body` invocations on each task.</span></span> <span data-ttu-id="5c9d5-282">Em seguida, cada invocação subsequente corpo retorna um valor de estado possivelmente modificado que é passado para a próxima invocação de corpo.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-282">Then, every subsequent body invocation returns a possibly modified state value that is passed to the next body invocation.</span></span> <span data-ttu-id="5c9d5-283">Por fim, a última chamada do corpo em cada tarefa retorna um valor de estado que é passado para o `localFinally` delegar.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-283">Finally, the last body invocation on each task returns a state value that is passed to the `localFinally` delegate.</span></span> <span data-ttu-id="5c9d5-284">O `localFinally` delegado é invocado uma vez por tarefa para executar uma ação final no estado local de cada tarefa.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-284">The `localFinally` delegate is invoked once per task to perform a final action on each task's local state.</span></span> <span data-ttu-id="5c9d5-285">Esse delegado pode ser invocado simultaneamente em várias tarefas; Portanto, você deve sincronizar o acesso a quaisquer variáveis compartilhadas.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-285">This delegate might be invoked concurrently on multiple tasks; therefore, you must synchronize access to any shared variables.</span></span>  
  
 <span data-ttu-id="5c9d5-286">O <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> método pode usar tarefas mais do que os threads durante a vida útil de sua execução, como as tarefas existentes são concluídas e são substituídas por novas tarefas.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-286">The <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> method may use more tasks than threads over the lifetime of its execution, as existing tasks complete and are replaced by new tasks.</span></span> <span data-ttu-id="5c9d5-287">Isso proporciona subjacente <xref:System.Threading.Tasks.TaskScheduler> do objeto a chance de adicionar, alterar ou remover threads que o loop de serviço.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-287">This gives the underlying <xref:System.Threading.Tasks.TaskScheduler> object the chance to add, change, or remove threads that service the loop.</span></span>  
  
 <span data-ttu-id="5c9d5-288">Se `fromInclusive` é maior que ou igual a `toExclusive`, em seguida, o método retornará imediatamente sem executar qualquer iterações.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-288">If `fromInclusive` is greater than or equal to `toExclusive`, then the method returns immediately without performing any iterations.</span></span>  
  
 <span data-ttu-id="5c9d5-289">Para obter um exemplo que usa esse método, consulte [como: Gravar um loop Parallel.For com variáveis locais de thread](~/docs/standard/parallel-programming/how-to-write-a-parallel-for-loop-with-thread-local-variables.md).</span><span class="sxs-lookup"><span data-stu-id="5c9d5-289">For an example that uses this method, see [How to: Write a Parallel.For Loop with Thread-Local Variables](~/docs/standard/parallel-programming/how-to-write-a-parallel-for-loop-with-thread-local-variables.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="5c9d5-290">O argumento <paramref name="body" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-290">The <paramref name="body" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="5c9d5-291">- ou -</span><span class="sxs-lookup"><span data-stu-id="5c9d5-291">-or-</span></span> 
<span data-ttu-id="5c9d5-292">O argumento <paramref name="localInit" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-292">The <paramref name="localInit" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="5c9d5-293">- ou -</span><span class="sxs-lookup"><span data-stu-id="5c9d5-293">-or-</span></span> 
<span data-ttu-id="5c9d5-294">O argumento <paramref name="localFinally" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-294">The <paramref name="localFinally" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="5c9d5-295">A exceção que contém todas as exceções individuais lançadas em todos os threads.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-295">The exception that contains all the individual exceptions thrown on all threads.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="5c9d5-296">Loops paralelos</span><span class="sxs-lookup"><span data-stu-id="5c9d5-296">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="For&lt;TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt; (int fromInclusive, int toExclusive, System.Threading.Tasks.ParallelOptions parallelOptions, Func&lt;TLocal&gt; localInit, Func&lt;int,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt;(int32 fromInclusive, int32 toExclusive, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;int32, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For``1(System.Int32,System.Int32,System.Threading.Tasks.ParallelOptions,System.Func{``0},System.Func{System.Int32,System.Threading.Tasks.ParallelLoopState,``0,``0},System.Action{``0})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult For(int fromInclusive, int toExclusive, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Func&lt;TLocal&gt; ^ localInit, Func&lt;int, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member For : int * int * System.Threading.Tasks.ParallelOptions * Func&lt;'Local&gt; * Func&lt;int, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, parallelOptions, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;System.Int32,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TLocal"><span data-ttu-id="5c9d5-297">O tipo dos dados locais do thread.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-297">The type of the thread-local data.</span></span></typeparam>
        <param name="fromInclusive"><span data-ttu-id="5c9d5-298">O índice inicial, inclusivo.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-298">The start index, inclusive.</span></span></param>
        <param name="toExclusive"><span data-ttu-id="5c9d5-299">O índice final, exclusivo.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-299">The end index, exclusive.</span></span></param>
        <param name="parallelOptions"><span data-ttu-id="5c9d5-300">Um objeto que configura o comportamento dessa operação.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-300">An object that configures the behavior of this operation.</span></span></param>
        <param name="localInit"><span data-ttu-id="5c9d5-301">O delegado da função que retorna o estado inicial dos dados locais para cada tarefa.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-301">The function delegate that returns the initial state of the local data for each task.</span></span></param>
        <param name="body"><span data-ttu-id="5c9d5-302">O delegado invocado uma vez por iteração.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-302">The delegate that is invoked once per iteration.</span></span></param>
        <param name="localFinally"><span data-ttu-id="5c9d5-303">O delegado que executa uma ação final no estado local de cada tarefa.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-303">The delegate that performs a final action on the local state of each task.</span></span></param>
        <summary><span data-ttu-id="5c9d5-304">Executa um loop <see langword="for" /> com os dados locais do thread nos quais iterações podem ser executadas em paralelo, opções de loop podem ser configuradas e o estado do loop pode ser monitorado e manipulado.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-304">Executes a <see langword="for" /> loop with thread-local data in which iterations may run in parallel, loop options can be configured, and the state of the loop can be monitored and manipulated.</span></span></summary>
        <returns><span data-ttu-id="5c9d5-305">Uma estrutura que contém informações sobre qual parte do loop foi concluída.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-305">A structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c9d5-306">O `body` delegado é invocado uma vez para cada valor no intervalo de iteração (`fromInclusive`, `toExclusive`).</span><span class="sxs-lookup"><span data-stu-id="5c9d5-306">The `body` delegate is invoked once for each value in the iteration range (`fromInclusive`, `toExclusive`).</span></span> <span data-ttu-id="5c9d5-307">Ele é fornecido com os seguintes parâmetros: a contagem de iteração (<xref:System.Int32>), um <xref:System.Threading.Tasks.ParallelLoopState> instância que pode ser usada para interromper o loop prematuramente e alguns estados de locais que podem ser compartilhados entre as iterações que são executados na mesma tarefa.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-307">It is provided with the following parameters: the iteration count (<xref:System.Int32>), a <xref:System.Threading.Tasks.ParallelLoopState> instance that may be used to break out of the loop prematurely, and some local state that may be shared amongst iterations that execute on the same task.</span></span>  
  
 <span data-ttu-id="5c9d5-308">O `localInit` delegado é invocado uma vez para cada tarefa que participa de execução do loop e retorna o estado local inicial para cada uma dessas tarefas.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-308">The `localInit` delegate is invoked once for each task that participates in the loop's execution and returns the initial local state for each of those tasks.</span></span> <span data-ttu-id="5c9d5-309">Esses estados iniciais são passados para o primeiro `body` invocações em cada tarefa.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-309">These initial states are passed to the first `body` invocations on each task.</span></span> <span data-ttu-id="5c9d5-310">Em seguida, cada invocação subsequente corpo retorna um valor de estado possivelmente modificado que é passado para a próxima invocação de corpo.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-310">Then, every subsequent body invocation returns a possibly modified state value that is passed to the next body invocation.</span></span> <span data-ttu-id="5c9d5-311">Por fim, a última chamada do corpo em cada tarefa retorna um valor de estado que é passado para o `localFinally` delegar.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-311">Finally, the last body invocation on each task returns a state value that is passed to the `localFinally` delegate.</span></span> <span data-ttu-id="5c9d5-312">O `localFinally` delegado é invocado uma vez por tarefa para executar uma ação final no estado local de cada tarefa.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-312">The `localFinally` delegate is invoked once per task to perform a final action on each task's local state.</span></span> <span data-ttu-id="5c9d5-313">Esse delegado pode ser invocado simultaneamente em vários threads; Portanto, você deve sincronizar o acesso a quaisquer variáveis compartilhadas.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-313">This delegate might be invoked concurrently on multiple threads; therefore, you must synchronize access to any shared variables.</span></span>  
  
 <span data-ttu-id="5c9d5-314">O <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> método pode usar tarefas mais do que os threads durante a vida útil de sua execução, como as tarefas existentes são concluídas e são substituídas por novas tarefas.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-314">The <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> method may use more tasks than threads over the lifetime of its execution, as existing tasks complete and are replaced by new tasks.</span></span> <span data-ttu-id="5c9d5-315">Isso proporciona subjacente <xref:System.Threading.Tasks.TaskScheduler> do objeto a chance de adicionar, alterar ou remover threads que o loop de serviço.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-315">This gives the underlying <xref:System.Threading.Tasks.TaskScheduler> object the chance to add, change, or remove threads that service the loop.</span></span>  
  
 <span data-ttu-id="5c9d5-316">Se `fromInclusive` é maior que ou igual a `toExclusive`, em seguida, o método retornará imediatamente sem executar qualquer iterações.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-316">If `fromInclusive` is greater than or equal to `toExclusive`, then the method returns immediately without performing any iterations.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5c9d5-317">O exemplo a seguir usa as variáveis locais de thread para calcular a soma dos resultados de muitas operações demoradas.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-317">The following example uses thread-local variables to compute the sum of the results of many lengthy operations.</span></span> <span data-ttu-id="5c9d5-318">Este exemplo limita o grau de paralelismo para quatro.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-318">This example limits the degree of parallelism to four.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Parallel#04](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/threadlocalforwithoptions.cs#04)]
 [!code-vb[System.Threading.Tasks.Parallel#04](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/threadlocalforwithoptions.vb#04)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="5c9d5-319">O argumento <paramref name="body" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-319">The <paramref name="body" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="5c9d5-320">- ou -</span><span class="sxs-lookup"><span data-stu-id="5c9d5-320">-or-</span></span> 
<span data-ttu-id="5c9d5-321">O argumento <paramref name="localInit" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-321">The <paramref name="localInit" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="5c9d5-322">- ou -</span><span class="sxs-lookup"><span data-stu-id="5c9d5-322">-or-</span></span> 
<span data-ttu-id="5c9d5-323">O argumento <paramref name="localFinally" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-323">The <paramref name="localFinally" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="5c9d5-324">- ou -</span><span class="sxs-lookup"><span data-stu-id="5c9d5-324">-or-</span></span> 
<span data-ttu-id="5c9d5-325">O argumento <paramref name="parallelOptions" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-325">The <paramref name="parallelOptions" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.OperationCanceledException"><span data-ttu-id="5c9d5-326">O <see cref="T:System.Threading.CancellationToken" /> no argumento <paramref name="parallelOptions" /> foi cancelado.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-326">The <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> argument is canceled.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="5c9d5-327">O <see cref="T:System.Threading.CancellationTokenSource" /> associado ao <see cref="T:System.Threading.CancellationToken" /> no <paramref name="parallelOptions" /> foi descartado.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-327">The <see cref="T:System.Threading.CancellationTokenSource" /> associated with the <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> has been disposed.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="5c9d5-328">A exceção que contém todas as exceções individuais lançadas em todos os threads.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-328">The exception that contains all the individual exceptions thrown on all threads.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="5c9d5-329">Loops paralelos</span><span class="sxs-lookup"><span data-stu-id="5c9d5-329">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="For&lt;TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt; (long fromInclusive, long toExclusive, System.Threading.Tasks.ParallelOptions parallelOptions, Func&lt;TLocal&gt; localInit, Func&lt;long,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt;(int64 fromInclusive, int64 toExclusive, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;int64, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For``1(System.Int64,System.Int64,System.Threading.Tasks.ParallelOptions,System.Func{``0},System.Func{System.Int64,System.Threading.Tasks.ParallelLoopState,``0,``0},System.Action{``0})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult For(long fromInclusive, long toExclusive, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Func&lt;TLocal&gt; ^ localInit, Func&lt;long, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member For : int64 * int64 * System.Threading.Tasks.ParallelOptions * Func&lt;'Local&gt; * Func&lt;int64, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, parallelOptions, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int64" />
        <Parameter Name="toExclusive" Type="System.Int64" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;System.Int64,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TLocal"><span data-ttu-id="5c9d5-330">O tipo dos dados locais do thread.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-330">The type of the thread-local data.</span></span></typeparam>
        <param name="fromInclusive"><span data-ttu-id="5c9d5-331">O índice inicial, inclusivo.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-331">The start index, inclusive.</span></span></param>
        <param name="toExclusive"><span data-ttu-id="5c9d5-332">O índice final, exclusivo.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-332">The end index, exclusive.</span></span></param>
        <param name="parallelOptions"><span data-ttu-id="5c9d5-333">Um objeto que configura o comportamento dessa operação.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-333">An object that configures the behavior of this operation.</span></span></param>
        <param name="localInit"><span data-ttu-id="5c9d5-334">O delegado da função que retorna o estado inicial dos dados locais para cada thread.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-334">The function delegate that returns the initial state of the local data for each thread.</span></span></param>
        <param name="body"><span data-ttu-id="5c9d5-335">O delegado invocado uma vez por iteração.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-335">The delegate that is invoked once per iteration.</span></span></param>
        <param name="localFinally"><span data-ttu-id="5c9d5-336">O delegado que executa uma ação final no estado local de cada thread.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-336">The delegate that performs a final action on the local state of each thread.</span></span></param>
        <summary><span data-ttu-id="5c9d5-337">Executa um loop <see langword="for" /> com índices de 64 bits e dados locais do thread nos quais iterações podem ser executadas em paralelo, opções de loop podem ser configuradas e o estado do loop pode ser monitorado e manipulado.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-337">Executes a <see langword="for" /> loop with 64-bit indexes and thread-local data in which iterations may run in parallel, loop options can be configured, and the state of the loop can be monitored and manipulated.</span></span></summary>
        <returns><span data-ttu-id="5c9d5-338">Uma estrutura que contém informações sobre qual parte do loop foi concluída.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-338">A structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c9d5-339">O `body` delegado é invocado uma vez para cada valor no intervalo de iteração (`fromInclusive`, `toExclusive`).</span><span class="sxs-lookup"><span data-stu-id="5c9d5-339">The `body` delegate is invoked once for each value in the iteration range (`fromInclusive`, `toExclusive`).</span></span> <span data-ttu-id="5c9d5-340">Ele é fornecido com os seguintes parâmetros: a contagem de iteração (<xref:System.Int64>), um <xref:System.Threading.Tasks.ParallelLoopState> instância que pode ser usada para interromper o loop prematuramente e alguns estados de locais que podem ser compartilhados entre as iterações que executam no mesmo thread.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-340">It is provided with the following parameters: the iteration count (<xref:System.Int64>), a <xref:System.Threading.Tasks.ParallelLoopState> instance that may be used to break out of the loop prematurely, and some local state that may be shared amongst iterations that execute on the same thread.</span></span>  
  
 <span data-ttu-id="5c9d5-341">O `localInit` delegado é invocado uma vez para cada thread que participa da execução do loop e retorna o estado local inicial para cada um desses segmentos.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-341">The `localInit` delegate is invoked once for each thread that participates in the loop's execution and returns the initial local state for each of those threads.</span></span> <span data-ttu-id="5c9d5-342">Esses estados iniciais são passados para o primeiro `body` invocações em cada thread.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-342">These initial states are passed to the first `body` invocations on each thread.</span></span> <span data-ttu-id="5c9d5-343">Em seguida, cada invocação subsequente corpo retorna um valor de estado possivelmente modificado que é passado para a próxima invocação de corpo.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-343">Then, every subsequent body invocation returns a possibly modified state value that is passed to the next body invocation.</span></span> <span data-ttu-id="5c9d5-344">Por fim, a última chamada do corpo em cada thread retorna um valor de estado que é passado para o `localFinally` delegar.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-344">Finally, the last body invocation on each thread returns a state value that is passed to the `localFinally` delegate.</span></span> <span data-ttu-id="5c9d5-345">O `localFinally` delegado é invocado uma vez por thread para executar uma ação final no estado local de cada thread.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-345">The `localFinally` delegate is invoked once per thread to perform a final action on each thread's local state.</span></span> <span data-ttu-id="5c9d5-346">Esse delegado pode ser invocado simultaneamente em vários threads; Portanto, você deve sincronizar o acesso a quaisquer variáveis compartilhadas.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-346">This delegate might be invoked concurrently on multiple threads; therefore, you must synchronize access to any shared variables.</span></span>  
  
 <span data-ttu-id="5c9d5-347">O <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> método pode usar tarefas mais do que os threads durante a vida útil de sua execução, como as tarefas existentes são concluídas e são substituídas por novas tarefas.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-347">The <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> method may use more tasks than threads over the lifetime of its execution, as existing tasks complete and are replaced by new tasks.</span></span> <span data-ttu-id="5c9d5-348">Isso proporciona subjacente <xref:System.Threading.Tasks.TaskScheduler> do objeto a chance de adicionar, alterar ou remover threads que o loop de serviço.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-348">This gives the underlying <xref:System.Threading.Tasks.TaskScheduler> object the chance to add, change, or remove threads that service the loop.</span></span>  
  
 <span data-ttu-id="5c9d5-349">Se `fromInclusive` é maior que ou igual a `toExclusive`, em seguida, o método retornará imediatamente sem executar qualquer iterações.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-349">If `fromInclusive` is greater than or equal to `toExclusive`, then the method returns immediately without performing any iterations.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="5c9d5-350">O argumento <paramref name="body" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-350">The <paramref name="body" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="5c9d5-351">- ou -</span><span class="sxs-lookup"><span data-stu-id="5c9d5-351">-or-</span></span> 
<span data-ttu-id="5c9d5-352">O argumento <paramref name="localInit" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-352">The <paramref name="localInit" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="5c9d5-353">- ou -</span><span class="sxs-lookup"><span data-stu-id="5c9d5-353">-or-</span></span> 
<span data-ttu-id="5c9d5-354">O argumento <paramref name="localFinally" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-354">The <paramref name="localFinally" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="5c9d5-355">- ou -</span><span class="sxs-lookup"><span data-stu-id="5c9d5-355">-or-</span></span> 
<span data-ttu-id="5c9d5-356">O argumento <paramref name="parallelOptions" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-356">The <paramref name="parallelOptions" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.OperationCanceledException"><span data-ttu-id="5c9d5-357">O <see cref="T:System.Threading.CancellationToken" /> no argumento <paramref name="parallelOptions" /> foi cancelado.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-357">The <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> argument is canceled.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="5c9d5-358">O <see cref="T:System.Threading.CancellationTokenSource" /> associado ao <see cref="T:System.Threading.CancellationToken" /> no <paramref name="parallelOptions" /> foi descartado.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-358">The <see cref="T:System.Threading.CancellationTokenSource" /> associated with the <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> has been disposed.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="5c9d5-359">A exceção que contém todas as exceções individuais lançadas em todos os threads.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-359">The exception that contains all the individual exceptions thrown on all threads.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="5c9d5-360">Loops paralelos</span><span class="sxs-lookup"><span data-stu-id="5c9d5-360">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ForEach&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="5c9d5-361">Executa uma operação <see langword="foreach" /> (<see langword="For Each " /> no Visual Basic) no qual as iterações podem ser executadas em paralelo.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-361">Executes a <see langword="foreach" /> (<see langword="For Each " /> in Visual Basic) operation in which iterations may run in parallel.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt; source, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,long&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Concurrent.OrderablePartitioner`1&lt;!!TSource&gt; source, class System.Action`3&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.OrderablePartitioner{``0},System.Action{``0,System.Threading.Tasks.ParallelLoopState,System.Int64})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource) (source As OrderablePartitioner(Of TSource), body As Action(Of TSource, ParallelLoopState, Long)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::OrderablePartitioner&lt;TSource&gt; ^ source, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.OrderablePartitioner&lt;'Source&gt; * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt;" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource"><span data-ttu-id="5c9d5-362">O tipo dos elementos em <paramref name="source" />.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-362">The type of the elements in <paramref name="source" />.</span></span></typeparam>
        <param name="source"><span data-ttu-id="5c9d5-363">O particionador solicitável que contém a fonte de dados original.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-363">The orderable partitioner that contains the original data source.</span></span></param>
        <param name="body"><span data-ttu-id="5c9d5-364">O delegado invocado uma vez por iteração.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-364">The delegate that is invoked once per iteration.</span></span></param>
        <summary><span data-ttu-id="5c9d5-365">Executa uma operação <see langword="foreach" /> (<see langword="For Each" /> no Visual Basic) em um <see cref="T:System.Collections.Concurrent.OrderablePartitioner`1" />, no qual as iterações podem ser executadas em paralelo e o estado do loop pode ser monitorado e manipulado.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-365">Executes a <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) operation on a <see cref="T:System.Collections.Concurrent.OrderablePartitioner`1" /> in which iterations may run in parallel and the state of the loop can be monitored and manipulated.</span></span></summary>
        <returns><span data-ttu-id="5c9d5-366">Uma estrutura que contém informações sobre qual parte do loop foi concluída.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-366">A structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c9d5-367">Essa sobrecarga é fornecida para cenários em que você deseja substituir o padrão de esquema de particionamento.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-367">This overload is provided for scenarios where you want to override the default partitioning scheme.</span></span> <span data-ttu-id="5c9d5-368">Por exemplo, corpos de loop pequenos podem se beneficiar do particionamento de intervalo.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-368">For example, small loop bodies might benefit from partitioning the range.</span></span> <span data-ttu-id="5c9d5-369">O <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> particionadores personalizados para dar suporte ao particionamento dinâmico de espera do método.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-369">The <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> method expects custom partitioners to support dynamic partitioning.</span></span> <span data-ttu-id="5c9d5-370">Para obter mais informações, consulte [Particionadores personalizados para PLINQ e TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) e [como: Implementar partições dinâmicas](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).</span><span class="sxs-lookup"><span data-stu-id="5c9d5-370">For more information, see [Custom Partitioners for PLINQ and TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) and [How to: Implement Dynamic Partitions](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="5c9d5-371">O argumento <paramref name="source" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-371">The <paramref name="source" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="5c9d5-372">- ou -</span><span class="sxs-lookup"><span data-stu-id="5c9d5-372">-or-</span></span> 
<span data-ttu-id="5c9d5-373">O argumento <paramref name="body" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-373">The <paramref name="body" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="5c9d5-374">A propriedade <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> no particionador solicitável <paramref name="source" /> retorna <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-374">The <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> property in the <paramref name="source" /> orderable partitioner returns <see langword="false" />.</span></span>  
  
<span data-ttu-id="5c9d5-375">- ou -</span><span class="sxs-lookup"><span data-stu-id="5c9d5-375">-or-</span></span> 
<span data-ttu-id="5c9d5-376">A propriedade <see cref="P:System.Collections.Concurrent.OrderablePartitioner`1.KeysNormalized" /> no particionador solicitável de origem retorna <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-376">The <see cref="P:System.Collections.Concurrent.OrderablePartitioner`1.KeysNormalized" /> property in the source orderable partitioner returns <see langword="false" />.</span></span>  
  
<span data-ttu-id="5c9d5-377">- ou -</span><span class="sxs-lookup"><span data-stu-id="5c9d5-377">-or-</span></span> 
<span data-ttu-id="5c9d5-378">Quaisquer métodos no particionador solicitável de origem retorna <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-378">Any methods in the source orderable partitioner return <see langword="null" />.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="5c9d5-379">Loops paralelos</span><span class="sxs-lookup"><span data-stu-id="5c9d5-379">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Concurrent.Partitioner&lt;TSource&gt; source, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Concurrent.Partitioner`1&lt;!!TSource&gt; source, class System.Action`2&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.Partitioner{``0},System.Action{``0,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource) (source As Partitioner(Of TSource), body As Action(Of TSource, ParallelLoopState)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::Partitioner&lt;TSource&gt; ^ source, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.Partitioner&lt;'Source&gt; * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.Partitioner&lt;TSource&gt;" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource"><span data-ttu-id="5c9d5-380">O tipo dos elementos em <paramref name="source" />.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-380">The type of the elements in <paramref name="source" />.</span></span></typeparam>
        <param name="source"><span data-ttu-id="5c9d5-381">O particionador que contém a fonte de dados original.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-381">The partitioner that contains the original data source.</span></span></param>
        <param name="body"><span data-ttu-id="5c9d5-382">O delegado invocado uma vez por iteração.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-382">The delegate that is invoked once per iteration.</span></span></param>
        <summary><span data-ttu-id="5c9d5-383">Executa uma operação <see langword="foreach" /> (<see langword="For Each" /> no Visual Basic) em um <see cref="T:System.Collections.Concurrent.Partitioner" />, na qual as iterações podem ser executadas em paralelo e o estado do loop pode ser monitorado e manipulado.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-383">Executes a <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) operation on a <see cref="T:System.Collections.Concurrent.Partitioner" /> in which iterations may run in parallel, and the state of the loop can be monitored and manipulated.</span></span></summary>
        <returns><span data-ttu-id="5c9d5-384">Uma estrutura que contém informações sobre qual parte do loop foi concluída.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-384">A structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c9d5-385">Essa sobrecarga é fornecida para cenários em que você deseja substituir o padrão de esquema de particionamento.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-385">This overload is provided for scenarios where you want to override the default partitioning scheme.</span></span> <span data-ttu-id="5c9d5-386">Por exemplo, corpos de loop pequenos podem se beneficiar do particionamento de intervalo.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-386">For example, small loop bodies might benefit from partitioning the range.</span></span> <span data-ttu-id="5c9d5-387">O <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> particionadores personalizados para dar suporte ao particionamento dinâmico de espera do método.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-387">The <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> method expects custom partitioners to support dynamic partitioning.</span></span> <span data-ttu-id="5c9d5-388">Para obter mais informações, consulte [Particionadores personalizados para PLINQ e TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) e [como: Implementar partições dinâmicas](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).</span><span class="sxs-lookup"><span data-stu-id="5c9d5-388">For more information, see [Custom Partitioners for PLINQ and TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) and [How to: Implement Dynamic Partitions](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="5c9d5-389">O argumento <paramref name="source" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-389">The <paramref name="source" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="5c9d5-390">- ou -</span><span class="sxs-lookup"><span data-stu-id="5c9d5-390">-or-</span></span> 
<span data-ttu-id="5c9d5-391">O argumento <paramref name="body" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-391">The <paramref name="body" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="5c9d5-392">A propriedade <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> no particionador <paramref name="source" /> retorna <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-392">The <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> property in the <paramref name="source" /> partitioner returns <see langword="false" />.</span></span>  
  
<span data-ttu-id="5c9d5-393">- ou -</span><span class="sxs-lookup"><span data-stu-id="5c9d5-393">-or-</span></span> 
<span data-ttu-id="5c9d5-394">O método no particionador <paramref name="source" /> retorna <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-394">A method in the <paramref name="source" /> partitioner returns <see langword="null" />.</span></span>  
  
<span data-ttu-id="5c9d5-395">- ou -</span><span class="sxs-lookup"><span data-stu-id="5c9d5-395">-or-</span></span> 
<span data-ttu-id="5c9d5-396">O método <see cref="M:System.Collections.Concurrent.Partitioner`1.GetPartitions(System.Int32)" /> no particionador <paramref name="source" /> não retorna o número de partições correto.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-396">The <see cref="M:System.Collections.Concurrent.Partitioner`1.GetPartitions(System.Int32)" /> method in the <paramref name="source" /> partitioner does not return the correct number of partitions.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="5c9d5-397">Loops paralelos</span><span class="sxs-lookup"><span data-stu-id="5c9d5-397">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Concurrent.Partitioner&lt;TSource&gt; source, Action&lt;TSource&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Concurrent.Partitioner`1&lt;!!TSource&gt; source, class System.Action`1&lt;!!TSource&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.Partitioner{``0},System.Action{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource) (source As Partitioner(Of TSource), body As Action(Of TSource)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::Partitioner&lt;TSource&gt; ^ source, Action&lt;TSource&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.Partitioner&lt;'Source&gt; * Action&lt;'Source&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.Partitioner&lt;TSource&gt;" />
        <Parameter Name="body" Type="System.Action&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource"><span data-ttu-id="5c9d5-398">O tipo dos elementos em <paramref name="source" />.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-398">The type of the elements in <paramref name="source" />.</span></span></typeparam>
        <param name="source"><span data-ttu-id="5c9d5-399">O particionador que contém a fonte de dados original.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-399">The partitioner that contains the original data source.</span></span></param>
        <param name="body"><span data-ttu-id="5c9d5-400">O delegado invocado uma vez por iteração.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-400">The delegate that is invoked once per iteration.</span></span></param>
        <summary><span data-ttu-id="5c9d5-401">Executa uma operação <see langword="foreach" /> (<see langword="For Each" /> no Visual Basic) em um <see cref="T:System.Collections.Concurrent.Partitioner" /> no qual as iterações podem ser executadas em paralelo.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-401">Executes a <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) operation on a <see cref="T:System.Collections.Concurrent.Partitioner" /> in which iterations may run in parallel.</span></span></summary>
        <returns><span data-ttu-id="5c9d5-402">Uma estrutura que contém informações sobre qual parte do loop foi concluída.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-402">A structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c9d5-403">Essa sobrecarga é fornecida para cenários em que você deseja substituir o padrão de esquema de particionamento.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-403">This overload is provided for scenarios where you want to override the default partitioning scheme.</span></span> <span data-ttu-id="5c9d5-404">Por exemplo, corpos de loop pequenos podem se beneficiar do particionamento de intervalo.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-404">For example, small loop bodies might benefit from partitioning the range.</span></span> <span data-ttu-id="5c9d5-405">O <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> particionadores personalizados para dar suporte ao particionamento dinâmico de espera do método.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-405">The <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> method expects custom partitioners to support dynamic partitioning.</span></span> <span data-ttu-id="5c9d5-406">Para obter mais informações, consulte [Particionadores personalizados para PLINQ e TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) e [como: Implementar partições dinâmicas](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).</span><span class="sxs-lookup"><span data-stu-id="5c9d5-406">For more information, see [Custom Partitioners for PLINQ and TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) and [How to: Implement Dynamic Partitions](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5c9d5-407">O exemplo a seguir mostra como implementar um particionador de intervalo para uso com <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType>:</span><span class="sxs-lookup"><span data-stu-id="5c9d5-407">The following example shows how to implement a range partitioner for use with <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType>:</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Parallel_RangePartitioners#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel_rangepartitioners/cs/rangepartitioner.cs#01)]
 [!code-vb[System.Threading.Tasks.Parallel_RangePartitioners#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel_rangepartitioners/vb/rangepart.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="5c9d5-408">O argumento <paramref name="source" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-408">The <paramref name="source" /> argument is  <see langword="null" />.</span></span>  
  
<span data-ttu-id="5c9d5-409">- ou -</span><span class="sxs-lookup"><span data-stu-id="5c9d5-409">-or-</span></span> 
<span data-ttu-id="5c9d5-410">O argumento <paramref name="body" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-410">The <paramref name="body" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="5c9d5-411">A propriedade <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> no particionador <paramref name="source" /> retorna <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-411">The <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> property in the <paramref name="source" /> partitioner returns <see langword="false" />.</span></span>  
  
<span data-ttu-id="5c9d5-412">- ou -</span><span class="sxs-lookup"><span data-stu-id="5c9d5-412">-or-</span></span> 
<span data-ttu-id="5c9d5-413">A exceção que é gerada quando qualquer método no particionador <paramref name="source" /> retorna <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-413">The exception that is thrown when any methods in the <paramref name="source" /> partitioner return <see langword="null" />.</span></span>  
  
<span data-ttu-id="5c9d5-414">- ou -</span><span class="sxs-lookup"><span data-stu-id="5c9d5-414">-or-</span></span> 
<span data-ttu-id="5c9d5-415">O método <see cref="M:System.Collections.Concurrent.Partitioner`1.GetPartitions(System.Int32)" /> no particionador <paramref name="source" /> não retorna o número de partições correto.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-415">The <see cref="M:System.Collections.Concurrent.Partitioner`1.GetPartitions(System.Int32)" /> method in the <paramref name="source" /> partitioner does not return the correct number of partitions.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="5c9d5-416">Loops paralelos</span><span class="sxs-lookup"><span data-stu-id="5c9d5-416">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,long&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Action`3&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0,System.Threading.Tasks.ParallelLoopState,System.Int64})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource) (source As IEnumerable(Of TSource), body As Action(Of TSource, ParallelLoopState, Long)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource"><span data-ttu-id="5c9d5-417">O tipo de dados na fonte.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-417">The type of the data in the source.</span></span></typeparam>
        <param name="source"><span data-ttu-id="5c9d5-418">Uma fonte de dados enumerável.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-418">An enumerable data source.</span></span></param>
        <param name="body"><span data-ttu-id="5c9d5-419">O delegado invocado uma vez por iteração.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-419">The delegate that is invoked once per iteration.</span></span></param>
        <summary><span data-ttu-id="5c9d5-420">Executa uma operação <see langword="foreach" /> (<see langword="For Each" /> no Visual Basic) com índices de 64 bits em uma <see cref="T:System.Collections.IEnumerable" /> na qual as iterações podem ser executadas em paralelo e o estado do loop pode ser monitorado e manipulado.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-420">Executes a <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) operation with 64-bit indexes on an <see cref="T:System.Collections.IEnumerable" /> in which iterations may run in parallel, and the state of the loop can be monitored and manipulated.</span></span></summary>
        <returns><span data-ttu-id="5c9d5-421">Uma estrutura que contém informações sobre qual parte do loop foi concluída.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-421">A structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c9d5-422">O `body` delegado é invocado uma vez para cada elemento no `source` enumerável.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-422">The `body` delegate is invoked once for each element in the `source` enumerable.</span></span> <span data-ttu-id="5c9d5-423">Ele é fornecido com os seguintes parâmetros: o elemento atual, uma <xref:System.Threading.Tasks.ParallelLoopState> instância que pode ser usada para interromper o loop prematuramente e o índice do elemento atual (<xref:System.Int64>).</span><span class="sxs-lookup"><span data-stu-id="5c9d5-423">It is provided with the following parameters: the current element, a <xref:System.Threading.Tasks.ParallelLoopState> instance that may be used to break out of the loop prematurely, and the current element's index (<xref:System.Int64>).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="5c9d5-424">O argumento <paramref name="source" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-424">The <paramref name="source" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="5c9d5-425">- ou -</span><span class="sxs-lookup"><span data-stu-id="5c9d5-425">-or-</span></span> 
<span data-ttu-id="5c9d5-426">O argumento <paramref name="body" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-426">The <paramref name="body" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="5c9d5-427">A exceção que contém todas as exceções individuais lançadas em todos os threads.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-427">The exception that contains all the individual exceptions thrown on all threads.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="5c9d5-428">Loops paralelos</span><span class="sxs-lookup"><span data-stu-id="5c9d5-428">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Action`2&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource) (source As IEnumerable(Of TSource), body As Action(Of TSource, ParallelLoopState)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource"><span data-ttu-id="5c9d5-429">O tipo de dados na fonte.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-429">The type of the data in the source.</span></span></typeparam>
        <param name="source"><span data-ttu-id="5c9d5-430">Uma fonte de dados enumerável.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-430">An enumerable data source.</span></span></param>
        <param name="body"><span data-ttu-id="5c9d5-431">O delegado invocado uma vez por iteração.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-431">The delegate that is invoked once per iteration.</span></span></param>
        <summary><span data-ttu-id="5c9d5-432">Executa uma operação <see langword="foreach" /> (<see langword="For Each" /> no Visual Basic) em uma <see cref="T:System.Collections.IEnumerable" /> na qual as iterações podem ser executadas em paralelo e o estado do loop pode ser monitorado e manipulado.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-432">Executes a <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) operation on an <see cref="T:System.Collections.IEnumerable" /> in which iterations may run in parallel, and the state of the loop can be monitored and manipulated.</span></span></summary>
        <returns><span data-ttu-id="5c9d5-433">Uma estrutura que contém informações sobre qual parte do loop foi concluída.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-433">A structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c9d5-434">O `body` delegado é invocado uma vez para cada elemento no `source` enumerável.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-434">The `body` delegate is invoked once for each element in the `source` enumerable.</span></span> <span data-ttu-id="5c9d5-435">Ele é fornecido com os seguintes parâmetros: o elemento atual e um <xref:System.Threading.Tasks.ParallelLoopState> instância que pode ser usada para interromper o loop prematuramente.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-435">It is provided with the following parameters: the current element, and a <xref:System.Threading.Tasks.ParallelLoopState> instance that may be used to break out of the loop prematurely.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="5c9d5-436">O argumento <paramref name="source" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-436">The <paramref name="source" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="5c9d5-437">- ou -</span><span class="sxs-lookup"><span data-stu-id="5c9d5-437">-or-</span></span> 
<span data-ttu-id="5c9d5-438">O argumento <paramref name="body" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-438">The <paramref name="body" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="5c9d5-439">A exceção que contém todas as exceções individuais lançadas em todos os threads.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-439">The exception that contains all the individual exceptions thrown on all threads.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="5c9d5-440">Loops paralelos</span><span class="sxs-lookup"><span data-stu-id="5c9d5-440">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Action&lt;TSource&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Action`1&lt;!!TSource&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource) (source As IEnumerable(Of TSource), body As Action(Of TSource)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Action&lt;TSource&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * Action&lt;'Source&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="body" Type="System.Action&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource"><span data-ttu-id="5c9d5-441">O tipo de dados na fonte.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-441">The type of the data in the source.</span></span></typeparam>
        <param name="source"><span data-ttu-id="5c9d5-442">Uma fonte de dados enumerável.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-442">An enumerable data source.</span></span></param>
        <param name="body"><span data-ttu-id="5c9d5-443">O delegado invocado uma vez por iteração.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-443">The delegate that is invoked once per iteration.</span></span></param>
        <summary><span data-ttu-id="5c9d5-444">Executa uma operação <see langword="foreach" /> (<see langword="For Each" /> no Visual Basic) em um <see cref="T:System.Collections.IEnumerable" /> no qual as iterações podem ser executadas em paralelo.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-444">Executes a <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) operation on an <see cref="T:System.Collections.IEnumerable" /> in which iterations may run in parallel.</span></span></summary>
        <returns><span data-ttu-id="5c9d5-445">Uma estrutura que contém informações sobre qual parte do loop foi concluída.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-445">A structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c9d5-446">O `body` delegado é invocado uma vez para cada elemento no `source` enumerável.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-446">The `body` delegate is invoked once for each element in the `source` enumerable.</span></span> <span data-ttu-id="5c9d5-447">Ele é fornecido com o elemento atual como um parâmetro.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-447">It is provided with the current element as a parameter.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5c9d5-448">O exemplo a seguir usa o <xref:System.Threading.Tasks.Parallel.ForEach%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Action%7B%60%600%7D%29> método para contar o número de caracteres de espaço não em branco em um arquivo de texto e vogais.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-448">The following example uses the <xref:System.Threading.Tasks.Parallel.ForEach%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Action%7B%60%600%7D%29> method to count the number of vowels and non-white-space characters in a text file.</span></span> <span data-ttu-id="5c9d5-449">Nesse caso, o <xref:System.Threading.Tasks.ParallelLoopResult> valor retornado pelo método é ignorado.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-449">In this case, the <xref:System.Threading.Tasks.ParallelLoopResult> value returned by the method is ignored.</span></span> <span data-ttu-id="5c9d5-450">Observe que, porque as operações podem ser executados em paralelo, você deve garantir que a incrementar as variáveis de contador é uma operação atômica, e que vários threads não tentar acessar as variáveis de contador simultaneamente.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-450">Note that, because operations can run in parallel, you must ensure that incrementing the counter variables is an atomic operation, and that multiple threads do not attempt to access the counter variables simultaneously.</span></span> <span data-ttu-id="5c9d5-451">Para essa finalidade, o exemplo usa o `lock` instrução (em c#) e o `SyncLock` instrução (no Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="5c9d5-451">For this purpose, the example uses the `lock` statement (in C#) and the `SyncLock` statement (in Visual Basic).</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Parallel.ForEach#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel.foreach/cs/foreach1.cs#1)]
 [!code-vb[System.Threading.Tasks.Parallel.ForEach#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel.foreach/vb/foreach1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="5c9d5-452">O argumento <paramref name="source" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-452">The <paramref name="source" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="5c9d5-453">- ou -</span><span class="sxs-lookup"><span data-stu-id="5c9d5-453">-or-</span></span> 
<span data-ttu-id="5c9d5-454">O argumento <paramref name="body" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-454">The <paramref name="body" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="5c9d5-455">A exceção que contém todas as exceções individuais lançadas em todos os threads.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-455">The exception that contains all the individual exceptions thrown on all threads.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="5c9d5-456">Loops paralelos</span><span class="sxs-lookup"><span data-stu-id="5c9d5-456">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,long&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Concurrent.OrderablePartitioner`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`3&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.OrderablePartitioner{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0,System.Threading.Tasks.ParallelLoopState,System.Int64})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::OrderablePartitioner&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.OrderablePartitioner&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource"><span data-ttu-id="5c9d5-457">O tipo dos elementos em <paramref name="source" />.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-457">The type of the elements in <paramref name="source" />.</span></span></typeparam>
        <param name="source"><span data-ttu-id="5c9d5-458">O particionador ordenável que contém a fonte de dados original.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-458">The orderable partitioner that contains the original data source.</span></span></param>
        <param name="parallelOptions"><span data-ttu-id="5c9d5-459">Um objeto que configura o comportamento dessa operação.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-459">An object that configures the behavior of this operation.</span></span></param>
        <param name="body"><span data-ttu-id="5c9d5-460">O delegado invocado uma vez por iteração.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-460">The delegate that is invoked once per iteration.</span></span></param>
        <summary><span data-ttu-id="5c9d5-461">Executa uma operação <see langword="foreach" /> (<see langword="For Each" /> no Visual Basic) em um <see cref="T:System.Collections.Concurrent.OrderablePartitioner`1" />, em que iterações podem ser executadas em paralelo, opções de loop podem ser configuradas e o estado do loop pode ser monitorado e manipulado.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-461">Executes a <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) operation on a <see cref="T:System.Collections.Concurrent.OrderablePartitioner`1" /> in which iterations may run in parallel, loop options can be configured, and the state of the loop can be monitored and manipulated.</span></span></summary>
        <returns><span data-ttu-id="5c9d5-462">Uma estrutura que contém informações sobre qual parte do loop foi concluída.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-462">A structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c9d5-463">Essa sobrecarga é fornecida para cenários em que você deseja substituir o padrão de esquema de particionamento.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-463">This overload is provided for scenarios where you want to override the default partitioning scheme.</span></span> <span data-ttu-id="5c9d5-464">Por exemplo, corpos de loop pequenos podem se beneficiar do particionamento de intervalo.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-464">For example, small loop bodies might benefit from partitioning the range.</span></span> <span data-ttu-id="5c9d5-465">O <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> particionadores personalizados para dar suporte ao particionamento dinâmico de espera do método.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-465">The <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> method expects custom partitioners to support dynamic partitioning.</span></span> <span data-ttu-id="5c9d5-466">Para obter mais informações, consulte [Particionadores personalizados para PLINQ e TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) e [como: Implementar partições dinâmicas](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).</span><span class="sxs-lookup"><span data-stu-id="5c9d5-466">For more information, see [Custom Partitioners for PLINQ and TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) and [How to: Implement Dynamic Partitions](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException"><span data-ttu-id="5c9d5-467">O <see cref="T:System.Threading.CancellationToken" /> no argumento <paramref name="parallelOptions" /> foi cancelado</span><span class="sxs-lookup"><span data-stu-id="5c9d5-467">The <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> argument is canceled</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="5c9d5-468">O argumento <paramref name="source" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-468">The <paramref name="source" /> argument is  <see langword="null" />.</span></span>  
  
<span data-ttu-id="5c9d5-469">- ou -</span><span class="sxs-lookup"><span data-stu-id="5c9d5-469">-or-</span></span> 
<span data-ttu-id="5c9d5-470">O argumento <paramref name="parallelOptions" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-470">The <paramref name="parallelOptions" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="5c9d5-471">- ou -</span><span class="sxs-lookup"><span data-stu-id="5c9d5-471">-or-</span></span> 
<span data-ttu-id="5c9d5-472">O argumento <paramref name="body" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-472">The <paramref name="body" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="5c9d5-473">O <see cref="T:System.Threading.CancellationTokenSource" /> associado ao <see cref="T:System.Threading.CancellationToken" /> no <paramref name="parallelOptions" /> foi descartado.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-473">The <see cref="T:System.Threading.CancellationTokenSource" /> associated with the <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> has been disposed.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="5c9d5-474">A propriedade <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> no particionador solicitável <paramref name="source" /> retorna <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-474">The <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> property in the <paramref name="source" /> orderable partitioner returns <see langword="false" />.</span></span>  
  
<span data-ttu-id="5c9d5-475">- ou -</span><span class="sxs-lookup"><span data-stu-id="5c9d5-475">-or-</span></span> 
<span data-ttu-id="5c9d5-476">A propriedade <see cref="P:System.Collections.Concurrent.OrderablePartitioner`1.KeysNormalized" /> no particionador solicitável <paramref name="source" /> retorna <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-476">The <see cref="P:System.Collections.Concurrent.OrderablePartitioner`1.KeysNormalized" /> property in the <paramref name="source" /> orderable partitioner returns <see langword="false" />.</span></span>  
  
<span data-ttu-id="5c9d5-477">- ou -</span><span class="sxs-lookup"><span data-stu-id="5c9d5-477">-or-</span></span> 
<span data-ttu-id="5c9d5-478">A exceção que é gerada quando qualquer método no particionador solicitável <paramref name="source" /> retorna <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-478">The exception that is thrown when any methods in the <paramref name="source" /> orderable partitioner return <see langword="null" />.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="5c9d5-479">Loops paralelos</span><span class="sxs-lookup"><span data-stu-id="5c9d5-479">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Concurrent.Partitioner&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Concurrent.Partitioner`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`2&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.Partitioner{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::Partitioner&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.Partitioner&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.Partitioner&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource"><span data-ttu-id="5c9d5-480">O tipo dos elementos em <paramref name="source" />.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-480">The type of the elements in <paramref name="source" />.</span></span></typeparam>
        <param name="source"><span data-ttu-id="5c9d5-481">O particionador que contém a fonte de dados original.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-481">The partitioner that contains the original data source.</span></span></param>
        <param name="parallelOptions"><span data-ttu-id="5c9d5-482">Um objeto que configura o comportamento dessa operação.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-482">An object that configures the behavior of this operation.</span></span></param>
        <param name="body"><span data-ttu-id="5c9d5-483">O delegado invocado uma vez por iteração.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-483">The delegate that is invoked once per iteration.</span></span></param>
        <summary><span data-ttu-id="5c9d5-484">Executa uma operação <see langword="foreach" /> (<see langword="For Each" /> no Visual Basic) em um <see cref="T:System.Collections.Concurrent.Partitioner" />, em que iterações podem ser executadas em paralelo, opções de loop podem ser configuradas e o estado do loop pode ser monitorado e manipulado.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-484">Executes a <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) operation on a <see cref="T:System.Collections.Concurrent.Partitioner" /> in which iterations may run in parallel, loop options can be configured, and the state of the loop can be monitored and manipulated.</span></span></summary>
        <returns><span data-ttu-id="5c9d5-485">Uma estrutura que contém informações sobre qual parte do loop foi concluída.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-485">A  structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c9d5-486">Essa sobrecarga é fornecida para cenários em que você deseja substituir o padrão de esquema de particionamento.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-486">This overload is provided for scenarios where you want to override the default partitioning scheme.</span></span> <span data-ttu-id="5c9d5-487">Por exemplo, corpos de loop pequenos podem se beneficiar do particionamento de intervalo.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-487">For example, small loop bodies might benefit from partitioning the range.</span></span> <span data-ttu-id="5c9d5-488">O <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> particionadores personalizados para dar suporte ao particionamento dinâmico de espera do método.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-488">The <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> method expects custom partitioners to support dynamic partitioning.</span></span> <span data-ttu-id="5c9d5-489">Para obter mais informações, consulte [Particionadores personalizados para PLINQ e TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) e [como: Implementar partições dinâmicas](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).</span><span class="sxs-lookup"><span data-stu-id="5c9d5-489">For more information, see [Custom Partitioners for PLINQ and TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) and [How to: Implement Dynamic Partitions](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException"><span data-ttu-id="5c9d5-490">O <see cref="T:System.Threading.CancellationToken" /> no argumento <paramref name="parallelOptions" /> foi cancelado.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-490">The <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> argument is canceled.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="5c9d5-491">O <see cref="T:System.Threading.CancellationTokenSource" /> associado ao <see cref="T:System.Threading.CancellationToken" /> no <paramref name="parallelOptions" /> foi descartado.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-491">The <see cref="T:System.Threading.CancellationTokenSource" /> associated with the <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> has been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="5c9d5-492">O argumento <paramref name="source" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-492">The <paramref name="source" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="5c9d5-493">- ou -</span><span class="sxs-lookup"><span data-stu-id="5c9d5-493">-or-</span></span> 
<span data-ttu-id="5c9d5-494">O argumento <paramref name="parallelOptions" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-494">The <paramref name="parallelOptions" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="5c9d5-495">- ou -</span><span class="sxs-lookup"><span data-stu-id="5c9d5-495">-or-</span></span> 
<span data-ttu-id="5c9d5-496">O argumento <paramref name="body" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-496">The <paramref name="body" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="5c9d5-497">A propriedade <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> no particionador <paramref name="source" /> retorna <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-497">The <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> property in the <paramref name="source" /> partitioner returns <see langword="false" />.</span></span>  
  
<span data-ttu-id="5c9d5-498">- ou -</span><span class="sxs-lookup"><span data-stu-id="5c9d5-498">-or-</span></span> 
<span data-ttu-id="5c9d5-499">A exceção que é gerada quando qualquer método no particionador <paramref name="source" /> retorna <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-499">The exception that is thrown when any methods in the <paramref name="source" /> partitioner return <see langword="null" />.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="5c9d5-500">Loops paralelos</span><span class="sxs-lookup"><span data-stu-id="5c9d5-500">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Concurrent.Partitioner&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;TSource&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Concurrent.Partitioner`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`1&lt;!!TSource&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.Partitioner{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::Partitioner&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;TSource&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.Partitioner&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Action&lt;'Source&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.Partitioner&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource"><span data-ttu-id="5c9d5-501">O tipo dos elementos em <paramref name="source" />.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-501">The type of the elements in <paramref name="source" />.</span></span></typeparam>
        <param name="source"><span data-ttu-id="5c9d5-502">O particionador que contém a fonte de dados original.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-502">The partitioner that contains the original data source.</span></span></param>
        <param name="parallelOptions"><span data-ttu-id="5c9d5-503">Um objeto que configura o comportamento dessa operação.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-503">An object that configures the behavior of this operation.</span></span></param>
        <param name="body"><span data-ttu-id="5c9d5-504">O delegado invocado uma vez por iteração.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-504">The delegate that is invoked once per iteration.</span></span></param>
        <summary><span data-ttu-id="5c9d5-505">Executa uma operação <see langword="foreach" /> (<see langword="For Each" /> no Visual Basic) em um <see cref="T:System.Collections.Concurrent.Partitioner" /> no qual as iterações podem ser executadas em paralelo e as opções de loop podem ser configuradas.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-505">Executes a <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) operation on a <see cref="T:System.Collections.Concurrent.Partitioner" /> in which iterations may run in parallel and loop options can be configured.</span></span></summary>
        <returns><span data-ttu-id="5c9d5-506">Uma estrutura que contém informações sobre qual parte do loop foi concluída.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-506">A structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c9d5-507">Essa sobrecarga é fornecida para cenários em que você deseja substituir o padrão de esquema de particionamento.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-507">This overload is provided for scenarios where you want to override the default partitioning scheme.</span></span> <span data-ttu-id="5c9d5-508">Por exemplo, corpos de loop pequenos podem se beneficiar do particionamento de intervalo.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-508">For example, small loop bodies might benefit from partitioning the range.</span></span> <span data-ttu-id="5c9d5-509">O <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> particionadores personalizados para dar suporte ao particionamento dinâmico de espera do método.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-509">The <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> method expects custom partitioners to support dynamic partitioning.</span></span> <span data-ttu-id="5c9d5-510">Para obter mais informações, consulte [Particionadores personalizados para PLINQ e TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) e [como: Implementar partições dinâmicas](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).</span><span class="sxs-lookup"><span data-stu-id="5c9d5-510">For more information, see [Custom Partitioners for PLINQ and TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) and [How to: Implement Dynamic Partitions](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException"><span data-ttu-id="5c9d5-511">O <see cref="T:System.Threading.CancellationToken" /> no argumento <paramref name="parallelOptions" /> foi cancelado.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-511">The <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> argument is canceled.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="5c9d5-512">O <see cref="T:System.Threading.CancellationTokenSource" /> associado ao <see cref="T:System.Threading.CancellationToken" /> no <paramref name="parallelOptions" /> foi descartado.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-512">The <see cref="T:System.Threading.CancellationTokenSource" /> associated with the <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> has been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="5c9d5-513">O argumento <paramref name="source" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-513">The <paramref name="source" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="5c9d5-514">- ou -</span><span class="sxs-lookup"><span data-stu-id="5c9d5-514">-or-</span></span> 
<span data-ttu-id="5c9d5-515">O argumento <paramref name="parallelOptions" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-515">The <paramref name="parallelOptions" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="5c9d5-516">- ou -</span><span class="sxs-lookup"><span data-stu-id="5c9d5-516">-or-</span></span> 
<span data-ttu-id="5c9d5-517">O argumento <paramref name="body" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-517">The <paramref name="body" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="5c9d5-518">A propriedade <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> no particionador <paramref name="source" /> retorna <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-518">The <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> property in the <paramref name="source" /> partitioner returns <see langword="false" />.</span></span>  
  
<span data-ttu-id="5c9d5-519">- ou -</span><span class="sxs-lookup"><span data-stu-id="5c9d5-519">-or-</span></span> 
<span data-ttu-id="5c9d5-520">A exceção que é gerada quando qualquer método no particionador <paramref name="source" /> retorna <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-520">The exception that is thrown when any methods in the <paramref name="source" /> partitioner return <see langword="null" />.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="5c9d5-521">Loops paralelos</span><span class="sxs-lookup"><span data-stu-id="5c9d5-521">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,long&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`3&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0,System.Threading.Tasks.ParallelLoopState,System.Int64})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource"><span data-ttu-id="5c9d5-522">O tipo de dados na fonte.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-522">The type of the data in the source.</span></span></typeparam>
        <param name="source"><span data-ttu-id="5c9d5-523">Uma fonte de dados enumerável.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-523">An enumerable data source.</span></span></param>
        <param name="parallelOptions"><span data-ttu-id="5c9d5-524">Um objeto que configura o comportamento dessa operação.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-524">An object that configures the behavior of this operation.</span></span></param>
        <param name="body"><span data-ttu-id="5c9d5-525">O delegado invocado uma vez por iteração.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-525">The delegate that is invoked once per iteration.</span></span></param>
        <summary><span data-ttu-id="5c9d5-526">Executa uma operação <see langword="foreach" /> (<see langword="For Each" /> no Visual Basic) em índices de 64 bits em um <see cref="T:System.Collections.IEnumerable" />, no qual iterações podem ser executadas em paralelo, opções de loop podem ser configuradas e o estado de loop pode ser monitorado e manipulado.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-526">Executes a <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) operation with 64-bit indexes on an <see cref="T:System.Collections.IEnumerable" /> in which iterations may run in parallel, loop options can be configured, and the state of the loop can be monitored and manipulated.</span></span></summary>
        <returns><span data-ttu-id="5c9d5-527">Uma estrutura que contém informações sobre qual parte do loop foi concluída.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-527">A structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c9d5-528">O `body` delegado é invocado uma vez para cada elemento no `source` enumerável.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-528">The `body` delegate is invoked once for each element in the `source` enumerable.</span></span> <span data-ttu-id="5c9d5-529">Ele é fornecido com os seguintes parâmetros: o elemento atual, uma <xref:System.Threading.Tasks.ParallelLoopState> instância que pode ser usada para interromper o loop prematuramente e o índice do elemento atual (<xref:System.Int64>).</span><span class="sxs-lookup"><span data-stu-id="5c9d5-529">It is provided with the following parameters: the current element, a <xref:System.Threading.Tasks.ParallelLoopState> instance that may be used to break out of the loop prematurely, and the current element's index (<xref:System.Int64>).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException"><span data-ttu-id="5c9d5-530">O <see cref="T:System.Threading.CancellationToken" /> no argumento <paramref name="parallelOptions" /> foi cancelado</span><span class="sxs-lookup"><span data-stu-id="5c9d5-530">The <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> argument is canceled</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="5c9d5-531">O argumento <paramref name="source" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-531">The <paramref name="source" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="5c9d5-532">- ou -</span><span class="sxs-lookup"><span data-stu-id="5c9d5-532">-or-</span></span> 
<span data-ttu-id="5c9d5-533">O argumento <paramref name="parallelOptions" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-533">The <paramref name="parallelOptions" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="5c9d5-534">- ou -</span><span class="sxs-lookup"><span data-stu-id="5c9d5-534">-or-</span></span> 
<span data-ttu-id="5c9d5-535">O argumento <paramref name="body" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-535">The <paramref name="body" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="5c9d5-536">A exceção que contém todas as exceções individuais lançadas em todos os threads.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-536">The exception that contains all the individual exceptions thrown on all threads.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="5c9d5-537">O <see cref="T:System.Threading.CancellationTokenSource" /> associado ao <see cref="T:System.Threading.CancellationToken" /> no <paramref name="parallelOptions" /> foi descartado.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-537">The <see cref="T:System.Threading.CancellationTokenSource" /> associated with the <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> has been disposed.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="5c9d5-538">Loops paralelos</span><span class="sxs-lookup"><span data-stu-id="5c9d5-538">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`2&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource"><span data-ttu-id="5c9d5-539">O tipo de dados na fonte.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-539">The type of the data in the source.</span></span></typeparam>
        <param name="source"><span data-ttu-id="5c9d5-540">Uma fonte de dados enumerável.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-540">An enumerable data source.</span></span></param>
        <param name="parallelOptions"><span data-ttu-id="5c9d5-541">Um objeto que configura o comportamento dessa operação.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-541">An object that configures the behavior of this operation.</span></span></param>
        <param name="body"><span data-ttu-id="5c9d5-542">O delegado invocado uma vez por iteração.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-542">The delegate that is invoked once per iteration.</span></span></param>
        <summary><span data-ttu-id="5c9d5-543">Executa uma operação <see langword="foreach" /> (<see langword="For Each" /> no Visual Basic) em um <see cref="T:System.Collections.IEnumerable" />, no qual iterações podem ser executadas em paralelo, opções de loop podem ser configuradas e o estado de loop pode ser monitorado e manipulado.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-543">Executes a <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) operation on an <see cref="T:System.Collections.IEnumerable" /> in which iterations may run in parallel, loop options can be configured, and the state of the loop can be monitored and manipulated.</span></span></summary>
        <returns><span data-ttu-id="5c9d5-544">Uma estrutura que contém informações sobre qual parte do loop foi concluída.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-544">A structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c9d5-545">O `body` delegado é invocado uma vez para cada elemento no `source` enumerável.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-545">The `body` delegate is invoked once for each element in the `source` enumerable.</span></span> <span data-ttu-id="5c9d5-546">Ele é fornecido com os seguintes parâmetros: o elemento atual e um <xref:System.Threading.Tasks.ParallelLoopState> instância que pode ser usada para interromper o loop prematuramente.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-546">It is provided with the following parameters: the current element, and a <xref:System.Threading.Tasks.ParallelLoopState> instance that may be used to break out of the loop prematurely.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException"><span data-ttu-id="5c9d5-547">O <see cref="T:System.Threading.CancellationToken" /> no argumento <paramref name="parallelOptions" /> foi cancelado</span><span class="sxs-lookup"><span data-stu-id="5c9d5-547">The <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> argument is canceled</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="5c9d5-548">O argumento <paramref name="source" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-548">The <paramref name="source" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="5c9d5-549">- ou -</span><span class="sxs-lookup"><span data-stu-id="5c9d5-549">-or-</span></span> 
<span data-ttu-id="5c9d5-550">O argumento <paramref name="parallelOptions" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-550">The <paramref name="parallelOptions" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="5c9d5-551">- ou -</span><span class="sxs-lookup"><span data-stu-id="5c9d5-551">-or-</span></span> 
<span data-ttu-id="5c9d5-552">O argumento <paramref name="body" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-552">The <paramref name="body" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="5c9d5-553">A exceção que contém todas as exceções individuais lançadas em todos os threads.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-553">The exception that contains all the individual exceptions thrown on all threads.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="5c9d5-554">O <see cref="T:System.Threading.CancellationTokenSource" /> associado ao <see cref="T:System.Threading.CancellationToken" /> no <paramref name="parallelOptions" /> foi descartado.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-554">The <see cref="T:System.Threading.CancellationTokenSource" /> associated with the <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> has been disposed.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="5c9d5-555">Loops paralelos</span><span class="sxs-lookup"><span data-stu-id="5c9d5-555">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;TSource&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`1&lt;!!TSource&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;TSource&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Action&lt;'Source&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource"><span data-ttu-id="5c9d5-556">O tipo de dados na fonte.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-556">The type of the data in the source.</span></span></typeparam>
        <param name="source"><span data-ttu-id="5c9d5-557">Uma fonte de dados enumerável.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-557">An enumerable data source.</span></span></param>
        <param name="parallelOptions"><span data-ttu-id="5c9d5-558">Um objeto que configura o comportamento dessa operação.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-558">An object that configures the behavior of this operation.</span></span></param>
        <param name="body"><span data-ttu-id="5c9d5-559">O delegado invocado uma vez por iteração.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-559">The delegate that is invoked once per iteration.</span></span></param>
        <summary><span data-ttu-id="5c9d5-560">Executa uma operação <see langword="foreach" /> (<see langword="For Each" /> no Visual Basic) em um <see cref="T:System.Collections.IEnumerable" /> no qual as iterações podem ser executadas em paralelo e as opções de loop podem ser configuradas.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-560">Executes a <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) operation on an <see cref="T:System.Collections.IEnumerable" /> in which iterations may run in parallel and loop options can be configured.</span></span></summary>
        <returns><span data-ttu-id="5c9d5-561">Uma estrutura que contém informações sobre qual parte do loop foi concluída.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-561">A structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c9d5-562">O `body` delegado é invocado uma vez para cada elemento no `source` enumerável.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-562">The `body` delegate is invoked once for each element in the `source` enumerable.</span></span> <span data-ttu-id="5c9d5-563">Ele é fornecido com o elemento atual como um parâmetro.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-563">It is provided with the current element as a parameter.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException"><span data-ttu-id="5c9d5-564">O <see cref="T:System.Threading.CancellationToken" /> no argumento <paramref name="parallelOptions" /> foi cancelado</span><span class="sxs-lookup"><span data-stu-id="5c9d5-564">The <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> argument is canceled</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="5c9d5-565">O argumento <paramref name="source" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-565">The <paramref name="source" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="5c9d5-566">- ou -</span><span class="sxs-lookup"><span data-stu-id="5c9d5-566">-or-</span></span> 
<span data-ttu-id="5c9d5-567">O argumento <paramref name="parallelOptions" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-567">The <paramref name="parallelOptions" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="5c9d5-568">- ou -</span><span class="sxs-lookup"><span data-stu-id="5c9d5-568">-or-</span></span> 
<span data-ttu-id="5c9d5-569">O argumento <paramref name="body" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-569">The <paramref name="body" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="5c9d5-570">A exceção que contém todas as exceções individuais lançadas em todos os threads.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-570">The exception that contains all the individual exceptions thrown on all threads.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="5c9d5-571">O <see cref="T:System.Threading.CancellationTokenSource" /> associado ao <see cref="T:System.Threading.CancellationToken" /> no <paramref name="parallelOptions" /> foi descartado.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-571">The <see cref="T:System.Threading.CancellationTokenSource" /> associated with the <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> has been disposed.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="5c9d5-572">Loops paralelos</span><span class="sxs-lookup"><span data-stu-id="5c9d5-572">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt; source, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,long,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Concurrent.OrderablePartitioner`1&lt;!!TSource&gt; source, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`5&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Concurrent.OrderablePartitioner{``0},System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,System.Int64,``1,``1},System.Action{``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource, TLocal) (source As OrderablePartitioner(Of TSource), localInit As Func(Of TLocal), body As Func(Of TSource, ParallelLoopState, Long, TLocal, TLocal), localFinally As Action(Of TLocal)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::OrderablePartitioner&lt;TSource&gt; ^ source, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.OrderablePartitioner&lt;'Source&gt; * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt;" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource"><span data-ttu-id="5c9d5-573">O tipo dos elementos em <paramref name="source" />.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-573">The type of the elements in <paramref name="source" />.</span></span></typeparam>
        <typeparam name="TLocal"><span data-ttu-id="5c9d5-574">O tipo dos dados locais do thread.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-574">The type of the thread-local data.</span></span></typeparam>
        <param name="source"><span data-ttu-id="5c9d5-575">O particionador solicitável que contém a fonte de dados original.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-575">The orderable partitioner that contains the original data source.</span></span></param>
        <param name="localInit"><span data-ttu-id="5c9d5-576">O delegado da função que retorna o estado inicial dos dados locais para cada tarefa.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-576">The function delegate that returns the initial state of the local data for each task.</span></span></param>
        <param name="body"><span data-ttu-id="5c9d5-577">O delegado invocado uma vez por iteração.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-577">The delegate that is invoked once per iteration.</span></span></param>
        <param name="localFinally"><span data-ttu-id="5c9d5-578">O delegado que executa uma ação final no estado local de cada tarefa.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-578">The delegate that performs a final action on the local state of each task.</span></span></param>
        <summary><span data-ttu-id="5c9d5-579">Executa uma operação <see langword="foreach" /> (<see langword="For Each" /> no Visual Basic) com os dados locais do thread em um <see cref="T:System.Collections.Concurrent.OrderablePartitioner`1" />, no qual iterações podem ser executadas em paralelo, opções de loop podem ser configuradas e o estado do loop pode ser monitorado e manipulado.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-579">Executes a <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) operation with thread-local data on a <see cref="T:System.Collections.Concurrent.OrderablePartitioner`1" /> in which iterations may run in parallel, loop options can be configured, and the state of the loop can be monitored and manipulated.</span></span></summary>
        <returns><span data-ttu-id="5c9d5-580">Uma estrutura que contém informações sobre qual parte do loop foi concluída.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-580">A structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c9d5-581">Essa sobrecarga é fornecida para cenários em que você deseja substituir o padrão de esquema de particionamento.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-581">This overload is provided for scenarios where you want to override the default partitioning scheme.</span></span> <span data-ttu-id="5c9d5-582">Por exemplo, corpos de loop pequenos podem se beneficiar do particionamento de intervalo.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-582">For example, small loop bodies might benefit from partitioning the range.</span></span> <span data-ttu-id="5c9d5-583">O <xref:System.Threading.Tasks.Parallel.ForEach%2A> particionadores personalizados para dar suporte ao particionamento dinâmico de espera do método.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-583">The <xref:System.Threading.Tasks.Parallel.ForEach%2A> method expects custom partitioners to support dynamic partitioning.</span></span> <span data-ttu-id="5c9d5-584">Para obter mais informações, consulte [Particionadores personalizados para PLINQ e TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) e [como: Implementar partições dinâmicas](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).</span><span class="sxs-lookup"><span data-stu-id="5c9d5-584">For more information, see [Custom Partitioners for PLINQ and TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) and [How to: Implement Dynamic Partitions](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).</span></span>  
  
 <span data-ttu-id="5c9d5-585">O `localInit` delegado é invocado uma vez para cada tarefa que participa de execução do loop e retorna o estado local inicial para cada uma dessas tarefas.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-585">The `localInit` delegate is invoked once for each task that participates in the loop's execution and returns the initial local state for each of those tasks.</span></span> <span data-ttu-id="5c9d5-586">Esses estados iniciais são passados para o primeiro `body` invocações em cada tarefa.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-586">These initial states are passed to the first `body` invocations on each task.</span></span> <span data-ttu-id="5c9d5-587">Em seguida, cada invocação subsequente corpo retorna um valor de estado possivelmente modificado que é passado para a próxima invocação de corpo.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-587">Then, every subsequent body invocation returns a possibly modified state value that is passed to the next body invocation.</span></span> <span data-ttu-id="5c9d5-588">Por fim, a última chamada do corpo em cada tarefa retorna um valor de estado que é passado para o `localFinally` delegar.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-588">Finally, the last body invocation on each task returns a state value that is passed to the `localFinally` delegate.</span></span> <span data-ttu-id="5c9d5-589">O `localFinally` delegado é invocado uma vez por tarefa para executar uma ação final no estado local de cada tarefa.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-589">The `localFinally` delegate is invoked once per task to perform a final action on each task's local state.</span></span> <span data-ttu-id="5c9d5-590">Esse delegado pode ser invocado simultaneamente em várias tarefas; Portanto, você deve sincronizar o acesso a quaisquer variáveis compartilhadas.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-590">This delegate might be invoked concurrently on multiple tasks; therefore, you must synchronize access to any shared variables.</span></span>  
  
 <span data-ttu-id="5c9d5-591">O <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> método pode usar tarefas mais do que os threads durante a vida útil de sua execução, como as tarefas existentes são concluídas e são substituídas por novas tarefas.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-591">The <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> method may use more tasks than threads over the lifetime of its execution, as existing tasks complete and are replaced by new tasks.</span></span> <span data-ttu-id="5c9d5-592">Isso proporciona subjacente <xref:System.Threading.Tasks.TaskScheduler> do objeto a chance de adicionar, alterar ou remover threads que o loop de serviço.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-592">This gives the underlying <xref:System.Threading.Tasks.TaskScheduler> object the chance to add, change, or remove threads that service the loop.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="5c9d5-593">O argumento <paramref name="source" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-593">The <paramref name="source" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="5c9d5-594">- ou -</span><span class="sxs-lookup"><span data-stu-id="5c9d5-594">-or-</span></span> 
<span data-ttu-id="5c9d5-595">O argumento <paramref name="body" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-595">The <paramref name="body" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="5c9d5-596">- ou -</span><span class="sxs-lookup"><span data-stu-id="5c9d5-596">-or-</span></span> 
<span data-ttu-id="5c9d5-597">O argumento <paramref name="localInit" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-597">The <paramref name="localInit" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="5c9d5-598">- ou -</span><span class="sxs-lookup"><span data-stu-id="5c9d5-598">-or-</span></span> 
<span data-ttu-id="5c9d5-599">O argumento <paramref name="localFinally" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-599">The <paramref name="localFinally" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="5c9d5-600">A propriedade <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> no <paramref name="source" /><see cref="T:System.Collections.Concurrent.Partitioner" /> retorna <see langword="false" /> ou o particionador retorna partições <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-600">The <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> property in the <paramref name="source" /><see cref="T:System.Collections.Concurrent.Partitioner" /> returns <see langword="false" /> or the partitioner returns <see langword="null" /> partitions.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="5c9d5-601">A exceção que contém todas as exceções individuais lançadas em todos os threads.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-601">The exception that contains all the individual exceptions thrown on all threads.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="5c9d5-602">Loops paralelos</span><span class="sxs-lookup"><span data-stu-id="5c9d5-602">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Concurrent.Partitioner&lt;TSource&gt; source, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Concurrent.Partitioner`1&lt;!!TSource&gt; source, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Concurrent.Partitioner{``0},System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,``1,``1},System.Action{``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource, TLocal) (source As Partitioner(Of TSource), localInit As Func(Of TLocal), body As Func(Of TSource, ParallelLoopState, TLocal, TLocal), localFinally As Action(Of TLocal)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::Partitioner&lt;TSource&gt; ^ source, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.Partitioner&lt;'Source&gt; * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.Partitioner&lt;TSource&gt;" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource"><span data-ttu-id="5c9d5-603">O tipo dos elementos em <paramref name="source" />.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-603">The type of the elements in <paramref name="source" />.</span></span></typeparam>
        <typeparam name="TLocal"><span data-ttu-id="5c9d5-604">O tipo dos dados locais do thread.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-604">The type of the thread-local data.</span></span></typeparam>
        <param name="source"><span data-ttu-id="5c9d5-605">O particionador que contém a fonte de dados original.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-605">The partitioner that contains the original data source.</span></span></param>
        <param name="localInit"><span data-ttu-id="5c9d5-606">O delegado da função que retorna o estado inicial dos dados locais para cada tarefa.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-606">The function delegate that returns the initial state of the local data for each task.</span></span></param>
        <param name="body"><span data-ttu-id="5c9d5-607">O delegado invocado uma vez por iteração.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-607">The delegate that is invoked once per iteration.</span></span></param>
        <param name="localFinally"><span data-ttu-id="5c9d5-608">O delegado que executa uma ação final no estado local de cada tarefa.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-608">The delegate that performs a final action on the local state of each task.</span></span></param>
        <summary><span data-ttu-id="5c9d5-609">Executa uma operação <see langword="foreach" /> (<see langword="For Each" /> no Visual Basic) com os dados de local de thread em um <see cref="T:System.Collections.Concurrent.Partitioner" />, no qual as iterações podem ser executadas em paralelo e o estado do loop pode ser monitorado e manipulado.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-609">Executes a <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) operation with thread-local data on a <see cref="T:System.Collections.Concurrent.Partitioner" /> in which iterations may run in parallel and the state of the loop can be monitored and manipulated.</span></span></summary>
        <returns><span data-ttu-id="5c9d5-610">Uma estrutura que contém informações sobre qual parte do loop foi concluída.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-610">A structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c9d5-611">Essa sobrecarga é fornecida para cenários em que você deseja substituir o padrão de esquema de particionamento.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-611">This overload is provided for scenarios where you want to override the default partitioning scheme.</span></span> <span data-ttu-id="5c9d5-612">Por exemplo, corpos de loop pequenos podem se beneficiar do particionamento de intervalo.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-612">For example, small loop bodies might benefit from partitioning the range.</span></span> <span data-ttu-id="5c9d5-613">O <xref:System.Threading.Tasks.Parallel.ForEach%2A> particionadores personalizados para dar suporte ao particionamento dinâmico de espera do método.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-613">The <xref:System.Threading.Tasks.Parallel.ForEach%2A> method expects custom partitioners to support dynamic partitioning.</span></span> <span data-ttu-id="5c9d5-614">Para obter mais informações, consulte [Particionadores personalizados para PLINQ e TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) e [como: Implementar partições dinâmicas](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).</span><span class="sxs-lookup"><span data-stu-id="5c9d5-614">For more information, see [Custom Partitioners for PLINQ and TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) and [How to: Implement Dynamic Partitions](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).</span></span>  
  
 <span data-ttu-id="5c9d5-615">O `localInit` delegado é invocado uma vez para cada thread que participa da execução do loop e retorna o estado local inicial para cada uma dessas tarefas.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-615">The `localInit` delegate is invoked once for each thread that participates in the loop's execution and returns the initial local state for each of those tasks.</span></span> <span data-ttu-id="5c9d5-616">Esses estados iniciais são passados para o primeiro `body` invocações em cada tarefa.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-616">These initial states are passed to the first `body` invocations on each task.</span></span> <span data-ttu-id="5c9d5-617">Em seguida, cada invocação subsequente corpo retorna um valor de estado possivelmente modificado que é passado para a próxima invocação de corpo.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-617">Then, every subsequent body invocation returns a possibly modified state value that is passed to the next body invocation.</span></span> <span data-ttu-id="5c9d5-618">Por fim, a última chamada do corpo em cada tarefa retorna um valor de estado que é passado para o `localFinally` delegar.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-618">Finally, the last body invocation on each task returns a state value that is passed to the `localFinally` delegate.</span></span> <span data-ttu-id="5c9d5-619">O `localFinally` delegado é invocado uma vez por tarefa para executar uma ação final no estado local de cada tarefa.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-619">The `localFinally` delegate is invoked once per task to perform a final action on each task's local state.</span></span> <span data-ttu-id="5c9d5-620">Esse delegado pode ser invocado simultaneamente em várias tarefas; Portanto, você deve sincronizar o acesso a quaisquer variáveis compartilhadas.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-620">This delegate might be invoked concurrently on multiple tasks; therefore, you must synchronize access to any shared variables.</span></span>  
  
 <span data-ttu-id="5c9d5-621">O <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> método pode usar tarefas mais do que os threads durante a vida útil de sua execução, como as tarefas existentes são concluídas e são substituídas por novas tarefas.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-621">The <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> method may use more tasks than threads over the lifetime of its execution, as existing tasks complete and are replaced by new tasks.</span></span> <span data-ttu-id="5c9d5-622">Isso proporciona subjacente <xref:System.Threading.Tasks.TaskScheduler> do objeto a chance de adicionar, alterar ou remover threads que o loop de serviço.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-622">This gives the underlying <xref:System.Threading.Tasks.TaskScheduler> object the chance to add, change, or remove threads that service the loop.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="5c9d5-623">O argumento <paramref name="source" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-623">The <paramref name="source" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="5c9d5-624">- ou -</span><span class="sxs-lookup"><span data-stu-id="5c9d5-624">-or-</span></span> 
<span data-ttu-id="5c9d5-625">O argumento <paramref name="body" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-625">The <paramref name="body" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="5c9d5-626">- ou -</span><span class="sxs-lookup"><span data-stu-id="5c9d5-626">-or-</span></span> 
<span data-ttu-id="5c9d5-627">O argumento <paramref name="localInit" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-627">The <paramref name="localInit" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="5c9d5-628">- ou -</span><span class="sxs-lookup"><span data-stu-id="5c9d5-628">-or-</span></span> 
<span data-ttu-id="5c9d5-629">O argumento <paramref name="localFinally" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-629">The <paramref name="localFinally" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="5c9d5-630">A propriedade <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> no <paramref name="source" /><see cref="T:System.Collections.Concurrent.Partitioner" /> retorna <see langword="false" /> ou o particionador retorna partições <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-630">The <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> property in the <paramref name="source" /><see cref="T:System.Collections.Concurrent.Partitioner" /> returns <see langword="false" /> or the partitioner returns <see langword="null" /> partitions.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="5c9d5-631">A exceção que contém todas as exceções individuais lançadas em todos os threads.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-631">The exception that contains all the individual exceptions thrown on all threads.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="5c9d5-632">Loops paralelos</span><span class="sxs-lookup"><span data-stu-id="5c9d5-632">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,long,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`5&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,System.Int64,``1,``1},System.Action{``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource, TLocal) (source As IEnumerable(Of TSource), localInit As Func(Of TLocal), body As Func(Of TSource, ParallelLoopState, Long, TLocal, TLocal), localFinally As Action(Of TLocal)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource"><span data-ttu-id="5c9d5-633">O tipo de dados na fonte.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-633">The type of the data in the source.</span></span></typeparam>
        <typeparam name="TLocal"><span data-ttu-id="5c9d5-634">O tipo dos dados do local de thread.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-634">The type of the thread-local data.</span></span></typeparam>
        <param name="source"><span data-ttu-id="5c9d5-635">Uma fonte de dados enumerável.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-635">An enumerable data source.</span></span></param>
        <param name="localInit"><span data-ttu-id="5c9d5-636">O delegado da função que retorna o estado inicial dos dados locais para cada tarefa.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-636">The function delegate that returns the initial state of the local data for each task.</span></span></param>
        <param name="body"><span data-ttu-id="5c9d5-637">O delegado invocado uma vez por iteração.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-637">The delegate that is invoked once per iteration.</span></span></param>
        <param name="localFinally"><span data-ttu-id="5c9d5-638">O delegado que executa uma ação final no estado local de cada tarefa.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-638">The delegate that performs a final action on the local state of each task.</span></span></param>
        <summary><span data-ttu-id="5c9d5-639">Executa uma operação <see langword="foreach" /> (<see langword="For Each" /> no Visual Basic) com os dados de local de thread em um <see cref="T:System.Collections.IEnumerable" /> no qual as iterações podem ser executadas em paralelo e o estado do loop pode ser monitorado e manipulado.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-639">Executes a <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) operation with thread-local data on an <see cref="T:System.Collections.IEnumerable" /> in which iterations may run in parallel and the state of the loop can be monitored and manipulated.</span></span></summary>
        <returns><span data-ttu-id="5c9d5-640">Uma estrutura que contém informações sobre qual parte do loop foi concluída.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-640">A structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c9d5-641">O `body` delegado é invocado uma vez para cada elemento no `source` enumerável.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-641">The `body` delegate is invoked once for each element in the `source` enumerable.</span></span> <span data-ttu-id="5c9d5-642">Ele é fornecido com os seguintes parâmetros: o elemento atual, uma <xref:System.Threading.Tasks.ParallelLoopState> instância que pode ser usada para interromper o loop prematuramente, o índice do elemento atual (<xref:System.Int64>) e alguns estados de local que podem ser compartilhado entre as iterações que executarem no mesmo thread.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-642">It is provided with the following parameters: the current element, a <xref:System.Threading.Tasks.ParallelLoopState> instance that may be used to break out of the loop prematurely, the current element's index (<xref:System.Int64>), and some local state that may be shared amongst iterations that execute on the same thread.</span></span>  
  
 <span data-ttu-id="5c9d5-643">O `localInit` delegado é invocado uma vez para cada tarefa que participa de execução do loop e retorna o estado local inicial para cada uma dessas tarefas.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-643">The `localInit` delegate is invoked once for each task that participates in the loop's execution and returns the initial local state for each of those tasks.</span></span> <span data-ttu-id="5c9d5-644">Esses estados iniciais são passados para o primeiro `body` invocações em cada tarefa.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-644">These initial states are passed to the first `body` invocations on each task.</span></span> <span data-ttu-id="5c9d5-645">Em seguida, cada invocação subsequente corpo retorna um valor de estado possivelmente modificado que é passado para a próxima invocação de corpo.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-645">Then, every subsequent body invocation returns a possibly modified state value that is passed to the next body invocation.</span></span> <span data-ttu-id="5c9d5-646">Por fim, a última chamada do corpo em cada tarefa retorna um valor de estado que é passado para o `localFinally` delegar.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-646">Finally, the last body invocation on each task returns a state value that is passed to the `localFinally` delegate.</span></span> <span data-ttu-id="5c9d5-647">O `localFinally` delegado é invocado uma vez por tarefa para executar uma ação final no estado local de cada tarefa.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-647">The `localFinally` delegate is invoked once per task to perform a final action on each task's local state.</span></span> <span data-ttu-id="5c9d5-648">Esse delegado pode ser invocado simultaneamente em várias tarefas; Portanto, você deve sincronizar o acesso a quaisquer variáveis compartilhadas.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-648">This delegate might be invoked concurrently on multiple tasks; therefore, you must synchronize access to any shared variables.</span></span>  
  
 <span data-ttu-id="5c9d5-649">O <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> método pode usar tarefas mais do que os threads durante a vida útil de sua execução, como as tarefas existentes são concluídas e são substituídas por novas tarefas.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-649">The <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> method may use more tasks than threads over the lifetime of its execution, as existing tasks complete and are replaced by new tasks.</span></span> <span data-ttu-id="5c9d5-650">Isso proporciona subjacente <xref:System.Threading.Tasks.TaskScheduler> do objeto a chance de adicionar, alterar ou remover threads que o loop de serviço.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-650">This gives the underlying <xref:System.Threading.Tasks.TaskScheduler> object the chance to add, change, or remove threads that service the loop.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="5c9d5-651">O argumento <paramref name="source" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-651">The <paramref name="source" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="5c9d5-652">- ou -</span><span class="sxs-lookup"><span data-stu-id="5c9d5-652">-or-</span></span> 
<span data-ttu-id="5c9d5-653">O argumento <paramref name="body" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-653">The <paramref name="body" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="5c9d5-654">- ou -</span><span class="sxs-lookup"><span data-stu-id="5c9d5-654">-or-</span></span> 
<span data-ttu-id="5c9d5-655">O argumento <paramref name="localInit" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-655">The <paramref name="localInit" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="5c9d5-656">- ou -</span><span class="sxs-lookup"><span data-stu-id="5c9d5-656">-or-</span></span> 
<span data-ttu-id="5c9d5-657">O argumento <paramref name="localFinally" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-657">The <paramref name="localFinally" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="5c9d5-658">A exceção que contém todas as exceções individuais lançadas em todos os threads.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-658">The exception that contains all the individual exceptions thrown on all threads.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="5c9d5-659">Loops paralelos</span><span class="sxs-lookup"><span data-stu-id="5c9d5-659">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,``1,``1},System.Action{``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource, TLocal) (source As IEnumerable(Of TSource), localInit As Func(Of TLocal), body As Func(Of TSource, ParallelLoopState, TLocal, TLocal), localFinally As Action(Of TLocal)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource"><span data-ttu-id="5c9d5-660">O tipo de dados na fonte.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-660">The type of the data in the source.</span></span></typeparam>
        <typeparam name="TLocal"><span data-ttu-id="5c9d5-661">O tipo dos dados do local de thread.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-661">The type of the thread-local data.</span></span></typeparam>
        <param name="source"><span data-ttu-id="5c9d5-662">Uma fonte de dados enumerável.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-662">An enumerable data source.</span></span></param>
        <param name="localInit"><span data-ttu-id="5c9d5-663">O delegado da função que retorna o estado inicial dos dados locais para cada tarefa.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-663">The function delegate that returns the initial state of the local data for each task.</span></span></param>
        <param name="body"><span data-ttu-id="5c9d5-664">O delegado invocado uma vez por iteração.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-664">The delegate that is invoked once per iteration.</span></span></param>
        <param name="localFinally"><span data-ttu-id="5c9d5-665">O delegado que executa uma ação final no estado local de cada tarefa.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-665">The delegate that performs a final action on the local state of each task.</span></span></param>
        <summary><span data-ttu-id="5c9d5-666">Executa uma operação <see langword="foreach" /> (<see langword="For Each" /> no Visual Basic) com índices de dados de local de thread em um <see cref="T:System.Collections.IEnumerable" />, no qual as iterações podem ser executadas em paralelo e o estado do loop pode ser monitorado e manipulado.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-666">Executes a <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) operation with thread-local data on an <see cref="T:System.Collections.IEnumerable" /> in which iterations may run in parallel, and the state of the loop can be monitored and manipulated.</span></span></summary>
        <returns><span data-ttu-id="5c9d5-667">Uma estrutura que contém informações sobre qual parte do loop foi concluída.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-667">A structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c9d5-668">O `body` delegado é invocado uma vez para cada elemento no `source` enumerável.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-668">The `body` delegate is invoked once for each element in the `source` enumerable.</span></span> <span data-ttu-id="5c9d5-669">Ele é fornecido com os seguintes parâmetros: o elemento atual, um <xref:System.Threading.Tasks.ParallelLoopState> instância que pode ser usada para interromper o loop prematuramente e alguns estados de locais que podem ser compartilhados entre as iterações que executam no mesmo thread.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-669">It is provided with the following parameters: the current element, a <xref:System.Threading.Tasks.ParallelLoopState> instance that may be used to break out of the loop prematurely, and some local state that may be shared amongst iterations that execute on the same thread.</span></span>  
  
 <span data-ttu-id="5c9d5-670">O `localInit` delegado é invocado uma vez para cada tarefa que participa de execução do loop e retorna o estado local inicial para cada uma dessas tarefas.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-670">The `localInit` delegate is invoked once for each task that participates in the loop's execution and returns the initial local state for each of those tasks.</span></span> <span data-ttu-id="5c9d5-671">Esses estados iniciais são passados para o primeiro `body` invocações em cada tarefa.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-671">These initial states are passed to the first `body` invocations on each task.</span></span> <span data-ttu-id="5c9d5-672">Em seguida, cada invocação subsequente corpo retorna um valor de estado possivelmente modificado que é passado para a próxima invocação de corpo.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-672">Then, every subsequent body invocation returns a possibly modified state value that is passed to the next body invocation.</span></span> <span data-ttu-id="5c9d5-673">Por fim, a última chamada do corpo em cada tarefa retorna um valor de estado que é passado para o `localFinally` delegar.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-673">Finally, the last body invocation on each task returns a state value that is passed to the `localFinally` delegate.</span></span> <span data-ttu-id="5c9d5-674">O `localFinally` delegado é invocado uma vez por thread para executar uma ação final no estado local de cada tarefa.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-674">The `localFinally` delegate is invoked once per thread to perform a final action on each task's local state.</span></span> <span data-ttu-id="5c9d5-675">Esse delegado pode ser invocado simultaneamente em várias tarefas; Portanto, você deve sincronizar o acesso a quaisquer variáveis compartilhadas.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-675">This delegate might be invoked concurrently on multiple tasks; therefore, you must synchronize access to any shared variables.</span></span>  
  
 <span data-ttu-id="5c9d5-676">O <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> método pode usar tarefas mais do que os threads durante a vida útil de sua execução, como as tarefas existentes são concluídas e são substituídas por novas tarefas.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-676">The <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> method may use more tasks than threads over the lifetime of its execution, as existing tasks complete and are replaced by new tasks.</span></span> <span data-ttu-id="5c9d5-677">Isso proporciona subjacente <xref:System.Threading.Tasks.TaskScheduler> do objeto a chance de adicionar, alterar ou remover threads que o loop de serviço.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-677">This gives the underlying <xref:System.Threading.Tasks.TaskScheduler> object the chance to add, change, or remove threads that service the loop.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5c9d5-678">O exemplo a seguir mostra como usar um <xref:System.Threading.Tasks.Parallel.ForEach%2A> método com o estado local:</span><span class="sxs-lookup"><span data-stu-id="5c9d5-678">The following example shows how to use a <xref:System.Threading.Tasks.Parallel.ForEach%2A> method with local state:</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Parallel#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/parallelforeach.cs#02)]
 [!code-vb[System.Threading.Tasks.Parallel#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/parallelforeach.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="5c9d5-679">O argumento <paramref name="source" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-679">The <paramref name="source" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="5c9d5-680">- ou -</span><span class="sxs-lookup"><span data-stu-id="5c9d5-680">-or-</span></span> 
<span data-ttu-id="5c9d5-681">O argumento <paramref name="body" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-681">The <paramref name="body" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="5c9d5-682">- ou -</span><span class="sxs-lookup"><span data-stu-id="5c9d5-682">-or-</span></span> 
<span data-ttu-id="5c9d5-683">O argumento <paramref name="localInit" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-683">The <paramref name="localInit" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="5c9d5-684">- ou -</span><span class="sxs-lookup"><span data-stu-id="5c9d5-684">-or-</span></span> 
<span data-ttu-id="5c9d5-685">O argumento <paramref name="localFinally" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-685">The <paramref name="localFinally" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="5c9d5-686">A exceção que contém todas as exceções individuais lançadas em todos os threads.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-686">The exception that contains all the individual exceptions thrown on all threads.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="5c9d5-687">Loops paralelos</span><span class="sxs-lookup"><span data-stu-id="5c9d5-687">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,long,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Concurrent.OrderablePartitioner`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`5&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Concurrent.OrderablePartitioner{``0},System.Threading.Tasks.ParallelOptions,System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,System.Int64,``1,``1},System.Action{``1})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::OrderablePartitioner&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.OrderablePartitioner&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource"><span data-ttu-id="5c9d5-688">O tipo dos elementos em <paramref name="source" />.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-688">The type of the elements in <paramref name="source" />.</span></span></typeparam>
        <typeparam name="TLocal"><span data-ttu-id="5c9d5-689">O tipo dos dados locais do thread.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-689">The type of the thread-local data.</span></span></typeparam>
        <param name="source"><span data-ttu-id="5c9d5-690">O particionador solicitável que contém a fonte de dados original.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-690">The orderable partitioner that contains the original data source.</span></span></param>
        <param name="parallelOptions"><span data-ttu-id="5c9d5-691">Um objeto que configura o comportamento dessa operação.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-691">An object that configures the behavior of this operation.</span></span></param>
        <param name="localInit"><span data-ttu-id="5c9d5-692">O delegado da função que retorna o estado inicial dos dados locais para cada tarefa.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-692">The function delegate that returns the initial state of the local data for each task.</span></span></param>
        <param name="body"><span data-ttu-id="5c9d5-693">O delegado invocado uma vez por iteração.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-693">The delegate that is invoked once per iteration.</span></span></param>
        <param name="localFinally"><span data-ttu-id="5c9d5-694">O delegado que executa uma ação final no estado local de cada tarefa.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-694">The delegate that performs a final action on the local state of each task.</span></span></param>
        <summary><span data-ttu-id="5c9d5-695">Executa uma operação <see langword="foreach" /> (<see langword="For Each" /> no Visual Basic) com índices de 64 bits e dados locais do thread em um <see cref="T:System.Collections.Concurrent.OrderablePartitioner`1" />, no qual iterações podem ser executadas em paralelo, opções de loop podem ser configuradas e o estado do loop pode ser monitorado e manipulado.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-695">Executes a <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) operation with 64-bit indexes and  with thread-local data on a <see cref="T:System.Collections.Concurrent.OrderablePartitioner`1" /> in which iterations may run in parallel , loop options can be configured, and the state of the loop can be monitored and manipulated.</span></span></summary>
        <returns><span data-ttu-id="5c9d5-696">Uma estrutura que contém informações sobre qual parte do loop foi concluída.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-696">A structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c9d5-697">Essa sobrecarga é fornecida para cenários em que você deseja substituir o padrão de esquema de particionamento.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-697">This overload is provided for scenarios where you want to override the default partitioning scheme.</span></span> <span data-ttu-id="5c9d5-698">Por exemplo, corpos de loop pequenos podem se beneficiar do particionamento de intervalo.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-698">For example, small loop bodies might benefit from partitioning the range.</span></span> <span data-ttu-id="5c9d5-699">O <xref:System.Threading.Tasks.Parallel.ForEach%2A> particionadores personalizados para dar suporte ao particionamento dinâmico de espera do método.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-699">The <xref:System.Threading.Tasks.Parallel.ForEach%2A> method expects custom partitioners to support dynamic partitioning.</span></span> <span data-ttu-id="5c9d5-700">Para obter mais informações, consulte [Particionadores personalizados para PLINQ e TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) e [como: Implementar partições dinâmicas](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).</span><span class="sxs-lookup"><span data-stu-id="5c9d5-700">For more information, see [Custom Partitioners for PLINQ and TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) and [How to: Implement Dynamic Partitions](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).</span></span>  
  
 <span data-ttu-id="5c9d5-701">O `localInit` delegado é invocado uma vez para cada tarefa que participa de execução do loop e retorna o estado local inicial para cada uma dessas tarefas.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-701">The `localInit` delegate is invoked once for each task that participates in the loop's execution and returns the initial local state for each of those tasks.</span></span> <span data-ttu-id="5c9d5-702">Esses estados iniciais são passados para o primeiro `body` invocações em cada tarefa.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-702">These initial states are passed to the first `body` invocations on each task.</span></span> <span data-ttu-id="5c9d5-703">Em seguida, cada invocação subsequente corpo retorna um valor de estado possivelmente modificado que é passado para a próxima invocação de corpo.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-703">Then, every subsequent body invocation returns a possibly modified state value that is passed to the next body invocation.</span></span> <span data-ttu-id="5c9d5-704">Por fim, a última chamada do corpo em cada thread retorna um valor de estado que é passado para o `localFinally` delegar.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-704">Finally, the last body invocation on each thread returns a state value that is passed to the `localFinally` delegate.</span></span> <span data-ttu-id="5c9d5-705">O `localFinally` delegado é invocado uma vez por tarefa para executar uma ação final no estado local de cada tarefa.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-705">The `localFinally` delegate is invoked once per task to perform a final action on each task's local state.</span></span> <span data-ttu-id="5c9d5-706">Esse delegado pode ser invocado simultaneamente em várias tarefas; Portanto, você deve sincronizar o acesso a quaisquer variáveis compartilhadas.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-706">This delegate might be invoked concurrently on multiple tasks; therefore, you must synchronize access to any shared variables.</span></span>  
  
 <span data-ttu-id="5c9d5-707">O <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> método pode usar tarefas mais do que os threads durante a vida útil de sua execução, como as tarefas existentes são concluídas e são substituídas por novas tarefas.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-707">The <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> method may use more tasks than threads over the lifetime of its execution, as existing tasks complete and are replaced by new tasks.</span></span> <span data-ttu-id="5c9d5-708">Isso proporciona subjacente <xref:System.Threading.Tasks.TaskScheduler> do objeto a chance de adicionar, alterar ou remover threads que o loop de serviço.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-708">This gives the underlying <xref:System.Threading.Tasks.TaskScheduler> object the chance to add, change, or remove threads that service the loop.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="5c9d5-709">O argumento <paramref name="source" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-709">The <paramref name="source" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="5c9d5-710">- ou -</span><span class="sxs-lookup"><span data-stu-id="5c9d5-710">-or-</span></span> 
<span data-ttu-id="5c9d5-711">O argumento <paramref name="parallelOptions" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-711">The <paramref name="parallelOptions" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="5c9d5-712">- ou -</span><span class="sxs-lookup"><span data-stu-id="5c9d5-712">-or-</span></span> 
<span data-ttu-id="5c9d5-713">O argumento <paramref name="body" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-713">The <paramref name="body" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="5c9d5-714">- ou -</span><span class="sxs-lookup"><span data-stu-id="5c9d5-714">-or-</span></span> 
<span data-ttu-id="5c9d5-715">O argumento <paramref name="localInit" /> ou <paramref name="localFinally" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-715">The <paramref name="localInit" /> or <paramref name="localFinally" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="5c9d5-716">A propriedade <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> no <paramref name="source" /><see cref="T:System.Collections.Concurrent.Partitioner" /> retorna <see langword="false" /> ou o particionador retorna partições <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-716">The <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> property in the <paramref name="source" /><see cref="T:System.Collections.Concurrent.Partitioner" /> returns <see langword="false" /> or the partitioner returns <see langword="null" /> partitions.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="5c9d5-717">A exceção que contém todas as exceções individuais geradas em todos os threads.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-717">The exception that contains all the individual exceptions thrown on all threads.</span></span></exception>
        <exception cref="T:System.OperationCanceledException"><span data-ttu-id="5c9d5-718">O <see cref="T:System.Threading.CancellationToken" /> no argumento <paramref name="parallelOptions" /> foi cancelado.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-718">The <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> argument is canceled.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="5c9d5-719">O <see cref="T:System.Threading.CancellationTokenSource" /> associado ao <see cref="T:System.Threading.CancellationToken" /> no <paramref name="parallelOptions" /> foi descartado.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-719">The <see cref="T:System.Threading.CancellationTokenSource" /> associated with the <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> has been disposed.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="5c9d5-720">Loops paralelos</span><span class="sxs-lookup"><span data-stu-id="5c9d5-720">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Concurrent.Partitioner&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Concurrent.Partitioner`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Concurrent.Partitioner{``0},System.Threading.Tasks.ParallelOptions,System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,``1,``1},System.Action{``1})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::Partitioner&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.Partitioner&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.Partitioner&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource"><span data-ttu-id="5c9d5-721">O tipo dos elementos em <paramref name="source" />.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-721">The type of the elements in <paramref name="source" />.</span></span></typeparam>
        <typeparam name="TLocal"><span data-ttu-id="5c9d5-722">O tipo dos dados locais do thread.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-722">The type of the thread-local data.</span></span></typeparam>
        <param name="source"><span data-ttu-id="5c9d5-723">O particionador que contém a fonte de dados original.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-723">The partitioner that contains the original data source.</span></span></param>
        <param name="parallelOptions"><span data-ttu-id="5c9d5-724">Um objeto que configura o comportamento dessa operação.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-724">An object that configures the behavior of this operation.</span></span></param>
        <param name="localInit"><span data-ttu-id="5c9d5-725">O delegado da função que retorna o estado inicial dos dados locais para cada tarefa.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-725">The function delegate that returns the initial state of the local data for each task.</span></span></param>
        <param name="body"><span data-ttu-id="5c9d5-726">O delegado invocado uma vez por iteração.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-726">The delegate that is invoked once per iteration.</span></span></param>
        <param name="localFinally"><span data-ttu-id="5c9d5-727">O delegado que executa uma ação final no estado local de cada tarefa.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-727">The delegate that performs a final action on the local state of each task.</span></span></param>
        <summary><span data-ttu-id="5c9d5-728">Executa uma operação <see langword="foreach" /> (<see langword="For Each" /> no Visual Basic) com os dados locais do thread em um <see cref="T:System.Collections.Concurrent.Partitioner" />, no qual iterações podem ser executadas em paralelo, opções de loop podem ser configuradas e o estado do loop pode ser monitorado e manipulado.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-728">Executes a <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) operation  with thread-local data on a <see cref="T:System.Collections.Concurrent.Partitioner" /> in which iterations may run in parallel, loop options can be configured, and the state of the loop can be monitored and manipulated.</span></span></summary>
        <returns><span data-ttu-id="5c9d5-729">Uma estrutura que contém informações sobre qual parte do loop foi concluída.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-729">A structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c9d5-730">Essa sobrecarga é fornecida para cenários em que você deseja substituir o padrão de esquema de particionamento.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-730">This overload is provided for scenarios where you want to override the default partitioning scheme.</span></span> <span data-ttu-id="5c9d5-731">Por exemplo, corpos de loop pequenos podem se beneficiar do particionamento de intervalo.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-731">For example, small loop bodies might benefit from partitioning the range.</span></span> <span data-ttu-id="5c9d5-732">O <xref:System.Threading.Tasks.Parallel.ForEach%2A> particionadores personalizados para dar suporte ao particionamento dinâmico de espera do método.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-732">The <xref:System.Threading.Tasks.Parallel.ForEach%2A> method expects custom partitioners to support dynamic partitioning.</span></span> <span data-ttu-id="5c9d5-733">Essa sobrecarga é fornecida para cenários com corpos de loop pequenos que podem se beneficiar do particionamento de intervalo estático.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-733">This overload is provided for scenarios with small loop bodies that might benefit from static range partitioning.</span></span> <span data-ttu-id="5c9d5-734">Particionadores devem oferecer suporte a partições dinâmicas.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-734">Partitioners must support dynamic partitions.</span></span>  <span data-ttu-id="5c9d5-735">Para obter mais informações, consulte [Particionadores personalizados para PLINQ e TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) e [como: Implementar partições dinâmicas](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).</span><span class="sxs-lookup"><span data-stu-id="5c9d5-735">For more information, see [Custom Partitioners for PLINQ and TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) and [How to: Implement Dynamic Partitions](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).</span></span>  
  
 <span data-ttu-id="5c9d5-736">O `localInit` delegado é invocado uma vez para cada tarefa que participa de execução do loop e retorna o estado local inicial para cada uma dessas tarefas.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-736">The `localInit` delegate is invoked once for each task that participates in the loop's execution and returns the initial local state for each of those tasks.</span></span> <span data-ttu-id="5c9d5-737">Esses estados iniciais são passados para o primeiro `body` invocações em cada tarefa.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-737">These initial states are passed to the first `body` invocations on each task.</span></span> <span data-ttu-id="5c9d5-738">Em seguida, cada invocação subsequente corpo retorna um valor de estado possivelmente modificado que é passado para a próxima invocação de corpo.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-738">Then, every subsequent body invocation returns a possibly modified state value that is passed to the next body invocation.</span></span> <span data-ttu-id="5c9d5-739">Por fim, a última chamada do corpo em cada tarefa retorna um valor de estado que é passado para o `localFinally` delegar.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-739">Finally, the last body invocation on each task returns a state value that is passed to the `localFinally` delegate.</span></span> <span data-ttu-id="5c9d5-740">O `localFinally` delegado é invocado uma vez por tarefa para executar uma ação final no estado local de cada tarefa.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-740">The `localFinally` delegate is invoked once per task to perform a final action on each task's local state.</span></span> <span data-ttu-id="5c9d5-741">Esse delegado pode ser invocado simultaneamente em várias tarefas; Portanto, você deve sincronizar o acesso a quaisquer variáveis compartilhadas.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-741">This delegate might be invoked concurrently on multiple tasks; therefore, you must synchronize access to any shared variables.</span></span>  
  
 <span data-ttu-id="5c9d5-742">O <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> método pode usar tarefas mais do que os threads durante a vida útil de sua execução, como as tarefas existentes são concluídas e são substituídas por novas tarefas.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-742">The <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> method may use more tasks than threads over the lifetime of its execution, as existing tasks complete and are replaced by new tasks.</span></span> <span data-ttu-id="5c9d5-743">Isso proporciona subjacente <xref:System.Threading.Tasks.TaskScheduler> do objeto a chance de adicionar, alterar ou remover threads que o loop de serviço.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-743">This gives the underlying <xref:System.Threading.Tasks.TaskScheduler> object the chance to add, change, or remove threads that service the loop.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="5c9d5-744">O argumento <paramref name="source" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-744">The <paramref name="source" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="5c9d5-745">- ou -</span><span class="sxs-lookup"><span data-stu-id="5c9d5-745">-or-</span></span> 
<span data-ttu-id="5c9d5-746">O argumento <paramref name="parallelOptions" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-746">The <paramref name="parallelOptions" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="5c9d5-747">- ou -</span><span class="sxs-lookup"><span data-stu-id="5c9d5-747">-or-</span></span> 
<span data-ttu-id="5c9d5-748">O argumento <paramref name="body" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-748">The <paramref name="body" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="5c9d5-749">- ou -</span><span class="sxs-lookup"><span data-stu-id="5c9d5-749">-or-</span></span> 
<span data-ttu-id="5c9d5-750">O argumento <paramref name="localInit" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-750">The <paramref name="localInit" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="5c9d5-751">- ou -</span><span class="sxs-lookup"><span data-stu-id="5c9d5-751">-or-</span></span> 
<span data-ttu-id="5c9d5-752">O argumento <paramref name="localFinally" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-752">The <paramref name="localFinally" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="5c9d5-753">A propriedade <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> no <paramref name="source" /><see cref="T:System.Collections.Concurrent.Partitioner" /> retorna <see langword="false" /> ou o particionador retorna partições <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-753">The <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> property in the <paramref name="source" /><see cref="T:System.Collections.Concurrent.Partitioner" /> returns <see langword="false" /> or the partitioner returns <see langword="null" /> partitions.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="5c9d5-754">A exceção que contém todas as exceções individuais geradas em todos os threads.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-754">The exception that contains all the individual exceptions thrown on all threads.</span></span></exception>
        <exception cref="T:System.OperationCanceledException"><span data-ttu-id="5c9d5-755">O <see cref="T:System.Threading.CancellationToken" /> no argumento <paramref name="parallelOptions" /> foi cancelado.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-755">The <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> argument is canceled.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="5c9d5-756">O <see cref="T:System.Threading.CancellationTokenSource" /> associado ao <see cref="T:System.Threading.CancellationToken" /> no <paramref name="parallelOptions" /> foi descartado.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-756">The <see cref="T:System.Threading.CancellationTokenSource" /> associated with the <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> has been disposed.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="5c9d5-757">Loops paralelos</span><span class="sxs-lookup"><span data-stu-id="5c9d5-757">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,long,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`5&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,System.Int64,``1,``1},System.Action{``1})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource"><span data-ttu-id="5c9d5-758">O tipo de dados na fonte.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-758">The type of the data in the source.</span></span></typeparam>
        <typeparam name="TLocal"><span data-ttu-id="5c9d5-759">O tipo dos dados do local de thread.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-759">The type of the thread-local data.</span></span></typeparam>
        <param name="source"><span data-ttu-id="5c9d5-760">Uma fonte de dados enumerável.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-760">An enumerable data source.</span></span></param>
        <param name="parallelOptions"><span data-ttu-id="5c9d5-761">Um objeto que configura o comportamento dessa operação.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-761">An object that configures the behavior of this operation.</span></span></param>
        <param name="localInit"><span data-ttu-id="5c9d5-762">O delegado da função que retorna o estado inicial dos dados locais para cada tarefa.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-762">The function delegate that returns the initial state of the local data for each task.</span></span></param>
        <param name="body"><span data-ttu-id="5c9d5-763">O delegado invocado uma vez por iteração.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-763">The delegate that is invoked once per iteration.</span></span></param>
        <param name="localFinally"><span data-ttu-id="5c9d5-764">O delegado que executa uma ação final no estado local de cada tarefa.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-764">The delegate that performs a final action on the local state of each task.</span></span></param>
        <summary><span data-ttu-id="5c9d5-765">Executa uma operação <see langword="foreach" /> (<see langword="For Each" /> no Visual Basic) com os dados locais de thread e índices de 64 bits em um <see cref="T:System.Collections.IEnumerable" />, no qual iterações podem ser executadas em paralelo, opções de loop podem ser configuradas e o estado de loop pode ser monitorado e manipulado.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-765">Executes a <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) operation with thread-local data and 64-bit indexes on an <see cref="T:System.Collections.IEnumerable" /> in which iterations may run in parallel, loop options can be configured, and the state of the loop can be monitored and manipulated.</span></span></summary>
        <returns><span data-ttu-id="5c9d5-766">Uma estrutura que contém informações sobre qual parte do loop foi concluída.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-766">A structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c9d5-767">O `body` delegado é invocado uma vez para cada elemento no `source` enumerável.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-767">The `body` delegate is invoked once for each element in the `source` enumerable.</span></span> <span data-ttu-id="5c9d5-768">Ele é fornecido com os seguintes parâmetros: o elemento atual, uma <xref:System.Threading.Tasks.ParallelLoopState> instância que pode ser usada para interromper o loop prematuramente, o índice do elemento atual (<xref:System.Int64>) e alguns estados de local que podem ser compartilhado entre as iterações que executarem no mesmo thread.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-768">It is provided with the following parameters: the current element, a <xref:System.Threading.Tasks.ParallelLoopState> instance that may be used to break out of the loop prematurely, the current element's index (<xref:System.Int64>), and some local state that may be shared amongst iterations that execute on the same thread.</span></span>  
  
 <span data-ttu-id="5c9d5-769">O `localInit` delegado é invocado uma vez para cada tarefa que participa de execução do loop e retorna o estado local inicial para cada uma dessas tarefas.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-769">The `localInit` delegate is invoked once for each task that participates in the loop's execution and returns the initial local state for each of those tasks.</span></span> <span data-ttu-id="5c9d5-770">Esses estados iniciais são passados para o primeiro `body` invocações em cada tarefa.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-770">These initial states are passed to the first `body` invocations on each task.</span></span> <span data-ttu-id="5c9d5-771">Em seguida, cada invocação subsequente corpo retorna um valor de estado possivelmente modificado que é passado para a próxima invocação de corpo.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-771">Then, every subsequent body invocation returns a possibly modified state value that is passed to the next body invocation.</span></span> <span data-ttu-id="5c9d5-772">Por fim, a última chamada do corpo em cada tarefa retorna um valor de estado que é passado para o `localFinally` delegar.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-772">Finally, the last body invocation on each task returns a state value that is passed to the `localFinally` delegate.</span></span> <span data-ttu-id="5c9d5-773">O `localFinally` delegado é invocado uma vez por thread para executar uma ação final no estado local de cada tarefa.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-773">The `localFinally` delegate is invoked once per thread to perform a final action on each task's local state.</span></span> <span data-ttu-id="5c9d5-774">Esse delegado pode ser invocado simultaneamente em várias tarefas; Portanto, você deve sincronizar o acesso a quaisquer variáveis compartilhadas.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-774">This delegate might be invoked concurrently on multiple tasks; therefore, you must synchronize access to any shared variables.</span></span>  
  
 <span data-ttu-id="5c9d5-775">O <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> método pode usar tarefas mais do que os threads durante a vida útil de sua execução, como as tarefas existentes são concluídas e são substituídas por novas tarefas.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-775">The <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> method may use more tasks than threads over the lifetime of its execution, as existing tasks complete and are replaced by new tasks.</span></span> <span data-ttu-id="5c9d5-776">Isso proporciona subjacente <xref:System.Threading.Tasks.TaskScheduler> do objeto a chance de adicionar, alterar ou remover threads que o loop de serviço.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-776">This gives the underlying <xref:System.Threading.Tasks.TaskScheduler> object the chance to add, change, or remove threads that service the loop.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="5c9d5-777">O argumento <paramref name="source" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-777">The <paramref name="source" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="5c9d5-778">- ou -</span><span class="sxs-lookup"><span data-stu-id="5c9d5-778">-or-</span></span> 
<span data-ttu-id="5c9d5-779">O argumento <paramref name="parallelOptions" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-779">The <paramref name="parallelOptions" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="5c9d5-780">- ou -</span><span class="sxs-lookup"><span data-stu-id="5c9d5-780">-or-</span></span> 
<span data-ttu-id="5c9d5-781">O argumento <paramref name="body" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-781">The <paramref name="body" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="5c9d5-782">- ou -</span><span class="sxs-lookup"><span data-stu-id="5c9d5-782">-or-</span></span> 
<span data-ttu-id="5c9d5-783">O argumento <paramref name="localInit" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-783">The <paramref name="localInit" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="5c9d5-784">- ou -</span><span class="sxs-lookup"><span data-stu-id="5c9d5-784">-or-</span></span> 
<span data-ttu-id="5c9d5-785">O argumento <paramref name="localFinally" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-785">The <paramref name="localFinally" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.OperationCanceledException"><span data-ttu-id="5c9d5-786">O <see cref="T:System.Threading.CancellationToken" /> no argumento <paramref name="parallelOptions" /> foi cancelado.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-786">The <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> argument is canceled.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="5c9d5-787">O <see cref="T:System.Threading.CancellationTokenSource" /> associado ao <see cref="T:System.Threading.CancellationToken" /> no <paramref name="parallelOptions" /> foi descartado.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-787">The <see cref="T:System.Threading.CancellationTokenSource" /> associated with the <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> has been disposed.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="5c9d5-788">A exceção que contém todas as exceções individuais lançadas em todos os threads.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-788">The exception that contains all the individual exceptions thrown on all threads.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="5c9d5-789">Loops paralelos</span><span class="sxs-lookup"><span data-stu-id="5c9d5-789">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,``1,``1},System.Action{``1})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource"><span data-ttu-id="5c9d5-790">O tipo de dados na fonte.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-790">The type of the data in the source.</span></span></typeparam>
        <typeparam name="TLocal"><span data-ttu-id="5c9d5-791">O tipo dos dados do local de thread.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-791">The type of the thread-local data.</span></span></typeparam>
        <param name="source"><span data-ttu-id="5c9d5-792">Uma fonte de dados enumerável.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-792">An enumerable data source.</span></span></param>
        <param name="parallelOptions"><span data-ttu-id="5c9d5-793">Um objeto que configura o comportamento dessa operação.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-793">An object that configures the behavior of this operation.</span></span></param>
        <param name="localInit"><span data-ttu-id="5c9d5-794">O delegado da função que retorna o estado inicial dos dados locais para cada tarefa.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-794">The function delegate that returns the initial state of the local data for each task.</span></span></param>
        <param name="body"><span data-ttu-id="5c9d5-795">O delegado invocado uma vez por iteração.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-795">The delegate that is invoked once per iteration.</span></span></param>
        <param name="localFinally"><span data-ttu-id="5c9d5-796">O delegado que executa uma ação final no estado local de cada tarefa.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-796">The delegate that performs a final action on the local state of each task.</span></span></param>
        <summary><span data-ttu-id="5c9d5-797">Executa uma operação <see langword="foreach" /> (<see langword="For Each" /> no Visual Basic) com os dados locais do thread em um <see cref="T:System.Collections.IEnumerable" /> no qual as iterações podem ser executadas em paralelo, as opções de loop podem ser configuradas e o estado do loop pode ser monitorado e manipulado.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-797">Executes a <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) operation with thread-local data on an <see cref="T:System.Collections.IEnumerable" /> in which iterations may run in parallel, loop options can be configured, and the state of the loop can be monitored and manipulated.</span></span></summary>
        <returns><span data-ttu-id="5c9d5-798">Uma estrutura que contém informações sobre qual parte do loop foi concluída.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-798">A structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c9d5-799">O `body` delegado é invocado uma vez para cada elemento no `source` enumerável.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-799">The `body` delegate is invoked once for each element in the `source` enumerable.</span></span> <span data-ttu-id="5c9d5-800">Ele é fornecido com os seguintes parâmetros: o elemento atual, um <xref:System.Threading.Tasks.ParallelLoopState> instância que pode ser usada para interromper o loop prematuramente e alguns estados de locais que podem ser compartilhados entre as iterações que executam no mesmo thread.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-800">It is provided with the following parameters: the current element, a <xref:System.Threading.Tasks.ParallelLoopState> instance that may be used to break out of the loop prematurely, and some local state that may be shared amongst iterations that execute on the same thread.</span></span>  
  
 <span data-ttu-id="5c9d5-801">O `localInit` delegado é invocado uma vez para cada tarefa que participa de execução do loop e retorna o estado local inicial para cada uma dessas tarefas.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-801">The `localInit` delegate is invoked once for each task that participates in the loop's execution and returns the initial local state for each of those tasks.</span></span> <span data-ttu-id="5c9d5-802">Esses estados iniciais são passados para o primeiro `body` invocações em cada tarefa.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-802">These initial states are passed to the first `body` invocations on each task.</span></span> <span data-ttu-id="5c9d5-803">Em seguida, cada invocação subsequente corpo retorna um valor de estado possivelmente modificado que é passado para a próxima invocação de corpo.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-803">Then, every subsequent body invocation returns a possibly modified state value that is passed to the next body invocation.</span></span> <span data-ttu-id="5c9d5-804">Por fim, a última chamada do corpo em cada tarefa retorna um valor de estado que é passado para o `localFinally` delegar.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-804">Finally, the last body invocation on each task returns a state value that is passed to the `localFinally` delegate.</span></span> <span data-ttu-id="5c9d5-805">O `localFinally` delegado é invocado uma vez por thread para executar uma ação final no estado local de cada tarefa.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-805">The `localFinally` delegate is invoked once per thread to perform a final action on each task's local state.</span></span> <span data-ttu-id="5c9d5-806">Esse delegado pode ser invocado simultaneamente em várias tarefas; Portanto, você deve sincronizar o acesso a quaisquer variáveis compartilhadas.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-806">This delegate might be invoked concurrently on multiple tasks; therefore, you must synchronize access to any shared variables.</span></span>  
  
 <span data-ttu-id="5c9d5-807">O <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> método pode usar tarefas mais do que os threads durante a vida útil de sua execução, como as tarefas existentes são concluídas e são substituídas por novas tarefas.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-807">The <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> method may use more tasks than threads over the lifetime of its execution, as existing tasks complete and are replaced by new tasks.</span></span> <span data-ttu-id="5c9d5-808">Isso proporciona subjacente <xref:System.Threading.Tasks.TaskScheduler> do objeto a chance de adicionar, alterar ou remover threads que o loop de serviço.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-808">This gives the underlying <xref:System.Threading.Tasks.TaskScheduler> object the chance to add, change, or remove threads that service the loop.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="5c9d5-809">O argumento <paramref name="source" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-809">The <paramref name="source" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="5c9d5-810">- ou -</span><span class="sxs-lookup"><span data-stu-id="5c9d5-810">-or-</span></span> 
<span data-ttu-id="5c9d5-811">O argumento <paramref name="parallelOptions" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-811">The <paramref name="parallelOptions" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="5c9d5-812">- ou -</span><span class="sxs-lookup"><span data-stu-id="5c9d5-812">-or-</span></span> 
<span data-ttu-id="5c9d5-813">O argumento <paramref name="body" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-813">The <paramref name="body" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="5c9d5-814">- ou -</span><span class="sxs-lookup"><span data-stu-id="5c9d5-814">-or-</span></span> 
<span data-ttu-id="5c9d5-815">O argumento <paramref name="localInit" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-815">The <paramref name="localInit" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="5c9d5-816">- ou -</span><span class="sxs-lookup"><span data-stu-id="5c9d5-816">-or-</span></span> 
<span data-ttu-id="5c9d5-817">O argumento <paramref name="localFinally" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-817">The <paramref name="localFinally" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.OperationCanceledException"><span data-ttu-id="5c9d5-818">O <see cref="T:System.Threading.CancellationToken" /> no argumento <paramref name="parallelOptions" /> foi cancelado.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-818">The <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> argument is canceled.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="5c9d5-819">O <see cref="T:System.Threading.CancellationTokenSource" /> associado ao <see cref="T:System.Threading.CancellationToken" /> no <paramref name="parallelOptions" /> foi descartado.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-819">The <see cref="T:System.Threading.CancellationTokenSource" /> associated with the <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> has been disposed.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="5c9d5-820">A exceção que contém todas as exceções individuais lançadas em todos os threads.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-820">The exception that contains all the individual exceptions thrown on all threads.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="5c9d5-821">Loops paralelos</span><span class="sxs-lookup"><span data-stu-id="5c9d5-821">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Invoke">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="5c9d5-822">Executa cada uma das ações fornecidas, possivelmente em paralelo.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-822">Executes each of the provided actions, possibly in parallel.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public static void Invoke (params Action[] actions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Invoke(class System.Action[] actions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.Invoke(System.Action[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Invoke (ParamArray actions As Action())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Invoke(... cli::array &lt;Action ^&gt; ^ actions);" />
      <MemberSignature Language="F#" Value="static member Invoke : Action[] -&gt; unit" Usage="System.Threading.Tasks.Parallel.Invoke actions" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="actions" Type="System.Action[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="actions"><span data-ttu-id="5c9d5-823">Uma matriz de <see cref="T:System.Action" /> para executar.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-823">An array of <see cref="T:System.Action" /> to execute.</span></span></param>
        <summary><span data-ttu-id="5c9d5-824">Executa cada uma das ações fornecidas, possivelmente em paralelo.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-824">Executes each of the provided actions, possibly in parallel.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c9d5-825">Esse método pode ser usado para executar um conjunto de operações, possivelmente em paralelo.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-825">This method can be used to execute a set of operations, potentially in parallel.</span></span>  
  
 <span data-ttu-id="5c9d5-826">Não há garantias sobre a ordem na qual as operações são executadas ou se elas são executadas em paralelo.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-826">No guarantees are made about the order in which the operations execute or whether they execute in parallel.</span></span> <span data-ttu-id="5c9d5-827">Esse método não retorna até que cada uma das operações fornecidas for concluída, independentemente se o preenchimento ocorre devido ao encerramento normal ou excepcional.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-827">This method does not return until each of the provided operations has completed, regardless of whether completion occurs due to normal or exceptional termination.</span></span>  
  
 <span data-ttu-id="5c9d5-828">Para obter mais informações, consulte [Como usar Parallel.Invoke para executar operações em paralelo](~/docs/standard/parallel-programming/how-to-use-parallel-invoke-to-execute-parallel-operations.md).</span><span class="sxs-lookup"><span data-stu-id="5c9d5-828">For more information, see [How to: Use Parallel.Invoke to Execute Parallel Operations](~/docs/standard/parallel-programming/how-to-use-parallel-invoke-to-execute-parallel-operations.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5c9d5-829">Este exemplo demonstra como usar o <xref:System.Threading.Tasks.Parallel.Invoke%2A> método com outros métodos, delegados anônimos e expressões lambda.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-829">This example demonstrates how to use the <xref:System.Threading.Tasks.Parallel.Invoke%2A> method with other methods, anonymous delegates, and lambda expressions.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Parallel#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/parallelinvoke.cs#01)]
 [!code-vb[System.Threading.Tasks.Parallel#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/parallelinvoke.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="5c9d5-830">O argumento <paramref name="actions" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-830">The <paramref name="actions" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="5c9d5-831">A exceção que é gerada quando qualquer ação na matriz <paramref name="actions" /> gerar uma exceção.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-831">The exception that is thrown when any action in the <paramref name="actions" /> array throws an exception.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="5c9d5-832">A matriz <paramref name="actions" /> contém um elemento <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-832">The <paramref name="actions" /> array contains a <see langword="null" /> element.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public static void Invoke (System.Threading.Tasks.ParallelOptions parallelOptions, params Action[] actions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Invoke(class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action[] actions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.Invoke(System.Threading.Tasks.ParallelOptions,System.Action[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Invoke(System::Threading::Tasks::ParallelOptions ^ parallelOptions, ... cli::array &lt;Action ^&gt; ^ actions);" />
      <MemberSignature Language="F#" Value="static member Invoke : System.Threading.Tasks.ParallelOptions * Action[] -&gt; unit" Usage="System.Threading.Tasks.Parallel.Invoke (parallelOptions, actions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="actions" Type="System.Action[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="parallelOptions"><span data-ttu-id="5c9d5-833">Um objeto que configura o comportamento dessa operação.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-833">An object that configures the behavior of this operation.</span></span></param>
        <param name="actions"><span data-ttu-id="5c9d5-834">Uma matriz de ações a serem executadas.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-834">An array of actions to execute.</span></span></param>
        <summary><span data-ttu-id="5c9d5-835">Executa cada uma das ações fornecidas, possivelmente em paralelo, a menos que a operação seja cancelada pelo usuário.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-835">Executes each of the provided actions, possibly in parallel, unless the operation is cancelled by the user.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5c9d5-836">Esse método pode ser usado para executar um conjunto de operações, possivelmente em paralelo.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-836">This method can be used to execute a set of operations, potentially in parallel.</span></span> <span data-ttu-id="5c9d5-837">O token de cancelamento passado com o <xref:System.Threading.Tasks.ParallelOptions> estrutura permite que o chamador cancelar a operação inteira.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-837">The cancellation token passed in with the <xref:System.Threading.Tasks.ParallelOptions> structure enables the caller to cancel the entire operation.</span></span> <span data-ttu-id="5c9d5-838">Para saber mais, confira [Cancelamento em threads gerenciados](~/docs/standard/threading/cancellation-in-managed-threads.md).</span><span class="sxs-lookup"><span data-stu-id="5c9d5-838">For more information, see [Cancellation in Managed Threads](~/docs/standard/threading/cancellation-in-managed-threads.md).</span></span>  
  
 <span data-ttu-id="5c9d5-839">Não há garantias sobre a ordem na qual as operações são executadas ou se elas são executadas em paralelo.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-839">No guarantees are made about the order in which the operations execute or whether they execute in parallel.</span></span> <span data-ttu-id="5c9d5-840">Esse método não retorna até que cada uma das operações fornecidas for concluída, independentemente se o preenchimento ocorre devido ao encerramento normal ou excepcional.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-840">This method does not return until each of the provided operations has completed, regardless of whether completion occurs due to normal or exceptional termination.</span></span>  
  
 <span data-ttu-id="5c9d5-841">Para obter mais informações, consulte [Como usar Parallel.Invoke para executar operações em paralelo](~/docs/standard/parallel-programming/how-to-use-parallel-invoke-to-execute-parallel-operations.md).</span><span class="sxs-lookup"><span data-stu-id="5c9d5-841">For more information, see [How to: Use Parallel.Invoke to Execute Parallel Operations](~/docs/standard/parallel-programming/how-to-use-parallel-invoke-to-execute-parallel-operations.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException"><span data-ttu-id="5c9d5-842">O <see cref="T:System.Threading.CancellationToken" /> no <paramref name="parallelOptions" /> está definido.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-842">The <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> is set.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="5c9d5-843">O argumento <paramref name="actions" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-843">The <paramref name="actions" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="5c9d5-844">- ou -</span><span class="sxs-lookup"><span data-stu-id="5c9d5-844">-or-</span></span> 
<span data-ttu-id="5c9d5-845">O argumento <paramref name="parallelOptions" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-845">The <paramref name="parallelOptions" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="5c9d5-846">A exceção que é gerada quando qualquer ação na matriz <paramref name="actions" /> gerar uma exceção.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-846">The exception that is thrown when any action in the <paramref name="actions" /> array throws an exception.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="5c9d5-847">A matriz <paramref name="actions" /> contém um elemento <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-847">The <paramref name="actions" /> array contains a <see langword="null" /> element.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="5c9d5-848">O <see cref="T:System.Threading.CancellationTokenSource" /> associado ao <see cref="T:System.Threading.CancellationToken" /> no <paramref name="parallelOptions" /> foi descartado.</span><span class="sxs-lookup"><span data-stu-id="5c9d5-848">The <see cref="T:System.Threading.CancellationTokenSource" /> associated with the <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> has been disposed.</span></span></exception>
      </Docs>
    </Member>
  </Members>
</Type>
