<Type Name="ParallelLoopState" FullName="System.Threading.Tasks.ParallelLoopState">
  <Metadata><Meta Name="ms.openlocfilehash" Value="9f0237c0ab6a5df247c24cc0cab4d856a2a5ef27" /><Meta Name="ms.sourcegitcommit" Value="a3e01ec36374fac54a55add0dcc1e754e394abeb" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pt-BR" /><Meta Name="ms.lasthandoff" Value="03/30/2019" /><Meta Name="ms.locfileid" Value="58690523" /></Metadata><TypeSignature Language="C#" Value="public class ParallelLoopState" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ParallelLoopState extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Tasks.ParallelLoopState" />
  <TypeSignature Language="VB.NET" Value="Public Class ParallelLoopState" />
  <TypeSignature Language="C++ CLI" Value="public ref class ParallelLoopState" />
  <TypeSignature Language="F#" Value="type ParallelLoopState = class" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.3.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerDisplay("ShouldExitCurrentIteration = {ShouldExitCurrentIteration}")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="d102d-101">Permite que iterações de loops paralelos interajam com outras iterações.</span><span class="sxs-lookup"><span data-stu-id="d102d-101">Enables iterations of parallel loops to interact with other iterations.</span></span> <span data-ttu-id="d102d-102">Uma instância dessa classe é fornecida pela classe <see cref="T:System.Threading.Tasks.Parallel" /> a cada loop. Você não pode criar instâncias no seu código.</span><span class="sxs-lookup"><span data-stu-id="d102d-102">An instance of this class is provided by the <see cref="T:System.Threading.Tasks.Parallel" /> class to each loop; you can not create instances in your code.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d102d-103">Observe que você não pode instanciar uma instância dessa classe.</span><span class="sxs-lookup"><span data-stu-id="d102d-103">Note that you cannot instantiate an instance of this class.</span></span> <span data-ttu-id="d102d-104">Ele é gerado automaticamente pelo compilador como um argumento em uma chamada para o <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> ou <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="d102d-104">It is automatically generated by the compiler as an argument in a call to the <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> or <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="d102d-105">O exemplo fornece uma ilustração.</span><span class="sxs-lookup"><span data-stu-id="d102d-105">The example provides an illustration.</span></span>  
  
 <span data-ttu-id="d102d-106">Construções, como `for` e `foreach` (em C#) e `For` e `For Each` (no Visual Basic) são executadas sequencialmente do índice menor para o mais alto ou do primeiro objeto em um conjunto para o último.</span><span class="sxs-lookup"><span data-stu-id="d102d-106">Constructs such as `for` and `foreach` (in C#) and `For` and `For Each` (in Visual Basic) execute sequentially from the lowest index to the highest or from the first object in a set to the last.</span></span> <span data-ttu-id="d102d-107">Em contraste, o <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> e <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> métodos não fizer isso.</span><span class="sxs-lookup"><span data-stu-id="d102d-107">In contrast, the <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> and <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> methods do not.</span></span> <span data-ttu-id="d102d-108">Como individuais iterações do loop é executado em paralelo, elas podem começam e terminam em qualquer ordem.</span><span class="sxs-lookup"><span data-stu-id="d102d-108">Because individual iterations of the loop run in parallel, they can begin and end in any order.</span></span> <span data-ttu-id="d102d-109">O <xref:System.Threading.Tasks.ParallelLoopState> classe permite que iterações individuais de loops paralelos interajam uns com os outros.</span><span class="sxs-lookup"><span data-stu-id="d102d-109">The <xref:System.Threading.Tasks.ParallelLoopState> class allows individual iterations of parallel loops to interact with one another.</span></span> <span data-ttu-id="d102d-110">O <xref:System.Threading.Tasks.ParallelLoopState> classe permite que você:</span><span class="sxs-lookup"><span data-stu-id="d102d-110">The <xref:System.Threading.Tasks.ParallelLoopState> class allows you to:</span></span>  
  
-   <span data-ttu-id="d102d-111">Sair da iteração atual e evitar qualquer iterações adicionais seja iniciada chamando o <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d102d-111">Exit the current iteration and prevent any additional iterations from starting by calling the <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> method.</span></span> <span data-ttu-id="d102d-112">Isso não afeta as iterações que já começou a execução.</span><span class="sxs-lookup"><span data-stu-id="d102d-112">This does not affect iterations that have already begun execution.</span></span>  
  
-   <span data-ttu-id="d102d-113">Impedir que qualquer iterações com um índice maior que o índice atual em execução chamando o <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d102d-113">Prevent any iterations with an index greater than the current index from executing by calling the <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> method.</span></span> <span data-ttu-id="d102d-114">Isso não afeta as iterações que já começou a execução.</span><span class="sxs-lookup"><span data-stu-id="d102d-114">This does not affect iterations that have already begun execution.</span></span>  
  
-   <span data-ttu-id="d102d-115">Determinar se uma exceção ocorreu em qualquer iteração do loop, recuperando o valor da <xref:System.Threading.Tasks.ParallelLoopState.IsExceptional%2A> propriedade.</span><span class="sxs-lookup"><span data-stu-id="d102d-115">Determine whether an exception has occurred in any loop iteration by retrieving the value of the <xref:System.Threading.Tasks.ParallelLoopState.IsExceptional%2A> property.</span></span>  
  
-   <span data-ttu-id="d102d-116">Determinar se qualquer iteração do loop chamou o <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> método recuperando o valor da <xref:System.Threading.Tasks.ParallelLoopState.IsStopped%2A> propriedade.</span><span class="sxs-lookup"><span data-stu-id="d102d-116">Determine whether any iteration of the loop has called the <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> method by retrieving the value of the <xref:System.Threading.Tasks.ParallelLoopState.IsStopped%2A> property.</span></span> <span data-ttu-id="d102d-117">Você pode usar essa propriedade para retornar de iterações do loop que foi iniciado antes de chamar o <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> método, mas ainda estão sendo executadas.</span><span class="sxs-lookup"><span data-stu-id="d102d-117">You can use this property to return from iterations of the loop that started before the call to the <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> method but are still executing.</span></span>  
  
-   <span data-ttu-id="d102d-118">Determinar se qualquer iteração do loop chamou o <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> ou <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> método ou uma exceção foi gerada ao recuperar o valor da <xref:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration%2A> propriedade.</span><span class="sxs-lookup"><span data-stu-id="d102d-118">Determine whether any iteration of the loop has called the <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> or <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> method or has thrown an exception by retrieving the value of the <xref:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration%2A> property.</span></span>  
  
-   <span data-ttu-id="d102d-119">Sair de uma iteração de execução longa, cujo índice é maior que o índice de uma iteração que quebra foi chamada por recuperar o valor da <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A> propriedade.</span><span class="sxs-lookup"><span data-stu-id="d102d-119">Exit from a long-running iteration whose index is greater than the index of an iteration in which Break was called by retrieving the value of the <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A> property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d102d-120">O exemplo a seguir executa até 100 iterações de um loop em paralelo.</span><span class="sxs-lookup"><span data-stu-id="d102d-120">The following example executes up to 100 iterations of a loop in parallel.</span></span> <span data-ttu-id="d102d-121">Cada iteração pausa por um intervalo aleatório de 1 a 1.000 milissegundos.</span><span class="sxs-lookup"><span data-stu-id="d102d-121">Each iteration pauses for a random interval from 1 to 1,000 milliseconds.</span></span> <span data-ttu-id="d102d-122">Um valor gerado aleatoriamente determina em qual iteração do loop de <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> método é chamado.</span><span class="sxs-lookup"><span data-stu-id="d102d-122">A randomly generated value determines on which iteration of the loop the <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> method is called.</span></span> <span data-ttu-id="d102d-123">Como a saída do exemplo mostra, nenhuma iteração cujo índice é maior que o <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A> início do valor de propriedade após a chamada para o <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d102d-123">As the output from the example shows, no iterations whose index is greater than the <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A> property value start after the call to the <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> method.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.ParallelLoopState#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallelloopstate/cs/break1.cs#2)]
 [!code-vb[System.Threading.Tasks.ParallelLoopState#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallelloopstate/vb/break1.vb#2)]  
  
 <span data-ttu-id="d102d-124">Como as iterações do loop são ainda podem estar em execução quando o <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> método é chamado, as chamadas de cada iteração a <xref:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration%2A> propriedade para verificar se a outra iteração tiver chamado o <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d102d-124">Because iterations of the loop are still likely to be executing when the <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> method is called, each iteration calls the <xref:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration%2A> property to check whether another iteration has called the <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> method.</span></span> <span data-ttu-id="d102d-125">Se o valor da propriedade for `true`, a iteração verifica o valor da <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A> propriedade e, se ele for maior que o valor de índice da iteração atual, retorna imediatamente.</span><span class="sxs-lookup"><span data-stu-id="d102d-125">If  the property value is `true`, the iteration checks the value of the <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A> property and, if it is greater than the current iteration's index value, returns immediately.</span></span>  
  
 ]]></format>
    </remarks>
    <threadsafe><span data-ttu-id="d102d-126">Um <see cref="T:System.Threading.Tasks.ParallelLoopState" /> instância destina-se a ser usado somente dentro do corpo do loop para o qual uma instância foi fornecida.</span><span class="sxs-lookup"><span data-stu-id="d102d-126">A <see cref="T:System.Threading.Tasks.ParallelLoopState" /> instance is meant to be used only within the body of the loop to which an instance was provided.</span></span>  <span data-ttu-id="d102d-127">Não é seguro usar uma fornecida <see cref="T:System.Threading.Tasks.ParallelLoopState" /> instância após o loop associado termina, nem é seguro explicitamente entregá-lo a outros threads e ter esses threads acessá-lo a qualquer momento.</span><span class="sxs-lookup"><span data-stu-id="d102d-127">It is not safe to use a provided <see cref="T:System.Threading.Tasks.ParallelLoopState" /> instance after the associated loop ends, nor is it safe to explicitly hand it off to other threads and have those threads access it at any time.</span></span>  <span data-ttu-id="d102d-128">Outro <see cref="T:System.Threading.Tasks.ParallelLoopState" /> instância será fornecida para cada thread envolvido em um loop.</span><span class="sxs-lookup"><span data-stu-id="d102d-128">A different <see cref="T:System.Threading.Tasks.ParallelLoopState" /> instance will be provided to each thread involved in a loop.</span></span></threadsafe>
    <related type="Article" href="~/docs/standard/parallel-programming/data-parallelism-task-parallel-library.md"><span data-ttu-id="d102d-129">Paralelismo de dados (biblioteca de tarefas paralelas)</span><span class="sxs-lookup"><span data-stu-id="d102d-129">Data Parallelism (Task Parallel Library)</span></span></related>
  </Docs>
  <Members>
    <Member MemberName="Break">
      <MemberSignature Language="C#" Value="public void Break ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Break() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.ParallelLoopState.Break" />
      <MemberSignature Language="VB.NET" Value="Public Sub Break ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Break();" />
      <MemberSignature Language="F#" Value="member this.Break : unit -&gt; unit" Usage="parallelLoopState.Break " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d102d-130">Comunica que o loop de <see cref="T:System.Threading.Tasks.Parallel" /> deve encerrar a execução de iterações além da iteração atual, conforme a necessidade mais recente do sistema.</span><span class="sxs-lookup"><span data-stu-id="d102d-130">Communicates that the <see cref="T:System.Threading.Tasks.Parallel" /> loop should cease execution of iterations beyond the current iteration at the system's earliest convenience.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d102d-131"><xref:System.Threading.Tasks.ParallelLoopState.Break%2A> indica que nenhuma iteração após iteração atual deve ser executada.</span><span class="sxs-lookup"><span data-stu-id="d102d-131"><xref:System.Threading.Tasks.ParallelLoopState.Break%2A> indicates that no iterations after the current iteration should be run.</span></span> <span data-ttu-id="d102d-132">Ele efetivamente cancela qualquer adicionais iterações do loop.</span><span class="sxs-lookup"><span data-stu-id="d102d-132">It effectively cancels any additional iterations of the loop.</span></span> <span data-ttu-id="d102d-133">No entanto, não impede que qualquer iterações que já começou a execução.</span><span class="sxs-lookup"><span data-stu-id="d102d-133">However, it does not stop any iterations that have already begun execution.</span></span> <span data-ttu-id="d102d-134">Por exemplo, se <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> é chamado do 100 º iteração de um loop paralelo iteração de 0 a 1.000, todas as iterações menor que 100 devem ainda ser execução, mas as iterações de 101 até 1000 que ainda não foram iniciados não são executadas.</span><span class="sxs-lookup"><span data-stu-id="d102d-134">For example, if <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> is called from the 100th iteration of a parallel loop iterating from 0 to 1,000, all iterations less than 100 should still be run, but the iterations from 101 through to 1000 that have not yet started are not executed.</span></span>  
  
 <span data-ttu-id="d102d-135">Iterações de longa execução que podem já estar em execução, <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> define o <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A> índice da iteração atual se o índice atual é menor que o valor atual da propriedade <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A>.</span><span class="sxs-lookup"><span data-stu-id="d102d-135">For long-running iterations that may already be executing, <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> sets the <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A> property to the current iteration's index if the current index is less than the current value of <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A>.</span></span> <span data-ttu-id="d102d-136">Para interromper as iterações cujo índice é maior que a menor iteração de interrupção da execução concorrente, faça o seguinte:</span><span class="sxs-lookup"><span data-stu-id="d102d-136">To stop iterations whose index is greater than the lowest break iteration from competing execution, you should do the following:</span></span>  
  
1.  <span data-ttu-id="d102d-137">Verifique se o <xref:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration%2A> é de propriedade `true`.</span><span class="sxs-lookup"><span data-stu-id="d102d-137">Check whether the <xref:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration%2A> property is `true`.</span></span>  
  
2.  <span data-ttu-id="d102d-138">Sair da iteração, se o seu índice é maior que o <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A> valor da propriedade.</span><span class="sxs-lookup"><span data-stu-id="d102d-138">Exit from the iteration if its index is greater than the <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A> property value.</span></span>  
  
 <span data-ttu-id="d102d-139">O exemplo fornece uma ilustração.</span><span class="sxs-lookup"><span data-stu-id="d102d-139">The example provides an illustration.</span></span>  
  
 <span data-ttu-id="d102d-140"><xref:System.Threading.Tasks.ParallelLoopState.Break%2A> normalmente é utilizado em algoritmos baseados em pesquisa, onde uma ordenação está presente na fonte de dados.</span><span class="sxs-lookup"><span data-stu-id="d102d-140"><xref:System.Threading.Tasks.ParallelLoopState.Break%2A> is typically employed in search-based algorithms where an ordering is present in the data source.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d102d-141">O exemplo a seguir executa até 100 iterações de um loop em paralelo.</span><span class="sxs-lookup"><span data-stu-id="d102d-141">The following example executes up to 100 iterations of a loop in parallel.</span></span> <span data-ttu-id="d102d-142">Cada iteração pausa por um intervalo aleatório de 1 a 1.000 milissegundos.</span><span class="sxs-lookup"><span data-stu-id="d102d-142">Each iteration pauses for a random interval from 1 to 1,000 milliseconds.</span></span> <span data-ttu-id="d102d-143">Um valor gerado aleatoriamente determina em qual iteração do loop de <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> método é chamado.</span><span class="sxs-lookup"><span data-stu-id="d102d-143">A randomly generated value determines on which iteration of the loop the <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> method is called.</span></span> <span data-ttu-id="d102d-144">Como a saída do exemplo mostra, nenhuma iteração cujo índice é maior que o <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A> início do valor de propriedade após a chamada para o <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d102d-144">As the output from the example shows, no iterations whose index is greater than the <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A> property value start after the call to the <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> method.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.ParallelLoopState#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallelloopstate/cs/break1.cs#2)]
 [!code-vb[System.Threading.Tasks.ParallelLoopState#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallelloopstate/vb/break1.vb#2)]  
  
 <span data-ttu-id="d102d-145">Como as iterações do loop são ainda podem estar em execução quando o <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> método é chamado, as chamadas de cada iteração a <xref:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration%2A> propriedade para verificar se a outra iteração tiver chamado o <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d102d-145">Because iterations of the loop are still likely to be executing when the <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> method is called, each iteration calls the <xref:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration%2A> property to check whether another iteration has called the <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> method.</span></span> <span data-ttu-id="d102d-146">Se o valor da propriedade for `true`, a iteração verifica o valor da <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A> propriedade e, se ele for maior que o valor de índice da iteração atual, retorna imediatamente.</span><span class="sxs-lookup"><span data-stu-id="d102d-146">If  the property value is `true`, the iteration checks the value of the <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A> property and, if it is greater than the current iteration's index value, returns immediately.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d102d-147">O método <see cref="M:System.Threading.Tasks.ParallelLoopState.Stop" /> foi chamado anteriormente.</span><span class="sxs-lookup"><span data-stu-id="d102d-147">The <see cref="M:System.Threading.Tasks.ParallelLoopState.Stop" /> method was previously called.</span></span> <span data-ttu-id="d102d-148"><see cref="M:System.Threading.Tasks.ParallelLoopState.Break" /> e <see cref="M:System.Threading.Tasks.ParallelLoopState.Stop" /> não podem ser usados em combinação por iterações do mesmo loop.</span><span class="sxs-lookup"><span data-stu-id="d102d-148"><see cref="M:System.Threading.Tasks.ParallelLoopState.Break" /> and <see cref="M:System.Threading.Tasks.ParallelLoopState.Stop" /> may not be used in combination by iterations of the same loop.</span></span></exception>
        <altmember cref="P:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration" />
        <altmember cref="P:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration" />
        <related type="Article" href="~/docs/standard/parallel-programming/data-parallelism-task-parallel-library.md"><span data-ttu-id="d102d-149">Paralelismo de dados (biblioteca de tarefas paralelas)</span><span class="sxs-lookup"><span data-stu-id="d102d-149">Data Parallelism (Task Parallel Library)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsExceptional">
      <MemberSignature Language="C#" Value="public bool IsExceptional { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsExceptional" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.ParallelLoopState.IsExceptional" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsExceptional As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsExceptional { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsExceptional : bool" Usage="System.Threading.Tasks.ParallelLoopState.IsExceptional" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d102d-150">Obtém se qualquer iteração do loop gerou uma exceção que ficou sem tratamento por aquela iteração.</span><span class="sxs-lookup"><span data-stu-id="d102d-150">Gets whether any iteration of the loop has thrown an exception that went unhandled by that iteration.</span></span></summary>
        <value><span data-ttu-id="d102d-151"><see langword="true" /> Se tiver sido lançada uma exceção sem tratamento. Caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="d102d-151"><see langword="true" /> if an unhandled exception was thrown; otherwise, <see langword="false" />.</span></span></value>
        <remarks>To be added.</remarks>
        <related type="Article" href="~/docs/standard/parallel-programming/data-parallelism-task-parallel-library.md"><span data-ttu-id="d102d-152">Paralelismo de dados (biblioteca de tarefas paralelas)</span><span class="sxs-lookup"><span data-stu-id="d102d-152">Data Parallelism (Task Parallel Library)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsStopped">
      <MemberSignature Language="C#" Value="public bool IsStopped { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsStopped" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.ParallelLoopState.IsStopped" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsStopped As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsStopped { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsStopped : bool" Usage="System.Threading.Tasks.ParallelLoopState.IsStopped" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d102d-153">Obtém se qualquer iteração do loop chamou o método <see cref="M:System.Threading.Tasks.ParallelLoopState.Stop" />.</span><span class="sxs-lookup"><span data-stu-id="d102d-153">Gets whether any iteration of the loop has called the <see cref="M:System.Threading.Tasks.ParallelLoopState.Stop" /> method.</span></span></summary>
        <value><span data-ttu-id="d102d-154"><see langword="true" /> Se qualquer iteração tiver parado o loop, chamando o <see cref="M:System.Threading.Tasks.ParallelLoopState.Stop" /> método; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="d102d-154"><see langword="true" /> if any iteration has stopped the loop by calling the <see cref="M:System.Threading.Tasks.ParallelLoopState.Stop" /> method; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d102d-155">Para iterações de longa execução do loop, você pode recuperar o valor da <xref:System.Threading.Tasks.ParallelLoopState.IsStopped%2A> propriedade para determinar se qualquer iterações do loop que começou a execução antes de chamar o <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> método ainda estão sendo executadas.</span><span class="sxs-lookup"><span data-stu-id="d102d-155">For long-running iterations of the loop, you can retrieve the value of the <xref:System.Threading.Tasks.ParallelLoopState.IsStopped%2A> property to determine whether any iterations of the loop that began execution before the call to the <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> method are still executing.</span></span> <span data-ttu-id="d102d-156">Você pode usar o valor da <xref:System.Threading.Tasks.ParallelLoopState.IsStopped%2A> propriedade para determinar se eles devem retornar imediatamente ou executar normalmente.</span><span class="sxs-lookup"><span data-stu-id="d102d-156">You can then use the value of the <xref:System.Threading.Tasks.ParallelLoopState.IsStopped%2A> property to determine whether they should return immediately or execute normally.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d102d-157">O exemplo a seguir executa até 10.000 iterações de um loop em paralelo.</span><span class="sxs-lookup"><span data-stu-id="d102d-157">The following example executes up to 10,000 iterations of a loop in parallel.</span></span> <span data-ttu-id="d102d-158">Cada iteração pausa por um intervalo aleatório de 1 a 1.000 milissegundos.</span><span class="sxs-lookup"><span data-stu-id="d102d-158">Each iteration pauses for a random interval from 1 to 1,000 milliseconds.</span></span> <span data-ttu-id="d102d-159">Um valor gerado aleatoriamente determina em qual iteração do loop de <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> método é chamado.</span><span class="sxs-lookup"><span data-stu-id="d102d-159">A randomly generated value determines on which iteration of the loop the <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> method is called.</span></span> <span data-ttu-id="d102d-160">Porque as iterações do loop provavelmente ainda estar em execução quando o <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> método é chamado, a expressão de lambda chama o <xref:System.Threading.Tasks.ParallelLoopState.IsStopped%2A> método para verificar se a outra iteração tem chamado a <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d102d-160">Because iterations of the loop are still likely to be executing when the <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> method is called, the lambda expression calls the <xref:System.Threading.Tasks.ParallelLoopState.IsStopped%2A> method to check whether another iteration has called the <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> method.</span></span> <span data-ttu-id="d102d-161">Se ele retornar `true`, a iteração retorna imediatamente.</span><span class="sxs-lookup"><span data-stu-id="d102d-161">If it returns `true`, the iteration returns immediately.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.ParallelLoopState#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallelloopstate/cs/stop1.cs#1)]
 [!code-vb[System.Threading.Tasks.ParallelLoopState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallelloopstate/vb/stop1.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/parallel-programming/data-parallelism-task-parallel-library.md"><span data-ttu-id="d102d-162">Paralelismo de dados (biblioteca de tarefas paralelas)</span><span class="sxs-lookup"><span data-stu-id="d102d-162">Data Parallelism (Task Parallel Library)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="LowestBreakIteration">
      <MemberSignature Language="C#" Value="public Nullable&lt;long&gt; LowestBreakIteration { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Nullable`1&lt;int64&gt; LowestBreakIteration" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LowestBreakIteration As Nullable(Of Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Nullable&lt;long&gt; LowestBreakIteration { Nullable&lt;long&gt; get(); };" />
      <MemberSignature Language="F#" Value="member this.LowestBreakIteration : Nullable&lt;int64&gt;" Usage="System.Threading.Tasks.ParallelLoopState.LowestBreakIteration" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int64&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d102d-163">Obtém a menor iteração do loop do qual <see cref="M:System.Threading.Tasks.ParallelLoopState.Break" /> foi chamado.</span><span class="sxs-lookup"><span data-stu-id="d102d-163">Gets the lowest iteration of the loop from which <see cref="M:System.Threading.Tasks.ParallelLoopState.Break" /> was called.</span></span></summary>
        <value><span data-ttu-id="d102d-164">A menor iteração do qual <see cref="M:System.Threading.Tasks.ParallelLoopState.Break" /> foi chamado.</span><span class="sxs-lookup"><span data-stu-id="d102d-164">The lowest iteration from which <see cref="M:System.Threading.Tasks.ParallelLoopState.Break" /> was called.</span></span> <span data-ttu-id="d102d-165">No caso de um <see cref="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.Partitioner{``0},System.Action{``0})" /> loop, o valor é baseado em um índice gerado internamente.</span><span class="sxs-lookup"><span data-stu-id="d102d-165">In the case of a <see cref="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.Partitioner{``0},System.Action{``0})" /> loop, the value is based on an internally-generated index.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d102d-166">É possível que várias iterações de um loop paralelo para chamar o <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d102d-166">It is possible for multiple iterations of a parallel loop to call the <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> method.</span></span> <span data-ttu-id="d102d-167">Se Sim, esse valor é o menor índice de uma iteração que chamou <xref:System.Threading.Tasks.ParallelLoopState.Break%2A>.</span><span class="sxs-lookup"><span data-stu-id="d102d-167">If they do, this value is the smallest index of an iteration that called <xref:System.Threading.Tasks.ParallelLoopState.Break%2A>.</span></span> <span data-ttu-id="d102d-168">Se nenhuma iteração do loop é chamado <xref:System.Threading.Tasks.ParallelLoopState.Break%2A>, essa propriedade retornará `null`.</span><span class="sxs-lookup"><span data-stu-id="d102d-168">If no iteration of the loop called <xref:System.Threading.Tasks.ParallelLoopState.Break%2A>, this property returns `null`.</span></span> <span data-ttu-id="d102d-169">Observe que o valor da propriedade não é afetado por chamadas para o <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d102d-169">Note that the property value is unaffected by calls to the <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> method.</span></span>  
  
 <span data-ttu-id="d102d-170">Em iterações de longa execução na quais todas as iterações após a iteração que chama o <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> não precisará executar o método, o <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A> propriedade é usada para encerrar as iterações que começaram a execução antes de chamar o <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d102d-170">In long-running iterations in which all iterations after the iteration that calls the <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> method need not run, the <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A> property is used to terminate iterations that began execution before the call to the <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> method.</span></span> <span data-ttu-id="d102d-171">Para interromper as iterações cujo índice é maior que a menor iteração de interrupção da execução concorrente, faça o seguinte:</span><span class="sxs-lookup"><span data-stu-id="d102d-171">To stop iterations whose index is greater than the lowest break iteration from competing execution, you should do the following:</span></span>  
  
1.  <span data-ttu-id="d102d-172">Verifique se o <xref:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration%2A> é de propriedade `true`.</span><span class="sxs-lookup"><span data-stu-id="d102d-172">Check whether the <xref:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration%2A> property is `true`.</span></span>  
  
2.  <span data-ttu-id="d102d-173">Sair da iteração, se o seu índice é maior que o <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A> valor da propriedade.</span><span class="sxs-lookup"><span data-stu-id="d102d-173">Exit from the iteration if its index is greater than the <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A> property value.</span></span>  
  
 <span data-ttu-id="d102d-174">O exemplo fornece uma ilustração.</span><span class="sxs-lookup"><span data-stu-id="d102d-174">The example provides an illustration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d102d-175">O exemplo a seguir executa até 100 iterações de um loop em paralelo.</span><span class="sxs-lookup"><span data-stu-id="d102d-175">The following example executes up to 100 iterations of a loop in parallel.</span></span> <span data-ttu-id="d102d-176">Cada iteração pausa por um intervalo aleatório de 1 a 1.000 milissegundos.</span><span class="sxs-lookup"><span data-stu-id="d102d-176">Each iteration pauses for a random interval from 1 to 1,000 milliseconds.</span></span> <span data-ttu-id="d102d-177">Um valor gerado aleatoriamente determina em qual iteração do loop de <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> método é chamado.</span><span class="sxs-lookup"><span data-stu-id="d102d-177">A randomly generated value determines on which iteration of the loop the <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> method is called.</span></span> <span data-ttu-id="d102d-178">Isso impede que as iterações cujo índice é maior que o <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A> valor de propriedade de inicialização após a chamada para o <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> método, mas ele não afeta qualquer iterações que já começou a executar.</span><span class="sxs-lookup"><span data-stu-id="d102d-178">This prevents iterations whose index is greater than the <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A> property value from starting after the call to the <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> method, but it does not affect any iterations that have already begun executing.</span></span> <span data-ttu-id="d102d-179">Para impedir que eles concluam, cada iteração chama o <xref:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration%2A> método para verificar se a outra iteração tenha chamado o <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d102d-179">To prevent these from completing, each iteration calls the <xref:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration%2A> method to check whether another iteration has called the <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> method.</span></span> <span data-ttu-id="d102d-180">Se assim, a iteração verifica o valor da <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A> propriedade e, se ele for maior que o valor de índice da iteração atual, retorna imediatamente.</span><span class="sxs-lookup"><span data-stu-id="d102d-180">If so, the iteration checks the value of the <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A> property and, if it is greater than the current iteration's index value, returns immediately.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.ParallelLoopState#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallelloopstate/cs/break1.cs#2)]
 [!code-vb[System.Threading.Tasks.ParallelLoopState#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallelloopstate/vb/break1.vb#2)]  
  
 <span data-ttu-id="d102d-181">Observe que, como o <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A> valor está fora do escopo fora do loop paralelo, você deve atribuí-lo a uma variável que é visível fora do loop, se você quiser preservar seu valor.</span><span class="sxs-lookup"><span data-stu-id="d102d-181">Note that, because the <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A> value is out of scope outside of the parallel loop, you must assign it to a variable that is visible outside of the loop if you want to preserve its value.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration" />
        <altmember cref="M:System.Threading.Tasks.ParallelLoopState.Break" />
        <related type="Article" href="~/docs/standard/parallel-programming/data-parallelism-task-parallel-library.md"><span data-ttu-id="d102d-182">Paralelismo de dados (biblioteca de tarefas paralelas)</span><span class="sxs-lookup"><span data-stu-id="d102d-182">Data Parallelism (Task Parallel Library)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ShouldExitCurrentIteration">
      <MemberSignature Language="C#" Value="public bool ShouldExitCurrentIteration { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShouldExitCurrentIteration" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ShouldExitCurrentIteration As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ShouldExitCurrentIteration { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ShouldExitCurrentIteration : bool" Usage="System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d102d-183">Obtém se a iteração atual do loop deve sair com base nas solicitações feitas por esta ou outras iterações.</span><span class="sxs-lookup"><span data-stu-id="d102d-183">Gets whether the current iteration of the loop should exit based on requests made by this or other iterations.</span></span></summary>
        <value><span data-ttu-id="d102d-184"><see langword="true" /> Se a iteração atual deve sair; Caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="d102d-184"><see langword="true" /> if the current iteration should exit; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d102d-185">O <xref:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration%2A> estiver definida como `true` em qualquer uma das seguintes condições:</span><span class="sxs-lookup"><span data-stu-id="d102d-185">The <xref:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration%2A> property is set to `true` under any of the following conditions:</span></span>  
  
-   <span data-ttu-id="d102d-186">Das chamadas de loop de iteração <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> ou <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A>.</span><span class="sxs-lookup"><span data-stu-id="d102d-186">An iteration of the loop calls <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> or <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A>.</span></span>  
  
-   <span data-ttu-id="d102d-187">Uma iteração do loop lançará uma exceção.</span><span class="sxs-lookup"><span data-stu-id="d102d-187">An iteration of the loop throws an exception.</span></span>  
  
-   <span data-ttu-id="d102d-188">O loop será cancelado.</span><span class="sxs-lookup"><span data-stu-id="d102d-188">The loop is canceled.</span></span>  
  
 <span data-ttu-id="d102d-189">Quando essa propriedade é `true`, o <xref:System.Threading.Tasks.Parallel> classe proativamente tentará proibir adicionais iterações do loop de iniciar a execução.</span><span class="sxs-lookup"><span data-stu-id="d102d-189">When this property is `true`, the <xref:System.Threading.Tasks.Parallel> class will proactively attempt to prohibit additional iterations of the loop from starting execution.</span></span> <span data-ttu-id="d102d-190">No entanto, pode haver casos em que é impossível evitar iterações adicionais seja iniciado.</span><span class="sxs-lookup"><span data-stu-id="d102d-190">However, there may be cases where it is unable to prevent additional iterations from starting.</span></span>  
  
 <span data-ttu-id="d102d-191">Também pode ser o caso de uma iteração de longa execução já começou a execução.</span><span class="sxs-lookup"><span data-stu-id="d102d-191">It may also be the case that a long-running iteration has already begun execution.</span></span> <span data-ttu-id="d102d-192">Nesses casos, as iterações podem verificar explicitamente o <xref:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration%2A> propriedade e interromper a execução se a propriedade retornar `true`.</span><span class="sxs-lookup"><span data-stu-id="d102d-192">In such cases, iterations may explicitly check the <xref:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration%2A> property and cease execution if the property returns `true`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d102d-193">O exemplo a seguir executa até 100 iterações de um loop em paralelo.</span><span class="sxs-lookup"><span data-stu-id="d102d-193">The following example executes up to 100 iterations of a loop in parallel.</span></span> <span data-ttu-id="d102d-194">Cada iteração pausa por um intervalo aleatório de 1 a 1.000 milissegundos.</span><span class="sxs-lookup"><span data-stu-id="d102d-194">Each iteration pauses for a random interval from 1 to 1,000 milliseconds.</span></span> <span data-ttu-id="d102d-195">Um valor gerado aleatoriamente determina em qual iteração do loop de <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> método é chamado.</span><span class="sxs-lookup"><span data-stu-id="d102d-195">A randomly generated value determines on which iteration of the loop the <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> method is called.</span></span> <span data-ttu-id="d102d-196">Isso impede que as iterações cujo índice é maior que o <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A> valor de propriedade de inicialização após a chamada para o <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> método, mas ele não afeta qualquer iterações que já começou a executar.</span><span class="sxs-lookup"><span data-stu-id="d102d-196">This prevents iterations whose index is greater than the <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A> property value from starting after the call to the <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> method, but it does not affect any iterations that have already begun executing.</span></span> <span data-ttu-id="d102d-197">Para impedir que eles concluam, cada iteração chama o <xref:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration%2A> método para verificar se a outra iteração tenha chamado o <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d102d-197">To prevent these from completing, each iteration calls the <xref:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration%2A> method to check whether another iteration has called the <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> method.</span></span> <span data-ttu-id="d102d-198">Se assim, a iteração verifica o valor da <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A> propriedade e, se ele for maior que o valor de índice da iteração atual, retorna imediatamente.</span><span class="sxs-lookup"><span data-stu-id="d102d-198">If so, the iteration checks the value of the <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A> property and, if it is greater than the current iteration's index value, returns immediately.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.ParallelLoopState#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallelloopstate/cs/break1.cs#2)]
 [!code-vb[System.Threading.Tasks.ParallelLoopState#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallelloopstate/vb/break1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration" />
        <altmember cref="M:System.Threading.Tasks.ParallelLoopState.Break" />
        <altmember cref="M:System.Threading.Tasks.ParallelLoopState.Stop" />
        <related type="Article" href="~/docs/standard/parallel-programming/data-parallelism-task-parallel-library.md"><span data-ttu-id="d102d-199">Paralelismo de dados (biblioteca de tarefas paralelas)</span><span class="sxs-lookup"><span data-stu-id="d102d-199">Data Parallelism (Task Parallel Library)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Stop">
      <MemberSignature Language="C#" Value="public void Stop ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Stop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.ParallelLoopState.Stop" />
      <MemberSignature Language="VB.NET" Value="Public Sub Stop ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Stop();" />
      <MemberSignature Language="F#" Value="member this.Stop : unit -&gt; unit" Usage="parallelLoopState.Stop " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d102d-200">Comunica que o loop <see cref="T:System.Threading.Tasks.Parallel" /> deve cessar a execução assim que for possível para o sistema.</span><span class="sxs-lookup"><span data-stu-id="d102d-200">Communicates that the <see cref="T:System.Threading.Tasks.Parallel" /> loop should cease execution at the system's earliest convenience.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d102d-201">Chamar o <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> método indica que qualquer iterações do loop que ainda não iniciaram não precisam ser executadas.</span><span class="sxs-lookup"><span data-stu-id="d102d-201">Calling the <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> method indicates that any iterations of the loop that have not yet started need not be run.</span></span> <span data-ttu-id="d102d-202">Ele efetivamente cancela qualquer adicionais iterações do loop.</span><span class="sxs-lookup"><span data-stu-id="d102d-202">It effectively cancels any additional iterations of the loop.</span></span> <span data-ttu-id="d102d-203">No entanto, não impede que qualquer iterações que já começou a execução.</span><span class="sxs-lookup"><span data-stu-id="d102d-203">However, it does not stop any iterations that have already begun execution.</span></span>  
  
 <span data-ttu-id="d102d-204">Chamar o <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> método faz com que o <xref:System.Threading.Tasks.ParallelLoopState.IsStopped%2A> propriedade para retornar `true` para qualquer iteração do loop que ainda está em execução.</span><span class="sxs-lookup"><span data-stu-id="d102d-204">Calling the <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> method causes the <xref:System.Threading.Tasks.ParallelLoopState.IsStopped%2A> property to return `true` for any iteration of the loop that is still executing.</span></span> <span data-ttu-id="d102d-205">Isso é particularmente útil para iterações de longa execução, que podem verificar a <xref:System.Threading.Tasks.ParallelLoopState.IsStopped%2A> propriedade e sair antecipadamente se seu valor é `true`.</span><span class="sxs-lookup"><span data-stu-id="d102d-205">This is particularly useful for long-running iterations, which can check the <xref:System.Threading.Tasks.ParallelLoopState.IsStopped%2A> property and exit early if its value is `true`.</span></span>  
  
 <span data-ttu-id="d102d-206"><xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> normalmente é utilizado em algoritmos baseados em pesquisa, onde depois que um resultado for encontradas, nenhum outras iterações precisam ser executadas.</span><span class="sxs-lookup"><span data-stu-id="d102d-206"><xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> is typically employed in search-based algorithms, where once a result is found, no other iterations need be executed.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d102d-207">O exemplo a seguir executa até 10.000 iterações de um loop em paralelo.</span><span class="sxs-lookup"><span data-stu-id="d102d-207">The following example executes up to 10,000 iterations of a loop in parallel.</span></span> <span data-ttu-id="d102d-208">Cada iteração pausa por um intervalo aleatório de 1 a 1.000 milissegundos.</span><span class="sxs-lookup"><span data-stu-id="d102d-208">Each iteration pauses for a random interval from 1 to 1,000 milliseconds.</span></span> <span data-ttu-id="d102d-209">Um valor gerado aleatoriamente determina em qual iteração do loop de <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> método é chamado.</span><span class="sxs-lookup"><span data-stu-id="d102d-209">A randomly generated value determines on which iteration of the loop the <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> method is called.</span></span> <span data-ttu-id="d102d-210">Como mostra a saída do exemplo, não as iterações são executadas após a chamada para o <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d102d-210">As the output from the example shows, no iterations execute after the call to the <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> method.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.ParallelLoopState#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallelloopstate/cs/stop1.cs#1)]
 [!code-vb[System.Threading.Tasks.ParallelLoopState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallelloopstate/vb/stop1.vb#1)]  
  
 <span data-ttu-id="d102d-211">Como as iterações do loop são ainda podem estar em execução quando o <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> método é chamado, as chamadas de cada iteração a <xref:System.Threading.Tasks.ParallelLoopState.IsStopped%2A> método para verificar se a outra iteração tiver chamado o <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d102d-211">Because iterations of the loop are still likely to be executing when the <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> method is called, each iteration calls the <xref:System.Threading.Tasks.ParallelLoopState.IsStopped%2A> method to check whether another iteration has called the <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> method.</span></span> <span data-ttu-id="d102d-212">Se ele retornar `true`, a iteração retorna imediatamente.</span><span class="sxs-lookup"><span data-stu-id="d102d-212">If it returns `true`, the iteration returns immediately.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d102d-213">O método <see cref="M:System.Threading.Tasks.ParallelLoopState.Break" /> foi chamado anteriormente.</span><span class="sxs-lookup"><span data-stu-id="d102d-213">The <see cref="M:System.Threading.Tasks.ParallelLoopState.Break" /> method was called previously.</span></span> <span data-ttu-id="d102d-214"><see cref="M:System.Threading.Tasks.ParallelLoopState.Break" /> e <see cref="M:System.Threading.Tasks.ParallelLoopState.Stop" /> não podem ser usados em combinação por iterações do mesmo loop.</span><span class="sxs-lookup"><span data-stu-id="d102d-214"><see cref="M:System.Threading.Tasks.ParallelLoopState.Break" /> and <see cref="M:System.Threading.Tasks.ParallelLoopState.Stop" /> may not be used in combination by iterations of the same loop.</span></span></exception>
        <altmember cref="P:System.Threading.Tasks.ParallelLoopState.IsStopped" />
        <related type="Article" href="~/docs/standard/parallel-programming/data-parallelism-task-parallel-library.md"><span data-ttu-id="d102d-215">Paralelismo de dados (biblioteca de tarefas paralelas)</span><span class="sxs-lookup"><span data-stu-id="d102d-215">Data Parallelism (Task Parallel Library)</span></span></related>
      </Docs>
    </Member>
  </Members>
</Type>