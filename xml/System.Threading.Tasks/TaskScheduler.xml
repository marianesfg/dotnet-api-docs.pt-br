<Type Name="TaskScheduler" FullName="System.Threading.Tasks.TaskScheduler">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="07b247c6f7b2ed280c89a5c3f9f2c0520ed7a06d" />
    <Meta Name="ms.sourcegitcommit" Value="0d6aa6694f157a08fe52cd25b4d9d3dcf913e812" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="pt-BR" />
    <Meta Name="ms.lasthandoff" Value="10/12/2018" />
    <Meta Name="ms.locfileid" Value="49130424" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class TaskScheduler" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit TaskScheduler extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Tasks.TaskScheduler" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class TaskScheduler" />
  <TypeSignature Language="C++ CLI" Value="public ref class TaskScheduler abstract" />
  <TypeSignature Language="F#" Value="type TaskScheduler = class" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Tasks</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerDisplay("Id={Id}")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Threading.Tasks.TaskScheduler/SystemThreadingTasks_TaskSchedulerDebugView))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Representa um objeto que manipula o trabalho de nível baixo de enfileirar tarefas em threads.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uma instância da <xref:System.Threading.Tasks.TaskScheduler> classe representa um agendador de tarefas. Um agendador de tarefas garante que o trabalho de uma tarefa é eventualmente executado.  
  
 O Agendador de tarefas padrão baseia-se no pool de threads do .NET Framework 4, que fornece o roubo de trabalho para o balanceamento de carga, injeção de thread/desativação de taxa de transferência máxima e desempenho geral boa. Ele deve ser suficiente para a maioria dos cenários.  
  
 O <xref:System.Threading.Tasks.TaskScheduler> classe também serve como o ponto de extensão para toda a lógica de agendamento personalizável.  Isso inclui mecanismos, como como agendar uma tarefa para execução e as tarefas agendadas como deve ser exposto aos depuradores. Se você precisar de uma funcionalidade especial, você pode criar um agendador personalizado e habilitá-lo para tarefas específicas ou consultas.  
  
 Neste tópico:  
[O Agendador de tarefas padrão e o pool de threads](#Default)  
 [A fila global versus filas locais](#Queues)  
 [Roubo de trabalho](#Stealing)  
 [Tarefas de longa execução](#LongRunning)  
 [Inlining de tarefa](#Inlining)  
[Especificando um contexto de sincronização](#Sync)  
  
<a name="Default"></a>   
## <a name="the-default-task-scheduler-and-the-thread-pool"></a>O Agendador de tarefas padrão e o pool de threads  
 O agendador padrão para a biblioteca paralela de tarefas e o PLINQ utiliza o pool de threads do .NET Framework, que é representado pelo <xref:System.Threading.ThreadPool> classe enfileirar e executar o trabalho. O pool de threads usa as informações fornecidas pelo <xref:System.Threading.Tasks.Task> tipo para dar suporte a paralelismo refinado (unidades de curta duração do trabalho) que são paralelos tarefas e consultas geralmente representam com eficiência.  
  
<a name="Queues"></a>   
### <a name="the-global-queue-vs-local-queues"></a>A fila global versus filas locais  
 O pool de threads mantém a fila de threads em cada domínio de aplicativo de trabalho de um global PEPS (primeiro a entrar, primeiro a sair). Sempre que um programa chama o <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A?displayProperty=nameWithType> (ou <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A?displayProperty=nameWithType>) método, o trabalho é colocar nessa fila compartilhada e, eventualmente, da fila para próximo thread que se torna disponível. Começando com o .NET Framework 4, essa fila foi aperfeiçoada para usar um algoritmo livres de bloqueio que se parece com o <xref:System.Collections.Concurrent.ConcurrentQueue%601> classe. Ao usar essa implementação livres de bloqueio, o pool de threads gasta menos tempo quando ele coloca na fila e retira os itens de trabalho. Esse benefício de desempenho está disponível para todos os programas que usam o pool de threads.  
  
 Tarefas de nível superior, que são tarefas que não são criadas no contexto de outra tarefa, são colocadas na fila assim como qualquer outro item de trabalho global. No entanto, aninhados ou tarefas filho, que são criadas no contexto de outra tarefa, são tratadas de modo bem diferente. Um filho ou uma tarefa aninhada é colocada em uma fila local que é específica para o thread no qual a tarefa pai está em execução. A tarefa pai pode ser uma tarefa de nível superior ou também pode ser o filho de outra tarefa. Quando esse thread está pronto para mais de trabalho, ele primeiro procura na fila local. Se os itens de trabalho estiver aguardando lá, eles podem ser acessados rapidamente. As filas locais são acessadas na ordem último a entrar, primeiro a sair (UEPS) para preservar a localidade do cache e reduzir a contenção. Para obter mais informações sobre tarefas aninhadas e tarefas filho, consulte [anexadas e desanexadas tarefas de filho](~/docs/standard/parallel-programming/attached-and-detached-child-tasks.md).  
  
 O uso de filas locais não só reduz a pressão sobre a fila global, mas também se beneficia da localidade dos dados. Itens de trabalho no local da fila com frequência estruturas de dados de referência que estão fisicamente próximos uns dos outros na memória. Nesses casos, os dados já estão no cache após a primeira tarefa foi executada e pode ser acessada rapidamente. Ambos [PLINQ (Parallel LINQ)](~/docs/standard/parallel-programming/parallel-linq-plinq.md) e o <xref:System.Threading.Tasks.Parallel> classe tarefas aninhadas e tarefas filho extensivamente e obter aumentos de velocidade significativos, usando as filas de trabalho local.  
  
<a name="Stealing"></a>   
### <a name="work-stealing"></a>Roubo de trabalho  
 Começando com o .NET Framework 4, o pool de threads também apresenta um algoritmo de roubo de trabalho para ajudar a tornar-se de que nenhum thread está sentado ociosos enquanto outros ainda têm trabalham em suas filas. Quando um thread do pool de threads está pronto para mais de trabalho, ele primeiro procura no início da fila de local, em seguida, na fila de global e, em seguida, nas filas de local de outros threads. Se ele encontrar um item de trabalho na fila de local de outro thread, ele primeiro se aplica a heurística para certificar-se de que ele pode executar o trabalho com eficiência. Se for possível, ele retira o item de trabalho do fim (na ordem FIFO). Isso reduz a contenção em cada fila local e preserva a localidade dos dados. Essa arquitetura permite que o balanceamento de carga do pool threads funcionam de forma mais eficiente do que nas versões anteriores.  
  
<a name="LongRunning"></a>   
### <a name="long-running-tasks"></a>Tarefas de longa execução  
 Você talvez queira impedir explicitamente que uma tarefa que está sendo colocada em uma fila local. Por exemplo, você poderá saber que um determinado item de trabalho será executado em um tempo relativamente longo e é provável que bloqueie todos os outros itens de trabalho na fila local. Nesse caso, você pode especificar o <xref:System.Threading.Tasks.TaskCreationOptions?displayProperty=nameWithType> opção, que fornece uma dica para o Agendador de que um thread adicional pode ser necessário para a tarefa para que ele não bloqueia o progresso de outros threads ou itens de trabalho na fila local. Ao usar essa opção você evita o pool de threads completamente, incluindo as filas globais e locais.  
  
<a name="Inlining"></a>   
### <a name="task-inlining"></a>Inlining de tarefa  
 Em alguns casos, quando um <xref:System.Threading.Tasks.Task> esperou, ele pode ser executado de forma síncrona no thread que está executando a operação de espera. Isso melhora o desempenho, evitando a necessidade de um thread adicional e em vez de usar o thread existente, o que seria ter bloqueado a outra forma. Para evitar erros devido a reentrada, tarefa inlining só ocorre quando o destino de espera é encontrado na fila de local do thread relevante.  
  
<a name="Sync"></a>   
## <a name="specifying-a-synchronization-context"></a>Especificando um contexto de sincronização  
 Você pode usar o <xref:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext%2A?displayProperty=nameWithType> método para especificar que uma tarefa deve ser agendada para execução em um thread específico. Isso é útil em estruturas como o Windows Forms e Windows Presentation Foundation em que o acesso aos objetos de interface do usuário geralmente é limitado a código que está em execução no mesmo thread no qual o objeto de interface do usuário foi criado.  
  
 O exemplo a seguir usa o <xref:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext%2A?displayProperty=nameWithType> método em um aplicativo Windows Presentation Foundation (WPF) para agendar uma tarefa no mesmo thread que o controle de (UI) de interface do usuário foi criado.   O exemplo cria um mosaico de imagens que serão selecionadas aleatoriamente de um diretório especificado. Os objetos do WPF são usados para carregar e redimensione as imagens. Os pixels brutos são então passados para uma tarefa que usa um <xref:System.Threading.Tasks.Parallel.For%2A> loop para gravar os dados de pixel em uma grande matriz de byte único. Nenhuma sincronização é necessária porque não há dois blocos ocupam os mesmos elementos de matriz. Os blocos também podem ser gravados em qualquer ordem, porque sua posição é calculada independentemente de qualquer outro bloco. A matriz grande, em seguida, é passada para uma tarefa que executa no thread da interface do usuário, onde os dados de pixel são carregados em um controle de imagem.  
  
 O exemplo move os dados fora do thread de interface do usuário, modifica-o por meio de loops paralelos e <xref:System.Threading.Tasks.Task> objetos e, em seguida, passa de volta para uma tarefa que executa no thread da interface do usuário. Essa abordagem é útil quando você tem que usar a biblioteca paralela de tarefas para executar operações que não são compatíveis com a API do WPF, ou que não forem suficientemente rápidos. Outra maneira de criar um mosaico de imagem no WPF é usar um <xref:System.Windows.Controls.WrapPanel?displayProperty=nameWithType> controlar e adicionar imagens a ele. O <xref:System.Windows.Controls.WrapPanel> manipula o trabalho de posicionamento de blocos. No entanto, esse trabalho só pode ser executado no thread da interface do usuário.  
  
 [!code-csharp[TPL_SyncContext#01](~/samples/snippets/csharp/VS_Snippets_Misc/tpl_synccontext/cs/mainwindow.xaml.cs#01)]
 [!code-vb[TPL_SyncContext#01](~/samples/snippets/visualbasic/VS_Snippets_Misc/tpl_synccontext/vb/MainWindow.xaml.vb#01)]  
  
 Para criar o exemplo, criar um projeto de aplicativo do WPF no Visual Studio e atribuir um nome de sua escolha. Em seguida, faça o seguinte:  
  
1.  No modo de design, arraste um <xref:System.Windows.Controls.Image> controlar do **caixa de ferramentas** à superfície de design. No modo de exibição XAML, especifique o alinhamento horizontal como "Esquerda". O tamanho não importa porque o controle é redimensionado dinamicamente em tempo de execução. Aceite o nome padrão, "imagem".  
  
2.  Arraste uma <xref:System.Windows.Controls.Button> controlar do **caixa de ferramentas** até a parte inferior esquerda da janela do aplicativo. Clique duas vezes no botão para adicionar um <xref:System.Windows.Controls.Primitives.ButtonBase.Click> manipulador de eventos. No modo de exibição XAML, especifique o <xref:System.Windows.Controls.ContentControl.Content%2A> propriedade do botão como "Fazer um mosaico" e especifica o alinhamento horizontal como "Esquerda". Aceite o nome padrão, "button".  
  
3.  Substitua todo o conteúdo do arquivo. XAML. vb ou MainWindow.xaml.cs com o código deste exemplo. Certifique-se de que o nome do espaço de trabalho corresponde ao nome do projeto.  
  
4.  O exemplo lê imagens JPEG de um diretório chamado C:\Users\Public\Pictures\Sample imagens\\. Crie o diretório e colocar algumas imagens nele ou altere o caminho para fazer referência a outro diretório que contém imagens.  
  
 Este exemplo tem algumas limitações. Por exemplo, há suporte para imagens apenas 32-bits por pixel; imagens em outros formatos estão corrompidas pelo <xref:System.Windows.Media.Imaging.BitmapImage> objeto durante a operação de redimensionamento. Além disso, as imagens de origem devem todas ser maiores que o tamanho do bloco. Como um exercício adicional, você pode adicionar funcionalidade para lidar com vários formatos de pixel e tamanhos de arquivos.  
  
   
  
## Examples  
 O exemplo a seguir é retirado do [amostras para programação paralela com o .NET Framework 4](http://go.microsoft.com/fwlink/?LinkID=165717) no site da Web de galeria de código do MSDN.  Ele cria um agendador de tarefas personalizado que limita o número de threads usados pelo aplicativo. Em seguida, ele inicia dois conjuntos de tarefas e exibe informações sobre a tarefa e o thread no qual a tarefa está em execução.  
  
 [!code-csharp[TPL_Schedulers#02](~/samples/snippets/csharp/VS_Snippets_Misc/tpl_schedulers/cs/limitex1.cs#02)]
 [!code-vb[TPL_Schedulers#02](~/samples/snippets/visualbasic/VS_Snippets_Misc/tpl_schedulers/vb/module2.vb#02)]  
  
 Além disso, vários agendadores de tarefas de exemplo estão disponíveis na Galeria de código: [amostras para programação paralela com o .NET Framework 4](http://go.microsoft.com/fwlink/?LinkID=165717).  
  
 ]]></format>
    </remarks>
    <threadsafe>Todos os membros do resumo <see cref="T:System.Threading.Tasks.TaskScheduler" /> tipo são thread-safe e podem ser usados simultaneamente de vários threads.</threadsafe>
    <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
    <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Biblioteca de tarefas paralelas (TPL)</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected TaskScheduler ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; TaskScheduler();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa o <see cref="T:System.Threading.Tasks.TaskScheduler" />.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Biblioteca de tarefas paralelas (TPL)</related>
      </Docs>
    </Member>
    <Member MemberName="Current">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.TaskScheduler Current { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Threading.Tasks.TaskScheduler Current" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskScheduler.Current" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Current As TaskScheduler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Threading::Tasks::TaskScheduler ^ Current { System::Threading::Tasks::TaskScheduler ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Current : System.Threading.Tasks.TaskScheduler" Usage="System.Threading.Tasks.TaskScheduler.Current" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskScheduler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o <see cref="T:System.Threading.Tasks.TaskScheduler" /> associado à tarefa em execução no momento.</summary>
        <value>Retorna o <see cref="T:System.Threading.Tasks.TaskScheduler" /> associado à tarefa em execução no momento.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando chamado de uma tarefa, não <xref:System.Threading.Tasks.TaskScheduler.Current%2A> retornará o <xref:System.Threading.Tasks.TaskScheduler.Default%2A> Agendador.  
  
 Para obter mais informações, consulte <xref:System.Threading.Tasks.TaskScheduler>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Biblioteca de tarefas paralelas (TPL)</related>
      </Docs>
    </Member>
    <Member MemberName="Default">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.TaskScheduler Default { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Threading.Tasks.TaskScheduler Default" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskScheduler.Default" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Default As TaskScheduler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Threading::Tasks::TaskScheduler ^ Default { System::Threading::Tasks::TaskScheduler ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Default : System.Threading.Tasks.TaskScheduler" Usage="System.Threading.Tasks.TaskScheduler.Default" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskScheduler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém a instância <see cref="T:System.Threading.Tasks.TaskScheduler" /> padrão, fornecida pelo .NET Framework.</summary>
        <value>Retorna a instância padrão <see cref="T:System.Threading.Tasks.TaskScheduler" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obter mais informações, consulte <xref:System.Threading.Tasks.TaskScheduler>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Biblioteca de tarefas paralelas (TPL)</related>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~TaskScheduler ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!TaskScheduler ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="taskScheduler.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libera todos os recursos associados ao agendador.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FromCurrentSynchronizationContext">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.TaskScheduler FromCurrentSynchronizationContext ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.TaskScheduler FromCurrentSynchronizationContext() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromCurrentSynchronizationContext () As TaskScheduler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::TaskScheduler ^ FromCurrentSynchronizationContext();" />
      <MemberSignature Language="F#" Value="static member FromCurrentSynchronizationContext : unit -&gt; System.Threading.Tasks.TaskScheduler" Usage="System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskScheduler</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cria um <see cref="T:System.Threading.Tasks.TaskScheduler" /> associado ao <see cref="T:System.Threading.SynchronizationContext" /> atual.</summary>
        <returns>Um <see cref="T:System.Threading.Tasks.TaskScheduler" /> associado ao <see cref="T:System.Threading.SynchronizationContext" /> atual, conforme determinado por <see cref="P:System.Threading.SynchronizationContext.Current" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Todos os <xref:System.Threading.Tasks.Task> instâncias na fila para retornado Agendador será executado por meio de uma chamada para o <xref:System.Threading.SynchronizationContext.Post%2A> método nesse contexto.  
  
 Para obter mais informações, consulte <xref:System.Threading.Tasks.TaskScheduler>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">O SynchronizationContext atual não pode ser usado como um TaskScheduler.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Biblioteca de tarefas paralelas (TPL)</related>
      </Docs>
    </Member>
    <Member MemberName="GetScheduledTasks">
      <MemberSignature Language="C#" Value="protected abstract System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&gt; GetScheduledTasks ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class System.Threading.Tasks.Task&gt; GetScheduledTasks() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.GetScheduledTasks" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetScheduledTasks () As IEnumerable(Of Task)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Collections::Generic::IEnumerable&lt;System::Threading::Tasks::Task ^&gt; ^ GetScheduledTasks();" />
      <MemberSignature Language="F#" Value="abstract member GetScheduledTasks : unit -&gt; seq&lt;System.Threading.Tasks.Task&gt;" Usage="taskScheduler.GetScheduledTasks " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Apenas para o suporte do depurador, gera um enumerável de instâncias <see cref="T:System.Threading.Tasks.Task" /> atualmente na fila do Agendador aguardando ser executado.</summary>
        <returns>Um enumerável que permite que um depurador percorra as tarefas atualmente na fila para este agendador.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uma classe derivada de <xref:System.Threading.Tasks.TaskScheduler> implementa esse método para dar suporte à integração com depuradores. Esse método só será invocado pelo .NET Framework quando o depurador solicita acesso aos dados. O enumerável retornado será ser percorrido por utilitários para acessar as tarefas de depuração atualmente na fila para este Agendador, permitindo que o depurador para fornecer uma representação dessas informações na interface do usuário.  
  
 É importante observar que, quando esse método é chamado, todos os outros threads no processo serão congelados. Portanto, é importante evitar a sincronização com outros threads que podem levar ao bloqueio. Se a sincronização é necessária e você não conseguir adquirir o bloqueio nesse método, você deve lançar uma exceção para que o depurador não pare de responder. O exemplo a seguir mostra uma abordagem possível no c#:  
  
```  
protected override IEnumerable<Task> GetScheduledTasks()  
{  
    bool lockTaken = false;  
    try  
    {  
        Monitor.TryEnter(_syncObj, ref lockTaken);  
        if (lockTaken)  
        {  
            return _tasks.ToArray();  
        }  
        else throw new NotSupportedException();  
    }  
    finally  
    {  
    if (lockTaken) Monitor.Exit(_syncObj);  
    }}  
```  
  
 Além disso, esse método e o enumerável retornado não deve modificar qualquer estado global visível.  
  
 O retornado enumerável nunca deve ser nulo. Se não houver nenhuma tarefa em fila, um enumerável de vazio deve ser retornado.  
  
 Os desenvolvedores que estiverem implementando depuradores personalizados não deve chamar este método diretamente, mas deve usar o método wrapper interna `GetScheduledTasksForDebugger` em vez disso: `internal Task[] GetScheduledTasksForDebugger()`. Esse método de invólucro retorna uma matriz de tarefas em vez de um enumerável. Para recuperar uma lista de agendadores de Active Directory, use o método interno `internal static TaskScheduler[] GetTaskSchedulersForDebugger()`. Esse método estático retorna uma matriz de todos os assinantes ativos <xref:System.Threading.Tasks.TaskScheduler> instâncias. Você pode usar `GetScheduledTasksForDebugger` em cada instância de Agendador para recuperar sua lista de tarefas agendadas.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Este Agendador não é capaz de gerar uma lista de tarefas em fila no momento.</exception>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Biblioteca de tarefas paralelas (TPL)</related>
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public int Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Id" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskScheduler.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Id { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Id : int" Usage="System.Threading.Tasks.TaskScheduler.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém a ID exclusiva para este <see cref="T:System.Threading.Tasks.TaskScheduler" />.</summary>
        <value>Retorna a ID exclusiva para este <see cref="T:System.Threading.Tasks.TaskScheduler" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obter mais informações, consulte <xref:System.Threading.Tasks.TaskScheduler>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Biblioteca de tarefas paralelas (TPL)</related>
      </Docs>
    </Member>
    <Member MemberName="MaximumConcurrencyLevel">
      <MemberSignature Language="C#" Value="public virtual int MaximumConcurrencyLevel { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaximumConcurrencyLevel" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskScheduler.MaximumConcurrencyLevel" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property MaximumConcurrencyLevel As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int MaximumConcurrencyLevel { int get(); };" />
      <MemberSignature Language="F#" Value="member this.MaximumConcurrencyLevel : int" Usage="System.Threading.Tasks.TaskScheduler.MaximumConcurrencyLevel" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indica o nível de simultaneidade máximo ao qual esse <see cref="T:System.Threading.Tasks.TaskScheduler" /> pode dar suporte.</summary>
        <value>Retorna um inteiro que representa o nível máximo de simultaneidade. O agendador padrão retorna <see cref="F:System.Int32.MaxValue" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obter mais informações, consulte <xref:System.Threading.Tasks.TaskScheduler>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Biblioteca de tarefas paralelas (TPL)</related>
      </Docs>
    </Member>
    <Member MemberName="QueueTask">
      <MemberSignature Language="C#" Value="protected internal abstract void QueueTask (System.Threading.Tasks.Task task);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void QueueTask(class System.Threading.Tasks.Task task) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.QueueTask(System.Threading.Tasks.Task)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; abstract void QueueTask(System::Threading::Tasks::Task ^ task);" />
      <MemberSignature Language="F#" Value="abstract member QueueTask : System.Threading.Tasks.Task -&gt; unit" Usage="taskScheduler.QueueTask task" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="task" Type="System.Threading.Tasks.Task" />
      </Parameters>
      <Docs>
        <param name="task">O <see cref="T:System.Threading.Tasks.Task" /> a ser enfileirado.</param>
        <summary>Enfileira um <see cref="T:System.Threading.Tasks.Task" /> no agendador.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uma classe derivada de <xref:System.Threading.Tasks.TaskScheduler> implementa esse método para aceitar que estão sendo agendadas no Agendador de tarefas.  
  
 Uma implementação típica seria armazenar a tarefa em uma estrutura de dados interno, que deve ser atendida por threads que seriam executar essas tarefas em algum momento no futuro.  
  
 Este método destina-se somente a ser chamado pelo .NET Framework e não deve ser chamado diretamente pela classe derivada. Isso é necessário para manter a consistência do sistema.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O argumento <paramref name="task" /> é nulo.</exception>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Biblioteca de tarefas paralelas (TPL)</related>
      </Docs>
    </Member>
    <Member MemberName="TryDequeue">
      <MemberSignature Language="C#" Value="protected internal virtual bool TryDequeue (System.Threading.Tasks.Task task);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance bool TryDequeue(class System.Threading.Tasks.Task task) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.TryDequeue(System.Threading.Tasks.Task)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual bool TryDequeue(System::Threading::Tasks::Task ^ task);" />
      <MemberSignature Language="F#" Value="abstract member TryDequeue : System.Threading.Tasks.Task -&gt; bool&#xA;override this.TryDequeue : System.Threading.Tasks.Task -&gt; bool" Usage="taskScheduler.TryDequeue task" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="task" Type="System.Threading.Tasks.Task" />
      </Parameters>
      <Docs>
        <param name="task">O <see cref="T:System.Threading.Tasks.Task" /> a ser removido da fila.</param>
        <summary>Tenta remover da fila um <see cref="T:System.Threading.Tasks.Task" /> que anteriormente havia sido enfileirado para esse agendador.</summary>
        <returns>Um Booliano indicando se o argumento <paramref name="task" /> foi retirado da fila com êxito.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obter mais informações, consulte <xref:System.Threading.Tasks.TaskScheduler>.  
  
 Esse método pode ser executada em um bloco finally; Portanto, ele deverá retornar mais depressa possível assim que qualquer recursos, como <xref:System.Threading.CancellationTokenRegistration> objetos podem ser descartados de maneira oportuna.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O argumento <paramref name="task" /> é nulo.</exception>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Biblioteca de tarefas paralelas (TPL)</related>
      </Docs>
    </Member>
    <Member MemberName="TryExecuteTask">
      <MemberSignature Language="C#" Value="protected bool TryExecuteTask (System.Threading.Tasks.Task task);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool TryExecuteTask(class System.Threading.Tasks.Task task) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.TryExecuteTask(System.Threading.Tasks.Task)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; bool TryExecuteTask(System::Threading::Tasks::Task ^ task);" />
      <MemberSignature Language="F#" Value="member this.TryExecuteTask : System.Threading.Tasks.Task -&gt; bool" Usage="taskScheduler.TryExecuteTask task" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="task" Type="System.Threading.Tasks.Task" />
      </Parameters>
      <Docs>
        <param name="task">Um objeto <see cref="T:System.Threading.Tasks.Task" /> a ser executado.</param>
        <summary>Tenta executar o <see cref="T:System.Threading.Tasks.Task" /> fornecido neste agendador.</summary>
        <returns>Um booliano que será true se <paramref name="task" /> tiver sido executado com êxito, false se não tiver sido executado com êxito. Uma razão comum para a falha de execução é que a tarefa havia sido executada anteriormente ou ela está sendo executado por outro thread.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Implementações do Agendador são fornecidas com o <xref:System.Threading.Tasks.Task> instâncias a ser executado por meio de uma a <xref:System.Threading.Tasks.TaskScheduler.QueueTask%2A> método ou o <xref:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline%2A> método. Quando o Agendador considera apropriado para executar a tarefa fornecida, <xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A> deve ser usado para fazer isso. TryExecuteTask lida com todos os aspectos da execução de uma tarefa, incluindo a invocação de ação, tratamento de exceções, gerenciamento de estado e controle de ciclo de vida.  
  
 <xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A> deve ser usado somente para as tarefas fornecidas para esse Agendador pela infraestrutura do .NET Framework. Ele não deve ser usado para executar tarefas arbitrárias obtidas por meio de mecanismos personalizados.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">O <paramref name="task" /> não está associado a este agendador.</exception>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Biblioteca de tarefas paralelas (TPL)</related>
      </Docs>
    </Member>
    <Member MemberName="TryExecuteTaskInline">
      <MemberSignature Language="C#" Value="protected abstract bool TryExecuteTaskInline (System.Threading.Tasks.Task task, bool taskWasPreviouslyQueued);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool TryExecuteTaskInline(class System.Threading.Tasks.Task task, bool taskWasPreviouslyQueued) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool TryExecuteTaskInline(System::Threading::Tasks::Task ^ task, bool taskWasPreviouslyQueued);" />
      <MemberSignature Language="F#" Value="abstract member TryExecuteTaskInline : System.Threading.Tasks.Task * bool -&gt; bool" Usage="taskScheduler.TryExecuteTaskInline (task, taskWasPreviouslyQueued)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="task" Type="System.Threading.Tasks.Task" />
        <Parameter Name="taskWasPreviouslyQueued" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="task">O <see cref="T:System.Threading.Tasks.Task" /> a ser executado.</param>
        <param name="taskWasPreviouslyQueued">Um booliano que indica se a tarefa foi colocada na fila anteriormente. Se esse parâmetro for True, talvez a tarefa tenha sido colocada na fila anteriormente (agendada); se for False, será indicado que a tarefa não foi colocada na fila e essa chamada está sendo feita para executar a tarefa embutida sem colocá-la na fila.</param>
        <summary>Determina se o <see cref="T:System.Threading.Tasks.Task" /> fornecido pode ser executado de forma síncrona nessa chamada e, se for possível, o executa.</summary>
        <returns>Um valor booliano que indica se a tarefa foi executada embutida.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uma classe derivada de <xref:System.Threading.Tasks.TaskScheduler> implementa essa função para dar suporte à execução embutida de uma tarefa em um thread que inicia uma espera nesse objeto de tarefa. Execução embutida é opcional, e a solicitação pode ser rejeitada, retornando false. No entanto, as tarefas mais que pode ser embutida, melhor o Agendador será dimensionado. Na verdade, um agendador que inlines muito pouco pode ser propensa a deadlocks. Uma implementação apropriada deve garantir que uma solicitação em execução sob as diretivas garantidas pelo Agendador com êxito pode embutir. Por exemplo, se um agendador usa um thread dedicado para executar tarefas, as solicitações de inlining desse thread devem ter êxito.  
  
 Se decidir um agendador realizar a execução embutida, ele deve fazer isso chamando o TaskScheduler base <xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A> método com o objeto de tarefa fornecido, propagando o valor de retorno. Também pode ser apropriado para o Agendador remover uma tarefa embutida de suas estruturas de dados interna se decidir aceitar o pedido de inlining. No entanto, observe que em algumas circunstâncias um agendador poderá ser solicitado para embutir uma tarefa que anteriormente não foi fornecida a ele com o <xref:System.Threading.Tasks.TaskScheduler.QueueTask%2A> método.  
  
 O Agendador derivado é responsável por certificar-se de que o thread de chamada é adequado para executar a tarefa específica no seu próprio agendamento e com a preocupação de políticas de execução.  
  
 Para obter mais informações, consulte <xref:System.Threading.Tasks.TaskScheduler>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O argumento <paramref name="task" /> é nulo.</exception>
        <exception cref="T:System.InvalidOperationException">O <paramref name="task" /> já foi executado.</exception>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Biblioteca de tarefas paralelas (TPL)</related>
      </Docs>
    </Member>
    <Member MemberName="UnobservedTaskException">
      <MemberSignature Language="C#" Value="public static event EventHandler&lt;System.Threading.Tasks.UnobservedTaskExceptionEventArgs&gt; UnobservedTaskException;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Threading.Tasks.UnobservedTaskExceptionEventArgs&gt; UnobservedTaskException" />
      <MemberSignature Language="DocId" Value="E:System.Threading.Tasks.TaskScheduler.UnobservedTaskException" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event UnobservedTaskException As EventHandler(Of UnobservedTaskExceptionEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler&lt;System::Threading::Tasks::UnobservedTaskExceptionEventArgs ^&gt; ^ UnobservedTaskException;" />
      <MemberSignature Language="F#" Value="member this.UnobservedTaskException : EventHandler&lt;System.Threading.Tasks.UnobservedTaskExceptionEventArgs&gt; " Usage="member this.UnobservedTaskException : System.EventHandler&lt;System.Threading.Tasks.UnobservedTaskExceptionEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Threading.Tasks.UnobservedTaskExceptionEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre quando a exceção não observada da tarefa com falha está prestes a disparar a política de escalonamento de exceção, que, por padrão, encerrará o processo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse evento de todo o domínio de aplicativo fornece um mecanismo para impedir que a diretiva de escalonamento de exceção (que, por padrão, encerra o processo) de disparo.  
  
 Para tornar mais fácil para os desenvolvedores a escrever código assíncrono com base em tarefas, o [!INCLUDE[net_v45](~/includes/net-v45-md.md)] altera o comportamento de exceção padrão para exceções não observadas que. Embora geram exceções não observadas que ainda o <xref:System.Threading.Tasks.TaskScheduler.UnobservedTaskException> exceção, o processo não encerra por padrão. Em vez disso, a exceção é manipulada pelo tempo de execução depois que o evento é acionado, independentemente se um manipulador de eventos observa a exceção. Esse comportamento pode ser configurado. Começando com o [!INCLUDE[net_v45](~/includes/net-v45-md.md)], você pode usar o elemento de configuração para reverter para o comportamento do [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] e encerrar o processo:  
  
```xml  
<configuration>   
   <runtime>   
      <ThrowUnobservedTaskExceptions enabled="true"/>   
   </runtime>   
</configuration>  
  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Biblioteca de tarefas paralelas (TPL)</related>
        <related type="Article" href="~/docs/framework/configure-apps/file-schema/runtime/throwunobservedtaskexceptions-element.md">&lt;ThrowUnobservedTaskExceptions&gt; elemento</related>
      </Docs>
    </Member>
  </Members>
</Type>