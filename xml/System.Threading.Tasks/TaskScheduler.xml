<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="TaskScheduler.xml" source-language="en-US" target-language="pt-BR">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5ddd94061f594e353cba8674c76ffcb77a643ddb1.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ddd94061f594e353cba8674c76ffcb77a643ddb1</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>Represents an object that handles the low-level work of queuing tasks onto threads.</source>
          <target state="translated">Representa um objeto que manipula o trabalho de nível baixo de enfileirar tarefas em threads.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>An instance of the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler&gt;</ph> class represents a task scheduler.</source>
          <target state="translated">Uma instância do <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler&gt;</ph> classe representa um agendador de tarefas.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>A task scheduler ensures that the work of a task is eventually executed.</source>
          <target state="translated">Um agendador de tarefas garante que o trabalho de uma tarefa é executado eventualmente.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>The default task scheduler is based on the .NET Framework 4 thread pool, which provides work-stealing for load-balancing, thread injection/retirement for maximum throughput, and overall good performance.</source>
          <target state="translated">O Agendador de tarefas padrão baseia-se no pool de threads do .NET Framework 4, que fornece o roubo de trabalho para o balanceamento de carga, injeção de thread/desativação para taxa de transferência máxima e geral bom desempenho.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>It should be sufficient for most scenarios.</source>
          <target state="translated">Ele deve ser suficiente para a maioria dos cenários.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler&gt;</ph> class also serves as the extension point for all customizable scheduling logic.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler&gt;</ph> classe também serve como o ponto de extensão para toda a lógica de programação personalizável.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>This includes mechanisms such as how to schedule a task for execution, and how scheduled tasks should be exposed to debuggers.</source>
          <target state="translated">Isso inclui mecanismos como como agendar uma tarefa para execução e tarefas agendadas como deve ser exposto aos depuradores.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>If you require special functionality, you can create a custom scheduler and enable it for specific tasks or queries.</source>
          <target state="translated">Se você precisar de uma funcionalidade especial, você pode criar um agendador personalizado e habilitá-la para tarefas específicas ou consultas.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>In this topic:</source>
          <target state="translated">Neste tópico:</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source><bpt id="p1">[</bpt>The default task scheduler and the thread pool<ept id="p1">](#Default)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>O Agendador de tarefas padrão e o pool de threads<ept id="p1">](#Default)</ept></target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source><bpt id="p1">[</bpt>The global queue vs. local queues<ept id="p1">](#Queues)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>A fila global versus filas locais<ept id="p1">](#Queues)</ept></target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source><bpt id="p1">[</bpt>Work stealing<ept id="p1">](#Stealing)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Roubo de trabalho<ept id="p1">](#Stealing)</ept></target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source><bpt id="p1">[</bpt>Long-running tasks<ept id="p1">](#LongRunning)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Tarefas de longa execução<ept id="p1">](#LongRunning)</ept></target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source><bpt id="p1">[</bpt>Task inlining<ept id="p1">](#Inlining)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Tarefa inlining<ept id="p1">](#Inlining)</ept></target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source><bpt id="p1">[</bpt>Specifying a synchronization context<ept id="p1">](#Sync)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Especificar um contexto de sincronização<ept id="p1">](#Sync)</ept></target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>The default task scheduler and the thread pool</source>
          <target state="translated">O Agendador de tarefas padrão e o pool de threads</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>The default scheduler for the Task Parallel Library and PLINQ uses the .NET Framework thread pool, which is represented by the <ph id="ph1">&lt;xref:System.Threading.ThreadPool&gt;</ph> class, to queue and execute work.</source>
          <target state="translated">O agendador padrão para a biblioteca de tarefas paralelas e em PLINQ usa o pool de threads do .NET Framework, que é representado pela <ph id="ph1">&lt;xref:System.Threading.ThreadPool&gt;</ph> classe, fila e executar o trabalho.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>The thread pool uses the information that is provided by the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> type to efficiently     support the fine-grained parallelism (short-lived units of work) that parallel tasks and queries often represent.</source>
          <target state="translated">O pool de threads usa as informações fornecidas pelo <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> tipo eficiente suporte o paralelismo refinado (unidades de curta duração do trabalho) que paralelo de consultas e tarefas geralmente representam.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>The global queue vs. local queues</source>
          <target state="translated">A fila global versus filas locais</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>The thread pool maintains a global FIFO (first-in, first-out) work queue for threads in each application domain.</source>
          <target state="translated">O pool de threads mantém a fila de threads em cada domínio de aplicativo de trabalho de um global PEPS (primeiro a entrar, primeiro a sair).</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>Whenever a program calls the <ph id="ph1">&lt;xref:System.Threading.ThreadPool.QueueUserWorkItem%2A?displayProperty=nameWithType&gt;</ph> (or <ph id="ph2">&lt;xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A?displayProperty=nameWithType&gt;</ph>) method, the work is put on this shared queue and eventually de-queued onto the next thread that becomes available.</source>
          <target state="translated">Sempre que um programa chama o <ph id="ph1">&lt;xref:System.Threading.ThreadPool.QueueUserWorkItem%2A?displayProperty=nameWithType&gt;</ph> (ou <ph id="ph2">&lt;xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A?displayProperty=nameWithType&gt;</ph>) método, o trabalho é colocado nessa fila compartilhada e eventualmente retirados da fila para o próximo segmento que fica disponível.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>Starting with the .NET Framework 4, this queue has been improved to use a lock-free algorithm that resembles the <ph id="ph1">&lt;xref:System.Collections.Concurrent.ConcurrentQueue%601&gt;</ph> class.</source>
          <target state="translated">Começando com o .NET Framework 4, essa fila foi aprimorada para usar um algoritmo sem bloqueio que é semelhante a <ph id="ph1">&lt;xref:System.Collections.Concurrent.ConcurrentQueue%601&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>By using this lock-free implementation, the thread pool spends less time when it queues and de-queues work items.</source>
          <target state="translated">Usando essa implementação sem bloqueio, o pool de threads gasta menos tempo quando as filas e filas de itens de trabalho.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>This performance benefit is available to all programs that use the thread pool.</source>
          <target state="translated">Esse benefício de desempenho está disponível para todos os programas que usam o pool de threads.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>Top-level tasks, which are tasks that are not created in the context of another task, are put on the global queue just like any other work item.</source>
          <target state="translated">Tarefas de nível superior, que são tarefas que não são criadas no contexto de outra tarefa, são colocadas na fila assim como qualquer outro item de trabalho global.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>However, nested or child tasks, which are created in the context of another task, are handled quite differently.</source>
          <target state="translated">No entanto, aninhados ou tarefas filho, que são criadas no contexto de outra tarefa, são tratadas de forma muito diferente.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>A child or nested task is put on a local queue that is specific to the thread on which the parent task is executing.</source>
          <target state="translated">Um filho ou uma tarefa aninhada é colocada em uma fila local que é específica para o thread em que a tarefa pai está em execução.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>The parent task may be a top-level task or it also may be the child of another task.</source>
          <target state="translated">A tarefa pai pode ser uma tarefa de nível superior ou também pode ser o filho de outra tarefa.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>When this thread is ready for more work, it first looks in the local queue.</source>
          <target state="translated">Quando esse thread está pronto para mais trabalho, primeiro procura na fila local.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>If work items are waiting there, they can be accessed quickly.</source>
          <target state="translated">Se os itens de trabalho estiver esperando existe, eles podem ser acessados rapidamente.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>The local queues are accessed in last-in, first-out order (LIFO) to preserve cache locality and reduce contention.</source>
          <target state="translated">As filas locais são acessadas na ordem último a entrar, primeiro a sair (UEPS) para preservar a localidade do cache e reduzir a contenção.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>For more information about child tasks and nested tasks, see <bpt id="p1">[</bpt>Attached and Detached Child Tasks<ept id="p1">](~/docs/standard/parallel-programming/attached-and-detached-child-tasks.md)</ept>.</source>
          <target state="translated">Para obter mais informações sobre tarefas filho e tarefas aninhadas, consulte <bpt id="p1">[</bpt>anexadas e desanexadas tarefas de filho<ept id="p1">](~/docs/standard/parallel-programming/attached-and-detached-child-tasks.md)</ept>.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>The use of local queues not only reduces pressure on the global queue, but also takes advantage of data locality.</source>
          <target state="translated">O uso de filas locais não só reduz a pressão sobre a fila global, mas também aproveita localidade dos dados.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>Work items in the local queue frequently reference data structures that are physically near one another in memory.</source>
          <target state="translated">Itens de trabalho no local da fila com frequência as estruturas de dados de referência que estão fisicamente próximos uns dos outros na memória.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>In these cases, the data is already in the cache after the first task has run and can be accessed quickly.</source>
          <target state="translated">Nesses casos, os dados já estão em cache após a primeira tarefa foi executada e pode ser acessada rapidamente.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>Both <bpt id="p1">[</bpt>Parallel LINQ (PLINQ)<ept id="p1">](~/docs/standard/parallel-programming/parallel-linq-plinq.md)</ept> and the <ph id="ph1">&lt;xref:System.Threading.Tasks.Parallel&gt;</ph> class use nested tasks and child tasks extensively, and achieve significant speedups by using the local work queues.</source>
          <target state="translated">Ambos <bpt id="p1">[</bpt>LINQ paralelo (PLINQ)<ept id="p1">](~/docs/standard/parallel-programming/parallel-linq-plinq.md)</ept> e <ph id="ph1">&lt;xref:System.Threading.Tasks.Parallel&gt;</ph> classe use aninhado tarefas e tarefas filho extensivamente e obter aumentos de velocidade significativos usando as filas de trabalho local.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>Work stealing</source>
          <target state="translated">Roubo de trabalho</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>Starting with the .NET Framework 4, the thread pool also features a work-stealing algorithm to help make sure that no threads are sitting idle while others still have work in their queues.</source>
          <target state="translated">Começando com o .NET Framework 4, o pool de threads também apresenta um algoritmo de roubo de trabalho para certificar-se de que nenhum thread está usando ocioso enquanto outros ainda têm trabalham em suas filas.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>When a thread-pool thread is ready for more work, it first looks at the head of its local queue, then in the global queue, and then in the local queues of other threads.</source>
          <target state="translated">Quando um thread do pool de threads está pronto para mais de trabalho, primeiro procura no início da sua fila local, em seguida, na fila de global e nas filas de local de outros threads.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>If it finds a work item in the local queue of another thread, it first applies heuristics to make sure that it can run the work efficiently.</source>
          <target state="translated">Se ele encontrar um item de trabalho na fila de local de outro thread, ele primeiro se aplica a heurística para certificar-se de que ele pode executar o trabalho com eficiência.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>If it can, it de-queues the work item from the tail (in FIFO order).</source>
          <target state="translated">Se for possível, ele eliminação enfileira o item de trabalho do fim (na ordem de PEPS).</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>This reduces contention on each local queue and preserves data locality.</source>
          <target state="translated">Isso reduz a contenção em cada fila local e preserva a localidade dos dados.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>This architecture helps the  thread pool load-balance work more efficiently than past versions did.</source>
          <target state="translated">Essa arquitetura ajuda o balanceamento de carga do pool thread trabalhem com mais eficiência do que as versões anteriores.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>Long-running tasks</source>
          <target state="translated">Tarefas de longa execução</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>You may want to explicitly prevent a task from being put on a local queue.</source>
          <target state="translated">Você talvez queira impedir explicitamente uma tarefa que está sendo colocada em uma fila local.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>For example, you may know that a particular work item will run for a relatively long time and is likely to block all other work items on the local queue.</source>
          <target state="translated">Por exemplo, você pode saber o que um determinado item de trabalho será executado por um tempo relativamente longo e é provável que bloqueie todos os outros itens de trabalho na fila local.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>In this case, you can specify the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskCreationOptions?displayProperty=nameWithType&gt;</ph> option, which provides a hint to the scheduler that an additional thread might be required for the task so that it does not block the forward progress of other threads or work items on the local queue.</source>
          <target state="translated">Nesse caso, você pode especificar o <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskCreationOptions?displayProperty=nameWithType&gt;</ph> opção, que fornece uma dica para o Agendador que um thread adicional pode ser necessário para a tarefa para que ele não bloqueia o progresso de outros threads ou itens de trabalho na fila local.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>By using this option you avoid the thread pool completely, including the global and local queues.</source>
          <target state="translated">Usando essa opção é evita o pool de threads completamente, incluindo as filas globais e locais.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>Task inlining</source>
          <target state="translated">Tarefa inlining</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>In some cases when a <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> is waited on, it may be executed synchronously on the thread that is performing the wait operation.</source>
          <target state="translated">Em alguns casos, quando um <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> esperou, pode ser executado em modo síncrono no thread que está executando a operação de espera.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>This enhances performance by preventing the need for an additional thread and instead using the existing thread, which would have blocked otherwise.</source>
          <target state="translated">Isso melhora o desempenho, evitando a necessidade de um thread adicional e em vez de usar o segmento existente, o que poderia ter bloqueado caso contrário.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>To prevent errors due to re-entrancy, task inlining only occurs when the wait target is found in the relevant thread's local queue.</source>
          <target state="translated">Para evitar erros devido a reentrada, tarefa inlining só ocorre quando o destino de espera é encontrado na fila local do thread relevantes.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>Specifying a synchronization context</source>
          <target state="translated">Especificar um contexto de sincronização</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>You can use the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext%2A?displayProperty=nameWithType&gt;</ph> method to specify that a task should be scheduled to run on a particular thread.</source>
          <target state="translated">Você pode usar o <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext%2A?displayProperty=nameWithType&gt;</ph> método para especificar que uma tarefa deve ser agendada para execução em um thread específico.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>This is useful in frameworks such as Windows Forms and Windows Presentation Foundation where access to user interface objects is often restricted to code that is running on the same thread on which the UI object was created.</source>
          <target state="translated">Isso é útil em estruturas, como formulários do Windows e Windows Presentation Foundation onde o acesso aos objetos de interface do usuário geralmente é restrito ao código que está sendo executado no mesmo thread no qual o objeto de interface do usuário foi criado.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext%2A?displayProperty=nameWithType&gt;</ph> method in a Windows Presentation Foundation (WPF) app to schedule a task on the same thread that the user interface (UI) control was created on.</source>
          <target state="translated">O exemplo a seguir usa o <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext%2A?displayProperty=nameWithType&gt;</ph> método em um aplicativo do Windows Presentation Foundation (WPF) para agendar uma tarefa no mesmo thread em que o controle de interface do usuário foi criado.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>The example creates a mosaic of images that are randomly selected from a specified directory.</source>
          <target state="translated">O exemplo cria um mosaico de imagens que são selecionadas aleatoriamente de um diretório especificado.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>The WPF objects are used to load and resize the images.</source>
          <target state="translated">Os objetos do WPF são usados para carregar e redimensionar as imagens.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>The raw pixels are then passed to a task that uses a <ph id="ph1">&lt;xref:System.Threading.Tasks.Parallel.For%2A&gt;</ph> loop to write the pixel data into a large single-byte array.</source>
          <target state="translated">Os pixels brutos são passados para uma tarefa que usa um <ph id="ph1">&lt;xref:System.Threading.Tasks.Parallel.For%2A&gt;</ph> loop para gravar os dados de pixel em uma grande matriz de byte único.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>No synchronization is required because no two tiles occupy the same array elements.</source>
          <target state="translated">Nenhuma sincronização é necessária porque não há dois blocos ocupam os mesmos elementos de matriz.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>The tiles can also be written in any order because their position is calculated independently of any other tile.</source>
          <target state="translated">Os blocos também podem ser gravados em qualquer ordem, porque sua posição é calculada independentemente de qualquer outro bloco.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>The large array is then passed to a task that runs on the UI thread, where the pixel data is loaded into an Image control.</source>
          <target state="translated">A matriz grande é então passada para uma tarefa executada no thread da interface do usuário, onde os dados de pixel são carregados em um controle de imagem.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>The example moves data off the UI thread, modifies it by using parallel loops and <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> objects, and then passes it back to a task that runs on the UI thread.</source>
          <target state="translated">O exemplo move os dados do thread de interface do usuário, modifica-lo com o uso de loops paralelos e <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> objetos e, em seguida, passa-lo de volta para uma tarefa executada no thread da interface do usuário.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>This approach is useful when you have to use the Task Parallel Library to perform operations that either are not supported by the WPF API, or are not sufficiently fast.</source>
          <target state="translated">Essa abordagem é útil quando você precisa usar a biblioteca paralela de tarefas para executar operações que não são suportadas pela API do WPF, ou que não forem suficientemente rápidos.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>Another way to create an image mosaic in WPF is to use a <ph id="ph1">&lt;xref:System.Windows.Controls.WrapPanel?displayProperty=nameWithType&gt;</ph> control and add images to it.</source>
          <target state="translated">Outra maneira de criar um mosaico de imagem no WPF é usar um <ph id="ph1">&lt;xref:System.Windows.Controls.WrapPanel?displayProperty=nameWithType&gt;</ph> controlar e adicionar imagens a ele.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>The <ph id="ph1">&lt;xref:System.Windows.Controls.WrapPanel&gt;</ph> handles the work of positioning the tiles.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Windows.Controls.WrapPanel&gt;</ph> manipula o trabalho de posicionamento de blocos.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>However, this work can only be performed on the UI thread.</source>
          <target state="translated">No entanto, esse trabalho só pode ser executado no thread da interface do usuário.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>To create the example, create a WPF application project in Visual Studio and assign it a name of your choice.</source>
          <target state="translated">Para criar o exemplo, crie um projeto de aplicativo do WPF no Visual Studio e atribuir um nome de sua escolha.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>Then do the following:</source>
          <target state="translated">Em seguida, faça o seguinte:</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>In design view, drag an <ph id="ph1">&lt;xref:System.Windows.Controls.Image&gt;</ph> control from the <bpt id="p1">**</bpt>Toolbox<ept id="p1">**</ept> to the design surface.</source>
          <target state="translated">No modo de design, arraste um <ph id="ph1">&lt;xref:System.Windows.Controls.Image&gt;</ph> controlar do <bpt id="p1">**</bpt>caixa de ferramentas<ept id="p1">**</ept> à superfície de design.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>In XAML view, specify the horizontal alignment as "Left."</source>
          <target state="translated">No modo de exibição XAML, especifique o alinhamento horizontal como "Esquerda".</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>The size does not matter because the control is be dynamically resized at run time.</source>
          <target state="translated">O tamanho não é importante porque o controle é redimensionado dinamicamente em tempo de execução.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>Accept the default name, "image".</source>
          <target state="translated">Aceite o nome padrão, "imagem".</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>Drag a <ph id="ph1">&lt;xref:System.Windows.Controls.Button&gt;</ph> control from the <bpt id="p1">**</bpt>Toolbox<ept id="p1">**</ept> to the lower left part of the application window.</source>
          <target state="translated">Arraste um <ph id="ph1">&lt;xref:System.Windows.Controls.Button&gt;</ph> controlar do <bpt id="p1">**</bpt>caixa de ferramentas<ept id="p1">**</ept> para a parte inferior esquerda da janela do aplicativo.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>Double-click the button to add a <ph id="ph1">&lt;xref:System.Windows.Controls.Primitives.ButtonBase.Click&gt;</ph> event handler.</source>
          <target state="translated">Clique duas vezes no botão para adicionar um <ph id="ph1">&lt;xref:System.Windows.Controls.Primitives.ButtonBase.Click&gt;</ph> manipulador de eventos.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>In XAML view, specify the <ph id="ph1">&lt;xref:System.Windows.Controls.ContentControl.Content%2A&gt;</ph> property of the button as "Make a Mosaic" and specify its horizontal alignment as "Left".</source>
          <target state="translated">No modo de exibição XAML, especifique o <ph id="ph1">&lt;xref:System.Windows.Controls.ContentControl.Content%2A&gt;</ph> propriedade do botão como "Fazer um mosaico" e especifique o alinhamento horizontal como "Esquerda".</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>Accept the default name, "button".</source>
          <target state="translated">Aceite o nome padrão, "button".</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>Replace the entire contents of the MainWindow.xaml.cs or MainWindow.xaml.vb file with the code from this example.</source>
          <target state="translated">Substitua todo o conteúdo do arquivo MainWindow.xaml.cs ou MainWindow.xaml.vb com o código deste exemplo.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>Make sure that the name of the workspace matches the project name.</source>
          <target state="translated">Certifique-se de que o nome do espaço de trabalho corresponde ao nome do projeto.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>The example reads JPEG images from a directory named C:\Users\Public\Pictures\Sample Pictures<ph id="ph1">\\</ph>.</source>
          <target state="translated">O exemplo lê as imagens JPEG de um diretório chamado C:\Users\Public\Pictures\Sample imagens<ph id="ph1">\\</ph>.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>Either create the directory and place some images in it, or change the path to refer to some other directory that contains images.</source>
          <target state="translated">Crie o diretório e colocar algumas imagens nele ou altere o caminho para fazer referência a outro diretório que contém imagens.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>This example has some limitations.</source>
          <target state="translated">Este exemplo tem algumas limitações.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>For example, only 32-bits-per-pixel images are supported; images in other formats are corrupted by the <ph id="ph1">&lt;xref:System.Windows.Media.Imaging.BitmapImage&gt;</ph> object during the resizing operation.</source>
          <target state="translated">Por exemplo, há suporte para apenas 32-bits-por pixel imagens; imagens em outros formatos são corrompidas pelo <ph id="ph1">&lt;xref:System.Windows.Media.Imaging.BitmapImage&gt;</ph> objeto durante a operação de redimensionamento.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>Also, the source images must all be larger than the tile size.</source>
          <target state="translated">Além disso, as imagens de origem devem todas ser maiores que o tamanho do bloco.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>As a further exercise, you can add functionality to handle multiple pixel formats and file sizes.</source>
          <target state="translated">Como um exercício adicional, você pode adicionar funcionalidade para lidar com vários formatos de pixel e tamanhos de arquivos.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>The following example is taken from the <bpt id="p1">[</bpt>Samples for Parallel Programming with the .NET Framework 4<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=165717)</ept> on the MSDN Code Gallery Web site.</source>
          <target state="translated">O exemplo a seguir é obtido a <bpt id="p1">[</bpt>exemplos de programação paralela com o .NET Framework 4<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=165717)</ept> no site da Web de galeria de código do MSDN.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>It creates a custom task scheduler that limits the number of threads used by the app.</source>
          <target state="translated">Ele cria um agendador de tarefas personalizada que limita o número de threads usados pelo aplicativo.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>It then launches two sets of tasks and displays information about the task and the thread on which the task is executing.</source>
          <target state="translated">Em seguida, ele inicia dois conjuntos de tarefas e exibe informações sobre a tarefa e o thread em que a tarefa está em execução.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>In addition, several sample task schedulers are available on Code Gallery: <bpt id="p1">[</bpt>Samples for Parallel Programming with the .NET Framework 4<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=165717)</ept>.</source>
          <target state="translated">Além disso, vários agendadores de tarefa de exemplo estão disponíveis na Galeria de códigos: <bpt id="p1">[</bpt>exemplos de programação paralela com o .NET Framework 4<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=165717)</ept>.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>All members of the abstract <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph> type are thread-safe and may be used from multiple threads concurrently.</source>
          <target state="translated">Todos os membros do resumo <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph> tipo são thread-safe e podem ser usados em vários threads ao mesmo tempo.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.TaskScheduler.#ctor">
          <source>Initializes the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph>.</source>
          <target state="translated">Inicializa o <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" uid="P:System.Threading.Tasks.TaskScheduler.Current">
          <source>Gets the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph> associated with the currently executing task.</source>
          <target state="translated">Obtém o <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph> associado à tarefa em execução no momento.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.TaskScheduler.Current">
          <source>Returns the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph> associated with the currently executing task.</source>
          <target state="translated">Retorna o <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph> associado à tarefa em execução no momento.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.TaskScheduler.Current">
          <source>When not called from within a task, <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler.Current%2A&gt;</ph> will return the <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskScheduler.Default%2A&gt;</ph> scheduler.</source>
          <target state="translated">Quando chamado de uma tarefa não <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler.Current%2A&gt;</ph> retornará o <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskScheduler.Default%2A&gt;</ph> Agendador.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.TaskScheduler.Current">
          <source>For more information, see <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler&gt;</ph>.</source>
          <target state="translated">Para obter mais informações, consulte <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" uid="P:System.Threading.Tasks.TaskScheduler.Default">
          <source>Gets the default <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph> instance that is provided by the .NET Framework.</source>
          <target state="translated">Obtém a instância <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph> padrão, fornecida pelo .NET Framework.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.TaskScheduler.Default">
          <source>Returns the default <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph> instance.</source>
          <target state="translated">Retorna a instância padrão <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.TaskScheduler.Default">
          <source>For more information, see <bpt id="p1">[</bpt>Task Schedulers<ept id="p1">](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>agendadores de tarefa<ept id="p1">](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65)</ept>.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext">
          <source>Creates a <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph> associated with the current <ph id="ph2">&lt;see cref="T:System.Threading.SynchronizationContext" /&gt;</ph>.</source>
          <target state="translated">Cria um <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph> associado ao <ph id="ph2">&lt;see cref="T:System.Threading.SynchronizationContext" /&gt;</ph> atual.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext">
          <source>A <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph> associated with the current <ph id="ph2">&lt;see cref="T:System.Threading.SynchronizationContext" /&gt;</ph>, as determined by <ph id="ph3">&lt;see cref="P:System.Threading.SynchronizationContext.Current" /&gt;</ph>.</source>
          <target state="translated">Um <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph> associado ao <ph id="ph2">&lt;see cref="T:System.Threading.SynchronizationContext" /&gt;</ph> atual, conforme determinado por <ph id="ph3">&lt;see cref="P:System.Threading.SynchronizationContext.Current" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext">
          <source>All <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> instances queued to the returned scheduler will be executed through a call to the <ph id="ph2">&lt;xref:System.Threading.SynchronizationContext.Post%2A&gt;</ph> method on that context.</source>
          <target state="translated">Todos os <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> instâncias na fila para retornado Agendador será executado por meio de uma chamada para o <ph id="ph2">&lt;xref:System.Threading.SynchronizationContext.Post%2A&gt;</ph> método nesse contexto.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext">
          <source>For more information, see <bpt id="p1">[</bpt>Task Schedulers<ept id="p1">](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>agendadores de tarefa<ept id="p1">](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65)</ept>.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext">
          <source>The current SynchronizationContext may not be used as a TaskScheduler.</source>
          <target state="translated">O SynchronizationContext atual não pode ser usado como um TaskScheduler.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.TaskScheduler.GetScheduledTasks">
          <source>For debugger support only, generates an enumerable of <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> instances currently queued to the scheduler waiting to be executed.</source>
          <target state="translated">Apenas para o suporte do depurador, gera um enumerável de instâncias <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> atualmente na fila do Agendador aguardando ser executado.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.TaskScheduler.GetScheduledTasks">
          <source>An enumerable that allows a debugger to traverse the tasks currently queued to this scheduler.</source>
          <target state="translated">Um enumerável que permite que um depurador percorra as tarefas atualmente na fila para este agendador.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.GetScheduledTasks">
          <source>A class derived from <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler&gt;</ph> implements this method in order to support integration with debuggers.</source>
          <target state="translated">Uma classe derivada de <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler&gt;</ph> implementa este método para dar suporte à integração com depuradores.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.GetScheduledTasks">
          <source>This method will only be invoked by the .NET Framework when the debugger requests access to the data.</source>
          <target state="translated">Esse método só será invocado pelo .NET Framework quando o depurador solicita acesso aos dados.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.GetScheduledTasks">
          <source>The enumerable returned will be traversed by debugging utilities to access the tasks currently queued to this scheduler, enabling the debugger to provide a representation of this information in the user interface.</source>
          <target state="translated">O enumerável retornado será desviada por utilitários para acessar as tarefas de depuração atualmente na fila para este Agendador, permitindo que o depurador fornecer uma representação dessas informações na interface do usuário.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.GetScheduledTasks">
          <source>It is important to note that, when this method is called, all other threads in the process will be frozen.</source>
          <target state="translated">É importante observar que, quando esse método é chamado, todos os outros threads no processo serão congelados.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.GetScheduledTasks">
          <source>Therefore, it's important to avoid synchronization with other threads that may lead to blocking.</source>
          <target state="translated">Portanto, é importante evitar a sincronização com outros threads que podem resultar em bloqueio.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.GetScheduledTasks">
          <source>If synchronization is necessary, and you are unable to acquire the lock in this method, then you should throw an exception so that the debugger does not hang.</source>
          <target state="translated">Se a sincronização é necessária, e não é possível adquirir o bloqueio nesse método, você deve lançar uma exceção para que o depurador não pare de responder.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.GetScheduledTasks">
          <source>The following example shows one possible approach in C#:</source>
          <target state="translated">O exemplo a seguir mostra uma abordagem possível em c#:</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.GetScheduledTasks">
          <source>Additionally, this method and the enumerable returned must not modify any globally visible state.</source>
          <target state="translated">Além disso, este método e o enumerável retornado não modifique qualquer estado global visível.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.GetScheduledTasks">
          <source>The returned enumerable should never be null.</source>
          <target state="translated">O retornado enumerável nunca deve ser nulo.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.GetScheduledTasks">
          <source>If there are currently no queued tasks, an empty enumerable should be returned instead.</source>
          <target state="translated">Se não houver nenhuma tarefa em fila no momento, um enumerável de vazio deve ser retornado.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.GetScheduledTasks">
          <source>Developers who are implementing custom debuggers shouldn't call this method directly, but should use the internal wrapper method <ph id="ph1">`GetScheduledTasksForDebugger`</ph> instead: <ph id="ph2">`internal Task[] GetScheduledTasksForDebugger()`</ph>.</source>
          <target state="translated">Os desenvolvedores que estiverem implementando depuradores personalizados não devem chamar este método diretamente, mas deve usar o método wrapper interna <ph id="ph1">`GetScheduledTasksForDebugger`</ph> em vez disso: <ph id="ph2">`internal Task[] GetScheduledTasksForDebugger()`</ph>.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.GetScheduledTasks">
          <source>This wrapper method returns an array of tasks instead of an enumerable.</source>
          <target state="translated">Esse método wrapper retorna uma matriz de tarefas em vez de um enumerável.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.GetScheduledTasks">
          <source>To retrieve a list of active schedulers, use the internal method <ph id="ph1">`internal static TaskScheduler[] GetTaskSchedulersForDebugger()`</ph>.</source>
          <target state="translated">Para recuperar uma lista de agendadores active, use o método interno <ph id="ph1">`internal static TaskScheduler[] GetTaskSchedulersForDebugger()`</ph>.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.GetScheduledTasks">
          <source>This static method returns an array of all active <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler&gt;</ph> instances.</source>
          <target state="translated">Esse método estático retorna uma matriz de todos os ativos <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler&gt;</ph> instâncias.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.GetScheduledTasks">
          <source>You can then use <ph id="ph1">`GetScheduledTasksForDebugger`</ph> on each scheduler instance to retrieve its list of scheduled tasks.</source>
          <target state="translated">Você pode usar <ph id="ph1">`GetScheduledTasksForDebugger`</ph> em cada instância de Agendador para recuperar a lista de tarefas agendadas.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.TaskScheduler.GetScheduledTasks">
          <source>This scheduler is unable to generate a list of queued tasks at this time.</source>
          <target state="translated">Este Agendador não é capaz de gerar uma lista de tarefas em fila no momento.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" uid="P:System.Threading.Tasks.TaskScheduler.Id">
          <source>Gets the unique ID for this <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph>.</source>
          <target state="translated">Obtém a ID exclusiva para este <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.TaskScheduler.Id">
          <source>Returns the unique ID for this <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph>.</source>
          <target state="translated">Retorna a ID exclusiva para este <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.TaskScheduler.Id">
          <source>For more information, see <bpt id="p1">[</bpt>Task Schedulers<ept id="p1">](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>agendadores de tarefa<ept id="p1">](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65)</ept>.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" uid="P:System.Threading.Tasks.TaskScheduler.MaximumConcurrencyLevel">
          <source>Indicates the maximum concurrency level this <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph> is able to support.</source>
          <target state="translated">Indica o nível de simultaneidade máximo ao qual esse <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph> pode dar suporte.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.TaskScheduler.MaximumConcurrencyLevel">
          <source>Returns an integer that represents the maximum concurrency level.</source>
          <target state="translated">Retorna um inteiro que representa o nível máximo de simultaneidade.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.TaskScheduler.MaximumConcurrencyLevel">
          <source>The default scheduler returns <ph id="ph1">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</source>
          <target state="translated">O agendador padrão retorna <ph id="ph1">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.TaskScheduler.MaximumConcurrencyLevel">
          <source>For more information, see <bpt id="p1">[</bpt>Task Schedulers<ept id="p1">](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>agendadores de tarefa<ept id="p1">](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65)</ept>.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.TaskScheduler.QueueTask(System.Threading.Tasks.Task)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> to be queued.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> a ser enfileirado.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.TaskScheduler.QueueTask(System.Threading.Tasks.Task)">
          <source>Queues a <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> to the scheduler.</source>
          <target state="translated">Enfileira um <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> no agendador.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.QueueTask(System.Threading.Tasks.Task)">
          <source>A class derived from <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler&gt;</ph> implements this method to accept tasks being scheduled on the scheduler.</source>
          <target state="translated">Uma classe derivada de <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler&gt;</ph> implementa este método para aceitar agendadas no Agendador de tarefas.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.QueueTask(System.Threading.Tasks.Task)">
          <source>A typical implementation would store the task in an internal data structure, which would be serviced by threads that would execute those tasks at some time in the future.</source>
          <target state="translated">Uma implementação típica seria armazenar a tarefa em uma estrutura de dados interno, que deve ser atendida por threads que deve executar essas tarefas em algum momento no futuro.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.QueueTask(System.Threading.Tasks.Task)">
          <source>This method is only meant to be called by the .NET Framework and should not be called directly by the derived class.</source>
          <target state="translated">Este método só deve ser chamado pelo .NET Framework e não deve ser chamado diretamente pela classe derivada.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.QueueTask(System.Threading.Tasks.Task)">
          <source>This is necessary for maintaining the consistency of the system.</source>
          <target state="translated">Isso é necessário para manter a consistência do sistema.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.TaskScheduler.QueueTask(System.Threading.Tasks.Task)">
          <source>The <ph id="ph1">&lt;paramref name="task" /&gt;</ph> argument is null.</source>
          <target state="translated">O argumento <ph id="ph1">&lt;paramref name="task" /&gt;</ph> é nulo.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.TaskScheduler.TryDequeue(System.Threading.Tasks.Task)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> to be dequeued.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> a ser removido da fila.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.TaskScheduler.TryDequeue(System.Threading.Tasks.Task)">
          <source>Attempts to dequeue a <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> that was previously queued to this scheduler.</source>
          <target state="translated">Tenta remover da fila um <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> que anteriormente havia sido enfileirado para esse agendador.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.TaskScheduler.TryDequeue(System.Threading.Tasks.Task)">
          <source>A Boolean denoting whether the <ph id="ph1">&lt;paramref name="task" /&gt;</ph> argument was successfully dequeued.</source>
          <target state="translated">Um Booliano indicando se o argumento <ph id="ph1">&lt;paramref name="task" /&gt;</ph> foi retirado da fila com êxito.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.TryDequeue(System.Threading.Tasks.Task)">
          <source>For more information, see <bpt id="p1">[</bpt>Task Schedulers<ept id="p1">](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>agendadores de tarefa<ept id="p1">](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65)</ept>.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.TryDequeue(System.Threading.Tasks.Task)">
          <source>This method may execute in a finally block; therefore it should return as quickly as possible so that any resources such as <ph id="ph1">&lt;xref:System.Threading.CancellationTokenRegistration&gt;</ph> objects can be disposed of in a timely manner.</source>
          <target state="translated">Esse método pode ser executada em um bloco finally; Portanto, ele deverá retornar assim que possível para que qualquer recursos como <ph id="ph1">&lt;xref:System.Threading.CancellationTokenRegistration&gt;</ph> objetos podem ser descartados de maneira oportuna.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.TaskScheduler.TryDequeue(System.Threading.Tasks.Task)">
          <source>The <ph id="ph1">&lt;paramref name="task" /&gt;</ph> argument is null.</source>
          <target state="translated">O argumento <ph id="ph1">&lt;paramref name="task" /&gt;</ph> é nulo.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.TaskScheduler.TryExecuteTask(System.Threading.Tasks.Task)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> object to be executed.</source>
          <target state="translated">Um objeto <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> a ser executado.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.TaskScheduler.TryExecuteTask(System.Threading.Tasks.Task)">
          <source>Attempts to execute the provided <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> on this scheduler.</source>
          <target state="translated">Tenta executar o <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> fornecido neste agendador.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.TaskScheduler.TryExecuteTask(System.Threading.Tasks.Task)">
          <source>A Boolean that is true if <ph id="ph1">&lt;paramref name="task" /&gt;</ph> was successfully executed, false if it was not.</source>
          <target state="translated">Um booliano que será true se <ph id="ph1">&lt;paramref name="task" /&gt;</ph> tiver sido executado com êxito, false se não tiver sido executado com êxito.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.TaskScheduler.TryExecuteTask(System.Threading.Tasks.Task)">
          <source>A common reason for execution failure is that the task had previously been executed or is in the process of being executed by another thread.</source>
          <target state="translated">Uma razão comum para a falha de execução é que a tarefa havia sido executada anteriormente ou ela está sendo executado por outro thread.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.TryExecuteTask(System.Threading.Tasks.Task)">
          <source>Scheduler implementations are provided with <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> instances to be executed through either the <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskScheduler.QueueTask%2A&gt;</ph> method or the <ph id="ph3">&lt;xref:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline%2A&gt;</ph> method.</source>
          <target state="translated">Implementações de Agendador são fornecidas com <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> instâncias a ser executado por meio de <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskScheduler.QueueTask%2A&gt;</ph> método ou o <ph id="ph3">&lt;xref:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.TryExecuteTask(System.Threading.Tasks.Task)">
          <source>When the scheduler deems it appropriate to run the provided task, <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A&gt;</ph> should be used to do so.</source>
          <target state="translated">Quando o Agendador considerar apropriado para executar a tarefa fornecida, <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A&gt;</ph> deve ser usado para fazer isso.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.TryExecuteTask(System.Threading.Tasks.Task)">
          <source>TryExecuteTask handles all aspects of executing a task, including action invocation, exception handling, state management, and lifecycle control.</source>
          <target state="translated">TryExecuteTask trata todos os aspectos da execução de uma tarefa, incluindo a invocação de ação, tratamento de exceções, gerenciamento de estado e controle de ciclo de vida.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.TryExecuteTask(System.Threading.Tasks.Task)">
          <source><ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A&gt;</ph> must only be used for tasks provided to this scheduler by the .NET Framework infrastructure.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A&gt;</ph> deve ser usado somente para as tarefas fornecidas a este agendador pela infraestrutura do .NET Framework.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.TryExecuteTask(System.Threading.Tasks.Task)">
          <source>It should not be used to execute arbitrary tasks obtained through custom mechanisms.</source>
          <target state="translated">Ele não deve ser usado para executar tarefas arbitrárias obtidas por meio de mecanismos personalizados.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.TaskScheduler.TryExecuteTask(System.Threading.Tasks.Task)">
          <source>The <ph id="ph1">&lt;paramref name="task" /&gt;</ph> is not associated with this scheduler.</source>
          <target state="translated">O <ph id="ph1">&lt;paramref name="task" /&gt;</ph> não está associado a este agendador.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> to be executed.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> a ser executado.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
          <source>A Boolean denoting whether or not task has previously been queued.</source>
          <target state="translated">Um booliano que indica se a tarefa foi colocada na fila anteriormente.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
          <source>If this parameter is True, then the task may have been previously queued (scheduled); if False, then the task is known not to have been queued, and this call is being made in order to execute the task inline without queuing it.</source>
          <target state="translated">Se esse parâmetro for True, talvez a tarefa tenha sido colocada na fila anteriormente (agendada); se for False, será indicado que a tarefa não foi colocada na fila e essa chamada está sendo feita para executar a tarefa embutida sem colocá-la na fila.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
          <source>Determines whether the provided <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> can be executed synchronously in this call, and if it can, executes it.</source>
          <target state="translated">Determina se o <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> fornecido pode ser executado de forma síncrona nessa chamada e, se for possível, o executa.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
          <source>A Boolean value indicating whether the task was executed inline.</source>
          <target state="translated">Um valor booliano que indica se a tarefa foi executada embutida.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
          <source>A class derived from <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler&gt;</ph> implements this function to support inline execution of a task on a thread that initiates a wait on that task object.</source>
          <target state="translated">Uma classe derivada de <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler&gt;</ph> implementa essa função para dar suporte a execução embutida de uma tarefa em um thread que inicia uma espera desse objeto de tarefa.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
          <source>Inline execution is optional, and the request may be rejected by returning false.</source>
          <target state="translated">Execução embutida é opcional, e a solicitação pode ser rejeitada retornando falso.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
          <source>However, the more tasks that can be inlined, the better the scheduler will scale.</source>
          <target state="translated">No entanto, as tarefas mais que pode ser embutido, melhor o Agendador será dimensionado.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
          <source>In fact, a scheduler that inlines too little may be prone to deadlocks.</source>
          <target state="translated">Na verdade, um agendador que linhas internas muito pouco podem ser propensa a deadlocks.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
          <source>A proper implementation should ensure that a request executing under the policies guaranteed by the scheduler can successfully inline.</source>
          <target state="translated">Uma implementação correta deve garantir que uma solicitação de execução sob as políticas de garantia pelo Agendador com êxito pode embutido.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
          <source>For example, if a scheduler uses a dedicated thread to execute tasks, any inlining requests from that thread should succeed.</source>
          <target state="translated">Por exemplo, se um agendador usa um thread dedicado para executar tarefas, todas as solicitações de thread inlining devem ser bem-sucedidos.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
          <source>If a scheduler decides to perform the inline execution, it should do so by calling to the base TaskScheduler's <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A&gt;</ph> method with the provided task object, propagating the return value.</source>
          <target state="translated">Se um agendador decide realizar a execução embutido, ele deve fazer isso por chamada para o TaskScheduler base <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A&gt;</ph> método com o objeto de tarefa fornecido, propagar o valor de retorno.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
          <source>It may also be appropriate for the scheduler to remove an inlined task from its internal data structures if it decides to honor the inlining request.</source>
          <target state="translated">Também pode ser apropriado para o Agendador remover uma tarefa embutida de suas estruturas de dados interna se decide consideram a solicitação de inlining.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
          <source>Note, however, that under some circumstances a scheduler may be asked to inline a task that was not previously provided to it with the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler.QueueTask%2A&gt;</ph> method.</source>
          <target state="translated">No entanto, observe que em algumas circunstâncias um agendador poderá ser solicitado a embutido uma tarefa que não foi fornecida anteriormente a ele com o <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler.QueueTask%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
          <source>The derived scheduler is responsible for making sure that the calling thread is suitable for executing the given task as far as its own scheduling and execution policies are concerned.</source>
          <target state="translated">O Agendador derivado é responsável por garantir que o thread de chamada é adequado para executar a tarefa específica do ponto de vista suas próprias agendas e se preocupam com as políticas de execução.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
          <source>For more information, see <bpt id="p1">[</bpt>Task Schedulers<ept id="p1">](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>agendadores de tarefa<ept id="p1">](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65)</ept>.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
          <source>The <ph id="ph1">&lt;paramref name="task" /&gt;</ph> argument is null.</source>
          <target state="translated">O argumento <ph id="ph1">&lt;paramref name="task" /&gt;</ph> é nulo.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
          <source>The <ph id="ph1">&lt;paramref name="task" /&gt;</ph> was already executed.</source>
          <target state="translated">O <ph id="ph1">&lt;paramref name="task" /&gt;</ph> já foi executado.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" uid="E:System.Threading.Tasks.TaskScheduler.UnobservedTaskException">
          <source>Occurs when a faulted task's unobserved exception is about to trigger exception escalation policy, which, by default, would terminate the process.</source>
          <target state="translated">Ocorre quando a exceção não observada da tarefa com falha está prestes a disparar a política de escalonamento de exceção, que, por padrão, encerrará o processo.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Threading.Tasks.TaskScheduler.UnobservedTaskException">
          <source>This application domain-wide event provides a mechanism to prevent exception escalation policy (which, by default, terminates the process) from triggering.</source>
          <target state="translated">Esse evento de todo o domínio de aplicativo fornece um mecanismo para impedir que a diretiva de escalonamento de exceção (que, por padrão, encerra o processo) de disparo.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Threading.Tasks.TaskScheduler.UnobservedTaskException">
          <source>To make it easier for developers to write asynchronous code based on tasks, the <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph> changes the default exception behavior for unobserved exceptions.</source>
          <target state="translated">Para tornar mais fácil para os desenvolvedores a gravar código assíncrono baseado em tarefas, o <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph> altera o comportamento de exceção padrão para exceções observadas.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Threading.Tasks.TaskScheduler.UnobservedTaskException">
          <source>Although unobserved exceptions still raise the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler.UnobservedTaskException&gt;</ph> exception, the process does not terminate by default.</source>
          <target state="translated">Embora a gerar exceções observadas ainda o <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler.UnobservedTaskException&gt;</ph> exceção, o processo não encerra por padrão.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Threading.Tasks.TaskScheduler.UnobservedTaskException">
          <source>Instead, the exception is handled by the runtime after the event is raised, regardless of whether an event handler observes the exception.</source>
          <target state="translated">Em vez disso, a exceção é manipulada pelo tempo de execução depois que o evento é disparado, independentemente se um manipulador de eventos observa a exceção.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Threading.Tasks.TaskScheduler.UnobservedTaskException">
          <source>This behavior can be configured.</source>
          <target state="translated">Esse comportamento pode ser configurado.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Threading.Tasks.TaskScheduler.UnobservedTaskException">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>, you can use the  configuration element to revert to the behavior of the <ph id="ph2">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph> and terminate the process:</source>
          <target state="translated">Começando com o <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>, você pode usar o elemento de configuração para reverter para o comportamento do <ph id="ph2">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph> e encerrar o processo:</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>