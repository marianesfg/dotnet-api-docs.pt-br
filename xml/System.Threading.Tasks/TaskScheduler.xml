<Type Name="TaskScheduler" FullName="System.Threading.Tasks.TaskScheduler">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="9101875b3c768590b23db0c0c08ee17d09fc5e38" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="pt-BR" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37609216" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class TaskScheduler" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit TaskScheduler extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Tasks.TaskScheduler" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class TaskScheduler" />
  <TypeSignature Language="C++ CLI" Value="public ref class TaskScheduler abstract" />
  <TypeSignature Language="F#" Value="type TaskScheduler = class" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Tasks</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerDisplay("Id={Id}")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Threading.Tasks.TaskScheduler/SystemThreadingTasks_TaskSchedulerDebugView))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="14cc1-101">Representa um objeto que manipula o trabalho de nível baixo de enfileirar tarefas em threads.</span>
      <span class="sxs-lookup">
        <span data-stu-id="14cc1-101">Represents an object that handles the low-level work of queuing tasks onto threads.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="14cc1-102">Uma instância da <xref:System.Threading.Tasks.TaskScheduler> classe representa um agendador de tarefas.</span><span class="sxs-lookup"><span data-stu-id="14cc1-102">An instance of the <xref:System.Threading.Tasks.TaskScheduler> class represents a task scheduler.</span></span> <span data-ttu-id="14cc1-103">Um agendador de tarefas garante que o trabalho de uma tarefa é eventualmente executado.</span><span class="sxs-lookup"><span data-stu-id="14cc1-103">A task scheduler ensures that the work of a task is eventually executed.</span></span>  
  
 <span data-ttu-id="14cc1-104">O Agendador de tarefas padrão baseia-se no pool de threads do .NET Framework 4, que fornece o roubo de trabalho para o balanceamento de carga, injeção de thread/desativação de taxa de transferência máxima e desempenho geral boa.</span><span class="sxs-lookup"><span data-stu-id="14cc1-104">The default task scheduler is based on the .NET Framework 4 thread pool, which provides work-stealing for load-balancing, thread injection/retirement for maximum throughput, and overall good performance.</span></span> <span data-ttu-id="14cc1-105">Ele deve ser suficiente para a maioria dos cenários.</span><span class="sxs-lookup"><span data-stu-id="14cc1-105">It should be sufficient for most scenarios.</span></span>  
  
 <span data-ttu-id="14cc1-106">O <xref:System.Threading.Tasks.TaskScheduler> classe também serve como o ponto de extensão para toda a lógica de agendamento personalizável.</span><span class="sxs-lookup"><span data-stu-id="14cc1-106">The <xref:System.Threading.Tasks.TaskScheduler> class also serves as the extension point for all customizable scheduling logic.</span></span>  <span data-ttu-id="14cc1-107">Isso inclui mecanismos, como como agendar uma tarefa para execução e as tarefas agendadas como deve ser exposto aos depuradores.</span><span class="sxs-lookup"><span data-stu-id="14cc1-107">This includes mechanisms such as how to schedule a task for execution, and how scheduled tasks should be exposed to debuggers.</span></span> <span data-ttu-id="14cc1-108">Se você precisar de uma funcionalidade especial, você pode criar um agendador personalizado e habilitá-lo para tarefas específicas ou consultas.</span><span class="sxs-lookup"><span data-stu-id="14cc1-108">If you require special functionality, you can create a custom scheduler and enable it for specific tasks or queries.</span></span>  
  
 <span data-ttu-id="14cc1-109">Neste tópico:</span><span class="sxs-lookup"><span data-stu-id="14cc1-109">In this topic:</span></span>  
[<span data-ttu-id="14cc1-110">O Agendador de tarefas padrão e o pool de threads</span><span class="sxs-lookup"><span data-stu-id="14cc1-110">The default task scheduler and the thread pool</span></span>](#Default)  
 [<span data-ttu-id="14cc1-111">A fila global versus filas locais</span><span class="sxs-lookup"><span data-stu-id="14cc1-111">The global queue vs. local queues</span></span>](#Queues)  
 [<span data-ttu-id="14cc1-112">Roubo de trabalho</span><span class="sxs-lookup"><span data-stu-id="14cc1-112">Work stealing</span></span>](#Stealing)  
 [<span data-ttu-id="14cc1-113">Tarefas de longa execução</span><span class="sxs-lookup"><span data-stu-id="14cc1-113">Long-running tasks</span></span>](#LongRunning)  
 [<span data-ttu-id="14cc1-114">Inlining de tarefa</span><span class="sxs-lookup"><span data-stu-id="14cc1-114">Task inlining</span></span>](#Inlining)  
[<span data-ttu-id="14cc1-115">Especificando um contexto de sincronização</span><span class="sxs-lookup"><span data-stu-id="14cc1-115">Specifying a synchronization context</span></span>](#Sync)  
  
<a name="Default"></a>   
## <a name="the-default-task-scheduler-and-the-thread-pool"></a><span data-ttu-id="14cc1-116">O Agendador de tarefas padrão e o pool de threads</span><span class="sxs-lookup"><span data-stu-id="14cc1-116">The default task scheduler and the thread pool</span></span>  
 <span data-ttu-id="14cc1-117">O agendador padrão para a biblioteca paralela de tarefas e o PLINQ utiliza o pool de threads do .NET Framework, que é representado pelo <xref:System.Threading.ThreadPool> classe enfileirar e executar o trabalho.</span><span class="sxs-lookup"><span data-stu-id="14cc1-117">The default scheduler for the Task Parallel Library and PLINQ uses the .NET Framework thread pool, which is represented by the <xref:System.Threading.ThreadPool> class, to queue and execute work.</span></span> <span data-ttu-id="14cc1-118">O pool de threads usa as informações fornecidas pelo <xref:System.Threading.Tasks.Task> tipo para dar suporte a paralelismo refinado (unidades de curta duração do trabalho) que são paralelos tarefas e consultas geralmente representam com eficiência.</span><span class="sxs-lookup"><span data-stu-id="14cc1-118">The thread pool uses the information that is provided by the <xref:System.Threading.Tasks.Task> type to efficiently     support the fine-grained parallelism (short-lived units of work) that parallel tasks and queries often represent.</span></span>  
  
<a name="Queues"></a>   
### <a name="the-global-queue-vs-local-queues"></a><span data-ttu-id="14cc1-119">A fila global versus filas locais</span><span class="sxs-lookup"><span data-stu-id="14cc1-119">The global queue vs. local queues</span></span>  
 <span data-ttu-id="14cc1-120">O pool de threads mantém a fila de threads em cada domínio de aplicativo de trabalho de um global PEPS (primeiro a entrar, primeiro a sair).</span><span class="sxs-lookup"><span data-stu-id="14cc1-120">The thread pool maintains a global FIFO (first-in, first-out) work queue for threads in each application domain.</span></span> <span data-ttu-id="14cc1-121">Sempre que um programa chama o <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A?displayProperty=nameWithType> (ou <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A?displayProperty=nameWithType>) método, o trabalho é colocar nessa fila compartilhada e, eventualmente, da fila para próximo thread que se torna disponível.</span><span class="sxs-lookup"><span data-stu-id="14cc1-121">Whenever a program calls the <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A?displayProperty=nameWithType> (or <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A?displayProperty=nameWithType>) method, the work is put on this shared queue and eventually de-queued onto the next thread that becomes available.</span></span> <span data-ttu-id="14cc1-122">Começando com o .NET Framework 4, essa fila foi aperfeiçoada para usar um algoritmo livres de bloqueio que se parece com o <xref:System.Collections.Concurrent.ConcurrentQueue%601> classe.</span><span class="sxs-lookup"><span data-stu-id="14cc1-122">Starting with the .NET Framework 4, this queue has been improved to use a lock-free algorithm that resembles the <xref:System.Collections.Concurrent.ConcurrentQueue%601> class.</span></span> <span data-ttu-id="14cc1-123">Ao usar essa implementação livres de bloqueio, o pool de threads gasta menos tempo quando ele coloca na fila e retira os itens de trabalho.</span><span class="sxs-lookup"><span data-stu-id="14cc1-123">By using this lock-free implementation, the thread pool spends less time when it queues and de-queues work items.</span></span> <span data-ttu-id="14cc1-124">Esse benefício de desempenho está disponível para todos os programas que usam o pool de threads.</span><span class="sxs-lookup"><span data-stu-id="14cc1-124">This performance benefit is available to all programs that use the thread pool.</span></span>  
  
 <span data-ttu-id="14cc1-125">Tarefas de nível superior, que são tarefas que não são criadas no contexto de outra tarefa, são colocadas na fila assim como qualquer outro item de trabalho global.</span><span class="sxs-lookup"><span data-stu-id="14cc1-125">Top-level tasks, which are tasks that are not created in the context of another task, are put on the global queue just like any other work item.</span></span> <span data-ttu-id="14cc1-126">No entanto, aninhados ou tarefas filho, que são criadas no contexto de outra tarefa, são tratadas de modo bem diferente.</span><span class="sxs-lookup"><span data-stu-id="14cc1-126">However, nested or child tasks, which are created in the context of another task, are handled quite differently.</span></span> <span data-ttu-id="14cc1-127">Um filho ou uma tarefa aninhada é colocada em uma fila local que é específica para o thread no qual a tarefa pai está em execução.</span><span class="sxs-lookup"><span data-stu-id="14cc1-127">A child or nested task is put on a local queue that is specific to the thread on which the parent task is executing.</span></span> <span data-ttu-id="14cc1-128">A tarefa pai pode ser uma tarefa de nível superior ou também pode ser o filho de outra tarefa.</span><span class="sxs-lookup"><span data-stu-id="14cc1-128">The parent task may be a top-level task or it also may be the child of another task.</span></span> <span data-ttu-id="14cc1-129">Quando esse thread está pronto para mais de trabalho, ele primeiro procura na fila local.</span><span class="sxs-lookup"><span data-stu-id="14cc1-129">When this thread is ready for more work, it first looks in the local queue.</span></span> <span data-ttu-id="14cc1-130">Se os itens de trabalho estiver aguardando lá, eles podem ser acessados rapidamente.</span><span class="sxs-lookup"><span data-stu-id="14cc1-130">If work items are waiting there, they can be accessed quickly.</span></span> <span data-ttu-id="14cc1-131">As filas locais são acessadas na ordem último a entrar, primeiro a sair (UEPS) para preservar a localidade do cache e reduzir a contenção.</span><span class="sxs-lookup"><span data-stu-id="14cc1-131">The local queues are accessed in last-in, first-out order (LIFO) to preserve cache locality and reduce contention.</span></span> <span data-ttu-id="14cc1-132">Para obter mais informações sobre tarefas aninhadas e tarefas filho, consulte [anexadas e desanexadas tarefas de filho](~/docs/standard/parallel-programming/attached-and-detached-child-tasks.md).</span><span class="sxs-lookup"><span data-stu-id="14cc1-132">For more information about child tasks and nested tasks, see [Attached and Detached Child Tasks](~/docs/standard/parallel-programming/attached-and-detached-child-tasks.md).</span></span>  
  
 <span data-ttu-id="14cc1-133">O uso de filas locais não só reduz a pressão sobre a fila global, mas também se beneficia da localidade dos dados.</span><span class="sxs-lookup"><span data-stu-id="14cc1-133">The use of local queues not only reduces pressure on the global queue, but also takes advantage of data locality.</span></span> <span data-ttu-id="14cc1-134">Itens de trabalho no local da fila com frequência estruturas de dados de referência que estão fisicamente próximos uns dos outros na memória.</span><span class="sxs-lookup"><span data-stu-id="14cc1-134">Work items in the local queue frequently reference data structures that are physically near one another in memory.</span></span> <span data-ttu-id="14cc1-135">Nesses casos, os dados já estão no cache após a primeira tarefa foi executada e pode ser acessada rapidamente.</span><span class="sxs-lookup"><span data-stu-id="14cc1-135">In these cases, the data is already in the cache after the first task has run and can be accessed quickly.</span></span> <span data-ttu-id="14cc1-136">Ambos [PLINQ (Parallel LINQ)](~/docs/standard/parallel-programming/parallel-linq-plinq.md) e o <xref:System.Threading.Tasks.Parallel> classe tarefas aninhadas e tarefas filho extensivamente e obter aumentos de velocidade significativos, usando as filas de trabalho local.</span><span class="sxs-lookup"><span data-stu-id="14cc1-136">Both [Parallel LINQ (PLINQ)](~/docs/standard/parallel-programming/parallel-linq-plinq.md) and the <xref:System.Threading.Tasks.Parallel> class use nested tasks and child tasks extensively, and achieve significant speedups by using the local work queues.</span></span>  
  
<a name="Stealing"></a>   
### <a name="work-stealing"></a><span data-ttu-id="14cc1-137">Roubo de trabalho</span><span class="sxs-lookup"><span data-stu-id="14cc1-137">Work stealing</span></span>  
 <span data-ttu-id="14cc1-138">Começando com o .NET Framework 4, o pool de threads também apresenta um algoritmo de roubo de trabalho para ajudar a tornar-se de que nenhum thread está sentado ociosos enquanto outros ainda têm trabalham em suas filas.</span><span class="sxs-lookup"><span data-stu-id="14cc1-138">Starting with the .NET Framework 4, the thread pool also features a work-stealing algorithm to help make sure that no threads are sitting idle while others still have work in their queues.</span></span> <span data-ttu-id="14cc1-139">Quando um thread do pool de threads está pronto para mais de trabalho, ele primeiro procura no início da fila de local, em seguida, na fila de global e, em seguida, nas filas de local de outros threads.</span><span class="sxs-lookup"><span data-stu-id="14cc1-139">When a thread-pool thread is ready for more work, it first looks at the head of its local queue, then in the global queue, and then in the local queues of other threads.</span></span> <span data-ttu-id="14cc1-140">Se ele encontrar um item de trabalho na fila de local de outro thread, ele primeiro se aplica a heurística para certificar-se de que ele pode executar o trabalho com eficiência.</span><span class="sxs-lookup"><span data-stu-id="14cc1-140">If it finds a work item in the local queue of another thread, it first applies heuristics to make sure that it can run the work efficiently.</span></span> <span data-ttu-id="14cc1-141">Se for possível, ele retira o item de trabalho do fim (na ordem FIFO).</span><span class="sxs-lookup"><span data-stu-id="14cc1-141">If it can, it de-queues the work item from the tail (in FIFO order).</span></span> <span data-ttu-id="14cc1-142">Isso reduz a contenção em cada fila local e preserva a localidade dos dados.</span><span class="sxs-lookup"><span data-stu-id="14cc1-142">This reduces contention on each local queue and preserves data locality.</span></span> <span data-ttu-id="14cc1-143">Essa arquitetura permite que o balanceamento de carga do pool threads funcionam de forma mais eficiente do que nas versões anteriores.</span><span class="sxs-lookup"><span data-stu-id="14cc1-143">This architecture helps the  thread pool load-balance work more efficiently than past versions did.</span></span>  
  
<a name="LongRunning"></a>   
### <a name="long-running-tasks"></a><span data-ttu-id="14cc1-144">Tarefas de longa execução</span><span class="sxs-lookup"><span data-stu-id="14cc1-144">Long-running tasks</span></span>  
 <span data-ttu-id="14cc1-145">Você talvez queira impedir explicitamente que uma tarefa que está sendo colocada em uma fila local.</span><span class="sxs-lookup"><span data-stu-id="14cc1-145">You may want to explicitly prevent a task from being put on a local queue.</span></span> <span data-ttu-id="14cc1-146">Por exemplo, você poderá saber que um determinado item de trabalho será executado em um tempo relativamente longo e é provável que bloqueie todos os outros itens de trabalho na fila local.</span><span class="sxs-lookup"><span data-stu-id="14cc1-146">For example, you may know that a particular work item will run for a relatively long time and is likely to block all other work items on the local queue.</span></span> <span data-ttu-id="14cc1-147">Nesse caso, você pode especificar o <xref:System.Threading.Tasks.TaskCreationOptions?displayProperty=nameWithType> opção, que fornece uma dica para o Agendador de que um thread adicional pode ser necessário para a tarefa para que ele não bloqueia o progresso de outros threads ou itens de trabalho na fila local.</span><span class="sxs-lookup"><span data-stu-id="14cc1-147">In this case, you can specify the <xref:System.Threading.Tasks.TaskCreationOptions?displayProperty=nameWithType> option, which provides a hint to the scheduler that an additional thread might be required for the task so that it does not block the forward progress of other threads or work items on the local queue.</span></span> <span data-ttu-id="14cc1-148">Ao usar essa opção você evita o pool de threads completamente, incluindo as filas globais e locais.</span><span class="sxs-lookup"><span data-stu-id="14cc1-148">By using this option you avoid the thread pool completely, including the global and local queues.</span></span>  
  
<a name="Inlining"></a>   
### <a name="task-inlining"></a><span data-ttu-id="14cc1-149">Inlining de tarefa</span><span class="sxs-lookup"><span data-stu-id="14cc1-149">Task inlining</span></span>  
 <span data-ttu-id="14cc1-150">Em alguns casos, quando um <xref:System.Threading.Tasks.Task> esperou, ele pode ser executado de forma síncrona no thread que está executando a operação de espera.</span><span class="sxs-lookup"><span data-stu-id="14cc1-150">In some cases when a <xref:System.Threading.Tasks.Task> is waited on, it may be executed synchronously on the thread that is performing the wait operation.</span></span> <span data-ttu-id="14cc1-151">Isso melhora o desempenho, evitando a necessidade de um thread adicional e em vez de usar o thread existente, o que seria ter bloqueado a outra forma.</span><span class="sxs-lookup"><span data-stu-id="14cc1-151">This enhances performance by preventing the need for an additional thread and instead using the existing thread, which would have blocked otherwise.</span></span> <span data-ttu-id="14cc1-152">Para evitar erros devido a reentrada, tarefa inlining só ocorre quando o destino de espera é encontrado na fila de local do thread relevante.</span><span class="sxs-lookup"><span data-stu-id="14cc1-152">To prevent errors due to re-entrancy, task inlining only occurs when the wait target is found in the relevant thread's local queue.</span></span>  
  
<a name="Sync"></a>   
## <a name="specifying-a-synchronization-context"></a><span data-ttu-id="14cc1-153">Especificando um contexto de sincronização</span><span class="sxs-lookup"><span data-stu-id="14cc1-153">Specifying a synchronization context</span></span>  
 <span data-ttu-id="14cc1-154">Você pode usar o <xref:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext%2A?displayProperty=nameWithType> método para especificar que uma tarefa deve ser agendada para execução em um thread específico.</span><span class="sxs-lookup"><span data-stu-id="14cc1-154">You can use the <xref:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext%2A?displayProperty=nameWithType> method to specify that a task should be scheduled to run on a particular thread.</span></span> <span data-ttu-id="14cc1-155">Isso é útil em estruturas como o Windows Forms e Windows Presentation Foundation em que o acesso aos objetos de interface do usuário geralmente é limitado a código que está em execução no mesmo thread no qual o objeto de interface do usuário foi criado.</span><span class="sxs-lookup"><span data-stu-id="14cc1-155">This is useful in frameworks such as Windows Forms and Windows Presentation Foundation where access to user interface objects is often restricted to code that is running on the same thread on which the UI object was created.</span></span>  
  
 <span data-ttu-id="14cc1-156">O exemplo a seguir usa o <xref:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext%2A?displayProperty=nameWithType> método em um aplicativo Windows Presentation Foundation (WPF) para agendar uma tarefa no mesmo thread que o controle de (UI) de interface do usuário foi criado.</span><span class="sxs-lookup"><span data-stu-id="14cc1-156">The following example uses the <xref:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext%2A?displayProperty=nameWithType> method in a Windows Presentation Foundation (WPF) app to schedule a task on the same thread that the user interface (UI) control was created on.</span></span>   <span data-ttu-id="14cc1-157">O exemplo cria um mosaico de imagens que serão selecionadas aleatoriamente de um diretório especificado.</span><span class="sxs-lookup"><span data-stu-id="14cc1-157">The example creates a mosaic of images that are randomly selected from a specified directory.</span></span> <span data-ttu-id="14cc1-158">Os objetos do WPF são usados para carregar e redimensione as imagens.</span><span class="sxs-lookup"><span data-stu-id="14cc1-158">The WPF objects are used to load and resize the images.</span></span> <span data-ttu-id="14cc1-159">Os pixels brutos são então passados para uma tarefa que usa um <xref:System.Threading.Tasks.Parallel.For%2A> loop para gravar os dados de pixel em uma grande matriz de byte único.</span><span class="sxs-lookup"><span data-stu-id="14cc1-159">The raw pixels are then passed to a task that uses a <xref:System.Threading.Tasks.Parallel.For%2A> loop to write the pixel data into a large single-byte array.</span></span> <span data-ttu-id="14cc1-160">Nenhuma sincronização é necessária porque não há dois blocos ocupam os mesmos elementos de matriz.</span><span class="sxs-lookup"><span data-stu-id="14cc1-160">No synchronization is required because no two tiles occupy the same array elements.</span></span> <span data-ttu-id="14cc1-161">Os blocos também podem ser gravados em qualquer ordem, porque sua posição é calculada independentemente de qualquer outro bloco.</span><span class="sxs-lookup"><span data-stu-id="14cc1-161">The tiles can also be written in any order because their position is calculated independently of any other tile.</span></span> <span data-ttu-id="14cc1-162">A matriz grande, em seguida, é passada para uma tarefa que executa no thread da interface do usuário, onde os dados de pixel são carregados em um controle de imagem.</span><span class="sxs-lookup"><span data-stu-id="14cc1-162">The large array is then passed to a task that runs on the UI thread, where the pixel data is loaded into an Image control.</span></span>  
  
 <span data-ttu-id="14cc1-163">O exemplo move os dados fora do thread de interface do usuário, modifica-o por meio de loops paralelos e <xref:System.Threading.Tasks.Task> objetos e, em seguida, passa de volta para uma tarefa que executa no thread da interface do usuário.</span><span class="sxs-lookup"><span data-stu-id="14cc1-163">The example moves data off the UI thread, modifies it by using parallel loops and <xref:System.Threading.Tasks.Task> objects, and then passes it back to a task that runs on the UI thread.</span></span> <span data-ttu-id="14cc1-164">Essa abordagem é útil quando você tem que usar a biblioteca paralela de tarefas para executar operações que não são compatíveis com a API do WPF, ou que não forem suficientemente rápidos.</span><span class="sxs-lookup"><span data-stu-id="14cc1-164">This approach is useful when you have to use the Task Parallel Library to perform operations that either are not supported by the WPF API, or are not sufficiently fast.</span></span> <span data-ttu-id="14cc1-165">Outra maneira de criar um mosaico de imagem no WPF é usar um <xref:System.Windows.Controls.WrapPanel?displayProperty=nameWithType> controlar e adicionar imagens a ele.</span><span class="sxs-lookup"><span data-stu-id="14cc1-165">Another way to create an image mosaic in WPF is to use a <xref:System.Windows.Controls.WrapPanel?displayProperty=nameWithType> control and add images to it.</span></span> <span data-ttu-id="14cc1-166">O <xref:System.Windows.Controls.WrapPanel> manipula o trabalho de posicionamento de blocos.</span><span class="sxs-lookup"><span data-stu-id="14cc1-166">The <xref:System.Windows.Controls.WrapPanel> handles the work of positioning the tiles.</span></span> <span data-ttu-id="14cc1-167">No entanto, esse trabalho só pode ser executado no thread da interface do usuário.</span><span class="sxs-lookup"><span data-stu-id="14cc1-167">However, this work can only be performed on the UI thread.</span></span>  
  
 [!code-csharp[TPL_SyncContext#01](~/samples/snippets/csharp/VS_Snippets_Misc/tpl_synccontext/cs/mainwindow.xaml.cs#01)]
 [!code-vb[TPL_SyncContext#01](~/samples/snippets/visualbasic/VS_Snippets_Misc/tpl_synccontext/vb/MainWindow.xaml.vb#01)]  
  
 <span data-ttu-id="14cc1-168">Para criar o exemplo, criar um projeto de aplicativo do WPF no Visual Studio e atribuir um nome de sua escolha.</span><span class="sxs-lookup"><span data-stu-id="14cc1-168">To create the example, create a WPF application project in Visual Studio and assign it a name of your choice.</span></span> <span data-ttu-id="14cc1-169">Em seguida, faça o seguinte:</span><span class="sxs-lookup"><span data-stu-id="14cc1-169">Then do the following:</span></span>  
  
1.  <span data-ttu-id="14cc1-170">No modo de design, arraste um <xref:System.Windows.Controls.Image> controlar do **caixa de ferramentas** à superfície de design.</span><span class="sxs-lookup"><span data-stu-id="14cc1-170">In design view, drag an <xref:System.Windows.Controls.Image> control from the **Toolbox** to the design surface.</span></span> <span data-ttu-id="14cc1-171">No modo de exibição XAML, especifique o alinhamento horizontal como "Esquerda".</span><span class="sxs-lookup"><span data-stu-id="14cc1-171">In XAML view, specify the horizontal alignment as "Left."</span></span> <span data-ttu-id="14cc1-172">O tamanho não importa porque o controle é redimensionado dinamicamente em tempo de execução.</span><span class="sxs-lookup"><span data-stu-id="14cc1-172">The size does not matter because the control is be dynamically resized at run time.</span></span> <span data-ttu-id="14cc1-173">Aceite o nome padrão, "imagem".</span><span class="sxs-lookup"><span data-stu-id="14cc1-173">Accept the default name, "image".</span></span>  
  
2.  <span data-ttu-id="14cc1-174">Arraste uma <xref:System.Windows.Controls.Button> controlar do **caixa de ferramentas** até a parte inferior esquerda da janela do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="14cc1-174">Drag a <xref:System.Windows.Controls.Button> control from the **Toolbox** to the lower left part of the application window.</span></span> <span data-ttu-id="14cc1-175">Clique duas vezes no botão para adicionar um <xref:System.Windows.Controls.Primitives.ButtonBase.Click> manipulador de eventos.</span><span class="sxs-lookup"><span data-stu-id="14cc1-175">Double-click the button to add a <xref:System.Windows.Controls.Primitives.ButtonBase.Click> event handler.</span></span> <span data-ttu-id="14cc1-176">No modo de exibição XAML, especifique o <xref:System.Windows.Controls.ContentControl.Content%2A> propriedade do botão como "Fazer um mosaico" e especifica o alinhamento horizontal como "Esquerda".</span><span class="sxs-lookup"><span data-stu-id="14cc1-176">In XAML view, specify the <xref:System.Windows.Controls.ContentControl.Content%2A> property of the button as "Make a Mosaic" and specify its horizontal alignment as "Left".</span></span> <span data-ttu-id="14cc1-177">Aceite o nome padrão, "button".</span><span class="sxs-lookup"><span data-stu-id="14cc1-177">Accept the default name, "button".</span></span>  
  
3.  <span data-ttu-id="14cc1-178">Substitua todo o conteúdo do arquivo. XAML. vb ou MainWindow.xaml.cs com o código deste exemplo.</span><span class="sxs-lookup"><span data-stu-id="14cc1-178">Replace the entire contents of the MainWindow.xaml.cs or MainWindow.xaml.vb file with the code from this example.</span></span> <span data-ttu-id="14cc1-179">Certifique-se de que o nome do espaço de trabalho corresponde ao nome do projeto.</span><span class="sxs-lookup"><span data-stu-id="14cc1-179">Make sure that the name of the workspace matches the project name.</span></span>  
  
4.  <span data-ttu-id="14cc1-180">O exemplo lê imagens JPEG de um diretório chamado C:\Users\Public\Pictures\Sample imagens\\.</span><span class="sxs-lookup"><span data-stu-id="14cc1-180">The example reads JPEG images from a directory named C:\Users\Public\Pictures\Sample Pictures\\.</span></span> <span data-ttu-id="14cc1-181">Crie o diretório e colocar algumas imagens nele ou altere o caminho para fazer referência a outro diretório que contém imagens.</span><span class="sxs-lookup"><span data-stu-id="14cc1-181">Either create the directory and place some images in it, or change the path to refer to some other directory that contains images.</span></span>  
  
 <span data-ttu-id="14cc1-182">Este exemplo tem algumas limitações.</span><span class="sxs-lookup"><span data-stu-id="14cc1-182">This example has some limitations.</span></span> <span data-ttu-id="14cc1-183">Por exemplo, há suporte para imagens apenas 32-bits por pixel; imagens em outros formatos estão corrompidas pelo <xref:System.Windows.Media.Imaging.BitmapImage> objeto durante a operação de redimensionamento.</span><span class="sxs-lookup"><span data-stu-id="14cc1-183">For example, only 32-bits-per-pixel images are supported; images in other formats are corrupted by the <xref:System.Windows.Media.Imaging.BitmapImage> object during the resizing operation.</span></span> <span data-ttu-id="14cc1-184">Além disso, as imagens de origem devem todas ser maiores que o tamanho do bloco.</span><span class="sxs-lookup"><span data-stu-id="14cc1-184">Also, the source images must all be larger than the tile size.</span></span> <span data-ttu-id="14cc1-185">Como um exercício adicional, você pode adicionar funcionalidade para lidar com vários formatos de pixel e tamanhos de arquivos.</span><span class="sxs-lookup"><span data-stu-id="14cc1-185">As a further exercise, you can add functionality to handle multiple pixel formats and file sizes.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="14cc1-186">O exemplo a seguir é retirado do [amostras para programação paralela com o .NET Framework 4](http://go.microsoft.com/fwlink/?LinkID=165717) no site da Web de galeria de código do MSDN.</span><span class="sxs-lookup"><span data-stu-id="14cc1-186">The following example is taken from the [Samples for Parallel Programming with the .NET Framework 4](http://go.microsoft.com/fwlink/?LinkID=165717) on the MSDN Code Gallery Web site.</span></span>  <span data-ttu-id="14cc1-187">Ele cria um agendador de tarefas personalizado que limita o número de threads usados pelo aplicativo.</span><span class="sxs-lookup"><span data-stu-id="14cc1-187">It creates a custom task scheduler that limits the number of threads used by the app.</span></span> <span data-ttu-id="14cc1-188">Em seguida, ele inicia dois conjuntos de tarefas e exibe informações sobre a tarefa e o thread no qual a tarefa está em execução.</span><span class="sxs-lookup"><span data-stu-id="14cc1-188">It then launches two sets of tasks and displays information about the task and the thread on which the task is executing.</span></span>  
  
 [!code-csharp[TPL_Schedulers#02](~/samples/snippets/csharp/VS_Snippets_Misc/tpl_schedulers/cs/limitex1.cs#02)]
 [!code-vb[TPL_Schedulers#02](~/samples/snippets/visualbasic/VS_Snippets_Misc/tpl_schedulers/vb/module2.vb#02)]  
  
 <span data-ttu-id="14cc1-189">Além disso, vários agendadores de tarefas de exemplo estão disponíveis na Galeria de código: [amostras para programação paralela com o .NET Framework 4](http://go.microsoft.com/fwlink/?LinkID=165717).</span><span class="sxs-lookup"><span data-stu-id="14cc1-189">In addition, several sample task schedulers are available on Code Gallery: [Samples for Parallel Programming with the .NET Framework 4](http://go.microsoft.com/fwlink/?LinkID=165717).</span></span>  
  
 ]]></format>
    </remarks>
    <threadsafe>
      <span data-ttu-id="14cc1-190">Todos os membros do resumo <see cref="T:System.Threading.Tasks.TaskScheduler" /> tipo são thread-safe e podem ser usados simultaneamente de vários threads.</span>
      <span class="sxs-lookup">
        <span data-stu-id="14cc1-190">All members of the abstract <see cref="T:System.Threading.Tasks.TaskScheduler" /> type are thread-safe and may be used from multiple threads concurrently.</span>
      </span>
    </threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected TaskScheduler ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; TaskScheduler();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="14cc1-191">Inicializa o <see cref="T:System.Threading.Tasks.TaskScheduler" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="14cc1-191">Initializes the <see cref="T:System.Threading.Tasks.TaskScheduler" />.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Current">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.TaskScheduler Current { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Threading.Tasks.TaskScheduler Current" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskScheduler.Current" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Current As TaskScheduler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Threading::Tasks::TaskScheduler ^ Current { System::Threading::Tasks::TaskScheduler ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Current : System.Threading.Tasks.TaskScheduler" Usage="System.Threading.Tasks.TaskScheduler.Current" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskScheduler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="14cc1-192">Obtém o <see cref="T:System.Threading.Tasks.TaskScheduler" /> associado à tarefa em execução no momento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="14cc1-192">Gets the <see cref="T:System.Threading.Tasks.TaskScheduler" /> associated with the currently executing task.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="14cc1-193">Retorna o <see cref="T:System.Threading.Tasks.TaskScheduler" /> associado à tarefa em execução no momento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="14cc1-193">Returns the <see cref="T:System.Threading.Tasks.TaskScheduler" /> associated with the currently executing task.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="14cc1-194">Quando chamado de uma tarefa, não <xref:System.Threading.Tasks.TaskScheduler.Current%2A> retornará o <xref:System.Threading.Tasks.TaskScheduler.Default%2A> Agendador.</span><span class="sxs-lookup"><span data-stu-id="14cc1-194">When not called from within a task, <xref:System.Threading.Tasks.TaskScheduler.Current%2A> will return the <xref:System.Threading.Tasks.TaskScheduler.Default%2A> scheduler.</span></span>  
  
 <span data-ttu-id="14cc1-195">Para obter mais informações, consulte <xref:System.Threading.Tasks.TaskScheduler>.</span><span class="sxs-lookup"><span data-stu-id="14cc1-195">For more information, see <xref:System.Threading.Tasks.TaskScheduler>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Default">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.TaskScheduler Default { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Threading.Tasks.TaskScheduler Default" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskScheduler.Default" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Default As TaskScheduler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Threading::Tasks::TaskScheduler ^ Default { System::Threading::Tasks::TaskScheduler ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Default : System.Threading.Tasks.TaskScheduler" Usage="System.Threading.Tasks.TaskScheduler.Default" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskScheduler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="14cc1-196">Obtém a instância <see cref="T:System.Threading.Tasks.TaskScheduler" /> padrão, fornecida pelo .NET Framework.</span>
          <span class="sxs-lookup">
            <span data-stu-id="14cc1-196">Gets the default <see cref="T:System.Threading.Tasks.TaskScheduler" /> instance that is provided by the .NET Framework.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="14cc1-197">Retorna a instância padrão <see cref="T:System.Threading.Tasks.TaskScheduler" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="14cc1-197">Returns the default <see cref="T:System.Threading.Tasks.TaskScheduler" /> instance.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="14cc1-198">Para obter mais informações, consulte [agendadores de tarefa](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65).</span><span class="sxs-lookup"><span data-stu-id="14cc1-198">For more information, see [Task Schedulers](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~TaskScheduler ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!TaskScheduler ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="taskScheduler.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FromCurrentSynchronizationContext">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.TaskScheduler FromCurrentSynchronizationContext ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.TaskScheduler FromCurrentSynchronizationContext() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromCurrentSynchronizationContext () As TaskScheduler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::TaskScheduler ^ FromCurrentSynchronizationContext();" />
      <MemberSignature Language="F#" Value="static member FromCurrentSynchronizationContext : unit -&gt; System.Threading.Tasks.TaskScheduler" Usage="System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskScheduler</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="14cc1-199">Cria um <see cref="T:System.Threading.Tasks.TaskScheduler" /> associado ao <see cref="T:System.Threading.SynchronizationContext" /> atual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="14cc1-199">Creates a <see cref="T:System.Threading.Tasks.TaskScheduler" /> associated with the current <see cref="T:System.Threading.SynchronizationContext" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="14cc1-200">Um <see cref="T:System.Threading.Tasks.TaskScheduler" /> associado ao <see cref="T:System.Threading.SynchronizationContext" /> atual, conforme determinado por <see cref="P:System.Threading.SynchronizationContext.Current" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="14cc1-200">A <see cref="T:System.Threading.Tasks.TaskScheduler" /> associated with the current <see cref="T:System.Threading.SynchronizationContext" />, as determined by <see cref="P:System.Threading.SynchronizationContext.Current" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="14cc1-201">Todos os <xref:System.Threading.Tasks.Task> instâncias na fila para retornado Agendador será executado por meio de uma chamada para o <xref:System.Threading.SynchronizationContext.Post%2A> método nesse contexto.</span><span class="sxs-lookup"><span data-stu-id="14cc1-201">All <xref:System.Threading.Tasks.Task> instances queued to the returned scheduler will be executed through a call to the <xref:System.Threading.SynchronizationContext.Post%2A> method on that context.</span></span>  
  
 <span data-ttu-id="14cc1-202">Para obter mais informações, consulte [agendadores de tarefa](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65).</span><span class="sxs-lookup"><span data-stu-id="14cc1-202">For more information, see [Task Schedulers](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="14cc1-203">O SynchronizationContext atual não pode ser usado como um TaskScheduler.</span>
          <span class="sxs-lookup">
            <span data-stu-id="14cc1-203">The current SynchronizationContext may not be used as a TaskScheduler.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetScheduledTasks">
      <MemberSignature Language="C#" Value="protected abstract System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&gt; GetScheduledTasks ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class System.Threading.Tasks.Task&gt; GetScheduledTasks() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.GetScheduledTasks" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetScheduledTasks () As IEnumerable(Of Task)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Collections::Generic::IEnumerable&lt;System::Threading::Tasks::Task ^&gt; ^ GetScheduledTasks();" />
      <MemberSignature Language="F#" Value="abstract member GetScheduledTasks : unit -&gt; seq&lt;System.Threading.Tasks.Task&gt;" Usage="taskScheduler.GetScheduledTasks " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="14cc1-204">Apenas para o suporte do depurador, gera um enumerável de instâncias <see cref="T:System.Threading.Tasks.Task" /> atualmente na fila do Agendador aguardando ser executado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="14cc1-204">For debugger support only, generates an enumerable of <see cref="T:System.Threading.Tasks.Task" /> instances currently queued to the scheduler waiting to be executed.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="14cc1-205">Um enumerável que permite que um depurador percorra as tarefas atualmente na fila para este agendador.</span>
          <span class="sxs-lookup">
            <span data-stu-id="14cc1-205">An enumerable that allows a debugger to traverse the tasks currently queued to this scheduler.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="14cc1-206">Uma classe derivada de <xref:System.Threading.Tasks.TaskScheduler> implementa esse método para dar suporte à integração com depuradores.</span><span class="sxs-lookup"><span data-stu-id="14cc1-206">A class derived from <xref:System.Threading.Tasks.TaskScheduler> implements this method in order to support integration with debuggers.</span></span> <span data-ttu-id="14cc1-207">Esse método só será invocado pelo .NET Framework quando o depurador solicita acesso aos dados.</span><span class="sxs-lookup"><span data-stu-id="14cc1-207">This method will only be invoked by the .NET Framework when the debugger requests access to the data.</span></span> <span data-ttu-id="14cc1-208">O enumerável retornado será ser percorrido por utilitários para acessar as tarefas de depuração atualmente na fila para este Agendador, permitindo que o depurador para fornecer uma representação dessas informações na interface do usuário.</span><span class="sxs-lookup"><span data-stu-id="14cc1-208">The enumerable returned will be traversed by debugging utilities to access the tasks currently queued to this scheduler, enabling the debugger to provide a representation of this information in the user interface.</span></span>  
  
 <span data-ttu-id="14cc1-209">É importante observar que, quando esse método é chamado, todos os outros threads no processo serão congelados.</span><span class="sxs-lookup"><span data-stu-id="14cc1-209">It is important to note that, when this method is called, all other threads in the process will be frozen.</span></span> <span data-ttu-id="14cc1-210">Portanto, é importante evitar a sincronização com outros threads que podem levar ao bloqueio.</span><span class="sxs-lookup"><span data-stu-id="14cc1-210">Therefore, it's important to avoid synchronization with other threads that may lead to blocking.</span></span> <span data-ttu-id="14cc1-211">Se a sincronização é necessária e você não conseguir adquirir o bloqueio nesse método, você deve lançar uma exceção para que o depurador não pare de responder.</span><span class="sxs-lookup"><span data-stu-id="14cc1-211">If synchronization is necessary, and you are unable to acquire the lock in this method, then you should throw an exception so that the debugger does not hang.</span></span> <span data-ttu-id="14cc1-212">O exemplo a seguir mostra uma abordagem possível no c#:</span><span class="sxs-lookup"><span data-stu-id="14cc1-212">The following example shows one possible approach in C#:</span></span>  
  
```  
protected override IEnumerable<Task> GetScheduledTasks()  
{  
    bool lockTaken = false;  
    try  
    {  
        Monitor.TryEnter(_syncObj, ref lockTaken);  
        if (lockTaken)  
        {  
            return _tasks.ToArray();  
        }  
        else throw new NotSupportedException();  
    }  
    finally  
    {  
    if (lockTaken) Monitor.Exit(_syncObj);  
    }}  
```  
  
 <span data-ttu-id="14cc1-213">Além disso, esse método e o enumerável retornado não deve modificar qualquer estado global visível.</span><span class="sxs-lookup"><span data-stu-id="14cc1-213">Additionally, this method and the enumerable returned must not modify any globally visible state.</span></span>  
  
 <span data-ttu-id="14cc1-214">O retornado enumerável nunca deve ser nulo.</span><span class="sxs-lookup"><span data-stu-id="14cc1-214">The returned enumerable should never be null.</span></span> <span data-ttu-id="14cc1-215">Se não houver nenhuma tarefa em fila, um enumerável de vazio deve ser retornado.</span><span class="sxs-lookup"><span data-stu-id="14cc1-215">If there are currently no queued tasks, an empty enumerable should be returned instead.</span></span>  
  
 <span data-ttu-id="14cc1-216">Os desenvolvedores que estiverem implementando depuradores personalizados não deve chamar este método diretamente, mas deve usar o método wrapper interna `GetScheduledTasksForDebugger` em vez disso: `internal Task[] GetScheduledTasksForDebugger()`.</span><span class="sxs-lookup"><span data-stu-id="14cc1-216">Developers who are implementing custom debuggers shouldn't call this method directly, but should use the internal wrapper method `GetScheduledTasksForDebugger` instead: `internal Task[] GetScheduledTasksForDebugger()`.</span></span> <span data-ttu-id="14cc1-217">Esse método de invólucro retorna uma matriz de tarefas em vez de um enumerável.</span><span class="sxs-lookup"><span data-stu-id="14cc1-217">This wrapper method returns an array of tasks instead of an enumerable.</span></span> <span data-ttu-id="14cc1-218">Para recuperar uma lista de agendadores de Active Directory, use o método interno `internal static TaskScheduler[] GetTaskSchedulersForDebugger()`.</span><span class="sxs-lookup"><span data-stu-id="14cc1-218">To retrieve a list of active schedulers, use the internal method `internal static TaskScheduler[] GetTaskSchedulersForDebugger()`.</span></span> <span data-ttu-id="14cc1-219">Esse método estático retorna uma matriz de todos os assinantes ativos <xref:System.Threading.Tasks.TaskScheduler> instâncias.</span><span class="sxs-lookup"><span data-stu-id="14cc1-219">This static method returns an array of all active <xref:System.Threading.Tasks.TaskScheduler> instances.</span></span> <span data-ttu-id="14cc1-220">Você pode usar `GetScheduledTasksForDebugger` em cada instância de Agendador para recuperar sua lista de tarefas agendadas.</span><span class="sxs-lookup"><span data-stu-id="14cc1-220">You can then use `GetScheduledTasksForDebugger` on each scheduler instance to retrieve its list of scheduled tasks.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="14cc1-221">Este Agendador não é capaz de gerar uma lista de tarefas em fila no momento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="14cc1-221">This scheduler is unable to generate a list of queued tasks at this time.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public int Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Id" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskScheduler.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Id { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Id : int" Usage="System.Threading.Tasks.TaskScheduler.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="14cc1-222">Obtém a ID exclusiva para este <see cref="T:System.Threading.Tasks.TaskScheduler" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="14cc1-222">Gets the unique ID for this <see cref="T:System.Threading.Tasks.TaskScheduler" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="14cc1-223">Retorna a ID exclusiva para este <see cref="T:System.Threading.Tasks.TaskScheduler" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="14cc1-223">Returns the unique ID for this <see cref="T:System.Threading.Tasks.TaskScheduler" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="14cc1-224">Para obter mais informações, consulte [agendadores de tarefa](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65).</span><span class="sxs-lookup"><span data-stu-id="14cc1-224">For more information, see [Task Schedulers](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaximumConcurrencyLevel">
      <MemberSignature Language="C#" Value="public virtual int MaximumConcurrencyLevel { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaximumConcurrencyLevel" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskScheduler.MaximumConcurrencyLevel" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property MaximumConcurrencyLevel As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int MaximumConcurrencyLevel { int get(); };" />
      <MemberSignature Language="F#" Value="member this.MaximumConcurrencyLevel : int" Usage="System.Threading.Tasks.TaskScheduler.MaximumConcurrencyLevel" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="14cc1-225">Indica o nível de simultaneidade máximo ao qual esse <see cref="T:System.Threading.Tasks.TaskScheduler" /> pode dar suporte.</span>
          <span class="sxs-lookup">
            <span data-stu-id="14cc1-225">Indicates the maximum concurrency level this <see cref="T:System.Threading.Tasks.TaskScheduler" /> is able to support.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="14cc1-226">Retorna um inteiro que representa o nível máximo de simultaneidade.</span>
          <span class="sxs-lookup">
            <span data-stu-id="14cc1-226">Returns an integer that represents the maximum concurrency level.</span>
          </span>
          <span data-ttu-id="14cc1-227">O agendador padrão retorna <see cref="F:System.Int32.MaxValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="14cc1-227">The default scheduler returns <see cref="F:System.Int32.MaxValue" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="14cc1-228">Para obter mais informações, consulte [agendadores de tarefa](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65).</span><span class="sxs-lookup"><span data-stu-id="14cc1-228">For more information, see [Task Schedulers](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="QueueTask">
      <MemberSignature Language="C#" Value="protected internal abstract void QueueTask (System.Threading.Tasks.Task task);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void QueueTask(class System.Threading.Tasks.Task task) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.QueueTask(System.Threading.Tasks.Task)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; abstract void QueueTask(System::Threading::Tasks::Task ^ task);" />
      <MemberSignature Language="F#" Value="abstract member QueueTask : System.Threading.Tasks.Task -&gt; unit" Usage="taskScheduler.QueueTask task" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="task" Type="System.Threading.Tasks.Task" />
      </Parameters>
      <Docs>
        <param name="task">
          <span data-ttu-id="14cc1-229">O <see cref="T:System.Threading.Tasks.Task" /> a ser enfileirado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="14cc1-229">The <see cref="T:System.Threading.Tasks.Task" /> to be queued.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="14cc1-230">Enfileira um <see cref="T:System.Threading.Tasks.Task" /> no agendador.</span>
          <span class="sxs-lookup">
            <span data-stu-id="14cc1-230">Queues a <see cref="T:System.Threading.Tasks.Task" /> to the scheduler.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="14cc1-231">Uma classe derivada de <xref:System.Threading.Tasks.TaskScheduler> implementa esse método para aceitar que estão sendo agendadas no Agendador de tarefas.</span><span class="sxs-lookup"><span data-stu-id="14cc1-231">A class derived from <xref:System.Threading.Tasks.TaskScheduler> implements this method to accept tasks being scheduled on the scheduler.</span></span>  
  
 <span data-ttu-id="14cc1-232">Uma implementação típica seria armazenar a tarefa em uma estrutura de dados interno, que deve ser atendida por threads que seriam executar essas tarefas em algum momento no futuro.</span><span class="sxs-lookup"><span data-stu-id="14cc1-232">A typical implementation would store the task in an internal data structure, which would be serviced by threads that would execute those tasks at some time in the future.</span></span>  
  
 <span data-ttu-id="14cc1-233">Este método destina-se somente a ser chamado pelo .NET Framework e não deve ser chamado diretamente pela classe derivada.</span><span class="sxs-lookup"><span data-stu-id="14cc1-233">This method is only meant to be called by the .NET Framework and should not be called directly by the derived class.</span></span> <span data-ttu-id="14cc1-234">Isso é necessário para manter a consistência do sistema.</span><span class="sxs-lookup"><span data-stu-id="14cc1-234">This is necessary for maintaining the consistency of the system.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="14cc1-235">O argumento <paramref name="task" /> é nulo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="14cc1-235">The <paramref name="task" /> argument is null.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="TryDequeue">
      <MemberSignature Language="C#" Value="protected internal virtual bool TryDequeue (System.Threading.Tasks.Task task);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance bool TryDequeue(class System.Threading.Tasks.Task task) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.TryDequeue(System.Threading.Tasks.Task)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual bool TryDequeue(System::Threading::Tasks::Task ^ task);" />
      <MemberSignature Language="F#" Value="abstract member TryDequeue : System.Threading.Tasks.Task -&gt; bool&#xA;override this.TryDequeue : System.Threading.Tasks.Task -&gt; bool" Usage="taskScheduler.TryDequeue task" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="task" Type="System.Threading.Tasks.Task" />
      </Parameters>
      <Docs>
        <param name="task">
          <span data-ttu-id="14cc1-236">O <see cref="T:System.Threading.Tasks.Task" /> a ser removido da fila.</span>
          <span class="sxs-lookup">
            <span data-stu-id="14cc1-236">The <see cref="T:System.Threading.Tasks.Task" /> to be dequeued.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="14cc1-237">Tenta remover da fila um <see cref="T:System.Threading.Tasks.Task" /> que anteriormente havia sido enfileirado para esse agendador.</span>
          <span class="sxs-lookup">
            <span data-stu-id="14cc1-237">Attempts to dequeue a <see cref="T:System.Threading.Tasks.Task" /> that was previously queued to this scheduler.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="14cc1-238">Um Booliano indicando se o argumento <paramref name="task" /> foi retirado da fila com êxito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="14cc1-238">A Boolean denoting whether the <paramref name="task" /> argument was successfully dequeued.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="14cc1-239">Para obter mais informações, consulte [agendadores de tarefa](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65).</span><span class="sxs-lookup"><span data-stu-id="14cc1-239">For more information, see [Task Schedulers](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65).</span></span>  
  
 <span data-ttu-id="14cc1-240">Esse método pode ser executada em um bloco finally; Portanto, ele deverá retornar mais depressa possível assim que qualquer recursos, como <xref:System.Threading.CancellationTokenRegistration> objetos podem ser descartados de maneira oportuna.</span><span class="sxs-lookup"><span data-stu-id="14cc1-240">This method may execute in a finally block; therefore it should return as quickly as possible so that any resources such as <xref:System.Threading.CancellationTokenRegistration> objects can be disposed of in a timely manner.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="14cc1-241">O argumento <paramref name="task" /> é nulo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="14cc1-241">The <paramref name="task" /> argument is null.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="TryExecuteTask">
      <MemberSignature Language="C#" Value="protected bool TryExecuteTask (System.Threading.Tasks.Task task);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool TryExecuteTask(class System.Threading.Tasks.Task task) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.TryExecuteTask(System.Threading.Tasks.Task)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; bool TryExecuteTask(System::Threading::Tasks::Task ^ task);" />
      <MemberSignature Language="F#" Value="member this.TryExecuteTask : System.Threading.Tasks.Task -&gt; bool" Usage="taskScheduler.TryExecuteTask task" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="task" Type="System.Threading.Tasks.Task" />
      </Parameters>
      <Docs>
        <param name="task">
          <span data-ttu-id="14cc1-242">Um objeto <see cref="T:System.Threading.Tasks.Task" /> a ser executado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="14cc1-242">A <see cref="T:System.Threading.Tasks.Task" /> object to be executed.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="14cc1-243">Tenta executar o <see cref="T:System.Threading.Tasks.Task" /> fornecido neste agendador.</span>
          <span class="sxs-lookup">
            <span data-stu-id="14cc1-243">Attempts to execute the provided <see cref="T:System.Threading.Tasks.Task" /> on this scheduler.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="14cc1-244">Um booliano que será true se <paramref name="task" /> tiver sido executado com êxito, false se não tiver sido executado com êxito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="14cc1-244">A Boolean that is true if <paramref name="task" /> was successfully executed, false if it was not.</span>
          </span>
          <span data-ttu-id="14cc1-245">Uma razão comum para a falha de execução é que a tarefa havia sido executada anteriormente ou ela está sendo executado por outro thread.</span>
          <span class="sxs-lookup">
            <span data-stu-id="14cc1-245">A common reason for execution failure is that the task had previously been executed or is in the process of being executed by another thread.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="14cc1-246">Implementações do Agendador são fornecidas com o <xref:System.Threading.Tasks.Task> instâncias a ser executado por meio de uma a <xref:System.Threading.Tasks.TaskScheduler.QueueTask%2A> método ou o <xref:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline%2A> método.</span><span class="sxs-lookup"><span data-stu-id="14cc1-246">Scheduler implementations are provided with <xref:System.Threading.Tasks.Task> instances to be executed through either the <xref:System.Threading.Tasks.TaskScheduler.QueueTask%2A> method or the <xref:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline%2A> method.</span></span> <span data-ttu-id="14cc1-247">Quando o Agendador considera apropriado para executar a tarefa fornecida, <xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A> deve ser usado para fazer isso.</span><span class="sxs-lookup"><span data-stu-id="14cc1-247">When the scheduler deems it appropriate to run the provided task, <xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A> should be used to do so.</span></span> <span data-ttu-id="14cc1-248">TryExecuteTask lida com todos os aspectos da execução de uma tarefa, incluindo a invocação de ação, tratamento de exceções, gerenciamento de estado e controle de ciclo de vida.</span><span class="sxs-lookup"><span data-stu-id="14cc1-248">TryExecuteTask handles all aspects of executing a task, including action invocation, exception handling, state management, and lifecycle control.</span></span>  
  
 <span data-ttu-id="14cc1-249"><xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A> deve ser usado somente para as tarefas fornecidas para esse Agendador pela infraestrutura do .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="14cc1-249"><xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A> must only be used for tasks provided to this scheduler by the .NET Framework infrastructure.</span></span> <span data-ttu-id="14cc1-250">Ele não deve ser usado para executar tarefas arbitrárias obtidas por meio de mecanismos personalizados.</span><span class="sxs-lookup"><span data-stu-id="14cc1-250">It should not be used to execute arbitrary tasks obtained through custom mechanisms.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="14cc1-251">O <paramref name="task" /> não está associado a este agendador.</span>
          <span class="sxs-lookup">
            <span data-stu-id="14cc1-251">The <paramref name="task" /> is not associated with this scheduler.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="TryExecuteTaskInline">
      <MemberSignature Language="C#" Value="protected abstract bool TryExecuteTaskInline (System.Threading.Tasks.Task task, bool taskWasPreviouslyQueued);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool TryExecuteTaskInline(class System.Threading.Tasks.Task task, bool taskWasPreviouslyQueued) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool TryExecuteTaskInline(System::Threading::Tasks::Task ^ task, bool taskWasPreviouslyQueued);" />
      <MemberSignature Language="F#" Value="abstract member TryExecuteTaskInline : System.Threading.Tasks.Task * bool -&gt; bool" Usage="taskScheduler.TryExecuteTaskInline (task, taskWasPreviouslyQueued)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="task" Type="System.Threading.Tasks.Task" />
        <Parameter Name="taskWasPreviouslyQueued" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="task">
          <span data-ttu-id="14cc1-252">O <see cref="T:System.Threading.Tasks.Task" /> a ser executado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="14cc1-252">The <see cref="T:System.Threading.Tasks.Task" /> to be executed.</span>
          </span>
        </param>
        <param name="taskWasPreviouslyQueued">
          <span data-ttu-id="14cc1-253">Um booliano que indica se a tarefa foi colocada na fila anteriormente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="14cc1-253">A Boolean denoting whether or not task has previously been queued.</span>
          </span>
          <span data-ttu-id="14cc1-254">Se esse parâmetro for True, talvez a tarefa tenha sido colocada na fila anteriormente (agendada); se for False, será indicado que a tarefa não foi colocada na fila e essa chamada está sendo feita para executar a tarefa embutida sem colocá-la na fila.</span>
          <span class="sxs-lookup">
            <span data-stu-id="14cc1-254">If this parameter is True, then the task may have been previously queued (scheduled); if False, then the task is known not to have been queued, and this call is being made in order to execute the task inline without queuing it.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="14cc1-255">Determina se o <see cref="T:System.Threading.Tasks.Task" /> fornecido pode ser executado de forma síncrona nessa chamada e, se for possível, o executa.</span>
          <span class="sxs-lookup">
            <span data-stu-id="14cc1-255">Determines whether the provided <see cref="T:System.Threading.Tasks.Task" /> can be executed synchronously in this call, and if it can, executes it.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="14cc1-256">Um valor booliano que indica se a tarefa foi executada embutida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="14cc1-256">A Boolean value indicating whether the task was executed inline.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="14cc1-257">Uma classe derivada de <xref:System.Threading.Tasks.TaskScheduler> implementa essa função para dar suporte à execução embutida de uma tarefa em um thread que inicia uma espera nesse objeto de tarefa.</span><span class="sxs-lookup"><span data-stu-id="14cc1-257">A class derived from <xref:System.Threading.Tasks.TaskScheduler> implements this function to support inline execution of a task on a thread that initiates a wait on that task object.</span></span> <span data-ttu-id="14cc1-258">Execução embutida é opcional, e a solicitação pode ser rejeitada, retornando false.</span><span class="sxs-lookup"><span data-stu-id="14cc1-258">Inline execution is optional, and the request may be rejected by returning false.</span></span> <span data-ttu-id="14cc1-259">No entanto, as tarefas mais que pode ser embutida, melhor o Agendador será dimensionado.</span><span class="sxs-lookup"><span data-stu-id="14cc1-259">However, the more tasks that can be inlined, the better the scheduler will scale.</span></span> <span data-ttu-id="14cc1-260">Na verdade, um agendador que inlines muito pouco pode ser propensa a deadlocks.</span><span class="sxs-lookup"><span data-stu-id="14cc1-260">In fact, a scheduler that inlines too little may be prone to deadlocks.</span></span> <span data-ttu-id="14cc1-261">Uma implementação apropriada deve garantir que uma solicitação em execução sob as diretivas garantidas pelo Agendador com êxito pode embutir.</span><span class="sxs-lookup"><span data-stu-id="14cc1-261">A proper implementation should ensure that a request executing under the policies guaranteed by the scheduler can successfully inline.</span></span> <span data-ttu-id="14cc1-262">Por exemplo, se um agendador usa um thread dedicado para executar tarefas, as solicitações de inlining desse thread devem ter êxito.</span><span class="sxs-lookup"><span data-stu-id="14cc1-262">For example, if a scheduler uses a dedicated thread to execute tasks, any inlining requests from that thread should succeed.</span></span>  
  
 <span data-ttu-id="14cc1-263">Se decidir um agendador realizar a execução embutida, ele deve fazer isso chamando o TaskScheduler base <xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A> método com o objeto de tarefa fornecido, propagando o valor de retorno.</span><span class="sxs-lookup"><span data-stu-id="14cc1-263">If a scheduler decides to perform the inline execution, it should do so by calling to the base TaskScheduler's <xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A> method with the provided task object, propagating the return value.</span></span> <span data-ttu-id="14cc1-264">Também pode ser apropriado para o Agendador remover uma tarefa embutida de suas estruturas de dados interna se decidir aceitar o pedido de inlining.</span><span class="sxs-lookup"><span data-stu-id="14cc1-264">It may also be appropriate for the scheduler to remove an inlined task from its internal data structures if it decides to honor the inlining request.</span></span> <span data-ttu-id="14cc1-265">No entanto, observe que em algumas circunstâncias um agendador poderá ser solicitado para embutir uma tarefa que anteriormente não foi fornecida a ele com o <xref:System.Threading.Tasks.TaskScheduler.QueueTask%2A> método.</span><span class="sxs-lookup"><span data-stu-id="14cc1-265">Note, however, that under some circumstances a scheduler may be asked to inline a task that was not previously provided to it with the <xref:System.Threading.Tasks.TaskScheduler.QueueTask%2A> method.</span></span>  
  
 <span data-ttu-id="14cc1-266">O Agendador derivado é responsável por certificar-se de que o thread de chamada é adequado para executar a tarefa específica no seu próprio agendamento e com a preocupação de políticas de execução.</span><span class="sxs-lookup"><span data-stu-id="14cc1-266">The derived scheduler is responsible for making sure that the calling thread is suitable for executing the given task as far as its own scheduling and execution policies are concerned.</span></span>  
  
 <span data-ttu-id="14cc1-267">Para obter mais informações, consulte [agendadores de tarefa](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65).</span><span class="sxs-lookup"><span data-stu-id="14cc1-267">For more information, see [Task Schedulers](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="14cc1-268">O argumento <paramref name="task" /> é nulo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="14cc1-268">The <paramref name="task" /> argument is null.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="14cc1-269">O <paramref name="task" /> já foi executado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="14cc1-269">The <paramref name="task" /> was already executed.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="UnobservedTaskException">
      <MemberSignature Language="C#" Value="public static event EventHandler&lt;System.Threading.Tasks.UnobservedTaskExceptionEventArgs&gt; UnobservedTaskException;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Threading.Tasks.UnobservedTaskExceptionEventArgs&gt; UnobservedTaskException" />
      <MemberSignature Language="DocId" Value="E:System.Threading.Tasks.TaskScheduler.UnobservedTaskException" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event UnobservedTaskException As EventHandler(Of UnobservedTaskExceptionEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler&lt;System::Threading::Tasks::UnobservedTaskExceptionEventArgs ^&gt; ^ UnobservedTaskException;" />
      <MemberSignature Language="F#" Value="member this.UnobservedTaskException : EventHandler&lt;System.Threading.Tasks.UnobservedTaskExceptionEventArgs&gt; " Usage="member this.UnobservedTaskException : System.EventHandler&lt;System.Threading.Tasks.UnobservedTaskExceptionEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Threading.Tasks.UnobservedTaskExceptionEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="14cc1-270">Ocorre quando a exceção não observada da tarefa com falha está prestes a disparar a política de escalonamento de exceção, que, por padrão, encerrará o processo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="14cc1-270">Occurs when a faulted task's unobserved exception is about to trigger exception escalation policy, which, by default, would terminate the process.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="14cc1-271">Esse evento de todo o domínio de aplicativo fornece um mecanismo para impedir que a diretiva de escalonamento de exceção (que, por padrão, encerra o processo) de disparo.</span><span class="sxs-lookup"><span data-stu-id="14cc1-271">This application domain-wide event provides a mechanism to prevent exception escalation policy (which, by default, terminates the process) from triggering.</span></span>  
  
 <span data-ttu-id="14cc1-272">Para tornar mais fácil para os desenvolvedores a escrever código assíncrono com base em tarefas, o [!INCLUDE[net_v45](~/includes/net-v45-md.md)] altera o comportamento de exceção padrão para exceções não observadas que.</span><span class="sxs-lookup"><span data-stu-id="14cc1-272">To make it easier for developers to write asynchronous code based on tasks, the [!INCLUDE[net_v45](~/includes/net-v45-md.md)] changes the default exception behavior for unobserved exceptions.</span></span> <span data-ttu-id="14cc1-273">Embora geram exceções não observadas que ainda o <xref:System.Threading.Tasks.TaskScheduler.UnobservedTaskException> exceção, o processo não encerra por padrão.</span><span class="sxs-lookup"><span data-stu-id="14cc1-273">Although unobserved exceptions still raise the <xref:System.Threading.Tasks.TaskScheduler.UnobservedTaskException> exception, the process does not terminate by default.</span></span> <span data-ttu-id="14cc1-274">Em vez disso, a exceção é manipulada pelo tempo de execução depois que o evento é acionado, independentemente se um manipulador de eventos observa a exceção.</span><span class="sxs-lookup"><span data-stu-id="14cc1-274">Instead, the exception is handled by the runtime after the event is raised, regardless of whether an event handler observes the exception.</span></span> <span data-ttu-id="14cc1-275">Esse comportamento pode ser configurado.</span><span class="sxs-lookup"><span data-stu-id="14cc1-275">This behavior can be configured.</span></span> <span data-ttu-id="14cc1-276">Começando com o [!INCLUDE[net_v45](~/includes/net-v45-md.md)], você pode usar o elemento de configuração para reverter para o comportamento do [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] e encerrar o processo:</span><span class="sxs-lookup"><span data-stu-id="14cc1-276">Starting with the [!INCLUDE[net_v45](~/includes/net-v45-md.md)], you can use the  configuration element to revert to the behavior of the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] and terminate the process:</span></span>  
  
```xml  
<configuration>   
   <runtime>   
      <ThrowUnobservedTaskExceptions enabled="true"/>   
   </runtime>   
</configuration>  
  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>