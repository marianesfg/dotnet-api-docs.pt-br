<Type Name="SymWriter" FullName="System.Diagnostics.SymbolStore.SymWriter">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="4499bf1771d4fbd358a6ff7d9c9d6eb5ddbbd4d6" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="pt-BR" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39886900" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class SymWriter : System.Diagnostics.SymbolStore.SymWriterBase, IDisposable, System.Diagnostics.SymbolStore.ISymbolWriter" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit SymWriter extends System.Diagnostics.SymbolStore.SymWriterBase implements class System.Diagnostics.SymbolStore.ISymbolWriter, class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Diagnostics.SymbolStore.SymWriter" />
  <TypeSignature Language="VB.NET" Value="Public Class SymWriter&#xA;Inherits SymWriterBase&#xA;Implements IDisposable, ISymbolWriter" />
  <TypeSignature Language="C++ CLI" Value="public ref class SymWriter : System::Diagnostics::SymbolStore::SymWriterBase, IDisposable, System::Diagnostics::SymbolStore::ISymbolWriter" />
  <TypeSignature Language="F#" Value="type SymWriter = class&#xA;    inherit SymWriterBase&#xA;    interface ISymbolWriter&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>ISymWrapper</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Diagnostics.SymbolStore.SymWriterBase</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-1.1">System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Diagnostics.SymbolStore.ISymbolWriter</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Representa um gravador de símbolo do código gerenciado.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Diagnostics.SymbolStore.SymWriter> classe fornece métodos que definem pontos de sequência, documentos, escopos léxicos e variáveis.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SymWriter ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.SymbolStore.SymWriter.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SymWriter();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>ISymWrapper</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Diagnostics.SymbolStore.SymWriter" />.</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para a capacidade de acessar código não gerenciado.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SymWriter (bool noUnderlyingWriter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool noUnderlyingWriter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.SymbolStore.SymWriter.#ctor(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (noUnderlyingWriter As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SymWriter(bool noUnderlyingWriter);" />
      <MemberSignature Language="F#" Value="new System.Diagnostics.SymbolStore.SymWriter : bool -&gt; System.Diagnostics.SymbolStore.SymWriter" Usage="new System.Diagnostics.SymbolStore.SymWriter noUnderlyingWriter" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>ISymWrapper</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="noUnderlyingWriter" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="noUnderlyingWriter">
          <see langword="true" /> se um gravador de símbolo subjacente for fornecido ao chamar o método <see cref="M:System.Diagnostics.SymbolStore.SymWriter.SetUnderlyingWriter(System.IntPtr)" /> e <see langword="false" /> se um gravador de símbolo subjacente padrão precisar ser criado nesse caso.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Diagnostics.SymbolStore.SymWriter" />, especificando se deseja criar um gravador de símbolo subjacente.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="__dtor">
      <MemberSignature Language="C#" Value="public void __dtor ();" />
      <MemberSignature Language="ILAsm" Value=".method public instance void __dtor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.SymbolStore.SymWriter.__dtor" />
      <MemberSignature Language="VB.NET" Value="Public Sub __dtor ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void __dtor();" />
      <MemberSignature Language="F#" Value="member this.__dtor : unit -&gt; unit" Usage="symWriter.__dtor " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>ISymWrapper</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="{dtor}">
      <MemberSignature Language="C#" Value="public void {dtor} ();" />
      <MemberSignature Language="ILAsm" Value=".method public instance void {dtor}() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.SymbolStore.SymWriter.{dtor}" />
      <MemberSignature Language="VB.NET" Value="Public Sub {dtor} ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void {dtor}();" />
      <MemberSignature Language="F#" Value="member this.{dtor} : unit -&gt; unit" Usage="symWriter.{dtor} " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>ISymWrapper</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libera os recursos mantidos pela instância atual do objeto <see cref="T:System.Diagnostics.SymbolStore.SymWriter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

Use o <xref:System.Diagnostics.SymbolStore.SymWriter.Finalize> método para liberar recursos.
  
 ]]></format>
        </remarks>
        <forInternalUseOnly />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public virtual void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.SymbolStore.SymWriter.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Close();" />
      <MemberSignature Language="F#" Value="abstract member Close : unit -&gt; unit&#xA;override this.Close : unit -&gt; unit" Usage="symWriter.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>ISymWrapper</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Fecha o <see cref="T:System.Diagnostics.SymbolStore.SymWriter" /> e confirma os símbolos para o repositório de símbolos.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Após esta chamada, o <xref:System.Diagnostics.SymbolStore.SymWriter> se torna inválido para obter informações mais atualizadas.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CloseMethod">
      <MemberSignature Language="C#" Value="public virtual void CloseMethod ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CloseMethod() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.SymbolStore.SymWriter.CloseMethod" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub CloseMethod ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CloseMethod();" />
      <MemberSignature Language="F#" Value="abstract member CloseMethod : unit -&gt; unit&#xA;override this.CloseMethod : unit -&gt; unit" Usage="symWriter.CloseMethod " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>ISymWrapper</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Fecha o método atual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Depois que um método é fechado, você não pode definir um símbolo de dentro do método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CloseNamespace">
      <MemberSignature Language="C#" Value="public virtual void CloseNamespace ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CloseNamespace() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.SymbolStore.SymWriter.CloseNamespace" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub CloseNamespace ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CloseNamespace();" />
      <MemberSignature Language="F#" Value="abstract member CloseNamespace : unit -&gt; unit&#xA;override this.CloseNamespace : unit -&gt; unit" Usage="symWriter.CloseNamespace " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>ISymWrapper</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Fecha o namespace mais recente.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CloseScope">
      <MemberSignature Language="C#" Value="public virtual void CloseScope (int endOffset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CloseScope(int32 endOffset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.SymbolStore.SymWriter.CloseScope(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub CloseScope (endOffset As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CloseScope(int endOffset);" />
      <MemberSignature Language="F#" Value="abstract member CloseScope : int -&gt; unit&#xA;override this.CloseScope : int -&gt; unit" Usage="symWriter.CloseScope endOffset" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>ISymWrapper</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="endOffset" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="endOffset">O deslocamento de IL logo após a última instrução no escopo.</param>
        <summary>Fecha o escopo léxico atual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Depois que um escopo é fechado, você não pode definir uma variável de dentro do método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefineDocument">
      <MemberSignature Language="C#" Value="public virtual System.Diagnostics.SymbolStore.ISymbolDocumentWriter DefineDocument (string url, Guid language, Guid languageVendor, Guid documentType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Diagnostics.SymbolStore.ISymbolDocumentWriter DefineDocument(string url, valuetype System.Guid language, valuetype System.Guid languageVendor, valuetype System.Guid documentType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.SymbolStore.SymWriter.DefineDocument(System.String,System.Guid,System.Guid,System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function DefineDocument (url As String, language As Guid, languageVendor As Guid, documentType As Guid) As ISymbolDocumentWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Diagnostics::SymbolStore::ISymbolDocumentWriter ^ DefineDocument(System::String ^ url, Guid language, Guid languageVendor, Guid documentType);" />
      <MemberSignature Language="F#" Value="abstract member DefineDocument : string * Guid * Guid * Guid -&gt; System.Diagnostics.SymbolStore.ISymbolDocumentWriter&#xA;override this.DefineDocument : string * Guid * Guid * Guid -&gt; System.Diagnostics.SymbolStore.ISymbolDocumentWriter" Usage="symWriter.DefineDocument (url, language, languageVendor, documentType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>ISymWrapper</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.SymbolStore.ISymbolDocumentWriter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="url" Type="System.String" />
        <Parameter Name="language" Type="System.Guid" />
        <Parameter Name="languageVendor" Type="System.Guid" />
        <Parameter Name="documentType" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="url">A URL que identifica o documento.</param>
        <param name="language">O idioma do documento. Esse parâmetro pode ser <see cref="F:System.Guid.Empty" />.</param>
        <param name="languageVendor">A identidade do fornecedor para o idioma do documento. Esse parâmetro pode ser <see cref="F:System.Guid.Empty" />.</param>
        <param name="documentType">O tipo do documento. Esse parâmetro pode ser <see cref="F:System.Guid.Empty" />.</param>
        <summary>Define um documento de origem.</summary>
        <returns>O objeto <see cref="T:System.Diagnostics.SymbolStore.ISymbolDocumentWriter" /> que representa o documento.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefineField">
      <MemberSignature Language="C#" Value="public virtual void DefineField (System.Diagnostics.SymbolStore.SymbolToken parent, string name, System.Reflection.FieldAttributes attributes, byte[] signature, System.Diagnostics.SymbolStore.SymAddressKind addrKind, int addr1, int addr2, int addr3);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DefineField(valuetype System.Diagnostics.SymbolStore.SymbolToken parent, string name, valuetype System.Reflection.FieldAttributes attributes, unsigned int8[] signature, valuetype System.Diagnostics.SymbolStore.SymAddressKind addrKind, int32 addr1, int32 addr2, int32 addr3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.SymbolStore.SymWriter.DefineField(System.Diagnostics.SymbolStore.SymbolToken,System.String,System.Reflection.FieldAttributes,System.Byte[],System.Diagnostics.SymbolStore.SymAddressKind,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub DefineField (parent As SymbolToken, name As String, attributes As FieldAttributes, signature As Byte(), addrKind As SymAddressKind, addr1 As Integer, addr2 As Integer, addr3 As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void DefineField(System::Diagnostics::SymbolStore::SymbolToken parent, System::String ^ name, System::Reflection::FieldAttributes attributes, cli::array &lt;System::Byte&gt; ^ signature, System::Diagnostics::SymbolStore::SymAddressKind addrKind, int addr1, int addr2, int addr3);" />
      <MemberSignature Language="F#" Value="abstract member DefineField : System.Diagnostics.SymbolStore.SymbolToken * string * System.Reflection.FieldAttributes * byte[] * System.Diagnostics.SymbolStore.SymAddressKind * int * int * int -&gt; unit&#xA;override this.DefineField : System.Diagnostics.SymbolStore.SymbolToken * string * System.Reflection.FieldAttributes * byte[] * System.Diagnostics.SymbolStore.SymAddressKind * int * int * int -&gt; unit" Usage="symWriter.DefineField (parent, name, attributes, signature, addrKind, addr1, addr2, addr3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>ISymWrapper</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parent" Type="System.Diagnostics.SymbolStore.SymbolToken" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.FieldAttributes" />
        <Parameter Name="signature" Type="System.Byte[]" />
        <Parameter Name="addrKind" Type="System.Diagnostics.SymbolStore.SymAddressKind" />
        <Parameter Name="addr1" Type="System.Int32" />
        <Parameter Name="addr2" Type="System.Int32" />
        <Parameter Name="addr3" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="parent">Este parâmetro não é usado.</param>
        <param name="name">Este parâmetro não é usado.</param>
        <param name="attributes">Este parâmetro não é usado.</param>
        <param name="signature">Este parâmetro não é usado.</param>
        <param name="addrKind">Este parâmetro não é usado.</param>
        <param name="addr1">Este parâmetro não é usado.</param>
        <param name="addr2">Este parâmetro não é usado.</param>
        <param name="addr3">Este parâmetro não é usado.</param>
        <summary>Gera um <see cref="T:System.NotSupportedException" /> em todos os casos.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">Em todos os casos.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineGlobalVariable">
      <MemberSignature Language="C#" Value="public virtual void DefineGlobalVariable (string name, System.Reflection.FieldAttributes attributes, byte[] signature, System.Diagnostics.SymbolStore.SymAddressKind addrKind, int addr1, int addr2, int addr3);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DefineGlobalVariable(string name, valuetype System.Reflection.FieldAttributes attributes, unsigned int8[] signature, valuetype System.Diagnostics.SymbolStore.SymAddressKind addrKind, int32 addr1, int32 addr2, int32 addr3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.SymbolStore.SymWriter.DefineGlobalVariable(System.String,System.Reflection.FieldAttributes,System.Byte[],System.Diagnostics.SymbolStore.SymAddressKind,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub DefineGlobalVariable (name As String, attributes As FieldAttributes, signature As Byte(), addrKind As SymAddressKind, addr1 As Integer, addr2 As Integer, addr3 As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void DefineGlobalVariable(System::String ^ name, System::Reflection::FieldAttributes attributes, cli::array &lt;System::Byte&gt; ^ signature, System::Diagnostics::SymbolStore::SymAddressKind addrKind, int addr1, int addr2, int addr3);" />
      <MemberSignature Language="F#" Value="abstract member DefineGlobalVariable : string * System.Reflection.FieldAttributes * byte[] * System.Diagnostics.SymbolStore.SymAddressKind * int * int * int -&gt; unit&#xA;override this.DefineGlobalVariable : string * System.Reflection.FieldAttributes * byte[] * System.Diagnostics.SymbolStore.SymAddressKind * int * int * int -&gt; unit" Usage="symWriter.DefineGlobalVariable (name, attributes, signature, addrKind, addr1, addr2, addr3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>ISymWrapper</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.FieldAttributes" />
        <Parameter Name="signature" Type="System.Byte[]" />
        <Parameter Name="addrKind" Type="System.Diagnostics.SymbolStore.SymAddressKind" />
        <Parameter Name="addr1" Type="System.Int32" />
        <Parameter Name="addr2" Type="System.Int32" />
        <Parameter Name="addr3" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="name">Este parâmetro não é usado.</param>
        <param name="attributes">Este parâmetro não é usado.</param>
        <param name="signature">Este parâmetro não é usado.</param>
        <param name="addrKind">Este parâmetro não é usado.</param>
        <param name="addr1">Este parâmetro não é usado.</param>
        <param name="addr2">Este parâmetro não é usado.</param>
        <param name="addr3">Este parâmetro não é usado.</param>
        <summary>Gera um <see cref="T:System.NotSupportedException" /> em todos os casos.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">Em todos os casos.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineLocalVariable">
      <MemberSignature Language="C#" Value="public virtual void DefineLocalVariable (string name, System.Reflection.FieldAttributes attributes, byte[] signature, System.Diagnostics.SymbolStore.SymAddressKind addrKind, int addr1, int addr2, int addr3, int startOffset, int endOffset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DefineLocalVariable(string name, valuetype System.Reflection.FieldAttributes attributes, unsigned int8[] signature, valuetype System.Diagnostics.SymbolStore.SymAddressKind addrKind, int32 addr1, int32 addr2, int32 addr3, int32 startOffset, int32 endOffset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.SymbolStore.SymWriter.DefineLocalVariable(System.String,System.Reflection.FieldAttributes,System.Byte[],System.Diagnostics.SymbolStore.SymAddressKind,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub DefineLocalVariable (name As String, attributes As FieldAttributes, signature As Byte(), addrKind As SymAddressKind, addr1 As Integer, addr2 As Integer, addr3 As Integer, startOffset As Integer, endOffset As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void DefineLocalVariable(System::String ^ name, System::Reflection::FieldAttributes attributes, cli::array &lt;System::Byte&gt; ^ signature, System::Diagnostics::SymbolStore::SymAddressKind addrKind, int addr1, int addr2, int addr3, int startOffset, int endOffset);" />
      <MemberSignature Language="F#" Value="abstract member DefineLocalVariable : string * System.Reflection.FieldAttributes * byte[] * System.Diagnostics.SymbolStore.SymAddressKind * int * int * int * int * int -&gt; unit&#xA;override this.DefineLocalVariable : string * System.Reflection.FieldAttributes * byte[] * System.Diagnostics.SymbolStore.SymAddressKind * int * int * int * int * int -&gt; unit" Usage="symWriter.DefineLocalVariable (name, attributes, signature, addrKind, addr1, addr2, addr3, startOffset, endOffset)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>ISymWrapper</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.FieldAttributes" />
        <Parameter Name="signature" Type="System.Byte[]" />
        <Parameter Name="addrKind" Type="System.Diagnostics.SymbolStore.SymAddressKind" />
        <Parameter Name="addr1" Type="System.Int32" />
        <Parameter Name="addr2" Type="System.Int32" />
        <Parameter Name="addr3" Type="System.Int32" />
        <Parameter Name="startOffset" Type="System.Int32" />
        <Parameter Name="endOffset" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="name">O nome da variável local.</param>
        <param name="attributes">Os atributos da variável local especificados usando o enumerador <see cref="T:System.Reflection.FieldAttributes" />.</param>
        <param name="signature">A assinatura da variável local.</param>
        <param name="addrKind">Os tipos de endereço para <c>addr1</c>, <c>addr2</c> e <c>addr3</c> usando <see cref="T:System.Diagnostics.SymbolStore.SymAddressKind" />.</param>
        <param name="addr1">O primeiro endereço para a especificação da variável local.</param>
        <param name="addr2">O segundo endereço para a especificação da variável local.</param>
        <param name="addr3">O terceiro endereço para a especificação da variável local.</param>
        <param name="startOffset">O deslocamento inicial da variável. Se for zero, este parâmetro será ignorado e a variável será definida ao longo de todo o escopo. Se for diferente de zero, estará dentro dos deslocamentos do escopo atual.</param>
        <param name="endOffset">O deslocamento final da variável. Se for zero, este parâmetro será ignorado e a variável será definida ao longo de todo o escopo. Se for diferente de zero, estará dentro dos deslocamentos do escopo atual.</param>
        <summary>Define uma única variável no escopo léxico atual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `startOffset` e `endOffset` parâmetros são opcionais. Se seu valor for zero, eles serão ignorados e a variável será definida ao longo de todo o escopo. Se seu valor for diferente de zero, eles se encaixam dentro dos deslocamentos do escopo atual.  
  
 Você pode chamar <xref:System.Diagnostics.SymbolStore.SymWriter.DefineLocalVariable%2A> várias vezes para uma variável de mesmo nome ocorre várias vezes em diferentes intervalos de deslocamento ao longo de um escopo. (Nesse caso, os deslocamentos de início e término não devem se sobrepor.)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefineParameter">
      <MemberSignature Language="C#" Value="public virtual void DefineParameter (string name, System.Reflection.ParameterAttributes attributes, int sequence, System.Diagnostics.SymbolStore.SymAddressKind addrKind, int addr1, int addr2, int addr3);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DefineParameter(string name, valuetype System.Reflection.ParameterAttributes attributes, int32 sequence, valuetype System.Diagnostics.SymbolStore.SymAddressKind addrKind, int32 addr1, int32 addr2, int32 addr3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.SymbolStore.SymWriter.DefineParameter(System.String,System.Reflection.ParameterAttributes,System.Int32,System.Diagnostics.SymbolStore.SymAddressKind,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub DefineParameter (name As String, attributes As ParameterAttributes, sequence As Integer, addrKind As SymAddressKind, addr1 As Integer, addr2 As Integer, addr3 As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void DefineParameter(System::String ^ name, System::Reflection::ParameterAttributes attributes, int sequence, System::Diagnostics::SymbolStore::SymAddressKind addrKind, int addr1, int addr2, int addr3);" />
      <MemberSignature Language="F#" Value="abstract member DefineParameter : string * System.Reflection.ParameterAttributes * int * System.Diagnostics.SymbolStore.SymAddressKind * int * int * int -&gt; unit&#xA;override this.DefineParameter : string * System.Reflection.ParameterAttributes * int * System.Diagnostics.SymbolStore.SymAddressKind * int * int * int -&gt; unit" Usage="symWriter.DefineParameter (name, attributes, sequence, addrKind, addr1, addr2, addr3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>ISymWrapper</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.ParameterAttributes" />
        <Parameter Name="sequence" Type="System.Int32" />
        <Parameter Name="addrKind" Type="System.Diagnostics.SymbolStore.SymAddressKind" />
        <Parameter Name="addr1" Type="System.Int32" />
        <Parameter Name="addr2" Type="System.Int32" />
        <Parameter Name="addr3" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="name">Este parâmetro não é usado.</param>
        <param name="attributes">Este parâmetro não é usado.</param>
        <param name="sequence">Este parâmetro não é usado.</param>
        <param name="addrKind">Este parâmetro não é usado.</param>
        <param name="addr1">Este parâmetro não é usado.</param>
        <param name="addr2">Este parâmetro não é usado.</param>
        <param name="addr3">Este parâmetro não é usado.</param>
        <summary>Gera um <see cref="T:System.NotSupportedException" /> em todos os casos.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">Em todos os casos.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineSequencePoints">
      <MemberSignature Language="C#" Value="public virtual void DefineSequencePoints (System.Diagnostics.SymbolStore.ISymbolDocumentWriter document, int[] offsets, int[] lines, int[] columns, int[] endLines, int[] endColumns);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DefineSequencePoints(class System.Diagnostics.SymbolStore.ISymbolDocumentWriter document, int32[] offsets, int32[] lines, int32[] columns, int32[] endLines, int32[] endColumns) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.SymbolStore.SymWriter.DefineSequencePoints(System.Diagnostics.SymbolStore.ISymbolDocumentWriter,System.Int32[],System.Int32[],System.Int32[],System.Int32[],System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub DefineSequencePoints (document As ISymbolDocumentWriter, offsets As Integer(), lines As Integer(), columns As Integer(), endLines As Integer(), endColumns As Integer())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void DefineSequencePoints(System::Diagnostics::SymbolStore::ISymbolDocumentWriter ^ document, cli::array &lt;int&gt; ^ offsets, cli::array &lt;int&gt; ^ lines, cli::array &lt;int&gt; ^ columns, cli::array &lt;int&gt; ^ endLines, cli::array &lt;int&gt; ^ endColumns);" />
      <MemberSignature Language="F#" Value="abstract member DefineSequencePoints : System.Diagnostics.SymbolStore.ISymbolDocumentWriter * int[] * int[] * int[] * int[] * int[] -&gt; unit&#xA;override this.DefineSequencePoints : System.Diagnostics.SymbolStore.ISymbolDocumentWriter * int[] * int[] * int[] * int[] * int[] -&gt; unit" Usage="symWriter.DefineSequencePoints (document, offsets, lines, columns, endLines, endColumns)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>ISymWrapper</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="document" Type="System.Diagnostics.SymbolStore.ISymbolDocumentWriter" />
        <Parameter Name="offsets" Type="System.Int32[]" />
        <Parameter Name="lines" Type="System.Int32[]" />
        <Parameter Name="columns" Type="System.Int32[]" />
        <Parameter Name="endLines" Type="System.Int32[]" />
        <Parameter Name="endColumns" Type="System.Int32[]" />
      </Parameters>
      <Docs>
        <param name="document">O objeto de documento para o qual os pontos de sequência estão sendo definidos.</param>
        <param name="offsets">O deslocamento de IL dos pontos de sequência, medidos a partir do início do método.</param>
        <param name="lines">Os números de linha iniciais dos pontos de sequência.</param>
        <param name="columns">Os números de coluna iniciais dos pontos de sequência.</param>
        <param name="endLines">Os números de linha finais dos pontos de sequência.</param>
        <param name="endColumns">Os números da coluna finais dos pontos de sequência.</param>
        <summary>Define um grupo de pontos de sequência dentro do método atual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pontos de sequência são usados para mapear entre locais de arquivo de origem e os deslocamentos de IL.  Cada ponto de sequência consiste em uma IL deslocamento e a fonte de arquivo região, especificada por números de início e término de linha/coluna relativo a um <xref:System.Diagnostics.SymbolStore.ISymbolDocument> objeto.  Cada elemento em um índice específico de cada matriz corresponde a um ponto de sequência específico. Cada linha e coluna definem o início de uma instrução dentro de um método. As matrizes devem ser classificadas em ordem crescente de deslocamentos. O deslocamento é sempre o deslocamento do início do método, em bytes.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public override sealed void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.SymbolStore.SymWriter.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="symWriter.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>ISymWrapper</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libera os recursos usados pela instância atual da classe <see cref="T:System.Diagnostics.SymbolStore.SymWriter" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool A_0);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool A_0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.SymbolStore.SymWriter.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (A_0 As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool A_0);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="symWriter.Dispose A_0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>ISymWrapper</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptions</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="A_0" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="A_0">
          <see langword="true" /> para liberar recursos gerenciados e não gerenciados, <see langword="false" /> para liberar apenas recursos não gerenciados.</param>
        <summary>Chamado pelos métodos <see cref="M:System.Diagnostics.SymbolStore.SymWriter.Dispose" /> e <see cref="M:System.Diagnostics.SymbolStore.SymWriter.Finalize" /> para liberar os recursos gerenciados e não gerenciados usados pela instância atual da classe <see cref="T:System.Diagnostics.SymbolStore.SymWriter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é chamado somente pelo público <xref:System.Diagnostics.SymbolStore.SymWriter.Dispose%2A> e <xref:System.Diagnostics.SymbolStore.SymWriter.Finalize%2A> métodos; não chame este método diretamente.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~SymWriter ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.SymbolStore.SymWriter.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!SymWriter ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="symWriter.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>ISymWrapper</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libera recursos não gerenciados e executa outras operações de limpeza antes que <see cref="T:System.Diagnostics.SymbolStore.SymWriter" /> seja recuperado pela coleta de lixo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método substitui  <xref:System.Object.Finalize%2A>. O código do aplicativo não deve chamar este método; o método `Finalize` de um objeto é invocado automaticamente durante a coleta de lixo, a menos que a finalização pelo coletor de lixo tenha sido desabilitada por uma chamada para o método <xref:System.GC.SuppressFinalize%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetWriter">
      <MemberSignature Language="C#" Value="public ISymUnmanagedWriter* GetWriter ();" />
      <MemberSignature Language="ILAsm" Value=".method public instance ISymUnmanagedWriter* GetWriter() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.SymbolStore.SymWriter.GetWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ISymUnmanagedWriter* GetWriter();" />
      <MemberSignature Language="F#" Value="member this.GetWriter : unit -&gt; nativeptr&lt;ISymUnmanagedWriter&gt;" Usage="symWriter.GetWriter " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>ISymWrapper</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>ISymUnmanagedWriter*</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Initialize">
      <MemberSignature Language="C#" Value="public virtual void Initialize (IntPtr emitter, string filename, bool fFullBuild);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Initialize(native int emitter, string filename, bool fFullBuild) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.SymbolStore.SymWriter.Initialize(System.IntPtr,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Initialize (emitter As IntPtr, filename As String, fFullBuild As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Initialize(IntPtr emitter, System::String ^ filename, bool fFullBuild);" />
      <MemberSignature Language="F#" Value="abstract member Initialize : nativeint * string * bool -&gt; unit&#xA;override this.Initialize : nativeint * string * bool -&gt; unit" Usage="symWriter.Initialize (emitter, filename, fFullBuild)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>ISymWrapper</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="emitter" Type="System.IntPtr" />
        <Parameter Name="filename" Type="System.String" />
        <Parameter Name="fFullBuild" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="emitter">A interface do emissor de metadados.</param>
        <param name="filename">O nome do arquivo para o qual os símbolos de depuração são gravados. Alguns gravadores exigem um nome de arquivo, enquanto outros não. Se um nome de arquivo for especificado para um gravador que não use nomes de arquivo, esse parâmetro será ignorado.</param>
        <param name="fFullBuild">
          <see langword="true" /> indica que se trata de uma recompilação completa; <see langword="false" /> indica uma compilação incremental.</param>
        <summary>Define a interface do emissor de metadados a ser associada a este gravador.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.SymbolStore.ISymbolWriter.Initialize%2A> também define o nome do arquivo de saída em que os símbolos de depuração são gravados. Esse método pode ser chamado apenas uma vez e deve ser chamado antes de quaisquer outros métodos de gravador são chamados.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para a capacidade de acessar código não gerenciado.</permission>
      </Docs>
    </Member>
    <Member MemberName="InitWriter">
      <MemberSignature Language="C#" Value="public void InitWriter (bool noUnderlyingWriter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InitWriter(bool noUnderlyingWriter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.SymbolStore.SymWriter.InitWriter(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub InitWriter (noUnderlyingWriter As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InitWriter(bool noUnderlyingWriter);" />
      <MemberSignature Language="F#" Value="member this.InitWriter : bool -&gt; unit" Usage="symWriter.InitWriter noUnderlyingWriter" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>ISymWrapper</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="noUnderlyingWriter" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="noUnderlyingWriter">
          <see langword="true" /> se um gravador de símbolo subjacente for fornecido ao chamar o método <see cref="M:System.Diagnostics.SymbolStore.SymWriter.SetUnderlyingWriter(System.IntPtr)" /> e <see langword="false" /> se um gravador de símbolo subjacente padrão precisar ser criado nesse caso.</param>
        <summary>Inicializa o gravador de símbolo. Esse método não deve ser chamado diretamente. Ele é chamado pelo construtor.</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para a capacidade de acessar código não gerenciado.</permission>
      </Docs>
    </Member>
    <Member MemberName="OpenMethod">
      <MemberSignature Language="C#" Value="public virtual void OpenMethod (System.Diagnostics.SymbolStore.SymbolToken method);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void OpenMethod(valuetype System.Diagnostics.SymbolStore.SymbolToken method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.SymbolStore.SymWriter.OpenMethod(System.Diagnostics.SymbolStore.SymbolToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub OpenMethod (method As SymbolToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void OpenMethod(System::Diagnostics::SymbolStore::SymbolToken method);" />
      <MemberSignature Language="F#" Value="abstract member OpenMethod : System.Diagnostics.SymbolStore.SymbolToken -&gt; unit&#xA;override this.OpenMethod : System.Diagnostics.SymbolStore.SymbolToken -&gt; unit" Usage="symWriter.OpenMethod method" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>ISymWrapper</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Diagnostics.SymbolStore.SymbolToken" />
      </Parameters>
      <Docs>
        <param name="method">O token de metadados do método a ser aberto.</param>
        <summary>Abre um método no qual as informações de símbolo serão colocadas.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O método especificado torna-se o método atual para chamadas para definir pontos de sequência, parâmetros e escopos léxicos. Há um escopo léxico implícito ao redor de todo o método. Reabrir um método que foi fechado anteriormente apaga qualquer símbolos definidos anteriormente para o método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OpenNamespace">
      <MemberSignature Language="C#" Value="public virtual void OpenNamespace (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void OpenNamespace(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.SymbolStore.SymWriter.OpenNamespace(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub OpenNamespace (name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void OpenNamespace(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member OpenNamespace : string -&gt; unit&#xA;override this.OpenNamespace : string -&gt; unit" Usage="symWriter.OpenNamespace name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>ISymWrapper</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">O nome do novo namespace.</param>
        <summary>Abre um novo namespace.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chame esse método antes de definir os métodos ou variáveis que existem dentro de um namespace. Namespaces podem ser aninhados.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OpenScope">
      <MemberSignature Language="C#" Value="public virtual int OpenScope (int startOffset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 OpenScope(int32 startOffset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.SymbolStore.SymWriter.OpenScope(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function OpenScope (startOffset As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int OpenScope(int startOffset);" />
      <MemberSignature Language="F#" Value="abstract member OpenScope : int -&gt; int&#xA;override this.OpenScope : int -&gt; int" Usage="symWriter.OpenScope startOffset" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>ISymWrapper</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startOffset" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startOffset">O deslocamento de IL em bytes do início do método até a primeira instrução no escopo léxico.</param>
        <summary>Abre um novo escopo léxico no método atual.</summary>
        <returns>Um identificador de escopo opaco que pode ser usado com <see cref="M:System.Diagnostics.SymbolStore.SymWriter.SetScopeRange(System.Int32,System.Int32,System.Int32)" /> para definir os deslocamentos de início e término de um escopo em um momento posterior. Nesse caso, os deslocamentos passados para <see cref="M:System.Diagnostics.SymbolStore.SymWriter.OpenScope(System.Int32)" /> e <see cref="M:System.Diagnostics.SymbolStore.SymWriter.CloseScope(System.Int32)" /> são ignorados. Um identificador de escopo é válido somente no método atual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse escopo se torna o novo escopo atual e é enviada por push para uma pilha de escopos. Escopos devem formar uma hierarquia. Irmãos não podem se sobrepor.  
  
 Identificadores de escopo só são válidos no método atual.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetMethodSourceRange">
      <MemberSignature Language="C#" Value="public virtual void SetMethodSourceRange (System.Diagnostics.SymbolStore.ISymbolDocumentWriter startDoc, int startLine, int startColumn, System.Diagnostics.SymbolStore.ISymbolDocumentWriter endDoc, int endLine, int endColumn);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetMethodSourceRange(class System.Diagnostics.SymbolStore.ISymbolDocumentWriter startDoc, int32 startLine, int32 startColumn, class System.Diagnostics.SymbolStore.ISymbolDocumentWriter endDoc, int32 endLine, int32 endColumn) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.SymbolStore.SymWriter.SetMethodSourceRange(System.Diagnostics.SymbolStore.ISymbolDocumentWriter,System.Int32,System.Int32,System.Diagnostics.SymbolStore.ISymbolDocumentWriter,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub SetMethodSourceRange (startDoc As ISymbolDocumentWriter, startLine As Integer, startColumn As Integer, endDoc As ISymbolDocumentWriter, endLine As Integer, endColumn As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SetMethodSourceRange(System::Diagnostics::SymbolStore::ISymbolDocumentWriter ^ startDoc, int startLine, int startColumn, System::Diagnostics::SymbolStore::ISymbolDocumentWriter ^ endDoc, int endLine, int endColumn);" />
      <MemberSignature Language="F#" Value="abstract member SetMethodSourceRange : System.Diagnostics.SymbolStore.ISymbolDocumentWriter * int * int * System.Diagnostics.SymbolStore.ISymbolDocumentWriter * int * int -&gt; unit&#xA;override this.SetMethodSourceRange : System.Diagnostics.SymbolStore.ISymbolDocumentWriter * int * int * System.Diagnostics.SymbolStore.ISymbolDocumentWriter * int * int -&gt; unit" Usage="symWriter.SetMethodSourceRange (startDoc, startLine, startColumn, endDoc, endLine, endColumn)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>ISymWrapper</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startDoc" Type="System.Diagnostics.SymbolStore.ISymbolDocumentWriter" />
        <Parameter Name="startLine" Type="System.Int32" />
        <Parameter Name="startColumn" Type="System.Int32" />
        <Parameter Name="endDoc" Type="System.Diagnostics.SymbolStore.ISymbolDocumentWriter" />
        <Parameter Name="endLine" Type="System.Int32" />
        <Parameter Name="endColumn" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startDoc">Este parâmetro não é usado.</param>
        <param name="startLine">Este parâmetro não é usado.</param>
        <param name="startColumn">Este parâmetro não é usado.</param>
        <param name="endDoc">Este parâmetro não é usado.</param>
        <param name="endLine">Este parâmetro não é usado.</param>
        <param name="endColumn">Este parâmetro não é usado.</param>
        <summary>Gera um <see cref="T:System.NotSupportedException" /> em todos os casos.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">Em todos os casos.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetScopeRange">
      <MemberSignature Language="C#" Value="public virtual void SetScopeRange (int scopeID, int startOffset, int endOffset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetScopeRange(int32 scopeID, int32 startOffset, int32 endOffset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.SymbolStore.SymWriter.SetScopeRange(System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub SetScopeRange (scopeID As Integer, startOffset As Integer, endOffset As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SetScopeRange(int scopeID, int startOffset, int endOffset);" />
      <MemberSignature Language="F#" Value="abstract member SetScopeRange : int * int * int -&gt; unit&#xA;override this.SetScopeRange : int * int * int -&gt; unit" Usage="symWriter.SetScopeRange (scopeID, startOffset, endOffset)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>ISymWrapper</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scopeID" Type="System.Int32" />
        <Parameter Name="startOffset" Type="System.Int32" />
        <Parameter Name="endOffset" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="scopeID">O identificador do escopo léxico retornado pelo método <see cref="M:System.Diagnostics.SymbolStore.SymWriter.OpenScope(System.Int32)" />.</param>
        <param name="startOffset">O deslocamento de IL do início do escopo léxico.</param>
        <param name="endOffset">O deslocamento de IL do final do escopo léxico.</param>
        <summary>Define o intervalo de deslocamento do escopo léxico especificado.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetSymAttribute">
      <MemberSignature Language="C#" Value="public virtual void SetSymAttribute (System.Diagnostics.SymbolStore.SymbolToken parent, string name, byte[] data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetSymAttribute(valuetype System.Diagnostics.SymbolStore.SymbolToken parent, string name, unsigned int8[] data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.SymbolStore.SymWriter.SetSymAttribute(System.Diagnostics.SymbolStore.SymbolToken,System.String,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub SetSymAttribute (parent As SymbolToken, name As String, data As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SetSymAttribute(System::Diagnostics::SymbolStore::SymbolToken parent, System::String ^ name, cli::array &lt;System::Byte&gt; ^ data);" />
      <MemberSignature Language="F#" Value="abstract member SetSymAttribute : System.Diagnostics.SymbolStore.SymbolToken * string * byte[] -&gt; unit&#xA;override this.SetSymAttribute : System.Diagnostics.SymbolStore.SymbolToken * string * byte[] -&gt; unit" Usage="symWriter.SetSymAttribute (parent, name, data)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>ISymWrapper</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parent" Type="System.Diagnostics.SymbolStore.SymbolToken" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="data" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="parent">O token de metadados para o qual o atributo está sendo definido.</param>
        <param name="name">O nome do atributo.</param>
        <param name="data">O valor do atributo.</param>
        <summary>Define um atributo quando é fornecido o nome e o valor do atributo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Diagnostics.SymbolStore.SymWriter.SetSymAttribute%2A> método só está associado às informações simbólicas e não é um atributo de metadados personalizados.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetUnderlyingWriter">
      <MemberSignature Language="C#" Value="public virtual void SetUnderlyingWriter (IntPtr underlyingWriter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetUnderlyingWriter(native int underlyingWriter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.SymbolStore.SymWriter.SetUnderlyingWriter(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub SetUnderlyingWriter (underlyingWriter As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SetUnderlyingWriter(IntPtr underlyingWriter);" />
      <MemberSignature Language="F#" Value="abstract member SetUnderlyingWriter : nativeint -&gt; unit&#xA;override this.SetUnderlyingWriter : nativeint -&gt; unit" Usage="symWriter.SetUnderlyingWriter underlyingWriter" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>ISymWrapper</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="underlyingWriter" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="underlyingWriter">Um ponteiro de tipo <see cref="T:System.IntPtr" /> para o código que é o gravador subjacente.</param>
        <summary>Define a [Interface ISymUnmanagedWriter](~/docs/framework/unmanaged-api/diagnostics/isymunmanagedwriter-interface.md) subjacente (a API não gerenciada correspondente) que um <see cref="T:System.Diagnostics.SymbolStore.SymWriter" /> gerenciado usa para emitir símbolos.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Subjacente [ISymUnmanagedWriter Interface](~/docs/framework/unmanaged-api/diagnostics/isymunmanagedwriter-interface.md) (a API não gerenciada correspondente) interface representa um gravador de símbolo para código gerenciado. A interface fornece métodos para definir pontos de sequência, documentos, escopos léxicos e variáveis.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para a capacidade de acessar código não gerenciado.</permission>
      </Docs>
    </Member>
    <Member MemberName="SetUserEntryPoint">
      <MemberSignature Language="C#" Value="public virtual void SetUserEntryPoint (System.Diagnostics.SymbolStore.SymbolToken entryMethod);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetUserEntryPoint(valuetype System.Diagnostics.SymbolStore.SymbolToken entryMethod) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.SymbolStore.SymWriter.SetUserEntryPoint(System.Diagnostics.SymbolStore.SymbolToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub SetUserEntryPoint (entryMethod As SymbolToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SetUserEntryPoint(System::Diagnostics::SymbolStore::SymbolToken entryMethod);" />
      <MemberSignature Language="F#" Value="abstract member SetUserEntryPoint : System.Diagnostics.SymbolStore.SymbolToken -&gt; unit&#xA;override this.SetUserEntryPoint : System.Diagnostics.SymbolStore.SymbolToken -&gt; unit" Usage="symWriter.SetUserEntryPoint entryMethod" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>ISymWrapper</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entryMethod" Type="System.Diagnostics.SymbolStore.SymbolToken" />
      </Parameters>
      <Docs>
        <param name="entryMethod">O token de metadados do método que é o ponto de entrada do usuário.</param>
        <summary>Identifica o método definido pelo usuário como o ponto de entrada do módulo atual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Isso normalmente é o método principal.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UsingNamespace">
      <MemberSignature Language="C#" Value="public virtual void UsingNamespace (string fullName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void UsingNamespace(string fullName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.SymbolStore.SymWriter.UsingNamespace(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub UsingNamespace (fullName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void UsingNamespace(System::String ^ fullName);" />
      <MemberSignature Language="F#" Value="abstract member UsingNamespace : string -&gt; unit&#xA;override this.UsingNamespace : string -&gt; unit" Usage="symWriter.UsingNamespace fullName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>ISymWrapper</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fullName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fullName">O nome totalmente qualificado do namespace.</param>
        <summary>Especifica que o nome totalmente qualificado do namespace fornecido é usado dentro do escopo léxico aberto.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Fechar o escopo atual impede que esse escopo usando o namespace. O namespace permanece em uso em todos os escopos que herdam do escopo atual aberto.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>