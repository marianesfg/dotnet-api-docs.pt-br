<Type Name="Complex" FullName="System.Numerics.Complex">
  <TypeSignature Language="C#" Value="public struct Complex : IEquatable&lt;System.Numerics.Complex&gt;, IFormattable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit Complex extends System.ValueType implements class System.IEquatable`1&lt;valuetype System.Numerics.Complex&gt;, class System.IFormattable" />
  <TypeSignature Language="DocId" Value="T:System.Numerics.Complex" />
  <TypeSignature Language="VB.NET" Value="Public Structure Complex&#xA;Implements IEquatable(Of Complex), IFormattable" />
  <TypeSignature Language="C++ CLI" Value="public value class Complex : IEquatable&lt;System::Numerics::Complex&gt;, IFormattable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Numerics</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Numerics</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.Numerics.Complex&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IFormattable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary><span data-ttu-id="bcccb-101">Representa um número complexo.</span><span class="sxs-lookup"><span data-stu-id="bcccb-101">Represents a complex number.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bcccb-102">Um número complexo é um número que consiste em uma parte de número real e uma parte imaginária número.</span><span class="sxs-lookup"><span data-stu-id="bcccb-102">A complex number is a number that comprises a real number part and an imaginary number part.</span></span> <span data-ttu-id="bcccb-103">Um número complexo z geralmente é gravado no formato z = x + yi, onde *x* e *y* são números reais, e *,* é a unidade imaginária que tem a propriedade *,*<sup>2</sup> = -1.</span><span class="sxs-lookup"><span data-stu-id="bcccb-103">A complex number z is usually written in the form z = x + yi, where *x* and *y* are real numbers, and *i* is the imaginary unit that has the property *i*<sup>2</sup> = -1.</span></span> <span data-ttu-id="bcccb-104">A parte real do número complexo é representada por *x*, e a parte imaginária do número complexo é representada por *y*.</span><span class="sxs-lookup"><span data-stu-id="bcccb-104">The real part of the complex number is represented by *x*, and the imaginary part of the complex number is represented by *y*.</span></span>  
  
 <span data-ttu-id="bcccb-105">O <xref:System.Numerics.Complex> tipo usa o sistema de coordenadas cartesianas (real, imaginários) ao criar uma instância e manipular números complexos.</span><span class="sxs-lookup"><span data-stu-id="bcccb-105">The <xref:System.Numerics.Complex> type uses the Cartesian coordinate system (real, imaginary) when instantiating and manipulating complex numbers.</span></span> <span data-ttu-id="bcccb-106">Um número complexo pode ser representado como um ponto em um sistema de coordenadas bidimensional, que é conhecido como o plano complexos.</span><span class="sxs-lookup"><span data-stu-id="bcccb-106">A complex number can be represented as a point in a two-dimensional coordinate system, which is known as the complex plane.</span></span> <span data-ttu-id="bcccb-107">A parte real do número complexo é posicionada no eixo x (o eixo horizontal), e a parte imaginária é posicionada no eixo y (do eixo vertical).</span><span class="sxs-lookup"><span data-stu-id="bcccb-107">The real part of the complex number is positioned on the x-axis (the horizontal axis), and the imaginary part is positioned on the y-axis (the vertical axis).</span></span>  
  
 <span data-ttu-id="bcccb-108">Qualquer ponto no plano complexos também pode ser expressas com base em seu valor absoluto, usando o polar sistema de coordenadas., em coordenadas polares, um ponto é caracterizado por dois números:</span><span class="sxs-lookup"><span data-stu-id="bcccb-108">Any point in the complex plane can also be expressed based on its absolute value, by using the polar coordinate system., In polar coordinates, a point is characterized by two numbers:</span></span>  
  
-   <span data-ttu-id="bcccb-109">Sua magnitude, que é a distância do ponto de origem (ou seja, 0,0 ou o ponto no qual o eixo x e y interceptar).</span><span class="sxs-lookup"><span data-stu-id="bcccb-109">Its magnitude, which is the distance of the point from the origin (that is, 0,0, or the point at which the x-axis and the y-axis intersect).</span></span>  
  
-   <span data-ttu-id="bcccb-110">Sua fase, que é o ângulo entre o eixo real e a linha desenhada da origem para o ponto.</span><span class="sxs-lookup"><span data-stu-id="bcccb-110">Its phase, which is the angle between the real axis and the line drawn from the origin to the point.</span></span>  
  
## <a name="instantiating-a-complex-number"></a><span data-ttu-id="bcccb-111">Criando uma instância de um número complexo</span><span class="sxs-lookup"><span data-stu-id="bcccb-111">Instantiating a Complex Number</span></span>  
 <span data-ttu-id="bcccb-112">Você pode atribuir um valor para um número complexo em uma das seguintes maneiras:</span><span class="sxs-lookup"><span data-stu-id="bcccb-112">You can assign a value to a complex number in one of the following ways:</span></span>  
  
-   <span data-ttu-id="bcccb-113">Passando dois <xref:System.Double> valores para o construtor.</span><span class="sxs-lookup"><span data-stu-id="bcccb-113">By passing two <xref:System.Double> values to its constructor.</span></span> <span data-ttu-id="bcccb-114">O primeiro valor representa a parte real do número complexo, e o segundo valor representa sua parte imaginária.</span><span class="sxs-lookup"><span data-stu-id="bcccb-114">The first value represents the real part of the complex number, and the second value represents its imaginary part.</span></span> <span data-ttu-id="bcccb-115">Esses valores representam a posição do número complexo no sistema de coordenadas cartesianas bidimensional.</span><span class="sxs-lookup"><span data-stu-id="bcccb-115">These values represent the position of the complex number in the two-dimensional Cartesian coordinate system.</span></span>  
  
-   <span data-ttu-id="bcccb-116">Chamando estático (`Shared` no Visual Basic) <xref:System.Numerics.Complex.FromPolarCoordinates%2A?displayProperty=nameWithType> método para criar um número complexo de suas coordenadas polares.</span><span class="sxs-lookup"><span data-stu-id="bcccb-116">By calling the static (`Shared` in Visual Basic) <xref:System.Numerics.Complex.FromPolarCoordinates%2A?displayProperty=nameWithType> method to create a complex number from its polar coordinates.</span></span>  
  
-   <span data-ttu-id="bcccb-117">Atribuindo um <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, <xref:System.Single>, ou <xref:System.Double> valor para um <xref:System.Numerics.Complex> objeto.</span><span class="sxs-lookup"><span data-stu-id="bcccb-117">By assigning a <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, <xref:System.Single>, or <xref:System.Double> value to a <xref:System.Numerics.Complex> object.</span></span> <span data-ttu-id="bcccb-118">O valor se torna a parte real do número complexo, e sua parte imaginária é igual a 0.</span><span class="sxs-lookup"><span data-stu-id="bcccb-118">The value becomes the real part of the complex number, and its imaginary part equals 0.</span></span>  
  
-   <span data-ttu-id="bcccb-119">Conversão (em c#) ou convertendo (no Visual Basic) um <xref:System.Decimal> ou <xref:System.Numerics.BigInteger> valor para um <xref:System.Numerics.Complex> objeto.</span><span class="sxs-lookup"><span data-stu-id="bcccb-119">By casting (in C#) or converting (in Visual Basic) a <xref:System.Decimal> or <xref:System.Numerics.BigInteger> value to a <xref:System.Numerics.Complex> object.</span></span> <span data-ttu-id="bcccb-120">O valor se torna a parte real do número complexo, e sua parte imaginária é igual a 0.</span><span class="sxs-lookup"><span data-stu-id="bcccb-120">The value becomes the real part of the complex number, and its imaginary part equals 0.</span></span>  
  
-   <span data-ttu-id="bcccb-121">Atribuindo o número complexo que é retornado por um método ou um operador para um <xref:System.Numerics.Complex> objeto.</span><span class="sxs-lookup"><span data-stu-id="bcccb-121">By assigning the complex number that is returned by a method or operator to a <xref:System.Numerics.Complex> object.</span></span> <span data-ttu-id="bcccb-122">Por exemplo, <xref:System.Numerics.Complex.Add%2A?displayProperty=nameWithType> é um método estático que retorna um número complexo que é a soma de dois números complexos, e o <xref:System.Numerics.Complex.op_Addition%2A?displayProperty=nameWithType> operador adiciona dois números complexos e retorna o resultado.</span><span class="sxs-lookup"><span data-stu-id="bcccb-122">For example, <xref:System.Numerics.Complex.Add%2A?displayProperty=nameWithType> is a static method that returns a complex number that is the sum of two complex numbers, and the <xref:System.Numerics.Complex.op_Addition%2A?displayProperty=nameWithType> operator adds two complex numbers and returns the result.</span></span>  
  
 <span data-ttu-id="bcccb-123">O exemplo a seguir demonstra que cada um desses cinco modos de atribuir um valor para um número complexo.</span><span class="sxs-lookup"><span data-stu-id="bcccb-123">The following example demonstrates each of these five ways of assigning a value to a complex number.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.class/cs/create1.cs#2)]
 [!code-vb[System.Numerics.Complex.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.class/vb/create1.vb#2)]  
  
## <a name="operations-with-complex-numbers"></a><span data-ttu-id="bcccb-124">Operações com números complexos</span><span class="sxs-lookup"><span data-stu-id="bcccb-124">Operations with Complex Numbers</span></span>  
 <span data-ttu-id="bcccb-125">O <xref:System.Numerics.Complex> estrutura do .NET Framework inclui membros que fornecem a seguinte funcionalidade:</span><span class="sxs-lookup"><span data-stu-id="bcccb-125">The <xref:System.Numerics.Complex> structure in the .NET Framework includes members that provide the following functionality:</span></span>  
  
-   <span data-ttu-id="bcccb-126">Métodos para comparar dois números complexos para determinar se eles são iguais.</span><span class="sxs-lookup"><span data-stu-id="bcccb-126">Methods to compare two complex numbers to determine whether they are equal.</span></span>  
  
-   <span data-ttu-id="bcccb-127">Operadores para executar operações aritméticas em números complexos.</span><span class="sxs-lookup"><span data-stu-id="bcccb-127">Operators to perform arithmetic operations on complex numbers.</span></span> <span data-ttu-id="bcccb-128"><xref:System.Numerics.Complex> operadores permitem executar adição, subtração, multiplicação, divisão e negação unário com números complexos.</span><span class="sxs-lookup"><span data-stu-id="bcccb-128"><xref:System.Numerics.Complex> operators enable you to perform addition, subtraction, multiplication, division, and unary negation with complex numbers.</span></span>  
  
-   <span data-ttu-id="bcccb-129">Métodos para executar outras operações numéricas em números complexos.</span><span class="sxs-lookup"><span data-stu-id="bcccb-129">Methods to perform other numerical operations on complex numbers.</span></span> <span data-ttu-id="bcccb-130">As quatro operações aritméticas básicas, além de gerar um número complexo a uma potência especificada, localize a raiz quadrada de um número complexo e obter o valor absoluto de um número complexo.</span><span class="sxs-lookup"><span data-stu-id="bcccb-130">In addition to the four basic arithmetic operations, you can raise a complex number to a specified power, find the square root of a complex number, and get the absolute value of a complex number.</span></span>  
  
-   <span data-ttu-id="bcccb-131">Métodos para executar operações trigonométricas em números complexos.</span><span class="sxs-lookup"><span data-stu-id="bcccb-131">Methods to perform trigonometric operations on complex numbers.</span></span> <span data-ttu-id="bcccb-132">Por exemplo, você pode calcular a tangente de um ângulo representado por um número complexo.</span><span class="sxs-lookup"><span data-stu-id="bcccb-132">For example, you can calculate the tangent of an angle represented by a complex number.</span></span>  
  
 <span data-ttu-id="bcccb-133">Observe que, como o <xref:System.Numerics.Complex.Real%2A> e <xref:System.Numerics.Complex.Imaginary%2A> propriedades são somente leitura, você não pode modificar o valor de um objeto existente <xref:System.Numerics.Complex> objeto.</span><span class="sxs-lookup"><span data-stu-id="bcccb-133">Note that, because the <xref:System.Numerics.Complex.Real%2A> and  <xref:System.Numerics.Complex.Imaginary%2A> properties are read-only, you cannot modify the value of an existing <xref:System.Numerics.Complex> object.</span></span>  <span data-ttu-id="bcccb-134">Todos os métodos que executam uma operação em um <xref:System.Numerics.Complex> número, se o valor de retorno é do tipo <xref:System.Numerics.Complex>, retornam um novo <xref:System.Numerics.Complex> número.</span><span class="sxs-lookup"><span data-stu-id="bcccb-134">All methods that perform an operation on a <xref:System.Numerics.Complex> number, if their return value is of type <xref:System.Numerics.Complex>, return a new <xref:System.Numerics.Complex> number.</span></span>  
  
## <a name="precision-and-complex-numbers"></a><span data-ttu-id="bcccb-135">Precisão e números complexos</span><span class="sxs-lookup"><span data-stu-id="bcccb-135">Precision and Complex Numbers</span></span>  
 <span data-ttu-id="bcccb-136">As partes de um número complexo reais e imaginários são representadas por dois valores de ponto flutuantes de precisão dupla.</span><span class="sxs-lookup"><span data-stu-id="bcccb-136">The real and imaginary parts of a complex number are represented by two double-precision floating-point values.</span></span> <span data-ttu-id="bcccb-137">Isso significa que <xref:System.Numerics.Complex> valores, tais como valores de ponto flutuante de precisão dupla, podem perder precisão como resultado das operações numéricas.</span><span class="sxs-lookup"><span data-stu-id="bcccb-137">This means that <xref:System.Numerics.Complex> values, like double-precision floating-point values, can lose precision as a result of numerical operations.</span></span> <span data-ttu-id="bcccb-138">Isso significa que estrito comparações de igualdade de dois <xref:System.Numerics.Complex> valores podem falhar, mesmo se a diferença entre os dois valores é devido à perda de precisão.</span><span class="sxs-lookup"><span data-stu-id="bcccb-138">This means that strict comparisons for equality of two <xref:System.Numerics.Complex> values may fail, even if the difference between the two values is due to a loss of precision.</span></span> <span data-ttu-id="bcccb-139">Para obter mais informações, consulte <xref:System.Double>.</span><span class="sxs-lookup"><span data-stu-id="bcccb-139">For more information, see <xref:System.Double>.</span></span>  
  
 <span data-ttu-id="bcccb-140">Por exemplo, executar exponenciação no logaritmo de um número deve retornar o número original.</span><span class="sxs-lookup"><span data-stu-id="bcccb-140">For example, performing exponentiation on the logarithm of a number should return the original number.</span></span> <span data-ttu-id="bcccb-141">No entanto, em alguns casos, a perda de precisão de valores de ponto flutuante pode causar pequenas diferenças entre os dois valores, como mostra o exemplo a seguir.</span><span class="sxs-lookup"><span data-stu-id="bcccb-141">However, in some cases, the loss of precision of floating-point values can cause slight differences between the two values, as the following example illustrates.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.class/cs/precision1.cs#5)]
 [!code-vb[System.Numerics.Complex.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.class/vb/precision1.vb#5)]  
  
 <span data-ttu-id="bcccb-142">Da mesma forma, o exemplo a seguir, que calcula a raiz quadrada de um <xref:System.Numerics.Complex> número, gera resultados ligeiramente diferentes de 32 bits e IA64 versões do .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="bcccb-142">Similarly, the following example, which calculates the square root of a <xref:System.Numerics.Complex> number, produces slightly different results on the 32-bit and IA64 versions of the .NET Framework.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.class/cs/precision1.cs#6)]
 [!code-vb[System.Numerics.Complex.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.class/vb/precision1.vb#6)]  
  
## <a name="complex-numbers-infinity-and-nan"></a><span data-ttu-id="bcccb-143">Números complexos, infinito e NaN</span><span class="sxs-lookup"><span data-stu-id="bcccb-143">Complex Numbers, Infinity, and NaN</span></span>  
 <span data-ttu-id="bcccb-144">As partes de um número complexo reais e imaginários são representadas por <xref:System.Double> valores.</span><span class="sxs-lookup"><span data-stu-id="bcccb-144">The real and imaginary parts of a complex number are represented by <xref:System.Double> values.</span></span> <span data-ttu-id="bcccb-145">Além de desde <xref:System.Double.MinValue?displayProperty=nameWithType> para <xref:System.Double.MaxValue?displayProperty=nameWithType>, a parte imaginária ou real de um número complexo pode ter um valor de <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, ou <xref:System.Double.NaN?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="bcccb-145">In addition to ranging from <xref:System.Double.MinValue?displayProperty=nameWithType> to <xref:System.Double.MaxValue?displayProperty=nameWithType>, the real or imaginary part of a complex number can have a value of <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, or <xref:System.Double.NaN?displayProperty=nameWithType>.</span></span> <span data-ttu-id="bcccb-146"><xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, e <xref:System.Double.NaN?displayProperty=nameWithType> todos propaguem em qualquer operação aritmética ou trigonométrica.</span><span class="sxs-lookup"><span data-stu-id="bcccb-146"><xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, and <xref:System.Double.NaN?displayProperty=nameWithType> all propagate in any arithmetic or trigonometric operation.</span></span>  
  
 <span data-ttu-id="bcccb-147">No exemplo a seguir, divisão por <xref:System.Numerics.Complex.Zero> produz um número complexo cujos partes reais e imaginários são ambos <xref:System.Double.NaN?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="bcccb-147">In the following example, division by <xref:System.Numerics.Complex.Zero> produces a complex number whose real and imaginary parts are both <xref:System.Double.NaN?displayProperty=nameWithType>.</span></span> <span data-ttu-id="bcccb-148">Como resultado, executando a multiplicação com esse valor também produz um número complexo cujos partes reais e imaginários são <xref:System.Double.NaN?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="bcccb-148">As a result, performing multiplication with this value also produces a complex number whose real and imaginary parts are <xref:System.Double.NaN?displayProperty=nameWithType>.</span></span> <span data-ttu-id="bcccb-149">Da mesma forma, executar uma multiplicação que excede o intervalo da <xref:System.Double> tipo gera um número complexo cuja parte real é <xref:System.Double.NaN?displayProperty=nameWithType> e cuja parte imaginária é <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="bcccb-149">Similarly, performing a multiplication that overflows the range of the <xref:System.Double> type produces a complex number whose real part is <xref:System.Double.NaN?displayProperty=nameWithType> and whose imaginary part is <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>.</span></span> <span data-ttu-id="bcccb-150">Executar posteriormente a divisão com esse número complexo retorna um número complexo cuja parte real é <xref:System.Double.NaN?displayProperty=nameWithType> e cuja parte imaginária é <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="bcccb-150">Subsequently performing division with this complex number returns a complex number whose real part is <xref:System.Double.NaN?displayProperty=nameWithType> and whose imaginary part is <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.class/cs/nan1.cs#3)]
 [!code-vb[System.Numerics.Complex.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.class/vb/nan1.vb#3)]  
  
 <span data-ttu-id="bcccb-151">Operações matemáticas com números complexos que são inválidos ou que estourasse o intervalo da <xref:System.Double> tipo de dados não lançar uma exceção.</span><span class="sxs-lookup"><span data-stu-id="bcccb-151">Mathematical operations with complex numbers that are invalid or that overflow the range of the <xref:System.Double> data type do not throw an exception.</span></span> <span data-ttu-id="bcccb-152">Em vez disso, elas retornam um <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, ou <xref:System.Double.NaN?displayProperty=nameWithType> sob as seguintes condições:</span><span class="sxs-lookup"><span data-stu-id="bcccb-152">Instead, they return a <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, or <xref:System.Double.NaN?displayProperty=nameWithType> under the following conditions:</span></span>  
  
-   <span data-ttu-id="bcccb-153">A divisão de um número positivo, zero retorna <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="bcccb-153">The division of a positive number by zero returns <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="bcccb-154">Qualquer operação que excede o limite superior do <xref:System.Double> retorna tipo de dados <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="bcccb-154">Any operation that overflows the upper bound of the <xref:System.Double> data type returns <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="bcccb-155">A divisão de um número negativo, zero retorna <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="bcccb-155">The division of a negative number by zero returns <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="bcccb-156">Qualquer operação que excede o limite inferior do <xref:System.Double> retorna tipo de dados <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="bcccb-156">Any operation that overflows the lower bound of the <xref:System.Double> data type returns <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="bcccb-157">A divisão de um zero por zero retorna <xref:System.Double.NaN?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="bcccb-157">The division of a zero by zero returns <xref:System.Double.NaN?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="bcccb-158">Qualquer operação que é executada em operandos cujos valores são <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, ou <xref:System.Double.NaN?displayProperty=nameWithType> retorna <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, ou <xref:System.Double.NaN?displayProperty=nameWithType>, dependendo da operação específica.</span><span class="sxs-lookup"><span data-stu-id="bcccb-158">Any operation that is performed on operands whose values are <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, or <xref:System.Double.NaN?displayProperty=nameWithType> returns <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, or <xref:System.Double.NaN?displayProperty=nameWithType>, depending on the specific operation.</span></span>  
  
 <span data-ttu-id="bcccb-159">Observe que isso se aplica a todos os cálculos intermediários executados por um método.</span><span class="sxs-lookup"><span data-stu-id="bcccb-159">Note that this applies to any intermediate calculations performed by a method.</span></span> <span data-ttu-id="bcccb-160">Por exemplo, a multiplicação de `new Complex(9e308, 9e308) and new Complex(2.5, 3.5)` usa a fórmula (CA - bd) + (ad + continuidade de negócios).</span><span class="sxs-lookup"><span data-stu-id="bcccb-160">For example, the multiplication of `new Complex(9e308, 9e308) and new Complex(2.5, 3.5)` uses the formula (ac - bd) + (ad + bc)i.</span></span> <span data-ttu-id="bcccb-161">O cálculo do componente real que é o resultado da multiplicação avalia a expressão 9e308 * 2.5 - 9e308 * 3.5.</span><span class="sxs-lookup"><span data-stu-id="bcccb-161">The calculation of the real component that results from the multiplication evaluates the expression 9e308 * 2.5 - 9e308 * 3.5.</span></span> <span data-ttu-id="bcccb-162">Retorna cada multiplicação intermediária nesta expressão <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>e a tentativa de subtrair <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> de <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> retorna <xref:System.Double.NaN?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="bcccb-162">Each intermediate multiplication in this expression returns <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, and the attempt to subtract <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> from <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> returns <xref:System.Double.NaN?displayProperty=nameWithType>.</span></span>  
  
## <a name="formatting-a-complex-number"></a><span data-ttu-id="bcccb-163">Formatando um número complexo</span><span class="sxs-lookup"><span data-stu-id="bcccb-163">Formatting a Complex Number</span></span>  
 <span data-ttu-id="bcccb-164">Por padrão, a representação de cadeia de caracteres de um número complexo assume a forma `(` *real* `,` *imaginário*`)`, onde *real* e *imaginário* são as representações de cadeia de caracteres da <xref:System.Double> valores que formam os componentes de real e imaginário do número complexo.</span><span class="sxs-lookup"><span data-stu-id="bcccb-164">By default, the string representation of a complex number takes the form `(`*real*`,` *imaginary*`)`, where *real* and *imaginary* are the string representations of the <xref:System.Double> values that form the complex number's real and imaginary components.</span></span> <span data-ttu-id="bcccb-165">Algumas sobrecargas do <xref:System.Numerics.Complex.ToString%2A> método permitir a personalização das representações de cadeia de caracteres desses <xref:System.Double> valores para refletir as convenções de formatação de uma cultura específica ou para aparecer em um formato específico, definido por uma cadeia de caracteres de formato numérico padrão ou personalizadas.</span><span class="sxs-lookup"><span data-stu-id="bcccb-165">Some overloads of the <xref:System.Numerics.Complex.ToString%2A> method allow customization of the string representations of these <xref:System.Double> values to reflect the formatting conventions of a particular culture or to appear in a particular format defined by a standard or custom numeric format string.</span></span> <span data-ttu-id="bcccb-166">(Para obter mais informações, consulte [cadeias de caracteres de formato numérico padrão](~/docs/standard/base-types/standard-numeric-format-strings.md) e [cadeias de caracteres de formato numérico personalizado](~/docs/standard/base-types/custom-numeric-format-strings.md).)</span><span class="sxs-lookup"><span data-stu-id="bcccb-166">(For more information, see [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) and [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md).)</span></span>  
  
 <span data-ttu-id="bcccb-167">Uma das maneiras mais comuns de expressar a representação de cadeia de caracteres de um número complexo assume a forma a + bi, onde um é o componente real do número complexo, e b é o componente imaginário do número complexo.</span><span class="sxs-lookup"><span data-stu-id="bcccb-167">One of the more common ways of expressing the string representation of a complex number takes the form a + bi, where a is the complex number's real component, and b is the complex number's imaginary component.</span></span> <span data-ttu-id="bcccb-168">Em engenharia elétrica, um número complexo é geralmente expresso como um + bj.</span><span class="sxs-lookup"><span data-stu-id="bcccb-168">In electrical engineering, a complex number is most commonly expressed as a + bj.</span></span> <span data-ttu-id="bcccb-169">Você pode retornar a representação de cadeia de caracteres de um número complexo em um destes dois formatos.</span><span class="sxs-lookup"><span data-stu-id="bcccb-169">You can return the string representation of a complex number in either of these two forms.</span></span> <span data-ttu-id="bcccb-170">Para fazer isso, defina um provedor de formato personalizado implementando a <xref:System.ICustomFormatter> e <xref:System.IFormatProvider> interfaces e, em seguida, chame o <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="bcccb-170">To do this, define a custom format provider by implementing the <xref:System.ICustomFormatter> and <xref:System.IFormatProvider> interfaces, and then call the <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="bcccb-171">O exemplo a seguir define um `ComplexFormatter` a classe que representa um número complexo como uma cadeia de caracteres em forma de um + bi ou + bj.</span><span class="sxs-lookup"><span data-stu-id="bcccb-171">The following example defines a `ComplexFormatter` class that represents a complex number as a string in the form of either a + bi or a + bj.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.class/cs/customfmt1.cs#1)]
 [!code-vb[System.Numerics.Complex.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.class/vb/customfmt1.vb#1)]  
  
 <span data-ttu-id="bcccb-172">O exemplo a seguir usa este formatador personalizado para exibir a representação de cadeia de caracteres de um número complexo.</span><span class="sxs-lookup"><span data-stu-id="bcccb-172">The following example then uses this custom formatter to display the string representation of a complex number.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.class/cs/customfmt1.cs#4)]
 [!code-vb[System.Numerics.Complex.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.class/vb/customfmt1.vb#4)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Complex (double real, double imaginary);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(float64 real, float64 imaginary) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.#ctor(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (real As Double, imaginary As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Complex(double real, double imaginary);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="real" Type="System.Double" />
        <Parameter Name="imaginary" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="real"><span data-ttu-id="bcccb-173">A parte real do número complexo.</span><span class="sxs-lookup"><span data-stu-id="bcccb-173">The real part of the complex number.</span></span></param>
        <param name="imaginary"><span data-ttu-id="bcccb-174">A parte imaginária do número complexo.</span><span class="sxs-lookup"><span data-stu-id="bcccb-174">The imaginary part of the complex number.</span></span></param>
        <summary><span data-ttu-id="bcccb-175">Inicializa uma nova instância da estrutura <see cref="T:System.Numerics.Complex" /> usando os valores reais e imaginários especificados.</span><span class="sxs-lookup"><span data-stu-id="bcccb-175">Initializes a new instance of the <see cref="T:System.Numerics.Complex" /> structure using the specified real and imaginary values.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bcccb-176">O `real` ou `imaginary` argumentos podem perder a precisão se eles são os tipos de dados que exigem uma conversão explícita para <xref:System.Double>.</span><span class="sxs-lookup"><span data-stu-id="bcccb-176">The `real` or `imaginary` arguments may lose precision if they are data types that require an explicit cast to <xref:System.Double>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bcccb-177">O exemplo a seguir cria dois números complexos e, em seguida, usa-los em operações de adição, subtração, multiplicação e divisão.</span><span class="sxs-lookup"><span data-stu-id="bcccb-177">The following example instantiates two complex numbers, and then uses them in addition, subtraction, multiplication, and division operations.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.ctor/cs/ctor1.cs#1)]
 [!code-vb[System.Numerics.Complex.ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.ctor/vb/ctor1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Abs">
      <MemberSignature Language="C#" Value="public static double Abs (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Abs(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Abs(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Abs (value As Complex) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Abs(System::Numerics::Complex value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="bcccb-178">Um número complexo.</span><span class="sxs-lookup"><span data-stu-id="bcccb-178">A complex number.</span></span></param>
        <summary><span data-ttu-id="bcccb-179">Obtém o valor absoluto (ou magnitude) de um número complexo.</span><span class="sxs-lookup"><span data-stu-id="bcccb-179">Gets the absolute value (or magnitude) of a complex number.</span></span></summary>
        <returns><span data-ttu-id="bcccb-180">O valor absoluto de <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="bcccb-180">The absolute value of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bcccb-181">O valor absoluto de um número complexo é equivalente ao seu <xref:System.Numerics.Complex.Magnitude%2A> propriedade.</span><span class="sxs-lookup"><span data-stu-id="bcccb-181">The absolute value of a complex number is equivalent to its <xref:System.Numerics.Complex.Magnitude%2A> property.</span></span> <span data-ttu-id="bcccb-182">O valor absoluto de um número real um + bi é calculada da seguinte maneira:</span><span class="sxs-lookup"><span data-stu-id="bcccb-182">The absolute value of a real number a + bi is calculated as follows:</span></span>  
  
-   <span data-ttu-id="bcccb-183">Se b = 0, o resultado será 0.</span><span class="sxs-lookup"><span data-stu-id="bcccb-183">If b = 0, the result is 0.</span></span>  
  
-   <span data-ttu-id="bcccb-184">Se um > b, o resultado é um \*<xref:System.Math.Sqrt%2A?displayProperty=nameWithType>(1 + b<sup>2</sup>/a<sup>2</sup>).</span><span class="sxs-lookup"><span data-stu-id="bcccb-184">If a > b, the result is a \*<xref:System.Math.Sqrt%2A?displayProperty=nameWithType>(1 + b<sup>2</sup>/a<sup>2</sup>).</span></span>  
  
-   <span data-ttu-id="bcccb-185">Se b > um, o resultado é b \* <xref:System.Math.Sqrt%2A?displayProperty=nameWithType>(1 + um<sup>2</sup>/b<sup>2</sup>).</span><span class="sxs-lookup"><span data-stu-id="bcccb-185">If b > a, the result is b \* <xref:System.Math.Sqrt%2A?displayProperty=nameWithType>(1 + a<sup>2</sup>/b<sup>2</sup>).</span></span>  
  
 <span data-ttu-id="bcccb-186">Se o cálculo do valor absoluto resulta em um estouro, o método retorna um <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> ou <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="bcccb-186">If the calculation of the absolute value results in an overflow, the method returns either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span> <span data-ttu-id="bcccb-187">Se o <xref:System.Numerics.Complex.Real%2A> ou <xref:System.Numerics.Complex.Imaginary%2A> é de propriedade <xref:System.Double.NaN?displayProperty=nameWithType> e a outra propriedade não é nem <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> nem <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, o método retornará <xref:System.Double.NaN?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="bcccb-187">If either the <xref:System.Numerics.Complex.Real%2A> or <xref:System.Numerics.Complex.Imaginary%2A> property is <xref:System.Double.NaN?displayProperty=nameWithType> and the other property is neither <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> nor <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, the method returns <xref:System.Double.NaN?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bcccb-188">O exemplo a seguir calcula o valor absoluto de um número complexo e demonstra o que é equivalente ao valor da <xref:System.Numerics.Complex.Magnitude%2A> propriedade.</span><span class="sxs-lookup"><span data-stu-id="bcccb-188">The following example calculates the absolute value of a complex number and demonstrates that it is equivalent to the value of the <xref:System.Numerics.Complex.Magnitude%2A> property.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Abs#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.abs/cs/abs1.cs#1)]
 [!code-vb[System.Numerics.Complex.Abs#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.abs/vb/abs1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.Complex.Magnitude" />
      </Docs>
    </Member>
    <Member MemberName="Acos">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Acos (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Acos(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Acos(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Acos (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Acos(System::Numerics::Complex value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="bcccb-189">Um número complexo que representa um cosseno.</span><span class="sxs-lookup"><span data-stu-id="bcccb-189">A complex number that represents a cosine.</span></span></param>
        <summary><span data-ttu-id="bcccb-190">Retorna o ângulo que é o arco cosseno do número complexo especificado.</span><span class="sxs-lookup"><span data-stu-id="bcccb-190">Returns the angle that is the arc cosine of the specified complex number.</span></span></summary>
        <returns><span data-ttu-id="bcccb-191">O ângulo, medido em radianos, que é o arco cosseno de <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="bcccb-191">The angle, measured in radians, which is the arc cosine of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bcccb-192">O <xref:System.Numerics.Complex.Acos%2A> método para números complexos corresponde ao <xref:System.Math.Acos%2A?displayProperty=nameWithType> método para números reais.</span><span class="sxs-lookup"><span data-stu-id="bcccb-192">The <xref:System.Numerics.Complex.Acos%2A> method for complex numbers corresponds to the <xref:System.Math.Acos%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="bcccb-193">O <xref:System.Numerics.Complex.Acos%2A> método usa a seguinte fórmula:</span><span class="sxs-lookup"><span data-stu-id="bcccb-193">The <xref:System.Numerics.Complex.Acos%2A> method uses the following formula:</span></span>  
  
 <span data-ttu-id="bcccb-194">(-<xref:System.Numerics.Complex.ImaginaryOne>) \* <xref:System.Numerics.Complex.Log%2A>(`value` + <xref:System.Numerics.Complex.ImaginaryOne>\*<xref:System.Numerics.Complex.Sqrt%2A>(<xref:System.Numerics.Complex.One> - `value` \* `value`)))</span><span class="sxs-lookup"><span data-stu-id="bcccb-194">(-<xref:System.Numerics.Complex.ImaginaryOne>) \* <xref:System.Numerics.Complex.Log%2A>(`value` + <xref:System.Numerics.Complex.ImaginaryOne>\*<xref:System.Numerics.Complex.Sqrt%2A>(<xref:System.Numerics.Complex.One> - `value` \* `value`)))</span></span>    
  
   
  
## Examples  
 <span data-ttu-id="bcccb-195">O exemplo a seguir ilustra o <xref:System.Numerics.Complex.Acos%2A> método.</span><span class="sxs-lookup"><span data-stu-id="bcccb-195">The following example illustrates the <xref:System.Numerics.Complex.Acos%2A> method.</span></span> <span data-ttu-id="bcccb-196">Ele mostra que o valor retornado pelo passando o <xref:System.Numerics.Complex.Acos%2A> método para o <xref:System.Numerics.Complex.Cos%2A> método retorna original <xref:System.Numerics.Complex> valor.</span><span class="sxs-lookup"><span data-stu-id="bcccb-196">It shows that passing the value returned by the <xref:System.Numerics.Complex.Acos%2A> method to the <xref:System.Numerics.Complex.Cos%2A> method returns the original <xref:System.Numerics.Complex> value.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Acos#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.acos/cs/acos1.cs#1)]
 [!code-vb[System.Numerics.Complex.Acos#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.acos/vb/acos1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Cos(System.Numerics.Complex)" />
        <altmember cref="M:System.Math.Acos(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Add (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Add(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Add(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Add(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="bcccb-197">O primeiro número complexo a ser adicionado.</span><span class="sxs-lookup"><span data-stu-id="bcccb-197">The first complex number to add.</span></span></param>
        <param name="right"><span data-ttu-id="bcccb-198">O segundo número complexo a ser adicionado.</span><span class="sxs-lookup"><span data-stu-id="bcccb-198">The second complex number to add.</span></span></param>
        <summary><span data-ttu-id="bcccb-199">Adiciona dois números complexos e retorna o resultado.</span><span class="sxs-lookup"><span data-stu-id="bcccb-199">Adds two complex numbers and returns the result.</span></span></summary>
        <returns><span data-ttu-id="bcccb-200">A soma de <paramref name="left" /> e <paramref name="right" />.</span><span class="sxs-lookup"><span data-stu-id="bcccb-200">The sum of <paramref name="left" /> and <paramref name="right" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bcccb-201">A adição de um complexo de número, um + bi, e um segundo número complexo, c + injeção de dependência, leva o seguinte formato:</span><span class="sxs-lookup"><span data-stu-id="bcccb-201">The addition of a complex number, a + bi, and a second complex number, c + di, takes the following form:</span></span>  
  
 <span data-ttu-id="bcccb-202">(a + c) + (b + d) i.</span><span class="sxs-lookup"><span data-stu-id="bcccb-202">(a + c) + (b + d)i.</span></span>  
  
 <span data-ttu-id="bcccb-203">Se a chamada do método resultados em um estouro no componente real ou imaginário, o valor do componente é <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> ou <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="bcccb-203">If the method call results in an overflow in either the real or imaginary component, the value of the component is either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="bcccb-204">Idiomas que dão suporte a operadores personalizados podem usar o <xref:System.Numerics.Complex.Add%2A> método para realizar adição com números complexos.</span><span class="sxs-lookup"><span data-stu-id="bcccb-204">Languages that do not support custom operators can use the <xref:System.Numerics.Complex.Add%2A> method to perform addition with complex numbers.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bcccb-205">O exemplo a seguir ilustra a adição com números complexos.</span><span class="sxs-lookup"><span data-stu-id="bcccb-205">The following example illustrates addition with complex numbers.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Add#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.add/cs/add1.cs#1)]
 [!code-vb[System.Numerics.Complex.Add#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.add/vb/add1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Addition(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Asin">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Asin (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Asin(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Asin(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Asin (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Asin(System::Numerics::Complex value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="bcccb-206">Um número complexo.</span><span class="sxs-lookup"><span data-stu-id="bcccb-206">A complex number.</span></span></param>
        <summary><span data-ttu-id="bcccb-207">Retorna o ângulo que é o arco seno do número complexo especificado.</span><span class="sxs-lookup"><span data-stu-id="bcccb-207">Returns the angle that is the arc sine of the specified complex number.</span></span></summary>
        <returns><span data-ttu-id="bcccb-208">O ângulo que é o arco seno de <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="bcccb-208">The angle which is the arc sine of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bcccb-209">O <xref:System.Numerics.Complex.Asin%2A> método para números complexos corresponde ao <xref:System.Math.Asin%2A?displayProperty=nameWithType> método para números reais.</span><span class="sxs-lookup"><span data-stu-id="bcccb-209">The <xref:System.Numerics.Complex.Asin%2A> method for complex numbers corresponds to the <xref:System.Math.Asin%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="bcccb-210">O <xref:System.Numerics.Complex.Asin%2A> método usa a seguinte fórmula:</span><span class="sxs-lookup"><span data-stu-id="bcccb-210">The <xref:System.Numerics.Complex.Asin%2A> method uses the following formula:</span></span>  
  
 <span data-ttu-id="bcccb-211">-<xref:System.Numerics.Complex.ImaginaryOne> \* <xref:System.Numerics.Complex.Log%2A>(<xref:System.Numerics.Complex.ImaginaryOne> \* valor + <xref:System.Numerics.Complex.Sqrt%2A>(<xref:System.Numerics.Complex.One> -valor \* valor))</span><span class="sxs-lookup"><span data-stu-id="bcccb-211">-<xref:System.Numerics.Complex.ImaginaryOne> \* <xref:System.Numerics.Complex.Log%2A>(<xref:System.Numerics.Complex.ImaginaryOne> \* value + <xref:System.Numerics.Complex.Sqrt%2A>(<xref:System.Numerics.Complex.One> - value \* value))</span></span>    
  
   
  
## Examples  
 <span data-ttu-id="bcccb-212">O exemplo a seguir ilustra o <xref:System.Numerics.Complex.Asin%2A> método.</span><span class="sxs-lookup"><span data-stu-id="bcccb-212">The following example illustrates the <xref:System.Numerics.Complex.Asin%2A> method.</span></span> <span data-ttu-id="bcccb-213">Ele mostra que o valor retornado pelo passando o <xref:System.Numerics.Complex.Asin%2A> método para o <xref:System.Numerics.Complex.Sin%2A> método retorna original <xref:System.Numerics.Complex> valor.</span><span class="sxs-lookup"><span data-stu-id="bcccb-213">It shows that passing the value returned by the <xref:System.Numerics.Complex.Asin%2A> method to the <xref:System.Numerics.Complex.Sin%2A> method returns the original <xref:System.Numerics.Complex> value.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Asin#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.asin/cs/asin1.cs#1)]
 [!code-vb[System.Numerics.Complex.Asin#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.asin/vb/asin1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Sin(System.Numerics.Complex)" />
        <altmember cref="M:System.Math.Asin(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Atan">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Atan (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Atan(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Atan(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Atan (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Atan(System::Numerics::Complex value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="bcccb-214">Um número complexo.</span><span class="sxs-lookup"><span data-stu-id="bcccb-214">A complex number.</span></span></param>
        <summary><span data-ttu-id="bcccb-215">Retorna o ângulo que é o arco tangente do número complexo especificado.</span><span class="sxs-lookup"><span data-stu-id="bcccb-215">Returns the angle that is the arc tangent of the specified complex number.</span></span></summary>
        <returns><span data-ttu-id="bcccb-216">O ângulo que é o arco tangente de <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="bcccb-216">The angle that is the arc tangent of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bcccb-217">O <xref:System.Numerics.Complex.Atan%2A> método para números complexos corresponde ao <xref:System.Math.Atan%2A?displayProperty=nameWithType> método para números reais.</span><span class="sxs-lookup"><span data-stu-id="bcccb-217">The <xref:System.Numerics.Complex.Atan%2A> method for complex numbers corresponds to the <xref:System.Math.Atan%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="bcccb-218">O <xref:System.Numerics.Complex.Atan%2A> método usa a seguinte fórmula:</span><span class="sxs-lookup"><span data-stu-id="bcccb-218">The <xref:System.Numerics.Complex.Atan%2A> method uses the following formula:</span></span>  
  
 <span data-ttu-id="bcccb-219"><xref:System.Numerics.Complex.ImaginaryOne> / novo complexo (2.0, 0.0)) \* (<xref:System.Numerics.Complex.Log%2A>(<xref:System.Numerics.Complex.One>  -  <xref:System.Numerics.Complex.ImaginaryOne> \* valor)- <xref:System.Numerics.Complex.Log%2A>(<xref:System.Numerics.Complex.One> + ImaginaryOne \* valor)</span><span class="sxs-lookup"><span data-stu-id="bcccb-219"><xref:System.Numerics.Complex.ImaginaryOne> / new Complex(2.0, 0.0)) \* (<xref:System.Numerics.Complex.Log%2A>(<xref:System.Numerics.Complex.One> - <xref:System.Numerics.Complex.ImaginaryOne> \* value) - <xref:System.Numerics.Complex.Log%2A>(<xref:System.Numerics.Complex.One> + ImaginaryOne \* value)</span></span>   
  
   
  
## Examples  
 <span data-ttu-id="bcccb-220">O exemplo a seguir ilustra o <xref:System.Numerics.Complex.Atan%2A> método.</span><span class="sxs-lookup"><span data-stu-id="bcccb-220">The following example illustrates the <xref:System.Numerics.Complex.Atan%2A> method.</span></span> <span data-ttu-id="bcccb-221">Ele mostra que o valor retornado pelo passando o <xref:System.Numerics.Complex.Atan%2A> método para o <xref:System.Numerics.Complex.Tan%2A> método retorna original <xref:System.Numerics.Complex> valor.</span><span class="sxs-lookup"><span data-stu-id="bcccb-221">It shows that passing the value returned by the <xref:System.Numerics.Complex.Atan%2A> method to the <xref:System.Numerics.Complex.Tan%2A> method returns the original <xref:System.Numerics.Complex> value.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Atan#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.atan/cs/atan1.cs#1)]
 [!code-vb[System.Numerics.Complex.Atan#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.atan/vb/atan1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Tan(System.Numerics.Complex)" />
        <altmember cref="M:System.Math.Atan(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Conjugate">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Conjugate (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Conjugate(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Conjugate(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Conjugate (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Conjugate(System::Numerics::Complex value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="bcccb-222">Um número complexo.</span><span class="sxs-lookup"><span data-stu-id="bcccb-222">A complex number.</span></span></param>
        <summary><span data-ttu-id="bcccb-223">Calcula o conjugado de um número complexo e retorna o resultado.</span><span class="sxs-lookup"><span data-stu-id="bcccb-223">Computes the conjugate of a complex number and returns the result.</span></span></summary>
        <returns><span data-ttu-id="bcccb-224">O conjugado de <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="bcccb-224">The conjugate of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bcccb-225">O conjugado de um número complexo inverte o sinal do componente imaginário; ou seja, ela se aplica negação unário para o componente imaginário.</span><span class="sxs-lookup"><span data-stu-id="bcccb-225">The conjugate of a complex number inverts the sign of the imaginary component; that is, it applies unary negation to the imaginary component.</span></span> <span data-ttu-id="bcccb-226">Se um + bi é um número complexo, que é seu conjugado-bi.</span><span class="sxs-lookup"><span data-stu-id="bcccb-226">If a + bi is a complex number, its conjugate is a - bi.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bcccb-227">O exemplo a seguir exibe o conjugado de dois números complexos.</span><span class="sxs-lookup"><span data-stu-id="bcccb-227">The following example displays the conjugate of two complex numbers.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Conjugate#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.conjugate/cs/conjugate1.cs#1)]
 [!code-vb[System.Numerics.Complex.Conjugate#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.conjugate/vb/conjugate1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cos">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Cos (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Cos(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Cos(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Cos (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Cos(System::Numerics::Complex value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="bcccb-228">Um número complexo.</span><span class="sxs-lookup"><span data-stu-id="bcccb-228">A complex number.</span></span></param>
        <summary><span data-ttu-id="bcccb-229">Retorna o cosseno do número complexo especificado.</span><span class="sxs-lookup"><span data-stu-id="bcccb-229">Returns the cosine of the specified complex number.</span></span></summary>
        <returns><span data-ttu-id="bcccb-230">O cosseno de <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="bcccb-230">The cosine of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bcccb-231">O <xref:System.Numerics.Complex.Cos%2A> método para números complexos corresponde ao <xref:System.Math.Cos%2A?displayProperty=nameWithType> método para números reais.</span><span class="sxs-lookup"><span data-stu-id="bcccb-231">The <xref:System.Numerics.Complex.Cos%2A> method for complex numbers corresponds to the <xref:System.Math.Cos%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="bcccb-232">O <xref:System.Numerics.Complex.Cos%2A> método usa a seguinte fórmula para calcular o cosseno do número complexo a + bi:</span><span class="sxs-lookup"><span data-stu-id="bcccb-232">The <xref:System.Numerics.Complex.Cos%2A> method uses the following formula to calculate the cosine of the complex number a + bi:</span></span>  
  
 <span data-ttu-id="bcccb-233">(<xref:System.Math.Cos%2A>(a) * <xref:System.Math.Cosh%2A>(b), -(<xref:System.Math.Sin%2A>(a) * <xref:System.Math.Sinh%2A>(b)))</span><span class="sxs-lookup"><span data-stu-id="bcccb-233">(<xref:System.Math.Cos%2A>(a) * <xref:System.Math.Cosh%2A>(b), -(<xref:System.Math.Sin%2A>(a) * <xref:System.Math.Sinh%2A>(b)))</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bcccb-234">O exemplo a seguir ilustra o <xref:System.Numerics.Complex.Acos%2A> método.</span><span class="sxs-lookup"><span data-stu-id="bcccb-234">The following example illustrates the <xref:System.Numerics.Complex.Acos%2A> method.</span></span> <span data-ttu-id="bcccb-235">Ele mostra que o valor retornado pelo passando o <xref:System.Numerics.Complex.Acos%2A> método para o <xref:System.Numerics.Complex.Cos%2A> método retorna original <xref:System.Numerics.Complex> valor.</span><span class="sxs-lookup"><span data-stu-id="bcccb-235">It shows that passing the value returned by the <xref:System.Numerics.Complex.Acos%2A> method to the <xref:System.Numerics.Complex.Cos%2A> method returns the original <xref:System.Numerics.Complex> value.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Acos#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.acos/cs/acos1.cs#1)]
 [!code-vb[System.Numerics.Complex.Acos#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.acos/vb/acos1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Acos(System.Numerics.Complex)" />
        <altmember cref="M:System.Math.Cos(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Cosh">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Cosh (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Cosh(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Cosh(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Cosh (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Cosh(System::Numerics::Complex value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="bcccb-236">Um número complexo.</span><span class="sxs-lookup"><span data-stu-id="bcccb-236">A complex number.</span></span></param>
        <summary><span data-ttu-id="bcccb-237">Retorna o cosseno hiperbólico do número complexo especificado.</span><span class="sxs-lookup"><span data-stu-id="bcccb-237">Returns the hyperbolic cosine of the specified complex number.</span></span></summary>
        <returns><span data-ttu-id="bcccb-238">O cosseno hiperbólico de <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="bcccb-238">The hyperbolic cosine of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bcccb-239">O <xref:System.Numerics.Complex.Cosh%2A> método para números complexos corresponde ao <xref:System.Math.Cosh%2A?displayProperty=nameWithType> método para números reais.</span><span class="sxs-lookup"><span data-stu-id="bcccb-239">The <xref:System.Numerics.Complex.Cosh%2A> method for complex numbers corresponds to the <xref:System.Math.Cosh%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="bcccb-240">O <xref:System.Numerics.Complex.Cosh%2A> método usa a seguinte fórmula para calcular o cosseno hiperbólico do número complexo a + bi:</span><span class="sxs-lookup"><span data-stu-id="bcccb-240">The <xref:System.Numerics.Complex.Cosh%2A> method uses the following formula to calculate the hyperbolic cosine of the complex number a + bi:</span></span>  
  
 <span data-ttu-id="bcccb-241">(<xref:System.Math.Cosh%2A>(a) * <xref:System.Math.Cos%2A>(b), <xref:System.Math.Sinh%2A>(a) * <xref:System.Math.Sin%2A>(b))</span><span class="sxs-lookup"><span data-stu-id="bcccb-241">(<xref:System.Math.Cosh%2A>(a) * <xref:System.Math.Cos%2A>(b), <xref:System.Math.Sinh%2A>(a) * <xref:System.Math.Sin%2A>(b))</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Cosh(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Divide">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Divide (System.Numerics.Complex dividend, System.Numerics.Complex divisor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Divide(valuetype System.Numerics.Complex dividend, valuetype System.Numerics.Complex divisor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Divide(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Divide (dividend As Complex, divisor As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Divide(System::Numerics::Complex dividend, System::Numerics::Complex divisor);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dividend" Type="System.Numerics.Complex" />
        <Parameter Name="divisor" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="dividend"><span data-ttu-id="bcccb-242">O número complexo a ser dividido.</span><span class="sxs-lookup"><span data-stu-id="bcccb-242">The complex number to be divided.</span></span></param>
        <param name="divisor"><span data-ttu-id="bcccb-243">O número complexo pelo qual dividir.</span><span class="sxs-lookup"><span data-stu-id="bcccb-243">The complex number to divide by.</span></span></param>
        <summary><span data-ttu-id="bcccb-244">Divide um número complexo por outro e retorna o resultado.</span><span class="sxs-lookup"><span data-stu-id="bcccb-244">Divides one complex number by another and returns the result.</span></span></summary>
        <returns><span data-ttu-id="bcccb-245">O quociente da divisão.</span><span class="sxs-lookup"><span data-stu-id="bcccb-245">The quotient of the division.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bcccb-246">A divisão de um número complexo, um + bi, por um segundo número complexo, o número, a c + a injeção de dependência, leva o seguinte formato:</span><span class="sxs-lookup"><span data-stu-id="bcccb-246">The division of a complex number, a + bi, by a second complex number, number, c + di, takes the following form:</span></span>  
  
 <span data-ttu-id="bcccb-247">((AC + BD) / (c<sup>2</sup> + d<sup>2</sup>)) + ((bc-ad) / (c<sup>2</sup> + d<sup>2</sup>),</span><span class="sxs-lookup"><span data-stu-id="bcccb-247">((ac + bd) / (c<sup>2</sup> + d<sup>2</sup>)) + ((bc - ad) / (c<sup>2</sup> + d<sup>2</sup>)i</span></span>  
  
 <span data-ttu-id="bcccb-248">Se o cálculo do quociente resulta em um estouro no componente real ou imaginário, o valor desse componente é <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> ou <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="bcccb-248">If the calculation of the quotient results in an overflow in either the real or imaginary component, the value of that component is either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="bcccb-249">O <xref:System.Numerics.Complex.Divide%2A> método pode ser usado pelas linguagens que não dão suporte a operadores personalizados.</span><span class="sxs-lookup"><span data-stu-id="bcccb-249">The <xref:System.Numerics.Complex.Divide%2A> method can be used by languages that do not support custom operators.</span></span> <span data-ttu-id="bcccb-250">Seu comportamento é idêntico a divisão usando o operador de divisão.</span><span class="sxs-lookup"><span data-stu-id="bcccb-250">Its behavior is identical to division using the division operator.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bcccb-251">O exemplo a seguir divide um número complexo por cada elemento em uma matriz de números complexos.</span><span class="sxs-lookup"><span data-stu-id="bcccb-251">The following example divides a complex number by each element in an array of complex numbers.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Divide#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.divide/cs/divide1.cs#1)]
 [!code-vb[System.Numerics.Complex.Divide#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.divide/vb/divide1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Division(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="bcccb-252">Retorna um valor que indica se dois números complexos são iguais.</span><span class="sxs-lookup"><span data-stu-id="bcccb-252">Returns a value that indicates whether two complex numbers are equal.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Equals(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (value As Complex) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::Numerics::Complex value);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="bcccb-253">O número complexo a comparar.</span><span class="sxs-lookup"><span data-stu-id="bcccb-253">The complex number to compare.</span></span></param>
        <summary><span data-ttu-id="bcccb-254">Retorna um valor que indica se a instância atual e um número complexo especificado têm o mesmo valor.</span><span class="sxs-lookup"><span data-stu-id="bcccb-254">Returns a value that indicates whether the current instance and a specified complex number have the same value.</span></span></summary>
        <returns>
          <span data-ttu-id="bcccb-255"><see langword="true" /> se este número complexo <paramref name="value" /> tiverem o mesmo valor; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="bcccb-255"><see langword="true" /> if this complex number and <paramref name="value" /> have the same value; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bcccb-256">O <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> método fornece o <xref:System.IEquatable%601> implementação para o <xref:System.Numerics.Complex> estrutura.</span><span class="sxs-lookup"><span data-stu-id="bcccb-256">The <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> method provides the <xref:System.IEquatable%601> implementation for the <xref:System.Numerics.Complex> structure.</span></span> <span data-ttu-id="bcccb-257">Ele executa um pouco melhor do que <xref:System.Numerics.Complex.Equals%28System.Object%29> método porque ele não tem que converter o parâmetro para um número complexo.</span><span class="sxs-lookup"><span data-stu-id="bcccb-257">It performs slightly better than <xref:System.Numerics.Complex.Equals%28System.Object%29> method because it does not have to convert its parameter to a complex number.</span></span>  
  
 <span data-ttu-id="bcccb-258">Dois números complexos são iguais se suas partes reais são iguais e suas partes imaginários são iguais.</span><span class="sxs-lookup"><span data-stu-id="bcccb-258">Two complex numbers are equal if their real parts are equal and their imaginary parts are equal.</span></span> <span data-ttu-id="bcccb-259">O <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> método é equivalente à seguinte expressão:</span><span class="sxs-lookup"><span data-stu-id="bcccb-259">The <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> method is equivalent to the following expression:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/equals1.cs#1)]
 [!code-vb[System.Numerics.Complex.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/equals1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para><span data-ttu-id="bcccb-260">Use o <see cref="M:System.Numerics.Complex.Equals(System.Numerics.Complex)" /> método com cuidado, porque os dois valores que são equivalentes aparentemente podem ser consideradas diferentes devido à precisão diferente de seus componentes reais e imaginários.</span><span class="sxs-lookup"><span data-stu-id="bcccb-260">Use the <see cref="M:System.Numerics.Complex.Equals(System.Numerics.Complex)" /> method with caution, because two values that are apparently equivalent can be considered unequal due to the differing precision of their real and imaginary components.</span></span> <span data-ttu-id="bcccb-261">O exemplo a seguir relata que <c>(3.33333, 0.142857)</c> e <c>(10/3, 1/7)</c> não são iguais.</span><span class="sxs-lookup"><span data-stu-id="bcccb-261">The following example reports that <c>(3.33333, 0.142857)</c> and <c>(10/3, 1/7)</c> are not equal.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Equals#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/precision1.cs#4)]
 [!code-vb[System.Numerics.Complex.Equals#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/precision1.vb#4)]  
  
 <span data-ttu-id="bcccb-262">Um recomendado técnica é definir uma margem aceitável de diferença entre os dois valores (como. 01% de um dos componentes de real e imaginário os valores) em vez de comparar os valores para igualdade.</span><span class="sxs-lookup"><span data-stu-id="bcccb-262">One recommended technique is to define an acceptable margin of difference between the two values (such as .01% of one of the values' real and imaginary components) instead of comparing the values for equality.</span></span> <span data-ttu-id="bcccb-263">Se o valor absoluto da diferença entre os dois valores é menor ou igual a que a margem, a diferença é provavelmente devido a uma diferença de precisão e, portanto, os valores devem ser iguais.</span><span class="sxs-lookup"><span data-stu-id="bcccb-263">If the absolute value of the difference between the two values is less than or equal to that margin, the difference is likely to be due to a difference in precision, and, therefore, the values are likely to be equal.</span></span> <span data-ttu-id="bcccb-264">O exemplo a seguir usa essa técnica para comparar os dois valores complexos que o exemplo de código anterior encontrar ser diferentes.</span><span class="sxs-lookup"><span data-stu-id="bcccb-264">The following example uses this technique to compare the two complex values that the previous code example found to be unequal.</span></span> <span data-ttu-id="bcccb-265">Localiza os dois números complexos são iguais.</span><span class="sxs-lookup"><span data-stu-id="bcccb-265">It finds the two complex numbers to be equal.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Equals#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/precision1.cs#5)]
 [!code-vb[System.Numerics.Complex.Equals#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/precision1.vb#5)]</para>
        </block>
        <altmember cref="T:System.Double" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="bcccb-266">O objeto a ser comparado.</span><span class="sxs-lookup"><span data-stu-id="bcccb-266">The object to compare.</span></span></param>
        <summary><span data-ttu-id="bcccb-267">Retorna um valor que indica se a instância atual e um objeto especificado têm o mesmo valor.</span><span class="sxs-lookup"><span data-stu-id="bcccb-267">Returns a value that indicates whether the current instance and a specified object have the same value.</span></span></summary>
        <returns>
          <span data-ttu-id="bcccb-268"><see langword="true" /> se o parâmetro <paramref name="obj" /> for um objeto <see cref="T:System.Numerics.Complex" /> ou um tipo capaz de conversão implícita para um objeto <see cref="T:System.Numerics.Complex" /> e seu valor for igual ao objeto <see cref="T:System.Numerics.Complex" /> atual; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="bcccb-268"><see langword="true" /> if the <paramref name="obj" /> parameter is a <see cref="T:System.Numerics.Complex" /> object or a type capable of implicit conversion to a <see cref="T:System.Numerics.Complex" /> object, and its value is equal to the current <see cref="T:System.Numerics.Complex" /> object; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bcccb-269">Dois números complexos são iguais se suas partes reais são iguais e suas partes imaginários são iguais.</span><span class="sxs-lookup"><span data-stu-id="bcccb-269">Two complex numbers are equal if their real parts are equal and their imaginary parts are equal.</span></span> <span data-ttu-id="bcccb-270">O <xref:System.Numerics.Complex.Equals%28System.Object%29> método é equivalente à seguinte expressão:</span><span class="sxs-lookup"><span data-stu-id="bcccb-270">The <xref:System.Numerics.Complex.Equals%28System.Object%29> method is equivalent to the following expression:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/equals1.cs#2)]
 [!code-vb[System.Numerics.Complex.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/equals1.vb#2)]  
  
 <span data-ttu-id="bcccb-271">Se o `obj` parâmetro não é um <xref:System.Numerics.Complex> objeto, mas é um tipo de dados para o qual uma conversão implícita é definida, o <xref:System.Numerics.Complex.Equals%28System.Object%29> método converte `obj` para um <xref:System.Numerics.Complex> objeto cuja parte real é igual ao valor de `obj` e cuja parte imaginária é igual a zero antes de executar a comparação.</span><span class="sxs-lookup"><span data-stu-id="bcccb-271">If the `obj` parameter is not a <xref:System.Numerics.Complex> object, but it is a data type for which an implicit conversion is defined, the <xref:System.Numerics.Complex.Equals%28System.Object%29> method converts `obj` to a <xref:System.Numerics.Complex> object whose real part is equal to the value of `obj` and whose imaginary part is equal to zero before it performs the comparison.</span></span> <span data-ttu-id="bcccb-272">O exemplo a seguir ilustra isso localizando um número complexo e um valor de ponto flutuante de precisão dupla são iguais.</span><span class="sxs-lookup"><span data-stu-id="bcccb-272">The following example illustrates this by finding that a complex number and a double-precision floating-point value are equal.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Equals#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/equals3.cs#6)]
 [!code-vb[System.Numerics.Complex.Equals#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/equals3.vb#6)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para><span data-ttu-id="bcccb-273">Use o <see cref="M:System.Numerics.Complex.Equals(System.Numerics.Complex)" /> método com cuidado, porque os dois valores que são equivalentes aparentemente podem ser consideradas diferentes devido à precisão diferente de seus componentes reais e imaginários.</span><span class="sxs-lookup"><span data-stu-id="bcccb-273">Use the <see cref="M:System.Numerics.Complex.Equals(System.Numerics.Complex)" /> method with caution, because two values that are apparently equivalent can be considered unequal due to the differing precision of their real and imaginary components.</span></span> <span data-ttu-id="bcccb-274">O problema pode ser acentuado se <paramref name="obj" /> devem ser convertidos para um <see cref="T:System.Double" /> antes de executar a comparação.</span><span class="sxs-lookup"><span data-stu-id="bcccb-274">The problem can be accentuated if <paramref name="obj" /> must be converted to a <see cref="T:System.Double" /> before performing the comparison.</span></span> <span data-ttu-id="bcccb-275">O exemplo a seguir compara um número complexo cujo componente real parece ser igual a um <see cref="T:System.Single" /> valor com que <see cref="T:System.Single" /> valor.</span><span class="sxs-lookup"><span data-stu-id="bcccb-275">The following example compares a complex number whose real component appears to be equal to a <see cref="T:System.Single" /> value with that <see cref="T:System.Single" /> value.</span></span> <span data-ttu-id="bcccb-276">Como mostra a saída, a comparação de igualdade retorna <see langword="False" />.</span><span class="sxs-lookup"><span data-stu-id="bcccb-276">As the output shows, the comparison for equality returns <see langword="False" />.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Equals#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/equals4.cs#8)]
 [!code-vb[System.Numerics.Complex.Equals#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/equals4.vb#8)]  
  
 <span data-ttu-id="bcccb-277">Um recomendado técnica é definir uma margem aceitável de diferença entre os dois valores (como. 01% de um dos componentes de real e imaginário os valores) em vez de comparar os valores para igualdade.</span><span class="sxs-lookup"><span data-stu-id="bcccb-277">One recommended technique is to define an acceptable margin of difference between the two values (such as .01% of one of the values' real and imaginary components) instead of comparing the values for equality.</span></span> <span data-ttu-id="bcccb-278">Se o valor absoluto da diferença entre os dois valores é menor ou igual a que a margem, a diferença é provavelmente devido a uma diferença de precisão e, portanto, os valores devem ser iguais.</span><span class="sxs-lookup"><span data-stu-id="bcccb-278">If the absolute value of the difference between the two values is less than or equal to that margin, the difference is likely to be due to a difference in precision and, therefore, the values are likely to be equal.</span></span> <span data-ttu-id="bcccb-279">O exemplo a seguir usa essa técnica para comparar os dois valores que o exemplo de código anterior encontrar ser diferentes.</span><span class="sxs-lookup"><span data-stu-id="bcccb-279">The following example uses this technique to compare the two values that the previous code example found to be unequal.</span></span> <span data-ttu-id="bcccb-280">Agora encontra são iguais.</span><span class="sxs-lookup"><span data-stu-id="bcccb-280">It now finds them to be equal.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Equals#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/precision2.cs#7)]
 [!code-vb[System.Numerics.Complex.Equals#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/precision2.vb#7)]</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Exp">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Exp (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Exp(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Exp(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exp (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Exp(System::Numerics::Complex value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="bcccb-281">Um número complexo que especifica uma potência.</span><span class="sxs-lookup"><span data-stu-id="bcccb-281">A complex number that specifies a power.</span></span></param>
        <summary><span data-ttu-id="bcccb-282">Retorna <see langword="e" /> elevado à potência especificada por um número complexo.</span><span class="sxs-lookup"><span data-stu-id="bcccb-282">Returns <see langword="e" /> raised to the power specified by a complex number.</span></span></summary>
        <returns><span data-ttu-id="bcccb-283">O número <see langword="e" /> elevado à potência <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="bcccb-283">The number <see langword="e" /> raised to the power <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bcccb-284">Use o <xref:System.Numerics.Complex.Pow%2A> método para calcular potências de outras bases.</span><span class="sxs-lookup"><span data-stu-id="bcccb-284">Use the <xref:System.Numerics.Complex.Pow%2A> method to calculate the powers of other bases.</span></span>  
  
 <span data-ttu-id="bcccb-285">O <xref:System.Numerics.Complex.Exp%2A> método para números complexos corresponde ao <xref:System.Math.Exp%2A?displayProperty=nameWithType> método para números reais.</span><span class="sxs-lookup"><span data-stu-id="bcccb-285">The <xref:System.Numerics.Complex.Exp%2A> method for complex numbers corresponds to the <xref:System.Math.Exp%2A?displayProperty=nameWithType> method for real numbers.</span></span> <span data-ttu-id="bcccb-286"><xref:System.Numerics.Complex.Exp%2A> é o inverso de <xref:System.Numerics.Complex.Log%2A>.</span><span class="sxs-lookup"><span data-stu-id="bcccb-286"><xref:System.Numerics.Complex.Exp%2A> is the inverse of <xref:System.Numerics.Complex.Log%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bcccb-287">O exemplo a seguir ilustra o <xref:System.Numerics.Complex.Exp%2A> método.</span><span class="sxs-lookup"><span data-stu-id="bcccb-287">The following example illustrates the <xref:System.Numerics.Complex.Exp%2A> method.</span></span> <span data-ttu-id="bcccb-288">Mostra que, com algumas permitido para a falta de precisão do <xref:System.Double> passar o valor retornado pelo tipo de dados, o <xref:System.Numerics.Complex.Log%2A> método para o <xref:System.Numerics.Complex.Exp%2A> método retorna original <xref:System.Numerics.Complex> valor.</span><span class="sxs-lookup"><span data-stu-id="bcccb-288">It shows that, with some allowance for the lack of precision of the <xref:System.Double> data type, passing the value returned by the <xref:System.Numerics.Complex.Log%2A> method to the <xref:System.Numerics.Complex.Exp%2A> method returns the original <xref:System.Numerics.Complex> value.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Log#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.log/cs/log1.cs#1)] 
 [!code-vb[System.Numerics.Complex.Log#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.log/vb/log1.vb#1)]   
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Exp(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="FromPolarCoordinates">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex FromPolarCoordinates (double magnitude, double phase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex FromPolarCoordinates(float64 magnitude, float64 phase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.FromPolarCoordinates(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromPolarCoordinates (magnitude As Double, phase As Double) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex FromPolarCoordinates(double magnitude, double phase);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="magnitude" Type="System.Double" />
        <Parameter Name="phase" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="magnitude"><span data-ttu-id="bcccb-289">A magnitude, que é a distância da origem (a interseção entre os eixos x e y) para o número.</span><span class="sxs-lookup"><span data-stu-id="bcccb-289">The magnitude, which is the distance from the origin (the intersection of the x-axis and the y-axis) to the number.</span></span></param>
        <param name="phase"><span data-ttu-id="bcccb-290">A fase, que é o ângulo da para o eixo horizontal, medido em radianos.</span><span class="sxs-lookup"><span data-stu-id="bcccb-290">The phase, which is the angle from the line to the horizontal axis, measured in radians.</span></span></param>
        <summary><span data-ttu-id="bcccb-291">Cria um número complexo de coordenadas polares de um ponto.</span><span class="sxs-lookup"><span data-stu-id="bcccb-291">Creates a complex number from a point's polar coordinates.</span></span></summary>
        <returns><span data-ttu-id="bcccb-292">Um número complexo.</span><span class="sxs-lookup"><span data-stu-id="bcccb-292">A complex number.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bcccb-293">O <xref:System.Numerics.Complex.FromPolarCoordinates%2A> método instancia um número complexo com base em suas coordenadas polares.</span><span class="sxs-lookup"><span data-stu-id="bcccb-293">The <xref:System.Numerics.Complex.FromPolarCoordinates%2A> method instantiates a complex number based on its polar coordinates.</span></span>  
  
 <span data-ttu-id="bcccb-294">Porque há várias representações de um ponto em um plano de complexo, o valor de retorno de <xref:System.Numerics.Complex.FromPolarCoordinates%2A> método é normalizado.</span><span class="sxs-lookup"><span data-stu-id="bcccb-294">Because there are multiple representations of a point on a complex plane, the return value of the <xref:System.Numerics.Complex.FromPolarCoordinates%2A> method is normalized.</span></span> <span data-ttu-id="bcccb-295">A magnitude é normalizado de acordo com um número positivo e a fase é normalizado de acordo com um valor no intervalo de -<xref:System.Math.PI> para <xref:System.Math.PI>.</span><span class="sxs-lookup"><span data-stu-id="bcccb-295">The magnitude is normalized to a positive number, and the phase is normalized to a value in the range of -<xref:System.Math.PI> to <xref:System.Math.PI>.</span></span> <span data-ttu-id="bcccb-296">Como resultado, os valores da <xref:System.Numerics.Complex.Phase%2A> e <xref:System.Numerics.Complex.Magnitude%2A> propriedades do número complexo resultante podem não ser igual os valores originais do `magnitude` e `phase` parâmetros.</span><span class="sxs-lookup"><span data-stu-id="bcccb-296">As a result, the values of the <xref:System.Numerics.Complex.Phase%2A> and <xref:System.Numerics.Complex.Magnitude%2A> properties of the resulting complex number may not equal the original values of the `magnitude` and `phase` parameters.</span></span>  
  
 <span data-ttu-id="bcccb-297">Para converter um valor de graus em radianos para o `phase` parâmetro, multiplique-lo por  <xref:System.Math.PI?displayProperty=nameWithType> /180.</span><span class="sxs-lookup"><span data-stu-id="bcccb-297">To convert a value from degrees to radians for the `phase` parameter, multiply it by <xref:System.Math.PI?displayProperty=nameWithType>/180.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bcccb-298">O exemplo a seguir usa o <xref:System.Numerics.Complex.FromPolarCoordinates%2A> método para criar uma instância de um número complexo com base em suas coordenadas polares e, em seguida, exibe o valor da sua <xref:System.Numerics.Complex.Magnitude%2A> e <xref:System.Numerics.Complex.Phase%2A> propriedades.</span><span class="sxs-lookup"><span data-stu-id="bcccb-298">The following example uses the <xref:System.Numerics.Complex.FromPolarCoordinates%2A> method to instantiate a complex number based on its polar coordinates and then displays the value of its <xref:System.Numerics.Complex.Magnitude%2A> and <xref:System.Numerics.Complex.Phase%2A> properties.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Phase#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.phase/cs/phase1.cs#1)]
 [!code-vb[System.Numerics.Complex.Phase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.phase/vb/phase1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.Complex.Magnitude" />
        <altmember cref="P:System.Numerics.Complex.Phase" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="bcccb-299">Retorna o código hash para o objeto <see cref="T:System.Numerics.Complex" /> atual.</span><span class="sxs-lookup"><span data-stu-id="bcccb-299">Returns the hash code for the current <see cref="T:System.Numerics.Complex" /> object.</span></span></summary>
        <returns><span data-ttu-id="bcccb-300">Um código de hash do inteiro assinado de 32 bits.</span><span class="sxs-lookup"><span data-stu-id="bcccb-300">A 32-bit signed integer hash code.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Imaginary">
      <MemberSignature Language="C#" Value="public double Imaginary { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Imaginary" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Complex.Imaginary" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Imaginary As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Imaginary { double get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="bcccb-301">Obtém o componente imaginário do objeto <see cref="T:System.Numerics.Complex" /> atual.</span><span class="sxs-lookup"><span data-stu-id="bcccb-301">Gets the imaginary component of the current <see cref="T:System.Numerics.Complex" /> object.</span></span></summary>
        <value><span data-ttu-id="bcccb-302">O componente imaginário de um número complexo.</span><span class="sxs-lookup"><span data-stu-id="bcccb-302">The imaginary component of a complex number.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bcccb-303">Dado um número complexo a + bi, o <xref:System.Numerics.Complex.Imaginary%2A> propriedade retorna o valor de b.</span><span class="sxs-lookup"><span data-stu-id="bcccb-303">Given a complex number a + bi, the <xref:System.Numerics.Complex.Imaginary%2A> property returns the value of b.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bcccb-304">O exemplo a seguir cria uma matriz de <xref:System.Numerics.Complex> objetos e exibe os componentes reais e imaginários de cada no formulário a + bi.</span><span class="sxs-lookup"><span data-stu-id="bcccb-304">The following example instantiates an array of <xref:System.Numerics.Complex> objects and displays the real and imaginary components of each in the form a + bi.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Real#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.real/cs/real1.cs#1)]
 [!code-vb[System.Numerics.Complex.Real#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.real/vb/real1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.Complex.Real" />
      </Docs>
    </Member>
    <Member MemberName="ImaginaryOne">
      <MemberSignature Language="C#" Value="public static readonly System.Numerics.Complex ImaginaryOne;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Numerics.Complex ImaginaryOne" />
      <MemberSignature Language="DocId" Value="F:System.Numerics.Complex.ImaginaryOne" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ImaginaryOne As Complex " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Numerics::Complex ImaginaryOne;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="bcccb-305">Retorna uma nova instância do <see cref="T:System.Numerics.Complex" /> com um número real igual a zero e um número imaginário igual a um.</span><span class="sxs-lookup"><span data-stu-id="bcccb-305">Returns a new <see cref="T:System.Numerics.Complex" /> instance with a real number equal to zero and an imaginary number equal to one.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="bcccb-306">O exemplo a seguir cria um <xref:System.Numerics.Complex> valor usando o <xref:System.Numerics.Complex.ImaginaryOne> propriedade.</span><span class="sxs-lookup"><span data-stu-id="bcccb-306">The following example instantiates a <xref:System.Numerics.Complex> value by using the <xref:System.Numerics.Complex.ImaginaryOne> property.</span></span> <span data-ttu-id="bcccb-307">Ele então compara esse valor com outro valor que é instanciado chamando o <xref:System.Numerics.Complex> construtor com uma parte real igual a zero e uma parte imaginária igual a um.</span><span class="sxs-lookup"><span data-stu-id="bcccb-307">It then compares this value to another value that is instantiated by calling the <xref:System.Numerics.Complex> constructor with a real part equal to zero and an imaginary part equal to one.</span></span> <span data-ttu-id="bcccb-308">Como mostra a saída do exemplo, os dois valores são iguais.</span><span class="sxs-lookup"><span data-stu-id="bcccb-308">As the output from the example shows, the two values are equal.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.ImaginaryOne#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.imaginaryone/cs/imaginaryone1.cs#1)]
 [!code-vb[System.Numerics.Complex.ImaginaryOne#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.imaginaryone/vb/imaginaryone1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Numerics.Complex.One" />
        <altmember cref="F:System.Numerics.Complex.Zero" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Log">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="bcccb-309">Retorna o logaritmo de um número complexo.</span><span class="sxs-lookup"><span data-stu-id="bcccb-309">Returns the logarithm of a complex number.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Log (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Log(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Log(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Log(System::Numerics::Complex value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="bcccb-310">Um número complexo.</span><span class="sxs-lookup"><span data-stu-id="bcccb-310">A complex number.</span></span></param>
        <summary><span data-ttu-id="bcccb-311">Retorna o logaritmo natural (de base <see langword="e" />) de um número complexo especificado.</span><span class="sxs-lookup"><span data-stu-id="bcccb-311">Returns the natural (base <see langword="e" />) logarithm of a specified complex number.</span></span></summary>
        <returns><span data-ttu-id="bcccb-312">O logaritmo natural (de base <see langword="e" />) de <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="bcccb-312">The natural (base <see langword="e" />) logarithm of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bcccb-313">O <xref:System.Numerics.Complex.Log%28System.Numerics.Complex%29> método para números complexos corresponde ao <xref:System.Math.Log%28System.Double%29?displayProperty=nameWithType> método para números reais.</span><span class="sxs-lookup"><span data-stu-id="bcccb-313">The <xref:System.Numerics.Complex.Log%28System.Numerics.Complex%29> method for complex numbers corresponds to the <xref:System.Math.Log%28System.Double%29?displayProperty=nameWithType> method for real numbers.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bcccb-314">O exemplo a seguir ilustra o <xref:System.Numerics.Complex.Log%2A> método.</span><span class="sxs-lookup"><span data-stu-id="bcccb-314">The following example illustrates the <xref:System.Numerics.Complex.Log%2A> method.</span></span> <span data-ttu-id="bcccb-315">Mostra que, com algumas permitido para a falta de precisão do <xref:System.Double> passar o valor retornado pelo tipo de dados, o <xref:System.Numerics.Complex.Log%2A> método para o <xref:System.Numerics.Complex.Exp%2A> método retorna original <xref:System.Numerics.Complex> valor.</span><span class="sxs-lookup"><span data-stu-id="bcccb-315">It shows that, with some allowance for the lack of precision of the <xref:System.Double> data type, passing the value returned by the <xref:System.Numerics.Complex.Log%2A> method to the <xref:System.Numerics.Complex.Exp%2A> method returns the original <xref:System.Numerics.Complex> value.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Log#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.log/cs/log1.cs#1)] 
 [!code-vb[System.Numerics.Complex.Log#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.log/vb/log1.vb#1)]   
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Log(System.Double)" />
        <altmember cref="M:System.Numerics.Complex.Exp(System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Log (System.Numerics.Complex value, double baseValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Log(valuetype System.Numerics.Complex value, float64 baseValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Log(System.Numerics.Complex,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log (value As Complex, baseValue As Double) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Log(System::Numerics::Complex value, double baseValue);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
        <Parameter Name="baseValue" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="bcccb-316">Um número complexo.</span><span class="sxs-lookup"><span data-stu-id="bcccb-316">A complex number.</span></span></param>
        <param name="baseValue"><span data-ttu-id="bcccb-317">A base do logaritmo.</span><span class="sxs-lookup"><span data-stu-id="bcccb-317">The base of the logarithm.</span></span></param>
        <summary><span data-ttu-id="bcccb-318">Retorna o logaritmo de um número complexo especificado em uma base especificada.</span><span class="sxs-lookup"><span data-stu-id="bcccb-318">Returns the logarithm of a specified complex number in a specified base.</span></span></summary>
        <returns><span data-ttu-id="bcccb-319">O logaritmo de <paramref name="value" /> na base <paramref name="baseValue" />.</span><span class="sxs-lookup"><span data-stu-id="bcccb-319">The logarithm of <paramref name="value" /> in base <paramref name="baseValue" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bcccb-320">O <xref:System.Numerics.Complex.Log%28System.Numerics.Complex%2CSystem.Double%29> método para números complexos corresponde ao <xref:System.Math.Log%28System.Double%2CSystem.Double%29?displayProperty=nameWithType> método para números reais.</span><span class="sxs-lookup"><span data-stu-id="bcccb-320">The <xref:System.Numerics.Complex.Log%28System.Numerics.Complex%2CSystem.Double%29> method for complex numbers corresponds to the <xref:System.Math.Log%28System.Double%2CSystem.Double%29?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Log10">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Log10 (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Log10(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Log10(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log10 (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Log10(System::Numerics::Complex value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="bcccb-321">Um número complexo.</span><span class="sxs-lookup"><span data-stu-id="bcccb-321">A complex number.</span></span></param>
        <summary><span data-ttu-id="bcccb-322">Retorna o logaritmo de base 10 de um número complexo especificado.</span><span class="sxs-lookup"><span data-stu-id="bcccb-322">Returns the base-10 logarithm of a specified complex number.</span></span></summary>
        <returns><span data-ttu-id="bcccb-323">O logaritmo de base 10 de <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="bcccb-323">The base-10 logarithm of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bcccb-324">O <xref:System.Numerics.Complex.Log10%2A> método para números complexos corresponde ao <xref:System.Math.Log10%2A?displayProperty=nameWithType> método para números reais.</span><span class="sxs-lookup"><span data-stu-id="bcccb-324">The <xref:System.Numerics.Complex.Log10%2A> method for complex numbers corresponds to the <xref:System.Math.Log10%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Magnitude">
      <MemberSignature Language="C#" Value="public double Magnitude { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Magnitude" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Complex.Magnitude" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Magnitude As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Magnitude { double get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="bcccb-325">Obtém a magnitude (ou valor absoluto) de um número complexo.</span><span class="sxs-lookup"><span data-stu-id="bcccb-325">Gets the magnitude (or absolute value) of a complex number.</span></span></summary>
        <value><span data-ttu-id="bcccb-326">A magnitude da instância atual.</span><span class="sxs-lookup"><span data-stu-id="bcccb-326">The magnitude of the current instance.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bcccb-327">O <xref:System.Numerics.Complex.Magnitude%2A> propriedade é equivalente ao valor absoluto de um número complexo.</span><span class="sxs-lookup"><span data-stu-id="bcccb-327">The <xref:System.Numerics.Complex.Magnitude%2A> property is equivalent to the absolute value of a complex number.</span></span> <span data-ttu-id="bcccb-328">Especifica a distância da origem (a interseção do eixo x e y no sistema de coordenadas cartesianas) para o ponto bidimensional representado por um número complexo.</span><span class="sxs-lookup"><span data-stu-id="bcccb-328">It specifies the distance from the origin (the intersection of the x-axis and the y-axis in the Cartesian coordinate system) to the two-dimensional point represented by a complex number.</span></span> <span data-ttu-id="bcccb-329">O valor absoluto é calculado da seguinte maneira:</span><span class="sxs-lookup"><span data-stu-id="bcccb-329">The absolute value is calculated as follows:</span></span>  
  
 <span data-ttu-id="bcccb-330">&#124; a + bi &#124; = <xref:System.Math.Sqrt%2A?displayProperty=nameWithType>(a * a + b * b)</span><span class="sxs-lookup"><span data-stu-id="bcccb-330">&#124; a + bi &#124; = <xref:System.Math.Sqrt%2A?displayProperty=nameWithType>(a * a + b * b)</span></span>  
  
 <span data-ttu-id="bcccb-331">Se o cálculo do valor absoluto resulta em um estouro, essa propriedade retorna um <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> ou <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="bcccb-331">If the calculation of the absolute value results in an overflow, this property returns either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="bcccb-332">O <xref:System.Numerics.Complex.Magnitude%2A> e <xref:System.Numerics.Complex.Phase%2A> propriedades definem a posição de um ponto que representa um número complexo no sistema de coordenadas polares.</span><span class="sxs-lookup"><span data-stu-id="bcccb-332">The <xref:System.Numerics.Complex.Magnitude%2A> and the <xref:System.Numerics.Complex.Phase%2A> properties define the position of a point that represents a complex number in the polar coordinate system.</span></span>  
  
 <span data-ttu-id="bcccb-333">Você pode criar uma instância de um número complexo com base em suas coordenadas polares, em vez de suas coordenadas cartesianas chamando o <xref:System.Numerics.Complex.FromPolarCoordinates%2A> método.</span><span class="sxs-lookup"><span data-stu-id="bcccb-333">You can instantiate a complex number based on its polar coordinates instead of its Cartesian coordinates by calling the <xref:System.Numerics.Complex.FromPolarCoordinates%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bcccb-334">O exemplo a seguir calcula o valor absoluto de um número complexo e demonstra o que é equivalente ao valor da <xref:System.Numerics.Complex.Magnitude%2A> propriedade.</span><span class="sxs-lookup"><span data-stu-id="bcccb-334">The following example calculates the absolute value of a complex number and demonstrates that it is equivalent to the value of the <xref:System.Numerics.Complex.Magnitude%2A> property.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Abs#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.abs/cs/abs1.cs#1)]
 [!code-vb[System.Numerics.Complex.Abs#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.abs/vb/abs1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Abs(System.Numerics.Complex)" />
        <altmember cref="P:System.Numerics.Complex.Phase" />
      </Docs>
    </Member>
    <Member MemberName="Multiply">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Multiply (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Multiply(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Multiply(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Multiply (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Multiply(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="bcccb-335">O primeiro número complexo a multiplicar.</span><span class="sxs-lookup"><span data-stu-id="bcccb-335">The first complex number to multiply.</span></span></param>
        <param name="right"><span data-ttu-id="bcccb-336">O segundo número complexo a multiplicar.</span><span class="sxs-lookup"><span data-stu-id="bcccb-336">The second complex number to multiply.</span></span></param>
        <summary><span data-ttu-id="bcccb-337">Retorna o produto de dois números complexos.</span><span class="sxs-lookup"><span data-stu-id="bcccb-337">Returns the product of two complex numbers.</span></span></summary>
        <returns><span data-ttu-id="bcccb-338">O produto dos parâmetros <paramref name="left" /> e <paramref name="right" />.</span><span class="sxs-lookup"><span data-stu-id="bcccb-338">The product of the <paramref name="left" /> and <paramref name="right" /> parameters.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bcccb-339">A multiplicação de um complexo de número, um + bi, e um segundo número complexo, c + injeção de dependência, leva o seguinte formato:</span><span class="sxs-lookup"><span data-stu-id="bcccb-339">The multiplication of a complex number, a + bi, and a second complex number, c + di, takes the following form:</span></span>  
  
 <span data-ttu-id="bcccb-340">(o CA - bd) + (ad + continuidade de negócios),</span><span class="sxs-lookup"><span data-stu-id="bcccb-340">(ac - bd) + (ad + bc)i</span></span>  
  
 <span data-ttu-id="bcccb-341">Se a multiplicação resulta em um estouro no componente real ou imaginário, o valor desse componente é <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> ou <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="bcccb-341">If the multiplication results in an overflow in either the real or imaginary component, the value of that component is either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="bcccb-342">O <xref:System.Numerics.Complex.Multiply%2A> método é implementado para os idiomas que não dão suporte a operadores personalizados.</span><span class="sxs-lookup"><span data-stu-id="bcccb-342">The <xref:System.Numerics.Complex.Multiply%2A> method is implemented for languages that do not support custom operators.</span></span> <span data-ttu-id="bcccb-343">Seu comportamento é idêntico a multiplicação usando o operador de multiplicação.</span><span class="sxs-lookup"><span data-stu-id="bcccb-343">Its behavior is identical to multiplication using the multiplication operator.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bcccb-344">O exemplo a seguir múltiplos um número complexo por cada elemento em uma matriz de números complexos.</span><span class="sxs-lookup"><span data-stu-id="bcccb-344">The following example multiples a complex number by each element in an array of complex numbers.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Multiply#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.multiply/cs/multiply1.cs#1)]
 [!code-vb[System.Numerics.Complex.Multiply#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.multiply/vb/multiply1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Multiply(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Negate">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Negate (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Negate(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Negate(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Negate (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Negate(System::Numerics::Complex value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="bcccb-345">Um número complexo.</span><span class="sxs-lookup"><span data-stu-id="bcccb-345">A complex number.</span></span></param>
        <summary><span data-ttu-id="bcccb-346">Retorna o inverso aditivo de um número complexo especificado.</span><span class="sxs-lookup"><span data-stu-id="bcccb-346">Returns the additive inverse of a specified complex number.</span></span></summary>
        <returns><span data-ttu-id="bcccb-347">O resultado dos componentes <see cref="P:System.Numerics.Complex.Real" /> e <see cref="P:System.Numerics.Complex.Imaginary" /> do parâmetro <paramref name="value" /> multiplicado por -1.</span><span class="sxs-lookup"><span data-stu-id="bcccb-347">The result of the <see cref="P:System.Numerics.Complex.Real" /> and <see cref="P:System.Numerics.Complex.Imaginary" /> components of the <paramref name="value" /> parameter multiplied by -1.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bcccb-348">O inverso aditivo de um número complexo é um número complexo que gera um valor de <xref:System.Numerics.Complex> quando ele é adicionado ao número complexo original.</span><span class="sxs-lookup"><span data-stu-id="bcccb-348">The additive inverse of a complex number is a complex number that produces a value of <xref:System.Numerics.Complex> when it is added to the original complex number.</span></span> <span data-ttu-id="bcccb-349">Esse método retorna um número complexo em que os componentes reais e imaginários do número complexo original são multiplicados por -1.</span><span class="sxs-lookup"><span data-stu-id="bcccb-349">This method returns a complex number in which the real and imaginary components of the original complex number are multiplied by -1.</span></span>  
  
 <span data-ttu-id="bcccb-350">O <xref:System.Numerics.Complex.Negate%2A> método é implementado para os idiomas que não dão suporte a operadores personalizados.</span><span class="sxs-lookup"><span data-stu-id="bcccb-350">The <xref:System.Numerics.Complex.Negate%2A> method is implemented for languages that do not support custom operators.</span></span> <span data-ttu-id="bcccb-351">Seu comportamento é idêntico à negação usando o operador de negação unário, <xref:System.Numerics.Complex.op_UnaryNegation%2A>.</span><span class="sxs-lookup"><span data-stu-id="bcccb-351">Its behavior is identical to negation using the unary negation operator, <xref:System.Numerics.Complex.op_UnaryNegation%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bcccb-352">O exemplo a seguir obtém o inverso aditivo de cada elemento em uma matriz de números complexos.</span><span class="sxs-lookup"><span data-stu-id="bcccb-352">The following example obtains the additive inverse of each element in an array of complex numbers.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Negate#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.negate/cs/negate1.cs#1)]
 [!code-vb[System.Numerics.Complex.Negate#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.negate/vb/negate1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_UnaryNegation(System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="One">
      <MemberSignature Language="C#" Value="public static readonly System.Numerics.Complex One;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Numerics.Complex One" />
      <MemberSignature Language="DocId" Value="F:System.Numerics.Complex.One" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly One As Complex " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Numerics::Complex One;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="bcccb-353">Retorna uma nova instância do <see cref="T:System.Numerics.Complex" /> com um número real igual a um e um número imaginário igual a zero.</span><span class="sxs-lookup"><span data-stu-id="bcccb-353">Returns a new <see cref="T:System.Numerics.Complex" /> instance with a real number equal to one and an imaginary number equal to zero.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="bcccb-354">O exemplo a seguir cria um <xref:System.Numerics.Complex> valor usando o <xref:System.Numerics.Complex.One> propriedade.</span><span class="sxs-lookup"><span data-stu-id="bcccb-354">The following example instantiates a <xref:System.Numerics.Complex> value by using the <xref:System.Numerics.Complex.One> property.</span></span> <span data-ttu-id="bcccb-355">Ele então compara esse valor com outro valor que é instanciado chamando o <xref:System.Numerics.Complex> construtor com igual à parte real e uma parte imaginária igual a zero.</span><span class="sxs-lookup"><span data-stu-id="bcccb-355">It then compares this value to another value that is instantiated by calling the <xref:System.Numerics.Complex> constructor with a real part equal to one and an imaginary part equal to zero.</span></span> <span data-ttu-id="bcccb-356">Como mostra a saída do exemplo, os dois valores são iguais.</span><span class="sxs-lookup"><span data-stu-id="bcccb-356">As the output from the example shows, the two values are equal.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.One#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.one/cs/one1.cs#1)]
 [!code-vb[System.Numerics.Complex.One#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.one/vb/one1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Numerics.Complex.ImaginaryOne" />
        <altmember cref="F:System.Numerics.Complex.Zero" />
      </Docs>
    </Member>
    <Member MemberName="op_Addition">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator + (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Addition(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Addition(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator + (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator +(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="bcccb-357">O primeiro valor a ser adicionado.</span><span class="sxs-lookup"><span data-stu-id="bcccb-357">The first value to add.</span></span></param>
        <param name="right"><span data-ttu-id="bcccb-358">O segundo valor a ser adicionado.</span><span class="sxs-lookup"><span data-stu-id="bcccb-358">The second value to add.</span></span></param>
        <summary><span data-ttu-id="bcccb-359">Adiciona dois números complexos.</span><span class="sxs-lookup"><span data-stu-id="bcccb-359">Adds two complex numbers.</span></span></summary>
        <returns><span data-ttu-id="bcccb-360">A soma de <paramref name="left" /> e <paramref name="right" />.</span><span class="sxs-lookup"><span data-stu-id="bcccb-360">The sum of <paramref name="left" /> and <paramref name="right" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bcccb-361">O <xref:System.Numerics.Complex.op_Addition%2A> método define a operação de adição de números complexos.</span><span class="sxs-lookup"><span data-stu-id="bcccb-361">The <xref:System.Numerics.Complex.op_Addition%2A> method defines the addition operation for complex numbers.</span></span> <span data-ttu-id="bcccb-362">Ele permite que o código seja o seguinte:</span><span class="sxs-lookup"><span data-stu-id="bcccb-362">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Add#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.add/cs/add3.cs#3)]
 [!code-vb[System.Numerics.Complex.Add#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.add/vb/add3.vb#3)]  
  
 <span data-ttu-id="bcccb-363">A adição de um complexo de número, um + bi, e um segundo número complexo, c + injeção de dependência, leva o seguinte formato:</span><span class="sxs-lookup"><span data-stu-id="bcccb-363">The addition of a complex number, a + bi, and a second complex number, c + di, takes the following form:</span></span>  
  
 <span data-ttu-id="bcccb-364">(a + c) + (b + d) i</span><span class="sxs-lookup"><span data-stu-id="bcccb-364">(a + c) + (b + d)i</span></span>  
  
 <span data-ttu-id="bcccb-365">Se a chamada do método resultados em um estouro no componente real ou imaginário, o valor desse componente é <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> ou <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="bcccb-365">If the method call results in an overflow in either the real or imaginary component, the value of that component is either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="bcccb-366">Linguagens que não dão suporte a operadores personalizados podem chamar o método <xref:System.Numerics.Complex.Add%2A> em vez disso.</span><span class="sxs-lookup"><span data-stu-id="bcccb-366">Languages that do not support custom operators can call the <xref:System.Numerics.Complex.Add%2A> method instead.</span></span>  
  
 <span data-ttu-id="bcccb-367">O método equivalente para esse operador é <xref:System.Numerics.Complex.Add%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="bcccb-367">The equivalent method for this operator is <xref:System.Numerics.Complex.Add%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType></span></span>  
  
## Examples  
 <span data-ttu-id="bcccb-368">O exemplo a seguir ilustra a adição com números complexos.</span><span class="sxs-lookup"><span data-stu-id="bcccb-368">The following example illustrates addition with complex numbers.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Add#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.add/cs/add2.cs#2)]
 [!code-vb[System.Numerics.Complex.Add#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.add/vb/add2.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Add(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="op_Division">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator / (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Division(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Division(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator / (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator /(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="bcccb-369">O valor a ser dividido.</span><span class="sxs-lookup"><span data-stu-id="bcccb-369">The value to be divided.</span></span></param>
        <param name="right"><span data-ttu-id="bcccb-370">O valor pelo qual dividir.</span><span class="sxs-lookup"><span data-stu-id="bcccb-370">The value to divide by.</span></span></param>
        <summary><span data-ttu-id="bcccb-371">Divide um número complexo especificado por outro número complexo especificado.</span><span class="sxs-lookup"><span data-stu-id="bcccb-371">Divides a specified complex number by another specified complex number.</span></span></summary>
        <returns><span data-ttu-id="bcccb-372">O resultado da divisão de <paramref name="left" /> por <paramref name="right" />.</span><span class="sxs-lookup"><span data-stu-id="bcccb-372">The result of dividing <paramref name="left" /> by <paramref name="right" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bcccb-373">O <xref:System.Numerics.Complex.op_Division%2A> método define a operação de divisão para números complexos.</span><span class="sxs-lookup"><span data-stu-id="bcccb-373">The <xref:System.Numerics.Complex.op_Division%2A> method defines the division operation for complex numbers.</span></span> <span data-ttu-id="bcccb-374">Ele permite que o código seja o seguinte:</span><span class="sxs-lookup"><span data-stu-id="bcccb-374">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Divide#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.divide/cs/divide2.cs#2)]
 [!code-vb[System.Numerics.Complex.Divide#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.divide/vb/divide2.vb#2)]  
  
 <span data-ttu-id="bcccb-375">A divisão de um complexo de número, um + bi, e um segundo número complexo, c + injeção de dependência, leva o seguinte formato:</span><span class="sxs-lookup"><span data-stu-id="bcccb-375">The division of a complex number, a + bi, and a second complex number, c + di, takes the following form:</span></span>  
  
 <span data-ttu-id="bcccb-376">((AC + BD) / (c<sup>2</sup> + d<sup>2</sup>)) + ((bc-ad) / (c<sup>2</sup> + d<sup>2</sup>),</span><span class="sxs-lookup"><span data-stu-id="bcccb-376">((ac + bd) / (c<sup>2</sup> + d<sup>2</sup>)) + ((bc - ad) / (c<sup>2</sup> + d<sup>2</sup>)i</span></span>  
  
 <span data-ttu-id="bcccb-377">Se a divisão resulta em um estouro no componente real ou imaginário, o valor desse componente é <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> ou <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="bcccb-377">If the division results in an overflow in either the real or imaginary component, the value of that component is either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="bcccb-378">Idiomas que dão suporte a operadores personalizados e sobrecarga de operador podem chamar o <xref:System.Numerics.Complex.Divide%2A> método em vez disso.</span><span class="sxs-lookup"><span data-stu-id="bcccb-378">Languages that do not support custom operators and operator overloading can call the <xref:System.Numerics.Complex.Divide%2A> method instead.</span></span>  
  
 <span data-ttu-id="bcccb-379">O método equivalente para esse operador é <xref:System.Numerics.Complex.Divide%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="bcccb-379">The equivalent method for this operator is <xref:System.Numerics.Complex.Divide%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType></span></span>]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Divide(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Equality(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Complex, right As Complex) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="bcccb-380">O primeiro número complexo a ser comparado.</span><span class="sxs-lookup"><span data-stu-id="bcccb-380">The first complex number to compare.</span></span></param>
        <param name="right"><span data-ttu-id="bcccb-381">O segundo número complexo a ser comparado.</span><span class="sxs-lookup"><span data-stu-id="bcccb-381">The second complex number to compare.</span></span></param>
        <summary><span data-ttu-id="bcccb-382">Retorna um valor que indica se dois números complexos são iguais.</span><span class="sxs-lookup"><span data-stu-id="bcccb-382">Returns a value that indicates whether two complex numbers are equal.</span></span></summary>
        <returns>
          <span data-ttu-id="bcccb-383"><see langword="true" /> se os parâmetros <paramref name="left" /> e <paramref name="right" /> tiverem o mesmo valor; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="bcccb-383"><see langword="true" /> if the <paramref name="left" /> and <paramref name="right" /> parameters have the same value; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bcccb-384">O <xref:System.Numerics.Complex.op_Equality%2A> método define a operação do operador de igualdade para <xref:System.Numerics.Complex> valores.</span><span class="sxs-lookup"><span data-stu-id="bcccb-384">The <xref:System.Numerics.Complex.op_Equality%2A> method defines the operation of the equality operator for <xref:System.Numerics.Complex> values.</span></span> <span data-ttu-id="bcccb-385">Ele permite que o código seja o seguinte:</span><span class="sxs-lookup"><span data-stu-id="bcccb-385">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Equals#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/eqoperator1.cs#9)]
 [!code-vb[System.Numerics.Complex.Equals#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/eqoperator1.vb#9)]  
  
 <span data-ttu-id="bcccb-386">Linguagens que não dão suporte a operadores personalizados podem chamar o método <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> em vez disso.</span><span class="sxs-lookup"><span data-stu-id="bcccb-386">Languages that do not support custom operators can call the <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> method instead.</span></span>  
  
 <span data-ttu-id="bcccb-387">Dois números complexos são iguais se suas partes reais são iguais e suas partes imaginários são iguais.</span><span class="sxs-lookup"><span data-stu-id="bcccb-387">Two complex numbers are equal if their real parts are equal and their imaginary parts are equal.</span></span> <span data-ttu-id="bcccb-388">O <xref:System.Numerics.Complex.op_Equality%2A> método é equivalente à seguinte expressão:</span><span class="sxs-lookup"><span data-stu-id="bcccb-388">The <xref:System.Numerics.Complex.op_Equality%2A> method is equivalent to the following expression:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Equals#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/equals1.cs#3)]
 [!code-vb[System.Numerics.Complex.Equals#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/equals1.vb#3)]  
  
 <span data-ttu-id="bcccb-389">Observe que, por causa das diferenças na precisão, dois números complexos aparentemente equivalentes podem ser considerados diferentes.</span><span class="sxs-lookup"><span data-stu-id="bcccb-389">Note that, because of differences in precision, two complex numbers that are apparently equivalent can be considered unequal.</span></span> <span data-ttu-id="bcccb-390">Para obter mais informações e uma solução alternativa, consulte o <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> método.</span><span class="sxs-lookup"><span data-stu-id="bcccb-390">For more information and a possible workaround, see the <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> method.</span></span>  
  
 <span data-ttu-id="bcccb-391">O método equivalente para esse operador é <xref:System.Numerics.Complex.Equals%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="bcccb-391">The equivalent method for this operator is <xref:System.Numerics.Complex.Equals%2A?displayProperty=nameWithType></span></span>]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Explicit">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="bcccb-392">Define uma conversão explícita entre um objeto <see cref="T:System.Numerics.Complex" /> e outro tipo.</span><span class="sxs-lookup"><span data-stu-id="bcccb-392">Defines an explicit conversion between a <see cref="T:System.Numerics.Complex" /> object and another type.</span></span></summary>
        <altmember cref="Overload:System.Numerics.Complex.op_Implicit" />
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Numerics.Complex (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Explicit(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Explicit(System.Decimal)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Decimal) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Numerics::Complex(System::Decimal value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="bcccb-393">O valor a ser convertido em um número complexo.</span><span class="sxs-lookup"><span data-stu-id="bcccb-393">The value to convert to a complex number.</span></span></param>
        <summary><span data-ttu-id="bcccb-394">Define uma conversão explícita de um valor <see cref="T:System.Decimal" /> para um número complexo.</span><span class="sxs-lookup"><span data-stu-id="bcccb-394">Defines an explicit conversion of a <see cref="T:System.Decimal" /> value to a complex number.</span></span></summary>
        <returns><span data-ttu-id="bcccb-395">Um número complexo que tem um componente real igual a <paramref name="value" /> e um componente imaginário igual a zero.</span><span class="sxs-lookup"><span data-stu-id="bcccb-395">A complex number that has a real component equal to <paramref name="value" /> and an imaginary component equal to zero.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bcccb-396">Operadores de conversão explícita definem tipos que podem ser convertidos em um <xref:System.Numerics.Complex> objeto.</span><span class="sxs-lookup"><span data-stu-id="bcccb-396">Explicit conversion operators define types that can be converted to a <xref:System.Numerics.Complex> object.</span></span> <span data-ttu-id="bcccb-397">Compiladores de linguagem não realizar essa conversão automaticamente porque ele pode envolver a perda de dados.</span><span class="sxs-lookup"><span data-stu-id="bcccb-397">Language compilers do not perform this conversion automatically because it can involve data loss.</span></span> <span data-ttu-id="bcccb-398">Em vez disso, eles executarem a conversão somente se um operador de conversão (em c#) ou uma função de conversão (como `CType` no Visual Basic) é usado.</span><span class="sxs-lookup"><span data-stu-id="bcccb-398">Instead, they perform the conversion only if a casting operator (in C#) or a conversion function (such as `CType` in Visual Basic) is used.</span></span> <span data-ttu-id="bcccb-399">Caso contrário, eles exibem um erro do compilador.</span><span class="sxs-lookup"><span data-stu-id="bcccb-399">Otherwise, they display a compiler error.</span></span>

 <span data-ttu-id="bcccb-400">A conversão de um <xref:System.Decimal> valor para a parte real de um número complexo pode resultar em perda de precisão porque um <xref:System.Double>, que é o tipo do número de complexo <xref:System.Numerics.Complex.Real%2A> propriedade, tem menos dígitos significativos que uma <xref:System.Decimal>.</span><span class="sxs-lookup"><span data-stu-id="bcccb-400">The conversion of a <xref:System.Decimal> value to the real part of a complex number can result in a loss of precision because a <xref:System.Double>, which is the type of the complex number's <xref:System.Numerics.Complex.Real%2A> property, has fewer significant digits than a <xref:System.Decimal>.</span></span>



## Examples
 <span data-ttu-id="bcccb-401">O exemplo a seguir ilustra a conversão explícita de <xref:System.Decimal> valores <xref:System.Numerics.Complex> valores.</span><span class="sxs-lookup"><span data-stu-id="bcccb-401">The following example illustrates the explicit conversion of <xref:System.Decimal> values to <xref:System.Numerics.Complex> values.</span></span>

 [!code-csharp[System.Numerics.Complex.Explicit#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.explicit/cs/explicit1.cs#1)]   
 [!code-vb[System.Numerics.Complex.Explicit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.explicit/vb/explicit1.vb#1)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Numerics.Complex (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Explicit(System.Numerics.BigInteger)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Numerics::Complex(System::Numerics::BigInteger value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="bcccb-402">O valor a ser convertido em um número complexo.</span><span class="sxs-lookup"><span data-stu-id="bcccb-402">The value to convert to a complex number.</span></span></param>
        <summary><span data-ttu-id="bcccb-403">Define uma conversão explícita de um valor <see cref="T:System.Numerics.BigInteger" /> para um número complexo.</span><span class="sxs-lookup"><span data-stu-id="bcccb-403">Defines an explicit conversion of a <see cref="T:System.Numerics.BigInteger" /> value to a complex number.</span></span></summary>
        <returns><span data-ttu-id="bcccb-404">Um número complexo que tem um componente real igual a <paramref name="value" /> e um componente imaginário igual a zero.</span><span class="sxs-lookup"><span data-stu-id="bcccb-404">A complex number that has a real component equal to <paramref name="value" /> and an imaginary component equal to zero.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bcccb-405">Operadores de conversão explícita definem tipos que podem ser convertidos em um <xref:System.Numerics.Complex> objeto.</span><span class="sxs-lookup"><span data-stu-id="bcccb-405">Explicit conversion operators define types that can be converted to a <xref:System.Numerics.Complex> object.</span></span> <span data-ttu-id="bcccb-406">Compiladores de linguagem não realizar essa conversão automaticamente porque ele pode envolver a perda de dados.</span><span class="sxs-lookup"><span data-stu-id="bcccb-406">Language compilers do not perform this conversion automatically because it can involve data loss.</span></span> <span data-ttu-id="bcccb-407">Em vez disso, eles executarem a conversão somente se um operador de conversão (em c#) ou uma função de conversão (como `CType` no Visual Basic) é usado.</span><span class="sxs-lookup"><span data-stu-id="bcccb-407">Instead, they perform the conversion only if a casting operator (in C#) or a conversion function (such as `CType` in Visual Basic) is used.</span></span> <span data-ttu-id="bcccb-408">Caso contrário, eles exibem um erro do compilador.</span><span class="sxs-lookup"><span data-stu-id="bcccb-408">Otherwise, they display a compiler error.</span></span>

 <span data-ttu-id="bcccb-409">A conversão de um <xref:System.Numerics.BigInteger> valor para a parte real de um número complexo pode resultar em perda de precisão porque um <xref:System.Double>, que é o tipo do número de complexo <xref:System.Numerics.Complex.Real%2A> propriedade, tem menos dígitos significativos que uma <xref:System.Numerics.BigInteger>.</span><span class="sxs-lookup"><span data-stu-id="bcccb-409">The conversion of a <xref:System.Numerics.BigInteger> value to the real part of a complex number can result in a loss of precision because a <xref:System.Double>, which is the type of the complex number's <xref:System.Numerics.Complex.Real%2A> property, has fewer significant digits than a <xref:System.Numerics.BigInteger>.</span></span>

 <span data-ttu-id="bcccb-410">Se a conversão for bem-sucedida porque a <xref:System.Numerics.BigInteger> valor está fora do intervalo de <xref:System.Double> tipo, a operação não gerará um <xref:System.OverflowException>.</span><span class="sxs-lookup"><span data-stu-id="bcccb-410">If the conversion is unsuccessful because the <xref:System.Numerics.BigInteger> value is out of the range of the <xref:System.Double> type, the operation does not throw an <xref:System.OverflowException>.</span></span> <span data-ttu-id="bcccb-411">Em vez disso, se `value` é menor que <xref:System.Double.MinValue>, o resultado é um número complexo que tem um <xref:System.Numerics.Complex.Real%2A> igual ao valor da propriedade <xref:System.Double.NegativeInfinity>.</span><span class="sxs-lookup"><span data-stu-id="bcccb-411">Instead, if `value` is less than <xref:System.Double.MinValue>, the result is a complex number that has a <xref:System.Numerics.Complex.Real%2A> property value equal to <xref:System.Double.NegativeInfinity>.</span></span> <span data-ttu-id="bcccb-412">Se `value` é maior do que <xref:System.Double.MaxValue>, o resultado é um número complexo que tem um <xref:System.Numerics.Complex.Real%2A> igual ao valor da propriedade <xref:System.Double.PositiveInfinity>.</span><span class="sxs-lookup"><span data-stu-id="bcccb-412">If `value` is greater than <xref:System.Double.MaxValue>, the result is a complex number that has a <xref:System.Numerics.Complex.Real%2A> property value equal to <xref:System.Double.PositiveInfinity>.</span></span>



## Examples
 <span data-ttu-id="bcccb-413">O exemplo a seguir ilustra a conversão explícita de <xref:System.Numerics.BigInteger> valores <xref:System.Numerics.Complex> valores.</span><span class="sxs-lookup"><span data-stu-id="bcccb-413">The following example illustrates the explicit conversion of <xref:System.Numerics.BigInteger> values to <xref:System.Numerics.Complex> values.</span></span>

 [!code-csharp[System.Numerics.Complex.Explicit#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.explicit/cs/explicit1.cs#2)]   
 [!code-vb[System.Numerics.Complex.Explicit#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.explicit/vb/explicit1.vb#2)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Implicit">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="bcccb-414">Define uma conversão implícita entre um objeto <see cref="T:System.Numerics.Complex" /> e outro tipo.</span><span class="sxs-lookup"><span data-stu-id="bcccb-414">Defines an implicit conversion between a <see cref="T:System.Numerics.Complex" /> object and another type.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.Byte)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Byte) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(System::Byte value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="bcccb-415">O valor a ser convertido em um número complexo.</span><span class="sxs-lookup"><span data-stu-id="bcccb-415">The value to convert to a complex number.</span></span></param>
        <summary><span data-ttu-id="bcccb-416">Define uma conversão implícita de um byte sem sinal em um número complexo.</span><span class="sxs-lookup"><span data-stu-id="bcccb-416">Defines an implicit conversion of an unsigned byte to a complex number.</span></span></summary>
        <returns><span data-ttu-id="bcccb-417">Um objeto que contém o valor do parâmetro <paramref name="value" /> como sua parte real e zero como sua parte imaginária.</span><span class="sxs-lookup"><span data-stu-id="bcccb-417">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bcccb-418">As sobrecargas do <xref:System.Numerics.Complex.op_Implicit%2A> operador definem os tipos da qual um compilador pode converter automaticamente um <xref:System.Numerics.Complex> objeto sem um operador de conversão explícita (em c#) ou uma chamada para uma função de conversão (no Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="bcccb-418">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="bcccb-419">Eles são widening conversões que não envolvem a perda de dados e não gerará uma <xref:System.OverflowException>.</span><span class="sxs-lookup"><span data-stu-id="bcccb-419">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="bcccb-420">Essa sobrecarga permite que o compilador trate conversões de um <xref:System.Byte> valor para um número complexo, como mostra o exemplo a seguir.</span><span class="sxs-lookup"><span data-stu-id="bcccb-420">This overload lets the compiler handle conversions from a <xref:System.Byte> value to a complex number, as the following example shows.</span></span> <span data-ttu-id="bcccb-421">Observe que o resultado da conversão é um número complexo cuja parte real é igual de <xref:System.Byte> valor e cuja parte imaginária é igual a zero.</span><span class="sxs-lookup"><span data-stu-id="bcccb-421">Note that the result of the conversion is a complex number whose real part is equal to the <xref:System.Byte> value and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#1)]   
 [!code-vb[System.Numerics.Complex.Implicit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#1)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.Double)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Double) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(double value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="bcccb-422">O valor a ser convertido em um número complexo.</span><span class="sxs-lookup"><span data-stu-id="bcccb-422">The value to convert to a complex number.</span></span></param>
        <summary><span data-ttu-id="bcccb-423">Define uma conversão explícita de um número de ponto flutuante de precisão dupla como um número complexo.</span><span class="sxs-lookup"><span data-stu-id="bcccb-423">Defines an implicit conversion of a double-precision floating-point number to a complex number.</span></span></summary>
        <returns><span data-ttu-id="bcccb-424">Um objeto que contém o valor do parâmetro <paramref name="value" /> como sua parte real e zero como sua parte imaginária.</span><span class="sxs-lookup"><span data-stu-id="bcccb-424">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bcccb-425">As sobrecargas do <xref:System.Numerics.Complex.op_Implicit%2A> operador definem os tipos da qual um compilador pode converter automaticamente um <xref:System.Numerics.Complex> objeto sem um operador de conversão explícita (em c#) ou uma chamada para uma função de conversão (no Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="bcccb-425">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="bcccb-426">Eles são widening conversões que não envolvem a perda de dados e não gerará uma <xref:System.OverflowException>.</span><span class="sxs-lookup"><span data-stu-id="bcccb-426">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="bcccb-427">Essa sobrecarga permite que o compilador trate conversões de um <xref:System.Double> valor para um número complexo, como mostra o exemplo a seguir.</span><span class="sxs-lookup"><span data-stu-id="bcccb-427">This overload lets the compiler handle conversions from a <xref:System.Double> value to a complex number, as the following example shows.</span></span> <span data-ttu-id="bcccb-428">Observe que o resultado da conversão é um número complexo cuja parte real é igual de <xref:System.Double> valor e cuja parte imaginária é igual a zero.</span><span class="sxs-lookup"><span data-stu-id="bcccb-428">Note that the result of the conversion is a complex number whose real part is equal to the <xref:System.Double> value and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#2)]   
 [!code-vb[System.Numerics.Complex.Implicit#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#2)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.Int16)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Short) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(short value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="bcccb-429">O valor a ser convertido em um número complexo.</span><span class="sxs-lookup"><span data-stu-id="bcccb-429">The value to convert to a complex number.</span></span></param>
        <summary><span data-ttu-id="bcccb-430">Define uma conversão implícita de um inteiro com sinal de 16 bits em um número complexo.</span><span class="sxs-lookup"><span data-stu-id="bcccb-430">Defines an implicit conversion of a 16-bit signed integer to a complex number.</span></span></summary>
        <returns><span data-ttu-id="bcccb-431">Um objeto que contém o valor do parâmetro <paramref name="value" /> como sua parte real e zero como sua parte imaginária.</span><span class="sxs-lookup"><span data-stu-id="bcccb-431">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bcccb-432">As sobrecargas do <xref:System.Numerics.Complex.op_Implicit%2A> operador definem os tipos da qual um compilador pode converter automaticamente um <xref:System.Numerics.Complex> objeto sem um operador de conversão explícita (em c#) ou uma chamada para uma função de conversão (no Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="bcccb-432">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="bcccb-433">Eles são widening conversões que não envolvem a perda de dados e não gerará uma <xref:System.OverflowException>.</span><span class="sxs-lookup"><span data-stu-id="bcccb-433">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="bcccb-434">Essa sobrecarga permite que o compilador trate conversões de um inteiro assinado de 16 bits para um número complexo, como mostra o exemplo a seguir.</span><span class="sxs-lookup"><span data-stu-id="bcccb-434">This overload lets the compiler handle conversions from a signed 16-bit integer to a complex number, as the following example shows.</span></span> <span data-ttu-id="bcccb-435">Observe que o resultado da conversão é um número complexo cuja parte real é igual para o inteiro assinado de 16 bits e cuja parte imaginária é igual a zero.</span><span class="sxs-lookup"><span data-stu-id="bcccb-435">Note that the result of the conversion is a complex number whose real part is equal to the signed 16-bit integer and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#3)]   
 [!code-vb[System.Numerics.Complex.Implicit#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#3)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.Int32)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Integer) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(int value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="bcccb-436">O valor a ser convertido em um número complexo.</span><span class="sxs-lookup"><span data-stu-id="bcccb-436">The value to convert to a complex number.</span></span></param>
        <summary><span data-ttu-id="bcccb-437">Define uma conversão implícita de um inteiro com sinal de 32 bits em um número complexo.</span><span class="sxs-lookup"><span data-stu-id="bcccb-437">Defines an implicit conversion of a 32-bit signed integer to a complex number.</span></span></summary>
        <returns><span data-ttu-id="bcccb-438">Um objeto que contém o valor do parâmetro <paramref name="value" /> como sua parte real e zero como sua parte imaginária.</span><span class="sxs-lookup"><span data-stu-id="bcccb-438">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bcccb-439">As sobrecargas do <xref:System.Numerics.Complex.op_Implicit%2A> operador definem os tipos da qual um compilador pode converter automaticamente um <xref:System.Numerics.Complex> objeto sem um operador de conversão explícita (em c#) ou uma chamada para uma função de conversão (no Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="bcccb-439">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="bcccb-440">Eles são widening conversões que não envolvem a perda de dados e não gerará uma <xref:System.OverflowException>.</span><span class="sxs-lookup"><span data-stu-id="bcccb-440">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="bcccb-441">Essa sobrecarga permite que o compilador trate conversões de um inteiro assinado de 32 bits em um número complexo, como mostra o exemplo a seguir.</span><span class="sxs-lookup"><span data-stu-id="bcccb-441">This overload lets the compiler handle conversions from a signed 32-bit integer to a complex number, as the following example shows.</span></span> <span data-ttu-id="bcccb-442">Observe que o resultado da conversão é um número complexo cuja parte real é igual para o inteiro assinado de 32 bits e cuja parte imaginária é igual a zero.</span><span class="sxs-lookup"><span data-stu-id="bcccb-442">Note that the result of the conversion is a complex number whose real part is equal to the signed 32-bit integer and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#4)]   
 [!code-vb[System.Numerics.Complex.Implicit#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#4)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.Int64)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Long) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(long value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="bcccb-443">O valor a ser convertido em um número complexo.</span><span class="sxs-lookup"><span data-stu-id="bcccb-443">The value to convert to a complex number.</span></span></param>
        <summary><span data-ttu-id="bcccb-444">Define uma conversão implícita de um inteiro com sinal de 64 bits em um número complexo.</span><span class="sxs-lookup"><span data-stu-id="bcccb-444">Defines an implicit conversion of a 64-bit signed integer to a complex number.</span></span></summary>
        <returns><span data-ttu-id="bcccb-445">Um objeto que contém o valor do parâmetro <paramref name="value" /> como sua parte real e zero como sua parte imaginária.</span><span class="sxs-lookup"><span data-stu-id="bcccb-445">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bcccb-446">As sobrecargas do <xref:System.Numerics.Complex.op_Implicit%2A> operador definem os tipos da qual um compilador pode converter automaticamente um <xref:System.Numerics.Complex> objeto sem um operador de conversão explícita (em c#) ou uma chamada para uma função de conversão (no Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="bcccb-446">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="bcccb-447">Eles são widening conversões que não envolvem a perda de dados e não gerará uma <xref:System.OverflowException>.</span><span class="sxs-lookup"><span data-stu-id="bcccb-447">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="bcccb-448">Essa sobrecarga permite que o compilador trate conversões de um inteiro assinado de 64 bits em um número complexo, como mostra o exemplo a seguir.</span><span class="sxs-lookup"><span data-stu-id="bcccb-448">This overload lets the compiler handle conversions from a signed 64-bit integer to a complex number, as the following example shows.</span></span> <span data-ttu-id="bcccb-449">Observe que o resultado da conversão é um número complexo cuja parte real é igual para o inteiro assinado de 64 bits e cuja parte imaginária é igual a zero.</span><span class="sxs-lookup"><span data-stu-id="bcccb-449">Note that the result of the conversion is a complex number whose real part is equal to the signed 64-bit integer and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#5)]   
 [!code-vb[System.Numerics.Complex.Implicit#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#5)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.SByte)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As SByte) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(System::SByte value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="bcccb-450">O valor a ser convertido em um número complexo.</span><span class="sxs-lookup"><span data-stu-id="bcccb-450">The value to convert to a complex number.</span></span></param>
        <summary><span data-ttu-id="bcccb-451">Define uma conversão implícita de um byte com sinal em um número complexo.</span><span class="sxs-lookup"><span data-stu-id="bcccb-451">Defines an implicit conversion of a signed byte to a complex number.</span></span>   
           
<span data-ttu-id="bcccb-452">Esta API não compatível com CLS.</span><span class="sxs-lookup"><span data-stu-id="bcccb-452">This API is not CLS-compliant.</span></span></summary>
        <returns><span data-ttu-id="bcccb-453">Um objeto que contém o valor do parâmetro <paramref name="value" /> como sua parte real e zero como sua parte imaginária.</span><span class="sxs-lookup"><span data-stu-id="bcccb-453">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bcccb-454">As sobrecargas do <xref:System.Numerics.Complex.op_Implicit%2A> operador definem os tipos da qual um compilador pode converter automaticamente um <xref:System.Numerics.Complex> objeto sem um operador de conversão explícita (em c#) ou uma chamada para uma função de conversão (no Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="bcccb-454">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="bcccb-455">Eles são widening conversões que não envolvem a perda de dados e não gerará uma <xref:System.OverflowException>.</span><span class="sxs-lookup"><span data-stu-id="bcccb-455">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="bcccb-456">Essa sobrecarga permite que o compilador trate conversões de um byte assinado para um número complexo, como mostra o exemplo a seguir.</span><span class="sxs-lookup"><span data-stu-id="bcccb-456">This overload lets the compiler handle conversions from a signed byte to a complex number, as the following example shows.</span></span> <span data-ttu-id="bcccb-457">Observe que o resultado da conversão é um número complexo cuja parte real é igual ao byte assinado e cujo parte imaginária é igual a zero.</span><span class="sxs-lookup"><span data-stu-id="bcccb-457">Note that the result of the conversion is a complex number whose real part is equal to the signed byte and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#6)]   
 [!code-vb[System.Numerics.Complex.Implicit#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#6)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.Single)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Single) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(float value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="bcccb-458">O valor a ser convertido em um número complexo.</span><span class="sxs-lookup"><span data-stu-id="bcccb-458">The value to convert to a complex number.</span></span></param>
        <summary><span data-ttu-id="bcccb-459">Define uma conversão explícita de um número de ponto flutuante de precisão simples como um número complexo.</span><span class="sxs-lookup"><span data-stu-id="bcccb-459">Defines an implicit conversion of a single-precision floating-point number to a complex number.</span></span></summary>
        <returns><span data-ttu-id="bcccb-460">Um objeto que contém o valor do parâmetro <paramref name="value" /> como sua parte real e zero como sua parte imaginária.</span><span class="sxs-lookup"><span data-stu-id="bcccb-460">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bcccb-461">As sobrecargas do <xref:System.Numerics.Complex.op_Implicit%2A> operador definem os tipos da qual um compilador pode converter automaticamente um <xref:System.Numerics.Complex> objeto sem um operador de conversão explícita (em c#) ou uma chamada para uma função de conversão (no Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="bcccb-461">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="bcccb-462">Eles são widening conversões que não envolvem a perda de dados e não gerará uma <xref:System.OverflowException>.</span><span class="sxs-lookup"><span data-stu-id="bcccb-462">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="bcccb-463">Essa sobrecarga permite que o compilador trate conversões de um <xref:System.Single> valor para um número complexo, como mostra o exemplo a seguir.</span><span class="sxs-lookup"><span data-stu-id="bcccb-463">This overload lets the compiler handle conversions from a <xref:System.Single> value to a complex number, as the following example shows.</span></span> <span data-ttu-id="bcccb-464">Observe que o resultado da conversão é um número complexo cuja parte real é igual de <xref:System.Single> valor e cuja parte imaginária é igual a zero.</span><span class="sxs-lookup"><span data-stu-id="bcccb-464">Note that the result of the conversion is a complex number whose real part is equal to the <xref:System.Single> value and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#7)]   
 [!code-vb[System.Numerics.Complex.Implicit#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#7)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.UInt16)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As UShort) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(System::UInt16 value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="bcccb-465">O valor a ser convertido em um número complexo.</span><span class="sxs-lookup"><span data-stu-id="bcccb-465">The value to convert to a complex number.</span></span></param>
        <summary><span data-ttu-id="bcccb-466">Define uma conversão implícita de um inteiro sem sinal de 16 bits em um número complexo.</span><span class="sxs-lookup"><span data-stu-id="bcccb-466">Defines an implicit conversion of a 16-bit unsigned integer to a complex number.</span></span>   
           
<span data-ttu-id="bcccb-467">Esta API não compatível com CLS.</span><span class="sxs-lookup"><span data-stu-id="bcccb-467">This API is not CLS-compliant.</span></span></summary>
        <returns><span data-ttu-id="bcccb-468">Um objeto que contém o valor do parâmetro <paramref name="value" /> como sua parte real e zero como sua parte imaginária.</span><span class="sxs-lookup"><span data-stu-id="bcccb-468">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bcccb-469">As sobrecargas do <xref:System.Numerics.Complex.op_Implicit%2A> operador definem os tipos da qual um compilador pode converter automaticamente um <xref:System.Numerics.Complex> objeto sem um operador de conversão explícita (em c#) ou uma chamada para uma função de conversão (no Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="bcccb-469">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="bcccb-470">Eles são widening conversões que não envolvem a perda de dados e não gerará uma <xref:System.OverflowException>.</span><span class="sxs-lookup"><span data-stu-id="bcccb-470">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="bcccb-471">Essa sobrecarga permite que o compilador trate conversões de um inteiro não assinado de 16 bits para um número complexo, como mostra o exemplo a seguir.</span><span class="sxs-lookup"><span data-stu-id="bcccb-471">This overload lets the compiler handle conversions from an unsigned 16-bit integer to a complex number, as the following example shows.</span></span> <span data-ttu-id="bcccb-472">Observe que o resultado da conversão é um número complexo cuja parte real é igual para o inteiro sem sinal de 16 bits e cuja parte imaginária é igual a zero.</span><span class="sxs-lookup"><span data-stu-id="bcccb-472">Note that the result of the conversion is a complex number whose real part is equal to the unsigned 16-bit integer and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#8)]   
 [!code-vb[System.Numerics.Complex.Implicit#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#8)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.UInt32)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As UInteger) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(System::UInt32 value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="bcccb-473">O valor a ser convertido em um número complexo.</span><span class="sxs-lookup"><span data-stu-id="bcccb-473">The value to convert to a complex number.</span></span></param>
        <summary><span data-ttu-id="bcccb-474">Define uma conversão implícita de um inteiro sem sinal de 32 bits em um número complexo.</span><span class="sxs-lookup"><span data-stu-id="bcccb-474">Defines an implicit conversion of a 32-bit unsigned integer to a complex number.</span></span>   
           
<span data-ttu-id="bcccb-475">Esta API não compatível com CLS.</span><span class="sxs-lookup"><span data-stu-id="bcccb-475">This API is not CLS-compliant.</span></span></summary>
        <returns><span data-ttu-id="bcccb-476">Um objeto que contém o valor do parâmetro <paramref name="value" /> como sua parte real e zero como sua parte imaginária.</span><span class="sxs-lookup"><span data-stu-id="bcccb-476">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bcccb-477">As sobrecargas do <xref:System.Numerics.Complex.op_Implicit%2A> operador definem os tipos da qual um compilador pode converter automaticamente um <xref:System.Numerics.Complex> objeto sem um operador de conversão explícita (em c#) ou uma chamada para uma função de conversão (no Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="bcccb-477">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="bcccb-478">Eles são widening conversões que não envolvem a perda de dados e não gerará uma <xref:System.OverflowException>.</span><span class="sxs-lookup"><span data-stu-id="bcccb-478">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="bcccb-479">Essa sobrecarga permite que o compilador trate conversões de um inteiro não assinado de 32 bits em um número complexo, como mostra o exemplo a seguir.</span><span class="sxs-lookup"><span data-stu-id="bcccb-479">This overload lets the compiler handle conversions from an unsigned 32-bit integer to a complex number, as the following example shows.</span></span> <span data-ttu-id="bcccb-480">Observe que o resultado da conversão é um número complexo cuja parte real é igual para o inteiro de 32 bits sem sinal e cuja parte imaginária é igual a zero.</span><span class="sxs-lookup"><span data-stu-id="bcccb-480">Note that the result of the conversion is a complex number whose real part is equal to the unsigned 32-bit integer and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#9)]   
 [!code-vb[System.Numerics.Complex.Implicit#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#9)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.UInt64)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As ULong) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(System::UInt64 value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="bcccb-481">O valor a ser convertido em um número complexo.</span><span class="sxs-lookup"><span data-stu-id="bcccb-481">The value to convert to a complex number.</span></span></param>
        <summary><span data-ttu-id="bcccb-482">Define uma conversão implícita de um inteiro sem sinal de 64 bits em um número complexo.</span><span class="sxs-lookup"><span data-stu-id="bcccb-482">Defines an implicit conversion of a 64-bit unsigned integer to a complex number.</span></span>   
           
<span data-ttu-id="bcccb-483">Esta API não compatível com CLS.</span><span class="sxs-lookup"><span data-stu-id="bcccb-483">This API is not CLS-compliant.</span></span></summary>
        <returns><span data-ttu-id="bcccb-484">Um objeto que contém o valor do parâmetro <paramref name="value" /> como sua parte real e zero como sua parte imaginária.</span><span class="sxs-lookup"><span data-stu-id="bcccb-484">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bcccb-485">As sobrecargas do <xref:System.Numerics.Complex.op_Implicit%2A> operador definem os tipos da qual um compilador pode converter automaticamente um <xref:System.Numerics.Complex> objeto sem um operador de conversão explícita (em c#) ou uma chamada para uma função de conversão (no Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="bcccb-485">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="bcccb-486">Eles são widening conversões que não envolvem a perda de dados e não gerará uma <xref:System.OverflowException>.</span><span class="sxs-lookup"><span data-stu-id="bcccb-486">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="bcccb-487">Essa sobrecarga permite que o compilador trate conversões de um inteiro não assinado de 64 bits em um número complexo, como mostra o exemplo a seguir.</span><span class="sxs-lookup"><span data-stu-id="bcccb-487">This overload lets the compiler handle conversions from an unsigned 64-bit integer to a complex number, as the following example shows.</span></span> <span data-ttu-id="bcccb-488">Observe que o resultado da conversão é um número complexo cuja parte real é igual para o inteiro sem sinal de 64 bits e cuja parte imaginária é igual a zero.</span><span class="sxs-lookup"><span data-stu-id="bcccb-488">Note that the result of the conversion is a complex number whose real part is equal to the unsigned 64-bit integer and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#10)]   
 [!code-vb[System.Numerics.Complex.Implicit#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#10)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Inequality(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Complex, right As Complex) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="bcccb-489">O primeiro valor a ser comparado.</span><span class="sxs-lookup"><span data-stu-id="bcccb-489">The first value to compare.</span></span></param>
        <param name="right"><span data-ttu-id="bcccb-490">O segundo valor a ser comparado.</span><span class="sxs-lookup"><span data-stu-id="bcccb-490">The second value to compare.</span></span></param>
        <summary><span data-ttu-id="bcccb-491">Retorna um valor que indica se dois números complexos não são iguais.</span><span class="sxs-lookup"><span data-stu-id="bcccb-491">Returns a value that indicates whether two complex numbers are not equal.</span></span></summary>
        <returns>
          <span data-ttu-id="bcccb-492"><see langword="true" /> se <paramref name="left" /> e <paramref name="right" /> não forem iguais; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="bcccb-492"><see langword="true" /> if <paramref name="left" /> and <paramref name="right" /> are not equal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bcccb-493">O <xref:System.Numerics.Complex.op_Equality%2A> método define a operação do operador de desigualdade para números complexos.</span><span class="sxs-lookup"><span data-stu-id="bcccb-493">The <xref:System.Numerics.Complex.op_Equality%2A> method defines the operation of the inequality operator for complex numbers.</span></span> <span data-ttu-id="bcccb-494">Ele permite que o código seja o seguinte:</span><span class="sxs-lookup"><span data-stu-id="bcccb-494">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Inequality#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.inequality/cs/inequality1.cs#1)]
 [!code-vb[System.Numerics.Complex.Inequality#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.inequality/vb/inequality1.vb#1)]  
  
 <span data-ttu-id="bcccb-495">Idiomas que dão suporte a operadores personalizados podem testar a desigualdade chamando o <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> método e a reversão de seu valor.</span><span class="sxs-lookup"><span data-stu-id="bcccb-495">Languages that do not support custom operators can test for inequality by calling the <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> method and reversing its value.</span></span>  
  
 <span data-ttu-id="bcccb-496">Observe que, por causa das diferenças na precisão, dois números complexos aparentemente equivalentes podem ser considerados diferentes.</span><span class="sxs-lookup"><span data-stu-id="bcccb-496">Note that, because of differences in precision, two complex numbers that are apparently equivalent can be considered unequal.</span></span> <span data-ttu-id="bcccb-497">Uma possível solução alternativa é implementar um método de comparação retorna `true` somente se a diferença entre as duas partes reais e imaginários dos números complexos excede determinado limite (como. 01% do valor do componente real ou imaginário de um dos números complexos).</span><span class="sxs-lookup"><span data-stu-id="bcccb-497">One possible workaround is to implement a comparison method that returns `true` only if the difference between the two real and imaginary parts of the complex numbers exceeds a certain threshold (such as .01% of the value of the real or imaginary component of one of the complex numbers).</span></span> <span data-ttu-id="bcccb-498">Para obter mais informações, consulte o método <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29>.</span><span class="sxs-lookup"><span data-stu-id="bcccb-498">For more information, see the <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> method.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Equality(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="op_Multiply">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator * (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Multiply(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Multiply(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator * (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator *(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="bcccb-499">O primeiro valor a ser multiplicado.</span><span class="sxs-lookup"><span data-stu-id="bcccb-499">The first value to multiply.</span></span></param>
        <param name="right"><span data-ttu-id="bcccb-500">O segundo valor a ser multiplicado.</span><span class="sxs-lookup"><span data-stu-id="bcccb-500">The second value to multiply.</span></span></param>
        <summary><span data-ttu-id="bcccb-501">Multiplica dois números complexos especificados.</span><span class="sxs-lookup"><span data-stu-id="bcccb-501">Multiplies two specified complex numbers.</span></span></summary>
        <returns><span data-ttu-id="bcccb-502">O produto de <paramref name="left" /> e <paramref name="right" />.</span><span class="sxs-lookup"><span data-stu-id="bcccb-502">The product of <paramref name="left" /> and <paramref name="right" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bcccb-503">O <xref:System.Numerics.Complex.op_Multiply%2A> método define a operação do operador de multiplicação para números complexos.</span><span class="sxs-lookup"><span data-stu-id="bcccb-503">The <xref:System.Numerics.Complex.op_Multiply%2A> method defines the operation of the multiplication operator for complex numbers.</span></span> <span data-ttu-id="bcccb-504">Ele permite que o código seja o seguinte:</span><span class="sxs-lookup"><span data-stu-id="bcccb-504">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Multiply#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.multiply/cs/multiply2.cs#2)]
 [!code-vb[System.Numerics.Complex.Multiply#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.multiply/vb/multiply2.vb#2)]  
  
 <span data-ttu-id="bcccb-505">A multiplicação de um complexo de número, um + bi, e um segundo número complexo, c + injeção de dependência, leva o seguinte formato:</span><span class="sxs-lookup"><span data-stu-id="bcccb-505">The multiplication of a complex number, a + bi, and a second complex number, c + di, takes the following form:</span></span>  
  
 <span data-ttu-id="bcccb-506">(o CA - bd) + (ad + continuidade de negócios),</span><span class="sxs-lookup"><span data-stu-id="bcccb-506">(ac - bd) + (ad + bc)i</span></span>  
  
 <span data-ttu-id="bcccb-507">Se a multiplicação resulta em um estouro no componente real ou imaginário, o valor desse componente é <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> ou <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="bcccb-507">If the multiplication results in an overflow in either the real or imaginary component, the value of that component is either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="bcccb-508">Linguagens que não dão suporte a operadores personalizados podem chamar o método <xref:System.Numerics.Complex.Multiply%2A> em vez disso.</span><span class="sxs-lookup"><span data-stu-id="bcccb-508">Languages that do not support custom operators can call the <xref:System.Numerics.Complex.Multiply%2A> method instead.</span></span>  
  
 <span data-ttu-id="bcccb-509">O método equivalente para esse operador é <xref:System.Numerics.Complex.Multiply%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="bcccb-509">The equivalent method for this operator is <xref:System.Numerics.Complex.Multiply%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType></span></span>]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Multiply(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="op_Subtraction">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator - (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Subtraction(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Subtraction(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator - (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator -(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="bcccb-510">O valor do qual um valor será subtraído (o minuendo).</span><span class="sxs-lookup"><span data-stu-id="bcccb-510">The value to subtract from (the minuend).</span></span></param>
        <param name="right"><span data-ttu-id="bcccb-511">O valor a ser subtraído (o subtraendo).</span><span class="sxs-lookup"><span data-stu-id="bcccb-511">The value to subtract (the subtrahend).</span></span></param>
        <summary><span data-ttu-id="bcccb-512">Subtrai um número complexo de outro número complexo.</span><span class="sxs-lookup"><span data-stu-id="bcccb-512">Subtracts a complex number from another complex number.</span></span></summary>
        <returns><span data-ttu-id="bcccb-513">O resultado da subtração de <paramref name="right" /> de <paramref name="left" />.</span><span class="sxs-lookup"><span data-stu-id="bcccb-513">The result of subtracting <paramref name="right" /> from <paramref name="left" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bcccb-514">O <xref:System.Numerics.Complex.op_Subtraction%2A> método define a operação do operador de subtração para números complexos.</span><span class="sxs-lookup"><span data-stu-id="bcccb-514">The <xref:System.Numerics.Complex.op_Subtraction%2A> method defines the operation of the subtraction operator for complex numbers.</span></span> <span data-ttu-id="bcccb-515">Ele permite que o código seja o seguinte:</span><span class="sxs-lookup"><span data-stu-id="bcccb-515">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Subtract#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.subtract/cs/subtract2.cs#2)]
 [!code-vb[System.Numerics.Complex.Subtract#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.subtract/vb/subtract2.vb#2)]  
  
 <span data-ttu-id="bcccb-516">Se a chamada do método resultados em um estouro no componente real ou imaginário, o valor desse componente é <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> ou <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="bcccb-516">If the method call results in an overflow in either the real or imaginary component, the value of that component is either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="bcccb-517">A subtração de um número complexo, c + di, de outro número complexo, um + bi leva o seguinte formato:</span><span class="sxs-lookup"><span data-stu-id="bcccb-517">The subtraction of a complex number, c + di, from another complex number, a + bi, takes the following form:</span></span>  
  
 <span data-ttu-id="bcccb-518">(a - c) + (b - d)i</span><span class="sxs-lookup"><span data-stu-id="bcccb-518">(a - c) + (b - d)i</span></span>  
  
 <span data-ttu-id="bcccb-519">Linguagens que não dão suporte a operadores personalizados podem chamar o método <xref:System.Numerics.Complex.Subtract%2A> em vez disso.</span><span class="sxs-lookup"><span data-stu-id="bcccb-519">Languages that do not support custom operators can call the <xref:System.Numerics.Complex.Subtract%2A> method instead.</span></span>  
  
 <span data-ttu-id="bcccb-520">O método equivalente para esse operador é <xref:System.Numerics.Complex.Subtract%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="bcccb-520">The equivalent method for this operator is <xref:System.Numerics.Complex.Subtract%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType></span></span>]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Subtract(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="op_UnaryNegation">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator - (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_UnaryNegation(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_UnaryNegation(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator - (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator -(System::Numerics::Complex value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="bcccb-521">O valor a ser negado.</span><span class="sxs-lookup"><span data-stu-id="bcccb-521">The value to negate.</span></span></param>
        <summary><span data-ttu-id="bcccb-522">Retorna o inverso aditivo de um número complexo especificado.</span><span class="sxs-lookup"><span data-stu-id="bcccb-522">Returns the additive inverse of a specified complex number.</span></span></summary>
        <returns><span data-ttu-id="bcccb-523">O resultado dos componentes <see cref="P:System.Numerics.Complex.Real" /> e <see cref="P:System.Numerics.Complex.Imaginary" /> do parâmetro <paramref name="value" /> multiplicado por -1.</span><span class="sxs-lookup"><span data-stu-id="bcccb-523">The result of the <see cref="P:System.Numerics.Complex.Real" /> and <see cref="P:System.Numerics.Complex.Imaginary" /> components of the <paramref name="value" /> parameter multiplied by -1.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bcccb-524">O <xref:System.Numerics.Complex.op_UnaryNegation%2A> método define a operação do operador unário de negação (aditivo inverso) para números complexos.</span><span class="sxs-lookup"><span data-stu-id="bcccb-524">The <xref:System.Numerics.Complex.op_UnaryNegation%2A> method defines the operation of the unary negation (additive inverse) operator for complex numbers.</span></span> <span data-ttu-id="bcccb-525">Ele permite que o código seja o seguinte:</span><span class="sxs-lookup"><span data-stu-id="bcccb-525">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Negate#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.negate/cs/negate2.cs#2)]
 [!code-vb[System.Numerics.Complex.Negate#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.negate/vb/negate2.vb#2)]  
  
 <span data-ttu-id="bcccb-526">O número complexo resultante produz um valor de <xref:System.Numerics.Complex> 0 (zero) quando ele é adicionado ao número complexo original.</span><span class="sxs-lookup"><span data-stu-id="bcccb-526">The resulting complex number produces a value of <xref:System.Numerics.Complex> 0 (zero) when it is added to the original complex number.</span></span> <span data-ttu-id="bcccb-527">Linguagens que não dão suporte a operadores personalizados podem chamar o método <xref:System.Numerics.Complex.Negate%2A> em vez disso.</span><span class="sxs-lookup"><span data-stu-id="bcccb-527">Languages that do not support custom operators can call the <xref:System.Numerics.Complex.Negate%2A> method instead.</span></span>  
  
 <span data-ttu-id="bcccb-528">O método equivalente para esse operador é <xref:System.Numerics.Complex.Negate%28System.Numerics.Complex%29?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="bcccb-528">The equivalent method for this operator is <xref:System.Numerics.Complex.Negate%28System.Numerics.Complex%29?displayProperty=nameWithType></span></span>]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Negate(System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Phase">
      <MemberSignature Language="C#" Value="public double Phase { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Phase" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Complex.Phase" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Phase As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Phase { double get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="bcccb-529">Obtém a fase de um número complexo.</span><span class="sxs-lookup"><span data-stu-id="bcccb-529">Gets the phase of a complex number.</span></span></summary>
        <value><span data-ttu-id="bcccb-530">A fase de um número complexo, em radianos.</span><span class="sxs-lookup"><span data-stu-id="bcccb-530">The phase of a complex number, in radians.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bcccb-531">Para um número complexo um + bi, a fase é calculada como <xref:System.Math.Atan2%2A?displayProperty=nameWithType>(b, um).</span><span class="sxs-lookup"><span data-stu-id="bcccb-531">For a complex number a + bi, the phase is computed as <xref:System.Math.Atan2%2A?displayProperty=nameWithType>(b, a).</span></span>  
  
 <span data-ttu-id="bcccb-532">Você pode identificar um número complexo por suas coordenadas cartesianas no plano complexas ou por suas coordenadas polares.</span><span class="sxs-lookup"><span data-stu-id="bcccb-532">You can identify a complex number by its Cartesian coordinates on the complex plane or by its polar coordinates.</span></span> <span data-ttu-id="bcccb-533">A fase (argumento) de um número complexo é o ângulo e o eixo real de uma linha desenhada a partir do ponto de origem (a interseção do eixo x e y) para o ponto representado pelo número complexo.</span><span class="sxs-lookup"><span data-stu-id="bcccb-533">The phase (argument) of a complex number is the angle to the real axis of a line drawn from the point of origin (the intersection of the x-axis and the y-axis) to the point represented by the complex number.</span></span> <span data-ttu-id="bcccb-534">A magnitude (representado pelo <xref:System.Numerics.Complex.Magnitude%2A> propriedade) é a distância entre o ponto de origem e o ponto que é representado pelo número complexo.</span><span class="sxs-lookup"><span data-stu-id="bcccb-534">The magnitude (represented by the <xref:System.Numerics.Complex.Magnitude%2A> property) is the distance from the point of origin to the point that is represented by the complex number.</span></span>  
  
 <span data-ttu-id="bcccb-535">Você pode criar uma instância de um número complexo com base em suas coordenadas polares, em vez de suas coordenadas cartesianas chamando o <xref:System.Numerics.Complex.FromPolarCoordinates%2A> método.</span><span class="sxs-lookup"><span data-stu-id="bcccb-535">You can instantiate a complex number based on its polar coordinates instead of its Cartesian coordinates by calling the <xref:System.Numerics.Complex.FromPolarCoordinates%2A> method.</span></span>  
  
 <span data-ttu-id="bcccb-536">Para converter a fase de radianos em graus, multiplique-o por 180 /<xref:System.Math.PI?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="bcccb-536">To convert the phase from radians to degrees, multiply it by 180/<xref:System.Math.PI?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bcccb-537">O exemplo a seguir usa o <xref:System.Numerics.Complex.FromPolarCoordinates%2A> método para criar uma instância de um número complexo com base em suas coordenadas polares e, em seguida, exibe o valor da sua <xref:System.Numerics.Complex.Magnitude%2A> e <xref:System.Numerics.Complex.Phase%2A> propriedades.</span><span class="sxs-lookup"><span data-stu-id="bcccb-537">The following example uses the <xref:System.Numerics.Complex.FromPolarCoordinates%2A> method to instantiate a complex number based on its polar coordinates, and then displays the value of its <xref:System.Numerics.Complex.Magnitude%2A> and <xref:System.Numerics.Complex.Phase%2A> properties.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Phase#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.phase/cs/phase1.cs#1)]
 [!code-vb[System.Numerics.Complex.Phase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.phase/vb/phase1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.Complex.Magnitude" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Pow">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="bcccb-538">Retorna um número complexo especificado elevado a uma potência especificada.</span><span class="sxs-lookup"><span data-stu-id="bcccb-538">Returns a specified complex number raised to a specified power.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Pow">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Pow (System.Numerics.Complex value, double power);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Pow(valuetype System.Numerics.Complex value, float64 power) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Pow(System.Numerics.Complex,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Pow (value As Complex, power As Double) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Pow(System::Numerics::Complex value, double power);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
        <Parameter Name="power" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="bcccb-539">Um número complexo a ser elevado a uma potência.</span><span class="sxs-lookup"><span data-stu-id="bcccb-539">A complex number to be raised to a power.</span></span></param>
        <param name="power"><span data-ttu-id="bcccb-540">Um número de ponto flutuante de precisão dupla que especifica uma potência.</span><span class="sxs-lookup"><span data-stu-id="bcccb-540">A double-precision floating-point number that specifies a power.</span></span></param>
        <summary><span data-ttu-id="bcccb-541">Retorna um número complexo especificado elevado a uma potência especificada por um número de ponto flutuante de precisão dupla.</span><span class="sxs-lookup"><span data-stu-id="bcccb-541">Returns a specified complex number raised to a power specified by a double-precision floating-point number.</span></span></summary>
        <returns><span data-ttu-id="bcccb-542">O número complexo <paramref name="value" /> elevado à potência <paramref name="power" />.</span><span class="sxs-lookup"><span data-stu-id="bcccb-542">The complex number <paramref name="value" /> raised to the power <paramref name="power" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bcccb-543">Se `value` for <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType>, o método retornará <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="bcccb-543">If `value` is <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType>, the method returns <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType>.</span></span> <span data-ttu-id="bcccb-544">Para outros valores, se `power` é 0, o método retorna <xref:System.Numerics.Complex.One?displayProperty=nameWithType>e se `power` é 1, ele retorna `value`.</span><span class="sxs-lookup"><span data-stu-id="bcccb-544">For other values, if `power` is 0, the method returns <xref:System.Numerics.Complex.One?displayProperty=nameWithType>, and if `power` is 1, it returns `value`.</span></span>  
  
 <span data-ttu-id="bcccb-545">Esse método corresponde do <xref:System.Math.Pow%2A?displayProperty=nameWithType> método para tipos numéricos primitivos.</span><span class="sxs-lookup"><span data-stu-id="bcccb-545">This method corresponds to the <xref:System.Math.Pow%2A?displayProperty=nameWithType> method for primitive numeric types.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bcccb-546">O exemplo a seguir ilustra a exponenciação usando um número complexo e um expoente cujos intervalos de valor de -1 a 10.</span><span class="sxs-lookup"><span data-stu-id="bcccb-546">The following example illustrates exponentiation using a complex number and an exponent whose value ranges from -1 to 10.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Pow#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.pow/cs/pow1.cs#1)]
 [!code-vb[System.Numerics.Complex.Pow#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.pow/vb/pow1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Pow">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Pow (System.Numerics.Complex value, System.Numerics.Complex power);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Pow(valuetype System.Numerics.Complex value, valuetype System.Numerics.Complex power) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Pow(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Pow (value As Complex, power As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Pow(System::Numerics::Complex value, System::Numerics::Complex power);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
        <Parameter Name="power" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="bcccb-547">Um número complexo a ser elevado a uma potência.</span><span class="sxs-lookup"><span data-stu-id="bcccb-547">A complex number to be raised to a power.</span></span></param>
        <param name="power"><span data-ttu-id="bcccb-548">Um número complexo que especifica uma potência.</span><span class="sxs-lookup"><span data-stu-id="bcccb-548">A complex number that specifies a power.</span></span></param>
        <summary><span data-ttu-id="bcccb-549">Retorna um número complexo especificado elevado a uma potência especificada por um número complexo.</span><span class="sxs-lookup"><span data-stu-id="bcccb-549">Returns a specified complex number raised to a power specified by a complex number.</span></span></summary>
        <returns><span data-ttu-id="bcccb-550">O número complexo <paramref name="value" /> elevado à potência <paramref name="power" />.</span><span class="sxs-lookup"><span data-stu-id="bcccb-550">The complex number <paramref name="value" /> raised to the power <paramref name="power" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Real">
      <MemberSignature Language="C#" Value="public double Real { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Real" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Complex.Real" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Real As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Real { double get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="bcccb-551">Obtém o componente real do objeto <see cref="T:System.Numerics.Complex" /> atual.</span><span class="sxs-lookup"><span data-stu-id="bcccb-551">Gets the real component of the current <see cref="T:System.Numerics.Complex" /> object.</span></span></summary>
        <value><span data-ttu-id="bcccb-552">O componente real de um número complexo.</span><span class="sxs-lookup"><span data-stu-id="bcccb-552">The real component of a complex number.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bcccb-553">Dado um número complexo a + bi, o <xref:System.Numerics.Complex.Real%2A> propriedade retorna o valor de um.</span><span class="sxs-lookup"><span data-stu-id="bcccb-553">Given a complex number a + bi, the <xref:System.Numerics.Complex.Real%2A> property returns the value of a.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bcccb-554">O exemplo a seguir cria uma matriz de <xref:System.Numerics.Complex> objetos e exibe os componentes reais e imaginários de cada no formulário a + bi.</span><span class="sxs-lookup"><span data-stu-id="bcccb-554">The following example instantiates an array of <xref:System.Numerics.Complex> objects and displays the real and imaginary components of each in the form a + bi.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Real#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.real/cs/real1.cs#1)]
 [!code-vb[System.Numerics.Complex.Real#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.real/vb/real1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.Complex.Imaginary" />
      </Docs>
    </Member>
    <Member MemberName="Reciprocal">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Reciprocal (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Reciprocal(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Reciprocal(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Reciprocal (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Reciprocal(System::Numerics::Complex value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="bcccb-555">Um número complexo.</span><span class="sxs-lookup"><span data-stu-id="bcccb-555">A complex number.</span></span></param>
        <summary><span data-ttu-id="bcccb-556">Retorna o inverso multiplicativo de um número complexo.</span><span class="sxs-lookup"><span data-stu-id="bcccb-556">Returns the multiplicative inverse of a complex number.</span></span></summary>
        <returns><span data-ttu-id="bcccb-557">O recíproco de <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="bcccb-557">The reciprocal of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bcccb-558">O recíproco ou multiplicative inverso, de um número *x* é um número *y* onde *x* multiplicado por *y* resulta em 1.</span><span class="sxs-lookup"><span data-stu-id="bcccb-558">The reciprocal, or multiplicative inverse, of a number *x* is a number *y* where *x* multiplied by *y* yields 1.</span></span> <span data-ttu-id="bcccb-559">O recíproco de um número complexo é o número complexo que produz <xref:System.Numerics.Complex.One?displayProperty=nameWithType> quando os dois números forem multiplicados.</span><span class="sxs-lookup"><span data-stu-id="bcccb-559">The reciprocal of a complex number is the complex number that produces <xref:System.Numerics.Complex.One?displayProperty=nameWithType> when the two numbers are multiplied.</span></span> <span data-ttu-id="bcccb-560">Se um número complexo é representado por um + bi, seu recíproca é representada pela expressão um / (um<sup>2</sup>+ b<sup>2</sup>) + b-/ (um<sup>2</sup> + b<sup>2</sup>).</span><span class="sxs-lookup"><span data-stu-id="bcccb-560">If a complex number is represented by a +bi, its reciprocal is represented by the expression a/(a<sup>2</sup>+b<sup>2</sup>) + -b/(a<sup>2</sup> + b<sup>2</sup>).</span></span>  
  
 <span data-ttu-id="bcccb-561">Se o valor é <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType>, o método retornará <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="bcccb-561">If value is <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType>, the method returns <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType>.</span></span> <span data-ttu-id="bcccb-562">Caso contrário, retorna o resultado da expressão <xref:System.Numerics.Complex.One?displayProperty=nameWithType> / `value`.</span><span class="sxs-lookup"><span data-stu-id="bcccb-562">Otherwise, it returns the result of the expression <xref:System.Numerics.Complex.One?displayProperty=nameWithType>/`value`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bcccb-563">O exemplo a seguir usa o <xref:System.Numerics.Complex.Reciprocal%2A> método para calcular os valores recíprocos de vários números complexos.</span><span class="sxs-lookup"><span data-stu-id="bcccb-563">The following example uses the <xref:System.Numerics.Complex.Reciprocal%2A> method to calculate the reciprocal values of several complex numbers.</span></span> <span data-ttu-id="bcccb-564">Ele também demonstra que o resultado da multiplicação de um número complexo por seu recíproca é <xref:System.Numerics.Complex.One?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="bcccb-564">It also demonstrates that the result of multiplying a complex number by its reciprocal is <xref:System.Numerics.Complex.One?displayProperty=nameWithType>.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Reciprocal#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.reciprocal/cs/reciprocal1.cs#1)]
 [!code-vb[System.Numerics.Complex.Reciprocal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.reciprocal/vb/reciprocal1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sin">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Sin (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Sin(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Sin(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sin (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Sin(System::Numerics::Complex value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="bcccb-565">Um número complexo.</span><span class="sxs-lookup"><span data-stu-id="bcccb-565">A complex number.</span></span></param>
        <summary><span data-ttu-id="bcccb-566">Retorna o seno do número complexo especificado.</span><span class="sxs-lookup"><span data-stu-id="bcccb-566">Returns the sine of the specified complex number.</span></span></summary>
        <returns><span data-ttu-id="bcccb-567">O seno de <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="bcccb-567">The sine of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bcccb-568">O <xref:System.Numerics.Complex.Sin%2A> método para números complexos corresponde ao <xref:System.Math.Sin%2A?displayProperty=nameWithType> método para números reais.</span><span class="sxs-lookup"><span data-stu-id="bcccb-568">The <xref:System.Numerics.Complex.Sin%2A> method for complex numbers corresponds to the <xref:System.Math.Sin%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="bcccb-569">O <xref:System.Numerics.Complex.Sin%2A> método usa a seguinte fórmula para calcular o seno do número complexo a + bi:</span><span class="sxs-lookup"><span data-stu-id="bcccb-569">The <xref:System.Numerics.Complex.Sin%2A> method uses the following formula to calculate the sine of the complex number a + bi:</span></span>  
  
 <span data-ttu-id="bcccb-570">(<xref:System.Math.Sin%2A>(a) * <xref:System.Math.Cosh%2A>(b), <xref:System.Math.Cos%2A>(a) * <xref:System.Math.Sinh%2A>(b))</span><span class="sxs-lookup"><span data-stu-id="bcccb-570">(<xref:System.Math.Sin%2A>(a) * <xref:System.Math.Cosh%2A>(b), <xref:System.Math.Cos%2A>(a) * <xref:System.Math.Sinh%2A>(b))</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bcccb-571">O exemplo a seguir ilustra o <xref:System.Numerics.Complex.Sin%2A> método.</span><span class="sxs-lookup"><span data-stu-id="bcccb-571">The following example illustrates the <xref:System.Numerics.Complex.Sin%2A> method.</span></span> <span data-ttu-id="bcccb-572">Ele mostra que o valor retornado pelo passando o <xref:System.Numerics.Complex.Asin%2A> método para o <xref:System.Numerics.Complex.Sin%2A> método retorna original <xref:System.Numerics.Complex> valor.</span><span class="sxs-lookup"><span data-stu-id="bcccb-572">It shows that passing the value returned by the <xref:System.Numerics.Complex.Asin%2A> method to the <xref:System.Numerics.Complex.Sin%2A> method returns the original <xref:System.Numerics.Complex> value.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Asin#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.asin/cs/asin1.cs#1)]
 [!code-vb[System.Numerics.Complex.Asin#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.asin/vb/asin1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Asin(System.Double)" />
        <altmember cref="M:System.Numerics.Complex.Sin(System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Sinh">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Sinh (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Sinh(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Sinh(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sinh (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Sinh(System::Numerics::Complex value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="bcccb-573">Um número complexo.</span><span class="sxs-lookup"><span data-stu-id="bcccb-573">A complex number.</span></span></param>
        <summary><span data-ttu-id="bcccb-574">Retorna o seno hiperbólico do número complexo especificado.</span><span class="sxs-lookup"><span data-stu-id="bcccb-574">Returns the hyperbolic sine of the specified complex number.</span></span></summary>
        <returns><span data-ttu-id="bcccb-575">O seno hiperbólico de <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="bcccb-575">The hyperbolic sine of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bcccb-576">O <xref:System.Numerics.Complex.Sinh%2A> método para números complexos corresponde ao <xref:System.Math.Sinh%2A?displayProperty=nameWithType> método para números reais.</span><span class="sxs-lookup"><span data-stu-id="bcccb-576">The <xref:System.Numerics.Complex.Sinh%2A> method for complex numbers corresponds to the <xref:System.Math.Sinh%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="bcccb-577">O <xref:System.Numerics.Complex.Sinh%2A> método usa a seguinte fórmula para calcular o seno hiperbólico do número complexo a + bi:</span><span class="sxs-lookup"><span data-stu-id="bcccb-577">The <xref:System.Numerics.Complex.Sinh%2A> method uses the following formula to calculate the hyperbolic sine of the complex number a + bi:</span></span>  
  
 <span data-ttu-id="bcccb-578">(<xref:System.Math.Sinh%2A>(a) * <xref:System.Math.Cos%2A>(b), <xref:System.Math.Cosh%2A>(a) * <xref:System.Math.Sin%2A>(b))</span><span class="sxs-lookup"><span data-stu-id="bcccb-578">(<xref:System.Math.Sinh%2A>(a) * <xref:System.Math.Cos%2A>(b), <xref:System.Math.Cosh%2A>(a) * <xref:System.Math.Sin%2A>(b))</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Sinh(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Sqrt">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Sqrt (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Sqrt(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Sqrt(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sqrt (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Sqrt(System::Numerics::Complex value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="bcccb-579">Um número complexo.</span><span class="sxs-lookup"><span data-stu-id="bcccb-579">A complex number.</span></span></param>
        <summary><span data-ttu-id="bcccb-580">Retorna a raiz quadrada de um número complexo especificado.</span><span class="sxs-lookup"><span data-stu-id="bcccb-580">Returns the square root of a specified complex number.</span></span></summary>
        <returns><span data-ttu-id="bcccb-581">A raiz quadrada de <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="bcccb-581">The square root of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bcccb-582">A raiz quadrada do número complexo `value` é calculado usando a fórmula a seguir:</span><span class="sxs-lookup"><span data-stu-id="bcccb-582">The square root of the complex number `value` is calculated by using the following formula:</span></span>  
  
 <span data-ttu-id="bcccb-583"><xref:System.Numerics.Complex.FromPolarCoordinates%2A?displayProperty=nameWithType>(<xref:System.Math.Sqrt%2A?displayProperty=nameWithType>(`value`.<xref:System.Numerics.Complex.Magnitude%2A>), `value`.<xref:System.Numerics.Complex.Phase%2A>/2.0)</span><span class="sxs-lookup"><span data-stu-id="bcccb-583"><xref:System.Numerics.Complex.FromPolarCoordinates%2A?displayProperty=nameWithType>(<xref:System.Math.Sqrt%2A?displayProperty=nameWithType>(`value`.<xref:System.Numerics.Complex.Magnitude%2A>), `value`.<xref:System.Numerics.Complex.Phase%2A>/2.0)</span></span>   
  
 <span data-ttu-id="bcccb-584">O <xref:System.Numerics.Complex.Sqrt%2A> método para números complexos corresponde ao <xref:System.Math.Sqrt%2A?displayProperty=nameWithType> método para números reais.</span><span class="sxs-lookup"><span data-stu-id="bcccb-584">The <xref:System.Numerics.Complex.Sqrt%2A> method for complex numbers corresponds to the <xref:System.Math.Sqrt%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Subtract">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Subtract (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Subtract(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Subtract(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Subtract (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Subtract(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="bcccb-585">O valor do qual um valor será subtraído (o minuendo).</span><span class="sxs-lookup"><span data-stu-id="bcccb-585">The value to subtract from (the minuend).</span></span></param>
        <param name="right"><span data-ttu-id="bcccb-586">O valor a ser subtraído (o subtraendo).</span><span class="sxs-lookup"><span data-stu-id="bcccb-586">The value to subtract (the subtrahend).</span></span></param>
        <summary><span data-ttu-id="bcccb-587">Subtrai um número complexo de outro e retorna o resultado.</span><span class="sxs-lookup"><span data-stu-id="bcccb-587">Subtracts one complex number from another and returns the result.</span></span></summary>
        <returns><span data-ttu-id="bcccb-588">O resultado da subtração de <paramref name="right" /> de <paramref name="left" />.</span><span class="sxs-lookup"><span data-stu-id="bcccb-588">The result of subtracting <paramref name="right" /> from <paramref name="left" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bcccb-589">A subtração de um número complexo, c + di, de outro número complexo, um + bi leva o seguinte formato:</span><span class="sxs-lookup"><span data-stu-id="bcccb-589">The subtraction of a complex number, c + di, from another complex number, a + bi, takes the following form:</span></span>  
  
 <span data-ttu-id="bcccb-590">(a - c) + (b - d)i</span><span class="sxs-lookup"><span data-stu-id="bcccb-590">(a - c) + (b - d)i</span></span>  
  
 <span data-ttu-id="bcccb-591">Se a chamada do método resultados em um estouro no componente real ou imaginário, o valor desse componente é <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> ou <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="bcccb-591">If the method call results in an overflow in either the real or imaginary component, the value of that component is either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="bcccb-592">Idiomas que dão suporte a operadores personalizados podem usar o <xref:System.Numerics.Complex.Subtract%2A> método executar subtração usando números complexos.</span><span class="sxs-lookup"><span data-stu-id="bcccb-592">Languages that do not support custom operators can use the <xref:System.Numerics.Complex.Subtract%2A> method to perform subtraction using complex numbers.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bcccb-593">O exemplo a seguir subtrai cada número complexo em uma matriz de um número complexo.</span><span class="sxs-lookup"><span data-stu-id="bcccb-593">The following example subtracts each complex number in an array from a complex number.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Subtract#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.subtract/cs/subtract1.cs#1)]
 [!code-vb[System.Numerics.Complex.Subtract#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.subtract/vb/subtract1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Subtraction(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Tan">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Tan (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Tan(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Tan(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Tan (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Tan(System::Numerics::Complex value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="bcccb-594">Um número complexo.</span><span class="sxs-lookup"><span data-stu-id="bcccb-594">A complex number.</span></span></param>
        <summary><span data-ttu-id="bcccb-595">Retorna a tangente do número complexo especificado.</span><span class="sxs-lookup"><span data-stu-id="bcccb-595">Returns the tangent of the specified complex number.</span></span></summary>
        <returns><span data-ttu-id="bcccb-596">A tangente de <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="bcccb-596">The tangent of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bcccb-597">O <xref:System.Numerics.Complex.Tan%2A> método para números complexos corresponde ao <xref:System.Math.Tan%2A?displayProperty=nameWithType> método para números reais.</span><span class="sxs-lookup"><span data-stu-id="bcccb-597">The <xref:System.Numerics.Complex.Tan%2A> method for complex numbers corresponds to the <xref:System.Math.Tan%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="bcccb-598">O <xref:System.Numerics.Complex.Tan%2A> método usa a seguinte fórmula para calcular a tangente do número complexo `value`:</span><span class="sxs-lookup"><span data-stu-id="bcccb-598">The <xref:System.Numerics.Complex.Tan%2A> method uses the following formula to calculate the tangent of the complex number `value`:</span></span>  
  
 <span data-ttu-id="bcccb-599"><xref:System.Numerics.Complex.Sin%2A>(`value`) / <xref:System.Numerics.Complex.Cos%2A>(`value`)</span><span class="sxs-lookup"><span data-stu-id="bcccb-599"><xref:System.Numerics.Complex.Sin%2A>(`value`) / <xref:System.Numerics.Complex.Cos%2A>(`value`)</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bcccb-600">O exemplo a seguir ilustra o <xref:System.Numerics.Complex.Tan%2A> método.</span><span class="sxs-lookup"><span data-stu-id="bcccb-600">The following example illustrates the <xref:System.Numerics.Complex.Tan%2A> method.</span></span> <span data-ttu-id="bcccb-601">Ele mostra que o valor retornado pelo passando o <xref:System.Numerics.Complex.Atan%2A> método para o <xref:System.Numerics.Complex.Tan%2A> método retorna original <xref:System.Numerics.Complex> valor.</span><span class="sxs-lookup"><span data-stu-id="bcccb-601">It shows that passing the value returned by the <xref:System.Numerics.Complex.Atan%2A> method to the <xref:System.Numerics.Complex.Tan%2A> method returns the original <xref:System.Numerics.Complex> value.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Atan#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.atan/cs/atan1.cs#1)]
 [!code-vb[System.Numerics.Complex.Atan#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.atan/vb/atan1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Atan(System.Numerics.Complex)" />
        <altmember cref="M:System.Math.Tan(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Tanh">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Tanh (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Tanh(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Tanh(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Tanh (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Tanh(System::Numerics::Complex value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="bcccb-602">Um número complexo.</span><span class="sxs-lookup"><span data-stu-id="bcccb-602">A complex number.</span></span></param>
        <summary><span data-ttu-id="bcccb-603">Retorna a tangente hiperbólico do número complexo especificado.</span><span class="sxs-lookup"><span data-stu-id="bcccb-603">Returns the hyperbolic tangent of the specified complex number.</span></span></summary>
        <returns><span data-ttu-id="bcccb-604">A tangente hiperbólica de <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="bcccb-604">The hyperbolic tangent of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bcccb-605">O <xref:System.Numerics.Complex.Tanh%2A> método para números complexos corresponde ao <xref:System.Math.Tanh%2A?displayProperty=nameWithType> método para números reais.</span><span class="sxs-lookup"><span data-stu-id="bcccb-605">The <xref:System.Numerics.Complex.Tanh%2A> method for complex numbers corresponds to the <xref:System.Math.Tanh%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="bcccb-606">O <xref:System.Numerics.Complex.Tanh%2A> método usa a seguinte fórmula para calcular a tangente hiperbólica do número complexo `value`:</span><span class="sxs-lookup"><span data-stu-id="bcccb-606">The <xref:System.Numerics.Complex.Tanh%2A> method uses the following formula to calculate the hyperbolic tangent of the complex number `value`:</span></span>  
  
 <span data-ttu-id="bcccb-607"><xref:System.Numerics.Complex.Sinh%2A>(`value`) / <xref:System.Numerics.Complex.Cosh%2A>(`value`)</span><span class="sxs-lookup"><span data-stu-id="bcccb-607"><xref:System.Numerics.Complex.Sinh%2A>(`value`) / <xref:System.Numerics.Complex.Cosh%2A>(`value`)</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Tanh(System.Double)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="bcccb-608">Converte o valor do número complexo na representação de cadeia de caracteres equivalente.</span><span class="sxs-lookup"><span data-stu-id="bcccb-608">Converts the value of a complex number to its equivalent string representation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="bcccb-609">Converte o valor do número complexo atual em sua representação de cadeia de caracteres equivalente usando o formato cartesiano.</span><span class="sxs-lookup"><span data-stu-id="bcccb-609">Converts the value of the current complex number to its equivalent string representation in Cartesian form.</span></span></summary>
        <returns><span data-ttu-id="bcccb-610">A representação de cadeia de caracteres da instância atual em formato cartesiano.</span><span class="sxs-lookup"><span data-stu-id="bcccb-610">The string representation of the current instance in Cartesian form.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bcccb-611">A representação de cadeia de caracteres padrão de um número complexo exibe o número com suas coordenadas cartesianas no formulário `(` *um* `,` *b*`)`, onde *um* é a parte real do número complexo, e *b* é sua parte imaginária.</span><span class="sxs-lookup"><span data-stu-id="bcccb-611">The default string representation of a complex number displays the number using its Cartesian coordinates in the form `(`*a*`,` *b*`)`, where *a* is the real part of the complex number, and *b* is its imaginary part.</span></span> <span data-ttu-id="bcccb-612">Ambos *um* e *b* formatados com o especificador de formato geral ("G") e as convenções da cultura atual do sistema.</span><span class="sxs-lookup"><span data-stu-id="bcccb-612">Both *a* and *b* are formatted using the general format specifier ("G") and the conventions of the current system culture.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bcccb-613">O exemplo a seguir exibe a representação de cadeia de caracteres de vários números complexos.</span><span class="sxs-lookup"><span data-stu-id="bcccb-613">The following example displays the string representation of several complex numbers.</span></span> <span data-ttu-id="bcccb-614">A saída usa as convenções de formatação do inglês - Estados Unidos ("en-US") cultura, que, nesse caso, é a cultura atual do sistema.</span><span class="sxs-lookup"><span data-stu-id="bcccb-614">The output uses the formatting conventions of the English - United States ("en-US") culture, which, in this case, is the current system culture.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.tostring/cs/tostring1.cs#1)]
 [!code-vb[System.Numerics.Complex.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.tostring/vb/tostring1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(IFormatProvider ^ provider);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider"><span data-ttu-id="bcccb-615">Um objeto que fornece informações de formatação específicas de cultura.</span><span class="sxs-lookup"><span data-stu-id="bcccb-615">An object that supplies culture-specific formatting information.</span></span></param>
        <summary><span data-ttu-id="bcccb-616">Converte o valor do número complexo atual na representação de cadeia de caracteres equivalente em formato cartesiano usando as informações especificadas de formatação específica à cultura.</span><span class="sxs-lookup"><span data-stu-id="bcccb-616">Converts the value of the current complex number to its equivalent string representation in Cartesian form by using the specified culture-specific formatting information.</span></span></summary>
        <returns><span data-ttu-id="bcccb-617">A representação de cadeia de caracteres da instância atual em formato cartesiano, conforme especificado por <paramref name="provider" />.</span><span class="sxs-lookup"><span data-stu-id="bcccb-617">The string representation of the current instance in Cartesian form, as specified by <paramref name="provider" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bcccb-618">A representação de cadeia de caracteres do número complexo retornada por este método exibe o número com suas coordenadas cartesianas no formulário `(` *um* `,` *b*`)`, onde *um* é a parte real do número complexo, e *b* é sua parte imaginária.</span><span class="sxs-lookup"><span data-stu-id="bcccb-618">The string representation of the complex number returned by this method displays the number using its Cartesian coordinates in the form `(`*a*`,` *b*`)`, where *a* is the real part of the complex number, and *b* is its imaginary part.</span></span> <span data-ttu-id="bcccb-619">Ambos *um* e *b* formatados com o especificador de formato geral ("G") e as convenções de cultura definido pelo `provider`.</span><span class="sxs-lookup"><span data-stu-id="bcccb-619">Both *a* and *b* are formatted using the general format specifier ("G") and the conventions of the culture defined by `provider`.</span></span>  
  
 <span data-ttu-id="bcccb-620">O parâmetro `provider` é uma implementação de <xref:System.IFormatProvider>.</span><span class="sxs-lookup"><span data-stu-id="bcccb-620">The `provider` parameter is an <xref:System.IFormatProvider> implementation.</span></span> <span data-ttu-id="bcccb-621">Seu <xref:System.IFormatProvider.GetFormat%2A> método retorna um <xref:System.Globalization.NumberFormatInfo> objeto que fornece informações específicas de cultura sobre o formato do real e imaginário números na cadeia de caracteres retornada.</span><span class="sxs-lookup"><span data-stu-id="bcccb-621">Its <xref:System.IFormatProvider.GetFormat%2A> method returns a <xref:System.Globalization.NumberFormatInfo> object that provides culture-specific information about the format of the real and imaginary numbers in the returned string.</span></span> <span data-ttu-id="bcccb-622">Se `provider` é `null`, a cadeia de caracteres retornada é formatada usando o <xref:System.Globalization.NumberFormatInfo> objeto da cultura atual.</span><span class="sxs-lookup"><span data-stu-id="bcccb-622">If `provider` is `null`, the returned string is formatted using the <xref:System.Globalization.NumberFormatInfo> object of the current culture.</span></span>  
  
 <span data-ttu-id="bcccb-623">O parâmetro `provider` pode ser um dos seguintes:</span><span class="sxs-lookup"><span data-stu-id="bcccb-623">The `provider` parameter can be one of the following:</span></span>  
  
-   <span data-ttu-id="bcccb-624">Um <xref:System.Globalization.CultureInfo> objeto que representa a cultura que forneça informações de formatação</span><span class="sxs-lookup"><span data-stu-id="bcccb-624">A <xref:System.Globalization.CultureInfo> object that represents the culture that supplies formatting information</span></span>  
  
-   <span data-ttu-id="bcccb-625">O objeto <xref:System.Globalization.NumberFormatInfo> que fornece informações de formatação.</span><span class="sxs-lookup"><span data-stu-id="bcccb-625">The <xref:System.Globalization.NumberFormatInfo> object that supplies formatting information.</span></span>  
  
-   <span data-ttu-id="bcccb-626">Um objeto personalizado que implementa a interface <xref:System.IFormatProvider>.</span><span class="sxs-lookup"><span data-stu-id="bcccb-626">A custom object that implements the <xref:System.IFormatProvider> interface.</span></span> <span data-ttu-id="bcccb-627">O método <xref:System.IFormatProvider.GetFormat%2A> retorna o objeto <xref:System.Globalization.NumberFormatInfo> que fornece informações de formatação.</span><span class="sxs-lookup"><span data-stu-id="bcccb-627">Its <xref:System.IFormatProvider.GetFormat%2A> method returns the <xref:System.Globalization.NumberFormatInfo> object that supplies formatting information.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bcccb-628">O exemplo a seguir exibe a representação de cadeia de caracteres de vários números complexos.</span><span class="sxs-lookup"><span data-stu-id="bcccb-628">The following example displays the string representation of several complex numbers.</span></span> <span data-ttu-id="bcccb-629">O resultado usa as convenções de formatação do inglês - Estados Unidos ("en-US") e francês - culturas França ("fr-FR").</span><span class="sxs-lookup"><span data-stu-id="bcccb-629">The result uses the formatting conventions of the English - United States ("en-US") and French - France ("fr-FR") cultures.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.ToString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.tostring/cs/tostring2.cs#2)]
 [!code-vb[System.Numerics.Complex.ToString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.tostring/vb/tostring2.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(string format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.ToString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(System::String ^ format);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="format"><span data-ttu-id="bcccb-630">Uma cadeia de caracteres padrão ou de formato numérico personalizado.</span><span class="sxs-lookup"><span data-stu-id="bcccb-630">A standard or custom numeric format string.</span></span></param>
        <summary><span data-ttu-id="bcccb-631">Converte o valor do número complexo atual na representação de cadeia de caracteres equivalente em formato cartesiano, usando o formato especificado para suas partes reais e imaginárias.</span><span class="sxs-lookup"><span data-stu-id="bcccb-631">Converts the value of the current complex number to its equivalent string representation in Cartesian form by using the specified format for its real and imaginary parts.</span></span></summary>
        <returns><span data-ttu-id="bcccb-632">A representação de cadeia de caracteres da instância atual em formato cartesiano.</span><span class="sxs-lookup"><span data-stu-id="bcccb-632">The string representation of the current instance in Cartesian form.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bcccb-633">A representação de cadeia de caracteres do número complexo retornada por este método exibe o número com suas coordenadas cartesianas no formulário `(` *um* `,` *b*`)`, onde *um* é a parte real do número complexo, e *b* é sua parte imaginária.</span><span class="sxs-lookup"><span data-stu-id="bcccb-633">The string representation of the complex number returned by this method displays the number using its Cartesian coordinates in the form `(`*a*`,` *b*`)`, where *a* is the real part of the complex number, and *b* is its imaginary part.</span></span> <span data-ttu-id="bcccb-634">Ambos *um* e *b* são formatados usando a cadeia de caracteres de formato especificada pelo `format`.</span><span class="sxs-lookup"><span data-stu-id="bcccb-634">Both *a* and *b* are formatted using the format string specified by `format`.</span></span> <span data-ttu-id="bcccb-635">O parâmetro `format` pode ser qualquer especificador de formato numérico padrão válido, ou uma combinação de especificadores de formato numérico personalizado.</span><span class="sxs-lookup"><span data-stu-id="bcccb-635">The `format` parameter can be any valid standard numeric format specifier, or any combination of custom numeric format specifiers.</span></span> <span data-ttu-id="bcccb-636">Se `format` é igual a <xref:System.String.Empty?displayProperty=nameWithType> ou `null`, as partes reais e imaginários do número complexo são formatadas com o especificador de formato geral ("G").</span><span class="sxs-lookup"><span data-stu-id="bcccb-636">If `format` is equal to <xref:System.String.Empty?displayProperty=nameWithType> or is `null`, the real and imaginary parts of the complex number are formatted with the general format specifier ("G").</span></span> <span data-ttu-id="bcccb-637">Caso `format` tenha qualquer outro valor, o método lança um <xref:System.FormatException>.</span><span class="sxs-lookup"><span data-stu-id="bcccb-637">If `format` is any other value, the method throws a <xref:System.FormatException>.</span></span>  
  
 <span data-ttu-id="bcccb-638">O .NET Framework fornece amplo suporte para formatação, que é descrita mais detalhadamente nos tópicos a seguir:</span><span class="sxs-lookup"><span data-stu-id="bcccb-638">The .NET Framework provides extensive formatting support, which is described in greater detail in the following topics:</span></span>  
  
-   <span data-ttu-id="bcccb-639">Para obter mais informações sobre cadeias de caracteres de formato numérico, consulte [cadeias de caracteres de formato numérico padrão](~/docs/standard/base-types/standard-numeric-format-strings.md) e [cadeias de caracteres de formato numérico personalizado](~/docs/standard/base-types/custom-numeric-format-strings.md).</span><span class="sxs-lookup"><span data-stu-id="bcccb-639">For more information about numeric format strings, see [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) and [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md).</span></span>  
  
-   <span data-ttu-id="bcccb-640">Para obter mais informações sobre a formatação do .NET Framework, consulte [tipos de formatação](~/docs/standard/base-types/formatting-types.md).</span><span class="sxs-lookup"><span data-stu-id="bcccb-640">For more information about formatting in the .NET Framework, see [Formatting Types](~/docs/standard/base-types/formatting-types.md).</span></span>  
  
 <span data-ttu-id="bcccb-641">O formato da cadeia de caracteres retornada é determinado pelo objeto <xref:System.Globalization.NumberFormatInfo> para a cultura atual.</span><span class="sxs-lookup"><span data-stu-id="bcccb-641">The format of the returned string is determined by the <xref:System.Globalization.NumberFormatInfo> object for the current culture.</span></span> <span data-ttu-id="bcccb-642">Dependendo do parâmetro `format`, esse objeto controla símbolos como o sinal negativo, o separador do grupo e o símbolo da vírgula decimal na cadeia de caracteres de saída.</span><span class="sxs-lookup"><span data-stu-id="bcccb-642">Depending on the `format` parameter, this object controls symbols such as the negative sign, the group separator, and the decimal point symbol in the output string.</span></span> <span data-ttu-id="bcccb-643">Para fornecer informações de formatação para culturas diferentes a cultura atual, chame o <xref:System.Numerics.Complex.ToString%28System.String%2CSystem.IFormatProvider%29> sobrecarga.</span><span class="sxs-lookup"><span data-stu-id="bcccb-643">To provide formatting information for cultures other than the current culture, call the <xref:System.Numerics.Complex.ToString%28System.String%2CSystem.IFormatProvider%29> overload.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bcccb-644">O exemplo a seguir inicializa um número complexo e exibe-o usando várias cadeias de caracteres de formato padrão.</span><span class="sxs-lookup"><span data-stu-id="bcccb-644">The following example initializes a complex number and displays it using several standard format strings.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.ToString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.tostring/cs/tostring3.cs#3)]
 [!code-vb[System.Numerics.Complex.ToString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.tostring/vb/tostring3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <span data-ttu-id="bcccb-645"><paramref name="format" /> não é uma cadeia de caracteres de formato válida.</span><span class="sxs-lookup"><span data-stu-id="bcccb-645"><paramref name="format" /> is not a valid format string.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(string format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.ToString(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String, provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(System::String ^ format, IFormatProvider ^ provider);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IFormattable.ToString(System.String,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="format"><span data-ttu-id="bcccb-646">Uma cadeia de caracteres padrão ou de formato numérico personalizado.</span><span class="sxs-lookup"><span data-stu-id="bcccb-646">A standard or custom numeric format string.</span></span></param>
        <param name="provider"><span data-ttu-id="bcccb-647">Um objeto que fornece informações de formatação específicas de cultura.</span><span class="sxs-lookup"><span data-stu-id="bcccb-647">An object that supplies culture-specific formatting information.</span></span></param>
        <summary><span data-ttu-id="bcccb-648">Converte o valor do número complexo atual na representação de cadeia de caracteres equivalente em formato cartesiano, usando o formato especificado e as informações de formato específicas à cultura para suas partes reais e imaginárias.</span><span class="sxs-lookup"><span data-stu-id="bcccb-648">Converts the value of the current complex number to its equivalent string representation in Cartesian form by using the specified format and culture-specific format information for its real and imaginary parts.</span></span></summary>
        <returns><span data-ttu-id="bcccb-649">A representação de cadeia de caracteres da instância atual em formato cartesiano, conforme especificado por <paramref name="format" /> e <paramref name="provider" />.</span><span class="sxs-lookup"><span data-stu-id="bcccb-649">The string representation of the current instance in Cartesian form, as specified by <paramref name="format" /> and <paramref name="provider" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bcccb-650">A representação de cadeia de caracteres do número complexo retornada por este método exibe o número com suas coordenadas cartesianas no formulário `(` *um* `,` *b*`)`, onde *um* é a parte real do número complexo, e *b* é sua parte imaginária.</span><span class="sxs-lookup"><span data-stu-id="bcccb-650">The string representation of the complex number returned by this method displays the number using its Cartesian coordinates in the form `(`*a*`,` *b*`)`, where *a* is the real part of the complex number, and *b* is its imaginary part.</span></span> <span data-ttu-id="bcccb-651">Ambos *um* e *b* são formatados usando a cadeia de caracteres de formato especificada pelo `format`.</span><span class="sxs-lookup"><span data-stu-id="bcccb-651">Both *a* and *b* are formatted using the format string specified by `format`.</span></span> <span data-ttu-id="bcccb-652">O parâmetro `format` pode ser qualquer especificador de formato numérico padrão válido, ou uma combinação de especificadores de formato numérico personalizado.</span><span class="sxs-lookup"><span data-stu-id="bcccb-652">The `format` parameter can be any valid standard numeric format specifier, or any combination of custom numeric format specifiers.</span></span> <span data-ttu-id="bcccb-653">Se `format` é igual a <xref:System.String.Empty?displayProperty=nameWithType> ou `null`, as partes reais e imaginários do número complexo são formatadas com o especificador de formato geral ("G").</span><span class="sxs-lookup"><span data-stu-id="bcccb-653">If `format` is equal to <xref:System.String.Empty?displayProperty=nameWithType> or is `null`, the real and imaginary parts of the complex number are formatted with the general format specifier ("G").</span></span> <span data-ttu-id="bcccb-654">Caso `format` tenha qualquer outro valor, o método lança um <xref:System.FormatException>.</span><span class="sxs-lookup"><span data-stu-id="bcccb-654">If `format` is any other value, the method throws a <xref:System.FormatException>.</span></span>  
  
 <span data-ttu-id="bcccb-655">O .NET Framework fornece amplo suporte para formatação, que é descrita mais detalhadamente nos tópicos a seguir:</span><span class="sxs-lookup"><span data-stu-id="bcccb-655">The .NET Framework provides extensive formatting support, which is described in greater detail in the following topics:</span></span>  
  
-   <span data-ttu-id="bcccb-656">Para obter mais informações sobre cadeias de caracteres de formato numérico, consulte [cadeias de caracteres de formato numérico padrão](~/docs/standard/base-types/standard-numeric-format-strings.md) e [cadeias de caracteres de formato numérico personalizado](~/docs/standard/base-types/custom-numeric-format-strings.md).</span><span class="sxs-lookup"><span data-stu-id="bcccb-656">For more information about numeric format strings, see [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) and [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md).</span></span>  
  
-   <span data-ttu-id="bcccb-657">Para obter mais informações sobre a formatação do .NET Framework, consulte [tipos de formatação](~/docs/standard/base-types/formatting-types.md).</span><span class="sxs-lookup"><span data-stu-id="bcccb-657">For more information about formatting in the .NET Framework, see [Formatting Types](~/docs/standard/base-types/formatting-types.md).</span></span>  
  
 <span data-ttu-id="bcccb-658">O parâmetro `provider` é uma implementação de <xref:System.IFormatProvider>.</span><span class="sxs-lookup"><span data-stu-id="bcccb-658">The `provider` parameter is an <xref:System.IFormatProvider> implementation.</span></span> <span data-ttu-id="bcccb-659">Seu <xref:System.IFormatProvider.GetFormat%2A> método retorna um <xref:System.Globalization.NumberFormatInfo> objeto que fornece informações específicas de cultura sobre o formato do real e imaginário números na cadeia de caracteres retornada.</span><span class="sxs-lookup"><span data-stu-id="bcccb-659">Its <xref:System.IFormatProvider.GetFormat%2A> method returns a <xref:System.Globalization.NumberFormatInfo> object that provides culture-specific information about the format of the real and imaginary numbers in the returned string.</span></span> <span data-ttu-id="bcccb-660">Dependendo do parâmetro `format`, esse objeto controla símbolos como o sinal negativo, o separador do grupo e o símbolo da vírgula decimal na cadeia de caracteres de saída.</span><span class="sxs-lookup"><span data-stu-id="bcccb-660">Depending on the `format` parameter, this object controls symbols such as the negative sign, the group separator, and the decimal point symbol in the output string.</span></span> <span data-ttu-id="bcccb-661">Se `provider` é `null`, a cadeia de caracteres retornada é formatada usando o <xref:System.Globalization.NumberFormatInfo> objeto da cultura atual.</span><span class="sxs-lookup"><span data-stu-id="bcccb-661">If `provider` is `null`, the returned string is formatted using the <xref:System.Globalization.NumberFormatInfo> object of the current culture.</span></span>  
  
 <span data-ttu-id="bcccb-662">O parâmetro `provider` pode ser um dos seguintes:</span><span class="sxs-lookup"><span data-stu-id="bcccb-662">The `provider` parameter can be one of the following:</span></span>  
  
-   <span data-ttu-id="bcccb-663">Um <xref:System.Globalization.CultureInfo> objeto que representa a cultura que forneça informações de formatação</span><span class="sxs-lookup"><span data-stu-id="bcccb-663">A <xref:System.Globalization.CultureInfo> object that represents the culture that supplies formatting information</span></span>  
  
-   <span data-ttu-id="bcccb-664">O objeto <xref:System.Globalization.NumberFormatInfo> que fornece informações de formatação.</span><span class="sxs-lookup"><span data-stu-id="bcccb-664">The <xref:System.Globalization.NumberFormatInfo> object that supplies formatting information.</span></span>  
  
-   <span data-ttu-id="bcccb-665">Um objeto personalizado que implementa a interface <xref:System.IFormatProvider>.</span><span class="sxs-lookup"><span data-stu-id="bcccb-665">A custom object that implements the <xref:System.IFormatProvider> interface.</span></span> <span data-ttu-id="bcccb-666">O método <xref:System.IFormatProvider.GetFormat%2A> retorna o objeto <xref:System.Globalization.NumberFormatInfo> que fornece informações de formatação.</span><span class="sxs-lookup"><span data-stu-id="bcccb-666">Its <xref:System.IFormatProvider.GetFormat%2A> method returns the <xref:System.Globalization.NumberFormatInfo> object that supplies formatting information.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bcccb-667">O exemplo a seguir cria uma matriz de números complexos e exibe cada usando várias cadeias de caracteres de formato padrão, bem como <xref:System.Globalization.CultureInfo> objetos que representam as culturas Inglês - Estados Unidos ("en-US") e francês - França ("fr-FR").</span><span class="sxs-lookup"><span data-stu-id="bcccb-667">The following example creates an array of complex numbers, and displays each using several standard format strings as well as <xref:System.Globalization.CultureInfo> objects that represent the English - United States ("en-US") and French - France ("fr-FR") cultures.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.ToString#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.tostring/cs/tostring4.cs#4)]
 [!code-vb[System.Numerics.Complex.ToString#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.tostring/vb/tostring4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <span data-ttu-id="bcccb-668"><paramref name="format" /> não é uma cadeia de caracteres de formato válida.</span><span class="sxs-lookup"><span data-stu-id="bcccb-668"><paramref name="format" /> is not a valid format string.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Zero">
      <MemberSignature Language="C#" Value="public static readonly System.Numerics.Complex Zero;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Numerics.Complex Zero" />
      <MemberSignature Language="DocId" Value="F:System.Numerics.Complex.Zero" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Zero As Complex " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Numerics::Complex Zero;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="bcccb-669">Retorna uma nova instância do <see cref="T:System.Numerics.Complex" /> com um número real igual a zero e um número imaginário igual a zero.</span><span class="sxs-lookup"><span data-stu-id="bcccb-669">Returns a new <see cref="T:System.Numerics.Complex" /> instance with a real number equal to zero and an imaginary number equal to zero.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bcccb-670">O <xref:System.Numerics.Complex.Zero> propriedade normalmente é usada para comparar um <xref:System.Numerics.Complex> valor como zero.</span><span class="sxs-lookup"><span data-stu-id="bcccb-670">The <xref:System.Numerics.Complex.Zero> property is most frequently used to compare a <xref:System.Numerics.Complex> value to zero.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bcccb-671">O exemplo a seguir cria um <xref:System.Numerics.Complex> valor usando o <xref:System.Numerics.Complex.Zero> propriedade.</span><span class="sxs-lookup"><span data-stu-id="bcccb-671">The following example instantiates a <xref:System.Numerics.Complex> value by using the <xref:System.Numerics.Complex.Zero> property.</span></span> <span data-ttu-id="bcccb-672">Ele então compara esse valor com outro valor que é instanciado chamando o <xref:System.Numerics.Complex> construtor com uma parte real igual a zero e uma parte imaginária igual a zero.</span><span class="sxs-lookup"><span data-stu-id="bcccb-672">It then compares this value to another value that is instantiated by calling the <xref:System.Numerics.Complex> constructor with a real part equal to zero and an imaginary part equal to zero.</span></span> <span data-ttu-id="bcccb-673">Como mostra a saída do exemplo, os dois valores são iguais.</span><span class="sxs-lookup"><span data-stu-id="bcccb-673">As the output from the example shows, the two values are equal.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Zero#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.zero/cs/zero1.cs#1)]
 [!code-vb[System.Numerics.Complex.Zero#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.zero/vb/zero1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Numerics.Complex.ImaginaryOne" />
        <altmember cref="F:System.Numerics.Complex.One" />
      </Docs>
    </Member>
  </Members>
</Type>