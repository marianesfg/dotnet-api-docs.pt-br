<Type Name="Complex" FullName="System.Numerics.Complex">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="45aed4a95edff1e825b957b2993f72dc022d64ea" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="pt-BR" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39754202" />
  </Metadata>
  <TypeSignature Language="C#" Value="public struct Complex : IEquatable&lt;System.Numerics.Complex&gt;, IFormattable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit Complex extends System.ValueType implements class System.IEquatable`1&lt;valuetype System.Numerics.Complex&gt;, class System.IFormattable" />
  <TypeSignature Language="DocId" Value="T:System.Numerics.Complex" />
  <TypeSignature Language="VB.NET" Value="Public Structure Complex&#xA;Implements IEquatable(Of Complex), IFormattable" />
  <TypeSignature Language="C++ CLI" Value="public value class Complex : IEquatable&lt;System::Numerics::Complex&gt;, IFormattable" />
  <TypeSignature Language="F#" Value="type Complex = struct&#xA;    interface IFormattable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Numerics</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Numerics</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.Numerics.Complex&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IFormattable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>
      <span data-ttu-id="44a32-101">Representa um número complexo.</span>
      <span class="sxs-lookup">
        <span data-stu-id="44a32-101">Represents a complex number.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="44a32-102">Um número complexo é um número que consiste em uma parte de número real e uma parte de número imaginário.</span><span class="sxs-lookup"><span data-stu-id="44a32-102">A complex number is a number that comprises a real number part and an imaginary number part.</span></span> <span data-ttu-id="44a32-103">Um número complexo z geralmente é gravado no formato z = x + yi, onde *x* e *y* são números reais, e *eu* é a unidade imaginária que tem a propriedade *i* <sup>2</sup> = -1.</span><span class="sxs-lookup"><span data-stu-id="44a32-103">A complex number z is usually written in the form z = x + yi, where *x* and *y* are real numbers, and *i* is the imaginary unit that has the property *i*<sup>2</sup> = -1.</span></span> <span data-ttu-id="44a32-104">A parte real do número complexo é representada por *x*, e a parte imaginária do número complexo é representada pela *y*.</span><span class="sxs-lookup"><span data-stu-id="44a32-104">The real part of the complex number is represented by *x*, and the imaginary part of the complex number is represented by *y*.</span></span>  
  
 <span data-ttu-id="44a32-105">O <xref:System.Numerics.Complex> tipo usa o sistema de coordenadas cartesianas (real, imaginário) ao criar uma instância e manipular números complexos.</span><span class="sxs-lookup"><span data-stu-id="44a32-105">The <xref:System.Numerics.Complex> type uses the Cartesian coordinate system (real, imaginary) when instantiating and manipulating complex numbers.</span></span> <span data-ttu-id="44a32-106">Um número complexo pode ser representado como um ponto em um sistema de coordenadas bidimensional, que é conhecido como plano complexo.</span><span class="sxs-lookup"><span data-stu-id="44a32-106">A complex number can be represented as a point in a two-dimensional coordinate system, which is known as the complex plane.</span></span> <span data-ttu-id="44a32-107">A parte real do número complexo é posicionada no eixo x (o eixo horizontal), e a parte imaginária é posicionada no eixo y (o eixo vertical).</span><span class="sxs-lookup"><span data-stu-id="44a32-107">The real part of the complex number is positioned on the x-axis (the horizontal axis), and the imaginary part is positioned on the y-axis (the vertical axis).</span></span>  
  
 <span data-ttu-id="44a32-108">Qualquer ponto no plano complexo também pode ser expressas com base em seu valor absoluto, usando o polar sistema de coordenadas., em coordenadas polares, um ponto é caracterizado por dois números:</span><span class="sxs-lookup"><span data-stu-id="44a32-108">Any point in the complex plane can also be expressed based on its absolute value, by using the polar coordinate system., In polar coordinates, a point is characterized by two numbers:</span></span>  
  
-   <span data-ttu-id="44a32-109">Sua magnitude, que é a distância do ponto da origem (ou seja, 0,0, ou o ponto no qual o eixo x e y interseccionam).</span><span class="sxs-lookup"><span data-stu-id="44a32-109">Its magnitude, which is the distance of the point from the origin (that is, 0,0, or the point at which the x-axis and the y-axis intersect).</span></span>  
  
-   <span data-ttu-id="44a32-110">Sua fase, que é o ângulo entre o eixo real e a linha desenhada de origem para o ponto.</span><span class="sxs-lookup"><span data-stu-id="44a32-110">Its phase, which is the angle between the real axis and the line drawn from the origin to the point.</span></span>  
  
## <a name="instantiating-a-complex-number"></a><span data-ttu-id="44a32-111">Criando uma instância de um número complexo</span><span class="sxs-lookup"><span data-stu-id="44a32-111">Instantiating a Complex Number</span></span>  
 <span data-ttu-id="44a32-112">Você pode atribuir um valor em um número complexo em uma das seguintes maneiras:</span><span class="sxs-lookup"><span data-stu-id="44a32-112">You can assign a value to a complex number in one of the following ways:</span></span>  
  
-   <span data-ttu-id="44a32-113">Passando dois <xref:System.Double> valores para seu construtor.</span><span class="sxs-lookup"><span data-stu-id="44a32-113">By passing two <xref:System.Double> values to its constructor.</span></span> <span data-ttu-id="44a32-114">O primeiro valor representa a parte real do número complexo e o segundo valor representa sua parte imaginária.</span><span class="sxs-lookup"><span data-stu-id="44a32-114">The first value represents the real part of the complex number, and the second value represents its imaginary part.</span></span> <span data-ttu-id="44a32-115">Esses valores representam a posição do número complexo no sistema de coordenadas cartesianas bidimensional.</span><span class="sxs-lookup"><span data-stu-id="44a32-115">These values represent the position of the complex number in the two-dimensional Cartesian coordinate system.</span></span>  
  
-   <span data-ttu-id="44a32-116">Chamando estático (`Shared` no Visual Basic) <xref:System.Numerics.Complex.FromPolarCoordinates%2A?displayProperty=nameWithType> método para criar um número complexo de suas coordenadas polares.</span><span class="sxs-lookup"><span data-stu-id="44a32-116">By calling the static (`Shared` in Visual Basic) <xref:System.Numerics.Complex.FromPolarCoordinates%2A?displayProperty=nameWithType> method to create a complex number from its polar coordinates.</span></span>  
  
-   <span data-ttu-id="44a32-117">Atribuindo uma <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, <xref:System.Single>, ou <xref:System.Double> de valor para um <xref:System.Numerics.Complex> objeto.</span><span class="sxs-lookup"><span data-stu-id="44a32-117">By assigning a <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, <xref:System.Single>, or <xref:System.Double> value to a <xref:System.Numerics.Complex> object.</span></span> <span data-ttu-id="44a32-118">O valor se tornará a parte real do número complexo e sua parte imaginária é igual a 0.</span><span class="sxs-lookup"><span data-stu-id="44a32-118">The value becomes the real part of the complex number, and its imaginary part equals 0.</span></span>  
  
-   <span data-ttu-id="44a32-119">Conversão (em c#) ou convertendo (no Visual Basic) um <xref:System.Decimal> ou <xref:System.Numerics.BigInteger> valor para um <xref:System.Numerics.Complex> objeto.</span><span class="sxs-lookup"><span data-stu-id="44a32-119">By casting (in C#) or converting (in Visual Basic) a <xref:System.Decimal> or <xref:System.Numerics.BigInteger> value to a <xref:System.Numerics.Complex> object.</span></span> <span data-ttu-id="44a32-120">O valor se tornará a parte real do número complexo e sua parte imaginária é igual a 0.</span><span class="sxs-lookup"><span data-stu-id="44a32-120">The value becomes the real part of the complex number, and its imaginary part equals 0.</span></span>  
  
-   <span data-ttu-id="44a32-121">Ao atribuir o número complexo que é retornado por um método ou operador para um <xref:System.Numerics.Complex> objeto.</span><span class="sxs-lookup"><span data-stu-id="44a32-121">By assigning the complex number that is returned by a method or operator to a <xref:System.Numerics.Complex> object.</span></span> <span data-ttu-id="44a32-122">Por exemplo, <xref:System.Numerics.Complex.Add%2A?displayProperty=nameWithType> é um método estático que retorna um número complexo que é a soma dos dois números complexos, e o <xref:System.Numerics.Complex.op_Addition%2A?displayProperty=nameWithType> operador adiciona dois números complexos e retorna o resultado.</span><span class="sxs-lookup"><span data-stu-id="44a32-122">For example, <xref:System.Numerics.Complex.Add%2A?displayProperty=nameWithType> is a static method that returns a complex number that is the sum of two complex numbers, and the <xref:System.Numerics.Complex.op_Addition%2A?displayProperty=nameWithType> operator adds two complex numbers and returns the result.</span></span>  
  
 <span data-ttu-id="44a32-123">O exemplo a seguir demonstra que cada uma dessas cinco maneiras de atribuir um valor em um número complexo.</span><span class="sxs-lookup"><span data-stu-id="44a32-123">The following example demonstrates each of these five ways of assigning a value to a complex number.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.class/cs/create1.cs#2)]
 [!code-vb[System.Numerics.Complex.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.class/vb/create1.vb#2)]  
  
## <a name="operations-with-complex-numbers"></a><span data-ttu-id="44a32-124">Operações com números complexos</span><span class="sxs-lookup"><span data-stu-id="44a32-124">Operations with Complex Numbers</span></span>  
 <span data-ttu-id="44a32-125">O <xref:System.Numerics.Complex> estrutura no .NET Framework inclui os membros que fornecem a seguinte funcionalidade:</span><span class="sxs-lookup"><span data-stu-id="44a32-125">The <xref:System.Numerics.Complex> structure in the .NET Framework includes members that provide the following functionality:</span></span>  
  
-   <span data-ttu-id="44a32-126">Métodos para comparar dois números complexos para determinar se eles são iguais.</span><span class="sxs-lookup"><span data-stu-id="44a32-126">Methods to compare two complex numbers to determine whether they are equal.</span></span>  
  
-   <span data-ttu-id="44a32-127">Operadores para executar operações aritméticas em números complexos.</span><span class="sxs-lookup"><span data-stu-id="44a32-127">Operators to perform arithmetic operations on complex numbers.</span></span> <span data-ttu-id="44a32-128"><xref:System.Numerics.Complex> operadores permitem executar adição, subtração, multiplicação, divisão e negação unária com números complexos.</span><span class="sxs-lookup"><span data-stu-id="44a32-128"><xref:System.Numerics.Complex> operators enable you to perform addition, subtraction, multiplication, division, and unary negation with complex numbers.</span></span>  
  
-   <span data-ttu-id="44a32-129">Métodos para executar outras operações numéricas em números complexos.</span><span class="sxs-lookup"><span data-stu-id="44a32-129">Methods to perform other numerical operations on complex numbers.</span></span> <span data-ttu-id="44a32-130">As quatro operações aritméticas básicas, além de gerar um número complexo a uma potência especificada, localize a raiz quadrada de um número complexo e obter o valor absoluto de um número complexo.</span><span class="sxs-lookup"><span data-stu-id="44a32-130">In addition to the four basic arithmetic operations, you can raise a complex number to a specified power, find the square root of a complex number, and get the absolute value of a complex number.</span></span>  
  
-   <span data-ttu-id="44a32-131">Métodos para executar operações trigonométricas em números complexos.</span><span class="sxs-lookup"><span data-stu-id="44a32-131">Methods to perform trigonometric operations on complex numbers.</span></span> <span data-ttu-id="44a32-132">Por exemplo, você pode calcular a tangente de um ângulo representado por um número complexo.</span><span class="sxs-lookup"><span data-stu-id="44a32-132">For example, you can calculate the tangent of an angle represented by a complex number.</span></span>  
  
 <span data-ttu-id="44a32-133">Observe que, como o <xref:System.Numerics.Complex.Real%2A> e <xref:System.Numerics.Complex.Imaginary%2A> as propriedades são somente leitura, você não pode modificar o valor de uma existente <xref:System.Numerics.Complex> objeto.</span><span class="sxs-lookup"><span data-stu-id="44a32-133">Note that, because the <xref:System.Numerics.Complex.Real%2A> and  <xref:System.Numerics.Complex.Imaginary%2A> properties are read-only, you cannot modify the value of an existing <xref:System.Numerics.Complex> object.</span></span>  <span data-ttu-id="44a32-134">Todos os métodos que executam uma operação em um <xref:System.Numerics.Complex> número, se o valor retornado é do tipo <xref:System.Numerics.Complex>, retornam um novo <xref:System.Numerics.Complex> número.</span><span class="sxs-lookup"><span data-stu-id="44a32-134">All methods that perform an operation on a <xref:System.Numerics.Complex> number, if their return value is of type <xref:System.Numerics.Complex>, return a new <xref:System.Numerics.Complex> number.</span></span>  
  
## <a name="precision-and-complex-numbers"></a><span data-ttu-id="44a32-135">Precisão e números complexos</span><span class="sxs-lookup"><span data-stu-id="44a32-135">Precision and Complex Numbers</span></span>  
 <span data-ttu-id="44a32-136">As partes reais e imaginárias de um número complexo são representadas por dois valores de ponto flutuantes de precisão dupla.</span><span class="sxs-lookup"><span data-stu-id="44a32-136">The real and imaginary parts of a complex number are represented by two double-precision floating-point values.</span></span> <span data-ttu-id="44a32-137">Isso significa que <xref:System.Numerics.Complex> valores, como valores de ponto flutuante de precisão dupla, podem perder a precisão como resultado de operações numéricas.</span><span class="sxs-lookup"><span data-stu-id="44a32-137">This means that <xref:System.Numerics.Complex> values, like double-precision floating-point values, can lose precision as a result of numerical operations.</span></span> <span data-ttu-id="44a32-138">Isso significa que estrito comparações de igualdade de dois <xref:System.Numerics.Complex> valores podem falhar, mesmo se a diferença entre os dois valores é devido à perda de precisão.</span><span class="sxs-lookup"><span data-stu-id="44a32-138">This means that strict comparisons for equality of two <xref:System.Numerics.Complex> values may fail, even if the difference between the two values is due to a loss of precision.</span></span> <span data-ttu-id="44a32-139">Para obter mais informações, consulte <xref:System.Double>.</span><span class="sxs-lookup"><span data-stu-id="44a32-139">For more information, see <xref:System.Double>.</span></span>  
  
 <span data-ttu-id="44a32-140">Por exemplo, a execução de exponenciação no logaritmo de um número deverá retornar o número original.</span><span class="sxs-lookup"><span data-stu-id="44a32-140">For example, performing exponentiation on the logarithm of a number should return the original number.</span></span> <span data-ttu-id="44a32-141">No entanto, em alguns casos, a perda de precisão dos valores de ponto flutuante pode causar pequenas diferenças entre os dois valores, como mostra o exemplo a seguir.</span><span class="sxs-lookup"><span data-stu-id="44a32-141">However, in some cases, the loss of precision of floating-point values can cause slight differences between the two values, as the following example illustrates.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.class/cs/precision1.cs#5)]
 [!code-vb[System.Numerics.Complex.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.class/vb/precision1.vb#5)]  
  
 <span data-ttu-id="44a32-142">Da mesma forma, o exemplo a seguir, que calcula a raiz quadrada de um <xref:System.Numerics.Complex> número, gera resultados ligeiramente diferentes de 32 bits e IA64 versões do .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="44a32-142">Similarly, the following example, which calculates the square root of a <xref:System.Numerics.Complex> number, produces slightly different results on the 32-bit and IA64 versions of the .NET Framework.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.class/cs/precision1.cs#6)]
 [!code-vb[System.Numerics.Complex.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.class/vb/precision1.vb#6)]  
  
## <a name="complex-numbers-infinity-and-nan"></a><span data-ttu-id="44a32-143">Números complexos, infinito e NaN</span><span class="sxs-lookup"><span data-stu-id="44a32-143">Complex Numbers, Infinity, and NaN</span></span>  
 <span data-ttu-id="44a32-144">As partes reais e imaginárias de um número complexo são representadas por <xref:System.Double> valores.</span><span class="sxs-lookup"><span data-stu-id="44a32-144">The real and imaginary parts of a complex number are represented by <xref:System.Double> values.</span></span> <span data-ttu-id="44a32-145">Além de desde <xref:System.Double.MinValue?displayProperty=nameWithType> à <xref:System.Double.MaxValue?displayProperty=nameWithType>, a parte real ou imaginária de um número complexo pode ter um valor de <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, ou <xref:System.Double.NaN?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="44a32-145">In addition to ranging from <xref:System.Double.MinValue?displayProperty=nameWithType> to <xref:System.Double.MaxValue?displayProperty=nameWithType>, the real or imaginary part of a complex number can have a value of <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, or <xref:System.Double.NaN?displayProperty=nameWithType>.</span></span> <span data-ttu-id="44a32-146"><xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, e <xref:System.Double.NaN?displayProperty=nameWithType> todos propagam em qualquer operação aritmética ou trigonométrica.</span><span class="sxs-lookup"><span data-stu-id="44a32-146"><xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, and <xref:System.Double.NaN?displayProperty=nameWithType> all propagate in any arithmetic or trigonometric operation.</span></span>  
  
 <span data-ttu-id="44a32-147">No exemplo a seguir, a divisão por <xref:System.Numerics.Complex.Zero> produz um número complexo cujas partes reais e imaginárias são ambos <xref:System.Double.NaN?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="44a32-147">In the following example, division by <xref:System.Numerics.Complex.Zero> produces a complex number whose real and imaginary parts are both <xref:System.Double.NaN?displayProperty=nameWithType>.</span></span> <span data-ttu-id="44a32-148">Como resultado, executar multiplicação com esse valor também produz um número complexo cujas partes reais e imaginárias são <xref:System.Double.NaN?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="44a32-148">As a result, performing multiplication with this value also produces a complex number whose real and imaginary parts are <xref:System.Double.NaN?displayProperty=nameWithType>.</span></span> <span data-ttu-id="44a32-149">Da mesma forma, executar uma multiplicação que ultrapassar o intervalo da <xref:System.Double> tipo produz um número complexo cuja parte real <xref:System.Double.NaN?displayProperty=nameWithType> e cuja parte imaginária é <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="44a32-149">Similarly, performing a multiplication that overflows the range of the <xref:System.Double> type produces a complex number whose real part is <xref:System.Double.NaN?displayProperty=nameWithType> and whose imaginary part is <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>.</span></span> <span data-ttu-id="44a32-150">Executar a divisão com este número complexo, subsequentemente, retorna um número complexo cuja parte real <xref:System.Double.NaN?displayProperty=nameWithType> e cuja parte imaginária é <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="44a32-150">Subsequently performing division with this complex number returns a complex number whose real part is <xref:System.Double.NaN?displayProperty=nameWithType> and whose imaginary part is <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.class/cs/nan1.cs#3)]
 [!code-vb[System.Numerics.Complex.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.class/vb/nan1.vb#3)]  
  
 <span data-ttu-id="44a32-151">Operações matemáticas com números complexos que são inválidos ou que estourasse o intervalo da <xref:System.Double> tipo de dados não lance uma exceção.</span><span class="sxs-lookup"><span data-stu-id="44a32-151">Mathematical operations with complex numbers that are invalid or that overflow the range of the <xref:System.Double> data type do not throw an exception.</span></span> <span data-ttu-id="44a32-152">Em vez disso, eles retornam um <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, ou <xref:System.Double.NaN?displayProperty=nameWithType> sob as seguintes condições:</span><span class="sxs-lookup"><span data-stu-id="44a32-152">Instead, they return a <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, or <xref:System.Double.NaN?displayProperty=nameWithType> under the following conditions:</span></span>  
  
-   <span data-ttu-id="44a32-153">A divisão de um número positivo por zero retorna <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="44a32-153">The division of a positive number by zero returns <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="44a32-154">Qualquer operação que excede o limite superior do <xref:System.Double> tipo de dados retorna <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="44a32-154">Any operation that overflows the upper bound of the <xref:System.Double> data type returns <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="44a32-155">A divisão de um número negativo por zero retorna <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="44a32-155">The division of a negative number by zero returns <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="44a32-156">Qualquer operação que excede o limite inferior do <xref:System.Double> tipo de dados retorna <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="44a32-156">Any operation that overflows the lower bound of the <xref:System.Double> data type returns <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="44a32-157">Retorna a divisão de um zero por zero <xref:System.Double.NaN?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="44a32-157">The division of a zero by zero returns <xref:System.Double.NaN?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="44a32-158">Qualquer operação que é executada em operandos cujos valores são <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, ou <xref:System.Double.NaN?displayProperty=nameWithType> retorna <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, ou <xref:System.Double.NaN?displayProperty=nameWithType>, dependendo da operação específica.</span><span class="sxs-lookup"><span data-stu-id="44a32-158">Any operation that is performed on operands whose values are <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, or <xref:System.Double.NaN?displayProperty=nameWithType> returns <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, or <xref:System.Double.NaN?displayProperty=nameWithType>, depending on the specific operation.</span></span>  
  
 <span data-ttu-id="44a32-159">Observe que isso se aplica a qualquer cálculos intermediários executados por um método.</span><span class="sxs-lookup"><span data-stu-id="44a32-159">Note that this applies to any intermediate calculations performed by a method.</span></span> <span data-ttu-id="44a32-160">Por exemplo, a multiplicação de `new Complex(9e308, 9e308) and new Complex(2.5, 3.5)` usa a fórmula (ac – bd) + (ad + bc) eu.</span><span class="sxs-lookup"><span data-stu-id="44a32-160">For example, the multiplication of `new Complex(9e308, 9e308) and new Complex(2.5, 3.5)` uses the formula (ac - bd) + (ad + bc)i.</span></span> <span data-ttu-id="44a32-161">O cálculo do componente real que resulta da multiplicação avalia a expressão 9e308 * 2.5 - 9e308 * 3.5.</span><span class="sxs-lookup"><span data-stu-id="44a32-161">The calculation of the real component that results from the multiplication evaluates the expression 9e308 * 2.5 - 9e308 * 3.5.</span></span> <span data-ttu-id="44a32-162">Cada multiplicação intermediária nesta expressão retorna <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>e a tentativa para subtrair <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> de <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> retorna <xref:System.Double.NaN?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="44a32-162">Each intermediate multiplication in this expression returns <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, and the attempt to subtract <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> from <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> returns <xref:System.Double.NaN?displayProperty=nameWithType>.</span></span>  
  
## <a name="formatting-a-complex-number"></a><span data-ttu-id="44a32-163">Formatando um número complexo</span><span class="sxs-lookup"><span data-stu-id="44a32-163">Formatting a Complex Number</span></span>  
 <span data-ttu-id="44a32-164">Por padrão, a representação de cadeia de caracteres de um número complexo assume a forma `(` *reais* `,` *imaginário*`)`, em que *real* e *imaginário* são as representações de cadeia de caracteres da <xref:System.Double> valores que formam os componentes de reais e imaginárias do número complexo.</span><span class="sxs-lookup"><span data-stu-id="44a32-164">By default, the string representation of a complex number takes the form `(`*real*`,` *imaginary*`)`, where *real* and *imaginary* are the string representations of the <xref:System.Double> values that form the complex number's real and imaginary components.</span></span> <span data-ttu-id="44a32-165">Algumas sobrecargas do <xref:System.Numerics.Complex.ToString%2A> método permitem a personalização das representações de cadeia de caracteres desses <xref:System.Double> valores para refletir as convenções de formatação de uma cultura específica ou para aparecer em um formato específico, definido por um numérico padrão ou personalizado cadeia de caracteres de formato.</span><span class="sxs-lookup"><span data-stu-id="44a32-165">Some overloads of the <xref:System.Numerics.Complex.ToString%2A> method allow customization of the string representations of these <xref:System.Double> values to reflect the formatting conventions of a particular culture or to appear in a particular format defined by a standard or custom numeric format string.</span></span> <span data-ttu-id="44a32-166">(Para obter mais informações, consulte [cadeias de caracteres de formato numérico padrão](~/docs/standard/base-types/standard-numeric-format-strings.md) e [às cadeias de caracteres de formato numérico personalizado](~/docs/standard/base-types/custom-numeric-format-strings.md).)</span><span class="sxs-lookup"><span data-stu-id="44a32-166">(For more information, see [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) and [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md).)</span></span>  
  
 <span data-ttu-id="44a32-167">Uma das maneiras mais comuns de expressar a representação de cadeia de caracteres de um número complexo assume a forma a + bi, onde um é o componente de real do número complexo e b é o componente imaginário do número complexo.</span><span class="sxs-lookup"><span data-stu-id="44a32-167">One of the more common ways of expressing the string representation of a complex number takes the form a + bi, where a is the complex number's real component, and b is the complex number's imaginary component.</span></span> <span data-ttu-id="44a32-168">Em engenharia elétrica, um número complexo é geralmente expresso como um + bj.</span><span class="sxs-lookup"><span data-stu-id="44a32-168">In electrical engineering, a complex number is most commonly expressed as a + bj.</span></span> <span data-ttu-id="44a32-169">Você pode retornar a representação de cadeia de caracteres de um número complexo em qualquer uma destas duas formas.</span><span class="sxs-lookup"><span data-stu-id="44a32-169">You can return the string representation of a complex number in either of these two forms.</span></span> <span data-ttu-id="44a32-170">Para fazer isso, definir um provedor de formato personalizado implementando a <xref:System.ICustomFormatter> e <xref:System.IFormatProvider> interfaces e, em seguida, chame o <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="44a32-170">To do this, define a custom format provider by implementing the <xref:System.ICustomFormatter> and <xref:System.IFormatProvider> interfaces, and then call the <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="44a32-171">O exemplo a seguir define uma `ComplexFormatter` classe que representa um número complexo como uma cadeia de caracteres na forma de um + bi ou um + bj.</span><span class="sxs-lookup"><span data-stu-id="44a32-171">The following example defines a `ComplexFormatter` class that represents a complex number as a string in the form of either a + bi or a + bj.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.class/cs/customfmt1.cs#1)]
 [!code-vb[System.Numerics.Complex.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.class/vb/customfmt1.vb#1)]  
  
 <span data-ttu-id="44a32-172">O exemplo a seguir, em seguida, usa esse formatador personalizado para exibir a representação de cadeia de caracteres de um número complexo.</span><span class="sxs-lookup"><span data-stu-id="44a32-172">The following example then uses this custom formatter to display the string representation of a complex number.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.class/cs/customfmt1.cs#4)]
 [!code-vb[System.Numerics.Complex.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.class/vb/customfmt1.vb#4)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Complex (double real, double imaginary);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(float64 real, float64 imaginary) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.#ctor(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (real As Double, imaginary As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Complex(double real, double imaginary);" />
      <MemberSignature Language="F#" Value="new System.Numerics.Complex : double * double -&gt; System.Numerics.Complex" Usage="new System.Numerics.Complex (real, imaginary)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="real" Type="System.Double" />
        <Parameter Name="imaginary" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="real">
          <span data-ttu-id="44a32-173">A parte real do número complexo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-173">The real part of the complex number.</span>
          </span>
        </param>
        <param name="imaginary">
          <span data-ttu-id="44a32-174">A parte imaginária do número complexo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-174">The imaginary part of the complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="44a32-175">Inicializa uma nova instância da estrutura <see cref="T:System.Numerics.Complex" /> usando os valores reais e imaginários especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-175">Initializes a new instance of the <see cref="T:System.Numerics.Complex" /> structure using the specified real and imaginary values.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="44a32-176">O `real` ou `imaginary` argumentos podem perder a precisão se eles forem tipos de dados que exigem uma conversão explícita para <xref:System.Double>.</span><span class="sxs-lookup"><span data-stu-id="44a32-176">The `real` or `imaginary` arguments may lose precision if they are data types that require an explicit cast to <xref:System.Double>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="44a32-177">O exemplo a seguir cria uma instância de dois números complexos e, em seguida, usa-os em operações de adição, subtração, multiplicação e divisão.</span><span class="sxs-lookup"><span data-stu-id="44a32-177">The following example instantiates two complex numbers, and then uses them in addition, subtraction, multiplication, and division operations.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.ctor/cs/ctor1.cs#1)]
 [!code-vb[System.Numerics.Complex.ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.ctor/vb/ctor1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Abs">
      <MemberSignature Language="C#" Value="public static double Abs (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Abs(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Abs(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Abs (value As Complex) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Abs(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Abs : System.Numerics.Complex -&gt; double" Usage="System.Numerics.Complex.Abs value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="44a32-178">Um número complexo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-178">A complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="44a32-179">Obtém o valor absoluto (ou magnitude) de um número complexo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-179">Gets the absolute value (or magnitude) of a complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="44a32-180">O valor absoluto de <paramref name="value" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-180">The absolute value of <paramref name="value" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="44a32-181">O valor absoluto de um número complexo é equivalente a seu <xref:System.Numerics.Complex.Magnitude%2A> propriedade.</span><span class="sxs-lookup"><span data-stu-id="44a32-181">The absolute value of a complex number is equivalent to its <xref:System.Numerics.Complex.Magnitude%2A> property.</span></span> <span data-ttu-id="44a32-182">O valor absoluto de um número real de um + bi é calculado da seguinte maneira:</span><span class="sxs-lookup"><span data-stu-id="44a32-182">The absolute value of a real number a + bi is calculated as follows:</span></span>  
  
-   <span data-ttu-id="44a32-183">Se b = 0, o resultado é 0.</span><span class="sxs-lookup"><span data-stu-id="44a32-183">If b = 0, the result is 0.</span></span>  
  
-   <span data-ttu-id="44a32-184">Se um > b, o resultado é um \*<xref:System.Math.Sqrt%2A?displayProperty=nameWithType>(1 + b<sup>2</sup>/a<sup>2</sup>).</span><span class="sxs-lookup"><span data-stu-id="44a32-184">If a > b, the result is a \*<xref:System.Math.Sqrt%2A?displayProperty=nameWithType>(1 + b<sup>2</sup>/a<sup>2</sup>).</span></span>  
  
-   <span data-ttu-id="44a32-185">Se b > um, o resultado é b \* <xref:System.Math.Sqrt%2A?displayProperty=nameWithType>(1 + a<sup>2</sup>/b<sup>2</sup>).</span><span class="sxs-lookup"><span data-stu-id="44a32-185">If b > a, the result is b \* <xref:System.Math.Sqrt%2A?displayProperty=nameWithType>(1 + a<sup>2</sup>/b<sup>2</sup>).</span></span>  
  
 <span data-ttu-id="44a32-186">Se o cálculo do valor absoluto resulta em um estouro, o método retorna um <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> ou <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="44a32-186">If the calculation of the absolute value results in an overflow, the method returns either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span> <span data-ttu-id="44a32-187">Se o <xref:System.Numerics.Complex.Real%2A> ou <xref:System.Numerics.Complex.Imaginary%2A> é de propriedade <xref:System.Double.NaN?displayProperty=nameWithType> e a outra propriedade não é nem <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> nem <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, o método retorna <xref:System.Double.NaN?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="44a32-187">If either the <xref:System.Numerics.Complex.Real%2A> or <xref:System.Numerics.Complex.Imaginary%2A> property is <xref:System.Double.NaN?displayProperty=nameWithType> and the other property is neither <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> nor <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, the method returns <xref:System.Double.NaN?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="44a32-188">O exemplo a seguir calcula o valor absoluto de um número complexo e demonstra que é equivalente ao valor da <xref:System.Numerics.Complex.Magnitude%2A> propriedade.</span><span class="sxs-lookup"><span data-stu-id="44a32-188">The following example calculates the absolute value of a complex number and demonstrates that it is equivalent to the value of the <xref:System.Numerics.Complex.Magnitude%2A> property.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Abs#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.abs/cs/abs1.cs#1)]
 [!code-vb[System.Numerics.Complex.Abs#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.abs/vb/abs1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.Complex.Magnitude" />
      </Docs>
    </Member>
    <Member MemberName="Acos">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Acos (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Acos(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Acos(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Acos (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Acos(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Acos : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Acos value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="44a32-189">Um número complexo que representa um cosseno.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-189">A complex number that represents a cosine.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="44a32-190">Retorna o ângulo que é o arco cosseno do número complexo especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-190">Returns the angle that is the arc cosine of the specified complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="44a32-191">O ângulo, medido em radianos, que é o arco cosseno de <paramref name="value" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-191">The angle, measured in radians, which is the arc cosine of <paramref name="value" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="44a32-192">O <xref:System.Numerics.Complex.Acos%2A> método para números complexos corresponde à <xref:System.Math.Acos%2A?displayProperty=nameWithType> método para números reais.</span><span class="sxs-lookup"><span data-stu-id="44a32-192">The <xref:System.Numerics.Complex.Acos%2A> method for complex numbers corresponds to the <xref:System.Math.Acos%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="44a32-193">O <xref:System.Numerics.Complex.Acos%2A> método usa a seguinte fórmula:</span><span class="sxs-lookup"><span data-stu-id="44a32-193">The <xref:System.Numerics.Complex.Acos%2A> method uses the following formula:</span></span>  
  
 <span data-ttu-id="44a32-194">(-<xref:System.Numerics.Complex.ImaginaryOne>) \* <xref:System.Numerics.Complex.Log%2A>(`value` + <xref:System.Numerics.Complex.ImaginaryOne>\*<xref:System.Numerics.Complex.Sqrt%2A>(<xref:System.Numerics.Complex.One> - `value` \* `value`)))</span><span class="sxs-lookup"><span data-stu-id="44a32-194">(-<xref:System.Numerics.Complex.ImaginaryOne>) \* <xref:System.Numerics.Complex.Log%2A>(`value` + <xref:System.Numerics.Complex.ImaginaryOne>\*<xref:System.Numerics.Complex.Sqrt%2A>(<xref:System.Numerics.Complex.One> - `value` \* `value`)))</span></span>    
  
   
  
## Examples  
 <span data-ttu-id="44a32-195">O exemplo a seguir ilustra o <xref:System.Numerics.Complex.Acos%2A> método.</span><span class="sxs-lookup"><span data-stu-id="44a32-195">The following example illustrates the <xref:System.Numerics.Complex.Acos%2A> method.</span></span> <span data-ttu-id="44a32-196">Ele mostra que o valor retornado por passando o <xref:System.Numerics.Complex.Acos%2A> método para o <xref:System.Numerics.Complex.Cos%2A> método retorna o original <xref:System.Numerics.Complex> valor.</span><span class="sxs-lookup"><span data-stu-id="44a32-196">It shows that passing the value returned by the <xref:System.Numerics.Complex.Acos%2A> method to the <xref:System.Numerics.Complex.Cos%2A> method returns the original <xref:System.Numerics.Complex> value.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Acos#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.acos/cs/acos1.cs#1)]
 [!code-vb[System.Numerics.Complex.Acos#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.acos/vb/acos1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Cos(System.Numerics.Complex)" />
        <altmember cref="M:System.Math.Acos(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Add (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Add(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Add(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Add(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member Add : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Add (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="44a32-197">O primeiro número complexo a ser adicionado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-197">The first complex number to add.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="44a32-198">O segundo número complexo a ser adicionado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-198">The second complex number to add.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="44a32-199">Adiciona dois números complexos e retorna o resultado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-199">Adds two complex numbers and returns the result.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="44a32-200">A soma de <paramref name="left" /> e <paramref name="right" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-200">The sum of <paramref name="left" /> and <paramref name="right" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="44a32-201">A adição de um complexo de número, a + bi, e um segundo número complexo, c + injeção de dependência, usa o seguinte formato:</span><span class="sxs-lookup"><span data-stu-id="44a32-201">The addition of a complex number, a + bi, and a second complex number, c + di, takes the following form:</span></span>  
  
 <span data-ttu-id="44a32-202">(a + c) + (b + d) eu.</span><span class="sxs-lookup"><span data-stu-id="44a32-202">(a + c) + (b + d)i.</span></span>  
  
 <span data-ttu-id="44a32-203">Se a chamada de método resultados em um estouro no componente real ou imaginário, o valor do componente é <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> ou <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="44a32-203">If the method call results in an overflow in either the real or imaginary component, the value of the component is either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="44a32-204">Idiomas que não dão suporte a operadores personalizados podem usar o <xref:System.Numerics.Complex.Add%2A> método para executar uma adição com números complexos.</span><span class="sxs-lookup"><span data-stu-id="44a32-204">Languages that do not support custom operators can use the <xref:System.Numerics.Complex.Add%2A> method to perform addition with complex numbers.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="44a32-205">O exemplo a seguir ilustra a adição com números complexos.</span><span class="sxs-lookup"><span data-stu-id="44a32-205">The following example illustrates addition with complex numbers.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Add#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.add/cs/add1.cs#1)]
 [!code-vb[System.Numerics.Complex.Add#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.add/vb/add1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Addition(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Asin">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Asin (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Asin(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Asin(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Asin (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Asin(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Asin : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Asin value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="44a32-206">Um número complexo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-206">A complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="44a32-207">Retorna o ângulo que é o arco seno do número complexo especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-207">Returns the angle that is the arc sine of the specified complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="44a32-208">O ângulo que é o arco seno de <paramref name="value" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-208">The angle which is the arc sine of <paramref name="value" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="44a32-209">O <xref:System.Numerics.Complex.Asin%2A> método para números complexos corresponde à <xref:System.Math.Asin%2A?displayProperty=nameWithType> método para números reais.</span><span class="sxs-lookup"><span data-stu-id="44a32-209">The <xref:System.Numerics.Complex.Asin%2A> method for complex numbers corresponds to the <xref:System.Math.Asin%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="44a32-210">O <xref:System.Numerics.Complex.Asin%2A> método usa a seguinte fórmula:</span><span class="sxs-lookup"><span data-stu-id="44a32-210">The <xref:System.Numerics.Complex.Asin%2A> method uses the following formula:</span></span>  
  
 <span data-ttu-id="44a32-211">-<xref:System.Numerics.Complex.ImaginaryOne> \* <xref:System.Numerics.Complex.Log%2A>(<xref:System.Numerics.Complex.ImaginaryOne> \* valor + <xref:System.Numerics.Complex.Sqrt%2A>(<xref:System.Numerics.Complex.One> -valor \* valor))</span><span class="sxs-lookup"><span data-stu-id="44a32-211">-<xref:System.Numerics.Complex.ImaginaryOne> \* <xref:System.Numerics.Complex.Log%2A>(<xref:System.Numerics.Complex.ImaginaryOne> \* value + <xref:System.Numerics.Complex.Sqrt%2A>(<xref:System.Numerics.Complex.One> - value \* value))</span></span>    
  
   
  
## Examples  
 <span data-ttu-id="44a32-212">O exemplo a seguir ilustra o <xref:System.Numerics.Complex.Asin%2A> método.</span><span class="sxs-lookup"><span data-stu-id="44a32-212">The following example illustrates the <xref:System.Numerics.Complex.Asin%2A> method.</span></span> <span data-ttu-id="44a32-213">Ele mostra que o valor retornado por passando o <xref:System.Numerics.Complex.Asin%2A> método para o <xref:System.Numerics.Complex.Sin%2A> método retorna o original <xref:System.Numerics.Complex> valor.</span><span class="sxs-lookup"><span data-stu-id="44a32-213">It shows that passing the value returned by the <xref:System.Numerics.Complex.Asin%2A> method to the <xref:System.Numerics.Complex.Sin%2A> method returns the original <xref:System.Numerics.Complex> value.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Asin#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.asin/cs/asin1.cs#1)]
 [!code-vb[System.Numerics.Complex.Asin#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.asin/vb/asin1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Sin(System.Numerics.Complex)" />
        <altmember cref="M:System.Math.Asin(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Atan">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Atan (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Atan(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Atan(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Atan (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Atan(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Atan : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Atan value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="44a32-214">Um número complexo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-214">A complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="44a32-215">Retorna o ângulo que é o arco tangente do número complexo especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-215">Returns the angle that is the arc tangent of the specified complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="44a32-216">O ângulo que é o arco tangente de <paramref name="value" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-216">The angle that is the arc tangent of <paramref name="value" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="44a32-217">O <xref:System.Numerics.Complex.Atan%2A> método para números complexos corresponde à <xref:System.Math.Atan%2A?displayProperty=nameWithType> método para números reais.</span><span class="sxs-lookup"><span data-stu-id="44a32-217">The <xref:System.Numerics.Complex.Atan%2A> method for complex numbers corresponds to the <xref:System.Math.Atan%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="44a32-218">O <xref:System.Numerics.Complex.Atan%2A> método usa a seguinte fórmula:</span><span class="sxs-lookup"><span data-stu-id="44a32-218">The <xref:System.Numerics.Complex.Atan%2A> method uses the following formula:</span></span>  
  
 <span data-ttu-id="44a32-219"><xref:System.Numerics.Complex.ImaginaryOne> / novo complexo (2.0, 0.0)) \* (<xref:System.Numerics.Complex.Log%2A>(<xref:System.Numerics.Complex.One>  -  <xref:System.Numerics.Complex.ImaginaryOne> \* valor)- <xref:System.Numerics.Complex.Log%2A>(<xref:System.Numerics.Complex.One> + ImaginaryOne \* valor)</span><span class="sxs-lookup"><span data-stu-id="44a32-219"><xref:System.Numerics.Complex.ImaginaryOne> / new Complex(2.0, 0.0)) \* (<xref:System.Numerics.Complex.Log%2A>(<xref:System.Numerics.Complex.One> - <xref:System.Numerics.Complex.ImaginaryOne> \* value) - <xref:System.Numerics.Complex.Log%2A>(<xref:System.Numerics.Complex.One> + ImaginaryOne \* value)</span></span>   
  
   
  
## Examples  
 <span data-ttu-id="44a32-220">O exemplo a seguir ilustra o <xref:System.Numerics.Complex.Atan%2A> método.</span><span class="sxs-lookup"><span data-stu-id="44a32-220">The following example illustrates the <xref:System.Numerics.Complex.Atan%2A> method.</span></span> <span data-ttu-id="44a32-221">Ele mostra que o valor retornado por passando o <xref:System.Numerics.Complex.Atan%2A> método para o <xref:System.Numerics.Complex.Tan%2A> método retorna o original <xref:System.Numerics.Complex> valor.</span><span class="sxs-lookup"><span data-stu-id="44a32-221">It shows that passing the value returned by the <xref:System.Numerics.Complex.Atan%2A> method to the <xref:System.Numerics.Complex.Tan%2A> method returns the original <xref:System.Numerics.Complex> value.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Atan#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.atan/cs/atan1.cs#1)]
 [!code-vb[System.Numerics.Complex.Atan#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.atan/vb/atan1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Tan(System.Numerics.Complex)" />
        <altmember cref="M:System.Math.Atan(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Conjugate">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Conjugate (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Conjugate(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Conjugate(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Conjugate (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Conjugate(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Conjugate : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Conjugate value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="44a32-222">Um número complexo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-222">A complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="44a32-223">Calcula o conjugado de um número complexo e retorna o resultado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-223">Computes the conjugate of a complex number and returns the result.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="44a32-224">O conjugado de <paramref name="value" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-224">The conjugate of <paramref name="value" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="44a32-225">O conjugado de um número complexo inverte o sinal do componente imaginário; ou seja, ele aplica o unário de negação para o componente imaginário.</span><span class="sxs-lookup"><span data-stu-id="44a32-225">The conjugate of a complex number inverts the sign of the imaginary component; that is, it applies unary negation to the imaginary component.</span></span> <span data-ttu-id="44a32-226">Se um + bi é um número complexo, seu conjugado é a – bi.</span><span class="sxs-lookup"><span data-stu-id="44a32-226">If a + bi is a complex number, its conjugate is a - bi.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="44a32-227">O exemplo a seguir exibe o conjugado de dois números complexos.</span><span class="sxs-lookup"><span data-stu-id="44a32-227">The following example displays the conjugate of two complex numbers.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Conjugate#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.conjugate/cs/conjugate1.cs#1)]
 [!code-vb[System.Numerics.Complex.Conjugate#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.conjugate/vb/conjugate1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cos">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Cos (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Cos(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Cos(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Cos (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Cos(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Cos : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Cos value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="44a32-228">Um número complexo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-228">A complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="44a32-229">Retorna o cosseno do número complexo especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-229">Returns the cosine of the specified complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="44a32-230">O cosseno de <paramref name="value" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-230">The cosine of <paramref name="value" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="44a32-231">O <xref:System.Numerics.Complex.Cos%2A> método para números complexos corresponde à <xref:System.Math.Cos%2A?displayProperty=nameWithType> método para números reais.</span><span class="sxs-lookup"><span data-stu-id="44a32-231">The <xref:System.Numerics.Complex.Cos%2A> method for complex numbers corresponds to the <xref:System.Math.Cos%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="44a32-232">O <xref:System.Numerics.Complex.Cos%2A> método usa a seguinte fórmula para calcular o cosseno do número complexo a + bi:</span><span class="sxs-lookup"><span data-stu-id="44a32-232">The <xref:System.Numerics.Complex.Cos%2A> method uses the following formula to calculate the cosine of the complex number a + bi:</span></span>  
  
 <span data-ttu-id="44a32-233">(<xref:System.Math.Cos%2A>(a) * <xref:System.Math.Cosh%2A>(b), -(<xref:System.Math.Sin%2A>(a) * <xref:System.Math.Sinh%2A>(b)))</span><span class="sxs-lookup"><span data-stu-id="44a32-233">(<xref:System.Math.Cos%2A>(a) * <xref:System.Math.Cosh%2A>(b), -(<xref:System.Math.Sin%2A>(a) * <xref:System.Math.Sinh%2A>(b)))</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="44a32-234">O exemplo a seguir ilustra o <xref:System.Numerics.Complex.Acos%2A> método.</span><span class="sxs-lookup"><span data-stu-id="44a32-234">The following example illustrates the <xref:System.Numerics.Complex.Acos%2A> method.</span></span> <span data-ttu-id="44a32-235">Ele mostra que o valor retornado por passando o <xref:System.Numerics.Complex.Acos%2A> método para o <xref:System.Numerics.Complex.Cos%2A> método retorna o original <xref:System.Numerics.Complex> valor.</span><span class="sxs-lookup"><span data-stu-id="44a32-235">It shows that passing the value returned by the <xref:System.Numerics.Complex.Acos%2A> method to the <xref:System.Numerics.Complex.Cos%2A> method returns the original <xref:System.Numerics.Complex> value.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Acos#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.acos/cs/acos1.cs#1)]
 [!code-vb[System.Numerics.Complex.Acos#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.acos/vb/acos1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Acos(System.Numerics.Complex)" />
        <altmember cref="M:System.Math.Cos(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Cosh">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Cosh (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Cosh(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Cosh(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Cosh (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Cosh(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Cosh : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Cosh value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="44a32-236">Um número complexo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-236">A complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="44a32-237">Retorna o cosseno hiperbólico do número complexo especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-237">Returns the hyperbolic cosine of the specified complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="44a32-238">O cosseno hiperbólico de <paramref name="value" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-238">The hyperbolic cosine of <paramref name="value" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="44a32-239">O <xref:System.Numerics.Complex.Cosh%2A> método para números complexos corresponde à <xref:System.Math.Cosh%2A?displayProperty=nameWithType> método para números reais.</span><span class="sxs-lookup"><span data-stu-id="44a32-239">The <xref:System.Numerics.Complex.Cosh%2A> method for complex numbers corresponds to the <xref:System.Math.Cosh%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="44a32-240">O <xref:System.Numerics.Complex.Cosh%2A> método usa a seguinte fórmula para calcular o cosseno hiperbólico do número complexo a + bi:</span><span class="sxs-lookup"><span data-stu-id="44a32-240">The <xref:System.Numerics.Complex.Cosh%2A> method uses the following formula to calculate the hyperbolic cosine of the complex number a + bi:</span></span>  
  
 <span data-ttu-id="44a32-241">(<xref:System.Math.Cosh%2A>(a) * <xref:System.Math.Cos%2A>(b), <xref:System.Math.Sinh%2A>(a) * <xref:System.Math.Sin%2A>(b))</span><span class="sxs-lookup"><span data-stu-id="44a32-241">(<xref:System.Math.Cosh%2A>(a) * <xref:System.Math.Cos%2A>(b), <xref:System.Math.Sinh%2A>(a) * <xref:System.Math.Sin%2A>(b))</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Cosh(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Divide">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Divide (System.Numerics.Complex dividend, System.Numerics.Complex divisor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Divide(valuetype System.Numerics.Complex dividend, valuetype System.Numerics.Complex divisor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Divide(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Divide (dividend As Complex, divisor As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Divide(System::Numerics::Complex dividend, System::Numerics::Complex divisor);" />
      <MemberSignature Language="F#" Value="static member Divide : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Divide (dividend, divisor)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dividend" Type="System.Numerics.Complex" />
        <Parameter Name="divisor" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="dividend">
          <span data-ttu-id="44a32-242">O número complexo a ser dividido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-242">The complex number to be divided.</span>
          </span>
        </param>
        <param name="divisor">
          <span data-ttu-id="44a32-243">O número complexo pelo qual dividir.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-243">The complex number to divide by.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="44a32-244">Divide um número complexo por outro e retorna o resultado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-244">Divides one complex number by another and returns the result.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="44a32-245">O quociente da divisão.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-245">The quotient of the division.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="44a32-246">A divisão de um número complexo, um + bi, por um segundo número complexo, o número, o c + a injeção de dependência, usa o seguinte formato:</span><span class="sxs-lookup"><span data-stu-id="44a32-246">The division of a complex number, a + bi, by a second complex number, number, c + di, takes the following form:</span></span>  
  
 <span data-ttu-id="44a32-247">((AC + BD) / (c<sup>2</sup> + d<sup>2</sup>)) + ((bc-ad) / (c<sup>2</sup> + d<sup>2</sup>),</span><span class="sxs-lookup"><span data-stu-id="44a32-247">((ac + bd) / (c<sup>2</sup> + d<sup>2</sup>)) + ((bc - ad) / (c<sup>2</sup> + d<sup>2</sup>)i</span></span>  
  
 <span data-ttu-id="44a32-248">Se o cálculo do quociente resulta em um estouro no componente real ou imaginário, o valor desse componente é <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> ou <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="44a32-248">If the calculation of the quotient results in an overflow in either the real or imaginary component, the value of that component is either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="44a32-249">O <xref:System.Numerics.Complex.Divide%2A> método pode ser usado por idiomas que não dão suporte a operadores personalizados.</span><span class="sxs-lookup"><span data-stu-id="44a32-249">The <xref:System.Numerics.Complex.Divide%2A> method can be used by languages that do not support custom operators.</span></span> <span data-ttu-id="44a32-250">Seu comportamento é idêntico à divisão usando o operador de divisão.</span><span class="sxs-lookup"><span data-stu-id="44a32-250">Its behavior is identical to division using the division operator.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="44a32-251">O exemplo a seguir divide um número complexo por cada elemento em uma matriz de números complexos.</span><span class="sxs-lookup"><span data-stu-id="44a32-251">The following example divides a complex number by each element in an array of complex numbers.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Divide#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.divide/cs/divide1.cs#1)]
 [!code-vb[System.Numerics.Complex.Divide#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.divide/vb/divide1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Division(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="44a32-252">Retorna um valor que indica se dois números complexos são iguais.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-252">Returns a value that indicates whether two complex numbers are equal.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Equals(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (value As Complex) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="override this.Equals : System.Numerics.Complex -&gt; bool" Usage="complex.Equals value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="44a32-253">O número complexo a comparar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-253">The complex number to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="44a32-254">Retorna um valor que indica se a instância atual e um número complexo especificado têm o mesmo valor.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-254">Returns a value that indicates whether the current instance and a specified complex number have the same value.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="44a32-255">
            <see langword="true" /> se este número complexo <paramref name="value" /> tiverem o mesmo valor; caso contrário, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-255">
              <see langword="true" /> if this complex number and <paramref name="value" /> have the same value; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="44a32-256">O <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> método fornece a <xref:System.IEquatable%601> implementação para o <xref:System.Numerics.Complex> estrutura.</span><span class="sxs-lookup"><span data-stu-id="44a32-256">The <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> method provides the <xref:System.IEquatable%601> implementation for the <xref:System.Numerics.Complex> structure.</span></span> <span data-ttu-id="44a32-257">Ele é um pouco melhor do que <xref:System.Numerics.Complex.Equals%28System.Object%29> método porque ele não precisa converter seu parâmetro para um número complexo.</span><span class="sxs-lookup"><span data-stu-id="44a32-257">It performs slightly better than <xref:System.Numerics.Complex.Equals%28System.Object%29> method because it does not have to convert its parameter to a complex number.</span></span>  
  
 <span data-ttu-id="44a32-258">Dois números complexos são iguais se suas partes reais são iguais e suas partes imaginárias são iguais.</span><span class="sxs-lookup"><span data-stu-id="44a32-258">Two complex numbers are equal if their real parts are equal and their imaginary parts are equal.</span></span> <span data-ttu-id="44a32-259">O <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> método é equivalente à expressão a seguir:</span><span class="sxs-lookup"><span data-stu-id="44a32-259">The <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> method is equivalent to the following expression:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/equals1.cs#1)]
 [!code-vb[System.Numerics.Complex.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/equals1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <span data-ttu-id="44a32-260">
            <para>Use o <see cref="M:System.Numerics.Complex.Equals(System.Numerics.Complex)" /> método com cuidado, porque os dois valores que são equivalentes, aparentemente, podem ser considerados desiguais devido à precisão diferente de seus componentes reais e imaginárias. O exemplo a seguir relata que <c>(3.33333, 0.142857)</c> e <c>(10/3, 1/7)</c> não são iguais.  [! código csharp[System.Numerics.Complex.Equals#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/precision1.cs#4)] [! código vb[System.Numerics.Complex.Equals#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/precision1.vb#4)] uma recomendada técnica é definir uma margem aceitável da diferença entre os dois valores (como. % 01 de um dos componentes dos valores reais e imaginários) em vez de comparar os valores para igualdade. Se o valor absoluto da diferença entre os dois valores é menor que ou igual a essa margem, provavelmente devido a uma diferença entre a precisão é a diferença e, portanto, os valores provavelmente serão iguais. O exemplo a seguir usa essa técnica para comparar os dois valores complexos que o exemplo de código anterior encontrado japonesas. Ele localiza dois números complexos são iguais.  [! código csharp[System.Numerics.Complex.Equals#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/precision1.cs#5)] [! código vb[System.Numerics.Complex.Equals#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/precision1.vb#5)]</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-260">
              <para>Use the <see cref="M:System.Numerics.Complex.Equals(System.Numerics.Complex)" /> method with caution, because two values that are apparently equivalent can be considered unequal due to the differing precision of their real and imaginary components. The following example reports that <c>(3.33333, 0.142857)</c> and <c>(10/3, 1/7)</c> are not equal.  [!code-csharp[System.Numerics.Complex.Equals#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/precision1.cs#4)] [!code-vb[System.Numerics.Complex.Equals#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/precision1.vb#4)]  One recommended technique is to define an acceptable margin of difference between the two values (such as .01% of one of the values' real and imaginary components) instead of comparing the values for equality. If the absolute value of the difference between the two values is less than or equal to that margin, the difference is likely to be due to a difference in precision, and, therefore, the values are likely to be equal. The following example uses this technique to compare the two complex values that the previous code example found to be unequal. It finds the two complex numbers to be equal.  [!code-csharp[System.Numerics.Complex.Equals#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/precision1.cs#5)] [!code-vb[System.Numerics.Complex.Equals#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/precision1.vb#5)]</para>
            </span>
          </span>
        </block>
        <altmember cref="T:System.Double" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="complex.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="44a32-261">O objeto a ser comparado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-261">The object to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="44a32-262">Retorna um valor que indica se a instância atual e um objeto especificado têm o mesmo valor.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-262">Returns a value that indicates whether the current instance and a specified object have the same value.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="44a32-263">
            <see langword="true" /> se o parâmetro <paramref name="obj" /> for um objeto <see cref="T:System.Numerics.Complex" /> ou um tipo capaz de conversão implícita para um objeto <see cref="T:System.Numerics.Complex" /> e seu valor for igual ao objeto <see cref="T:System.Numerics.Complex" /> atual; caso contrário, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-263">
              <see langword="true" /> if the <paramref name="obj" /> parameter is a <see cref="T:System.Numerics.Complex" /> object or a type capable of implicit conversion to a <see cref="T:System.Numerics.Complex" /> object, and its value is equal to the current <see cref="T:System.Numerics.Complex" /> object; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="44a32-264">Dois números complexos são iguais se suas partes reais são iguais e suas partes imaginárias são iguais.</span><span class="sxs-lookup"><span data-stu-id="44a32-264">Two complex numbers are equal if their real parts are equal and their imaginary parts are equal.</span></span> <span data-ttu-id="44a32-265">O <xref:System.Numerics.Complex.Equals%28System.Object%29> método é equivalente à expressão a seguir:</span><span class="sxs-lookup"><span data-stu-id="44a32-265">The <xref:System.Numerics.Complex.Equals%28System.Object%29> method is equivalent to the following expression:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/equals1.cs#2)]
 [!code-vb[System.Numerics.Complex.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/equals1.vb#2)]  
  
 <span data-ttu-id="44a32-266">Se o `obj` parâmetro não é um <xref:System.Numerics.Complex> objeto, mas é um tipo de dados para o qual uma conversão implícita é definida, o <xref:System.Numerics.Complex.Equals%28System.Object%29> método converte `obj` para um <xref:System.Numerics.Complex> objeto cuja parte real é igual ao valor de `obj`e cuja parte imaginária é igual a zero antes de executar a comparação.</span><span class="sxs-lookup"><span data-stu-id="44a32-266">If the `obj` parameter is not a <xref:System.Numerics.Complex> object, but it is a data type for which an implicit conversion is defined, the <xref:System.Numerics.Complex.Equals%28System.Object%29> method converts `obj` to a <xref:System.Numerics.Complex> object whose real part is equal to the value of `obj` and whose imaginary part is equal to zero before it performs the comparison.</span></span> <span data-ttu-id="44a32-267">O exemplo a seguir ilustra isso localizando um número complexo e um valor de ponto flutuante de precisão dupla são iguais.</span><span class="sxs-lookup"><span data-stu-id="44a32-267">The following example illustrates this by finding that a complex number and a double-precision floating-point value are equal.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Equals#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/equals3.cs#6)]
 [!code-vb[System.Numerics.Complex.Equals#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/equals3.vb#6)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <span data-ttu-id="44a32-268">
            <para>Use o <see cref="M:System.Numerics.Complex.Equals(System.Numerics.Complex)" /> método com cuidado, porque os dois valores que são equivalentes, aparentemente, podem ser considerados desiguais devido à precisão diferente de seus componentes reais e imaginárias. O problema pode ser acentuado se <paramref name="obj" /> deve ser convertido em um <see cref="T:System.Double" /> antes de executar a comparação. O exemplo a seguir compara um número complexo cujo componente real parece ser igual a um <see cref="T:System.Single" /> valor com que <see cref="T:System.Single" /> valor. Como mostra a saída, a comparação de igualdade retorna <see langword="False" />.  [! código csharp[System.Numerics.Complex.Equals#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/equals4.cs#8)] [! código vb[System.Numerics.Complex.Equals#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/equals4.vb#8)] uma recomendada técnica é definir uma margem aceitável da diferença entre os dois valores (como. % 01 de um dos componentes dos valores reais e imaginários) em vez de comparar os valores para igualdade. Se o valor absoluto da diferença entre os dois valores é menor que ou igual a essa margem, provavelmente devido a uma diferença entre a precisão é a diferença e, portanto, os valores são provavelmente será igual. O exemplo a seguir usa essa técnica para comparar os dois valores que o exemplo de código anterior encontrado japonesas. Agora localize sejam iguais.  [! código csharp[System.Numerics.Complex.Equals#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/precision2.cs#7)] [! código vb[System.Numerics.Complex.Equals#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/precision2.vb#7)]</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-268">
              <para>Use the <see cref="M:System.Numerics.Complex.Equals(System.Numerics.Complex)" /> method with caution, because two values that are apparently equivalent can be considered unequal due to the differing precision of their real and imaginary components. The problem can be accentuated if <paramref name="obj" /> must be converted to a <see cref="T:System.Double" /> before performing the comparison. The following example compares a complex number whose real component appears to be equal to a <see cref="T:System.Single" /> value with that <see cref="T:System.Single" /> value. As the output shows, the comparison for equality returns <see langword="False" />.  [!code-csharp[System.Numerics.Complex.Equals#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/equals4.cs#8)] [!code-vb[System.Numerics.Complex.Equals#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/equals4.vb#8)]  One recommended technique is to define an acceptable margin of difference between the two values (such as .01% of one of the values' real and imaginary components) instead of comparing the values for equality. If the absolute value of the difference between the two values is less than or equal to that margin, the difference is likely to be due to a difference in precision and, therefore, the values are likely to be equal. The following example uses this technique to compare the two values that the previous code example found to be unequal. It now finds them to be equal.  [!code-csharp[System.Numerics.Complex.Equals#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/precision2.cs#7)] [!code-vb[System.Numerics.Complex.Equals#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/precision2.vb#7)]</para>
            </span>
          </span>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Exp">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Exp (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Exp(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Exp(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exp (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Exp(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Exp : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Exp value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="44a32-269">Um número complexo que especifica uma potência.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-269">A complex number that specifies a power.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="44a32-270">Retorna <see langword="e" /> elevado à potência especificada por um número complexo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-270">Returns <see langword="e" /> raised to the power specified by a complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="44a32-271">O número <see langword="e" /> elevado à potência <paramref name="value" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-271">The number <see langword="e" /> raised to the power <paramref name="value" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="44a32-272">Use o <xref:System.Numerics.Complex.Pow%2A> método para calcular as potências de outras bases.</span><span class="sxs-lookup"><span data-stu-id="44a32-272">Use the <xref:System.Numerics.Complex.Pow%2A> method to calculate the powers of other bases.</span></span>  
  
 <span data-ttu-id="44a32-273">O <xref:System.Numerics.Complex.Exp%2A> método para números complexos corresponde à <xref:System.Math.Exp%2A?displayProperty=nameWithType> método para números reais.</span><span class="sxs-lookup"><span data-stu-id="44a32-273">The <xref:System.Numerics.Complex.Exp%2A> method for complex numbers corresponds to the <xref:System.Math.Exp%2A?displayProperty=nameWithType> method for real numbers.</span></span> <span data-ttu-id="44a32-274"><xref:System.Numerics.Complex.Exp%2A> é o inverso de <xref:System.Numerics.Complex.Log%2A>.</span><span class="sxs-lookup"><span data-stu-id="44a32-274"><xref:System.Numerics.Complex.Exp%2A> is the inverse of <xref:System.Numerics.Complex.Log%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="44a32-275">O exemplo a seguir ilustra o <xref:System.Numerics.Complex.Exp%2A> método.</span><span class="sxs-lookup"><span data-stu-id="44a32-275">The following example illustrates the <xref:System.Numerics.Complex.Exp%2A> method.</span></span> <span data-ttu-id="44a32-276">Ele mostra que, com algumas franquia a falta de precisão do <xref:System.Double> tipo de dados, passando o valor retornado pela <xref:System.Numerics.Complex.Log%2A> método para o <xref:System.Numerics.Complex.Exp%2A> método retorna o original <xref:System.Numerics.Complex> valor.</span><span class="sxs-lookup"><span data-stu-id="44a32-276">It shows that, with some allowance for the lack of precision of the <xref:System.Double> data type, passing the value returned by the <xref:System.Numerics.Complex.Log%2A> method to the <xref:System.Numerics.Complex.Exp%2A> method returns the original <xref:System.Numerics.Complex> value.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Log#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.log/cs/log1.cs#1)] 
 [!code-vb[System.Numerics.Complex.Log#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.log/vb/log1.vb#1)]   
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Exp(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="FromPolarCoordinates">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex FromPolarCoordinates (double magnitude, double phase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex FromPolarCoordinates(float64 magnitude, float64 phase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.FromPolarCoordinates(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromPolarCoordinates (magnitude As Double, phase As Double) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex FromPolarCoordinates(double magnitude, double phase);" />
      <MemberSignature Language="F#" Value="static member FromPolarCoordinates : double * double -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.FromPolarCoordinates (magnitude, phase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="magnitude" Type="System.Double" />
        <Parameter Name="phase" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="magnitude">
          <span data-ttu-id="44a32-277">A magnitude, que é a distância da origem (a interseção entre os eixos x e y) para o número.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-277">The magnitude, which is the distance from the origin (the intersection of the x-axis and the y-axis) to the number.</span>
          </span>
        </param>
        <param name="phase">
          <span data-ttu-id="44a32-278">A fase, que é o ângulo da para o eixo horizontal, medido em radianos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-278">The phase, which is the angle from the line to the horizontal axis, measured in radians.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="44a32-279">Cria um número complexo de coordenadas polares de um ponto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-279">Creates a complex number from a point's polar coordinates.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="44a32-280">Um número complexo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-280">A complex number.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="44a32-281">O <xref:System.Numerics.Complex.FromPolarCoordinates%2A> método cria uma instância de um número complexo com base em suas coordenadas polares.</span><span class="sxs-lookup"><span data-stu-id="44a32-281">The <xref:System.Numerics.Complex.FromPolarCoordinates%2A> method instantiates a complex number based on its polar coordinates.</span></span>  
  
 <span data-ttu-id="44a32-282">Como há várias representações de um ponto em um plano complexo, o valor de retorno a <xref:System.Numerics.Complex.FromPolarCoordinates%2A> método é normalizado.</span><span class="sxs-lookup"><span data-stu-id="44a32-282">Because there are multiple representations of a point on a complex plane, the return value of the <xref:System.Numerics.Complex.FromPolarCoordinates%2A> method is normalized.</span></span> <span data-ttu-id="44a32-283">A magnitude é normalizada para um número positivo, e a fase é normalizada para um valor no intervalo de -<xref:System.Math.PI> para <xref:System.Math.PI>.</span><span class="sxs-lookup"><span data-stu-id="44a32-283">The magnitude is normalized to a positive number, and the phase is normalized to a value in the range of -<xref:System.Math.PI> to <xref:System.Math.PI>.</span></span> <span data-ttu-id="44a32-284">Como resultado, os valores da <xref:System.Numerics.Complex.Phase%2A> e <xref:System.Numerics.Complex.Magnitude%2A> propriedades do número complexo resultante não pode ser igual aos valores originais da `magnitude` e `phase` parâmetros.</span><span class="sxs-lookup"><span data-stu-id="44a32-284">As a result, the values of the <xref:System.Numerics.Complex.Phase%2A> and <xref:System.Numerics.Complex.Magnitude%2A> properties of the resulting complex number may not equal the original values of the `magnitude` and `phase` parameters.</span></span>  
  
 <span data-ttu-id="44a32-285">Para converter um valor de graus em radianos para o `phase` parâmetro, multiplique-lo por  <xref:System.Math.PI?displayProperty=nameWithType> /180.</span><span class="sxs-lookup"><span data-stu-id="44a32-285">To convert a value from degrees to radians for the `phase` parameter, multiply it by <xref:System.Math.PI?displayProperty=nameWithType>/180.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="44a32-286">O exemplo a seguir usa o <xref:System.Numerics.Complex.FromPolarCoordinates%2A> método para criar uma instância de um número complexo com base em suas coordenadas polares e, em seguida, exibe o valor do seu <xref:System.Numerics.Complex.Magnitude%2A> e <xref:System.Numerics.Complex.Phase%2A> propriedades.</span><span class="sxs-lookup"><span data-stu-id="44a32-286">The following example uses the <xref:System.Numerics.Complex.FromPolarCoordinates%2A> method to instantiate a complex number based on its polar coordinates and then displays the value of its <xref:System.Numerics.Complex.Magnitude%2A> and <xref:System.Numerics.Complex.Phase%2A> properties.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Phase#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.phase/cs/phase1.cs#1)]
 [!code-vb[System.Numerics.Complex.Phase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.phase/vb/phase1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.Complex.Magnitude" />
        <altmember cref="P:System.Numerics.Complex.Phase" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="complex.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="44a32-287">Retorna o código hash para o objeto <see cref="T:System.Numerics.Complex" /> atual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-287">Returns the hash code for the current <see cref="T:System.Numerics.Complex" /> object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="44a32-288">Um código de hash do inteiro assinado de 32 bits.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-288">A 32-bit signed integer hash code.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Imaginary">
      <MemberSignature Language="C#" Value="public double Imaginary { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Imaginary" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Complex.Imaginary" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Imaginary As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Imaginary { double get(); };" />
      <MemberSignature Language="F#" Value="member this.Imaginary : double" Usage="System.Numerics.Complex.Imaginary" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="44a32-289">Obtém o componente imaginário do objeto <see cref="T:System.Numerics.Complex" /> atual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-289">Gets the imaginary component of the current <see cref="T:System.Numerics.Complex" /> object.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="44a32-290">O componente imaginário de um número complexo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-290">The imaginary component of a complex number.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="44a32-291">Dado um número complexo a + bi, o <xref:System.Numerics.Complex.Imaginary%2A> propriedade retorna o valor de b.</span><span class="sxs-lookup"><span data-stu-id="44a32-291">Given a complex number a + bi, the <xref:System.Numerics.Complex.Imaginary%2A> property returns the value of b.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="44a32-292">O exemplo a seguir cria uma matriz de <xref:System.Numerics.Complex> objetos e exibe os componentes reais e imaginários de cada um no formulário a + bi.</span><span class="sxs-lookup"><span data-stu-id="44a32-292">The following example instantiates an array of <xref:System.Numerics.Complex> objects and displays the real and imaginary components of each in the form a + bi.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Real#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.real/cs/real1.cs#1)]
 [!code-vb[System.Numerics.Complex.Real#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.real/vb/real1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.Complex.Real" />
      </Docs>
    </Member>
    <Member MemberName="ImaginaryOne">
      <MemberSignature Language="C#" Value="public static readonly System.Numerics.Complex ImaginaryOne;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Numerics.Complex ImaginaryOne" />
      <MemberSignature Language="DocId" Value="F:System.Numerics.Complex.ImaginaryOne" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ImaginaryOne As Complex " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Numerics::Complex ImaginaryOne;" />
      <MemberSignature Language="F#" Value=" staticval mutable ImaginaryOne : System.Numerics.Complex" Usage="System.Numerics.Complex.ImaginaryOne" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="44a32-293">Retorna uma nova instância do <see cref="T:System.Numerics.Complex" /> com um número real igual a zero e um número imaginário igual a um.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-293">Returns a new <see cref="T:System.Numerics.Complex" /> instance with a real number equal to zero and an imaginary number equal to one.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="44a32-294">O exemplo a seguir instancia um <xref:System.Numerics.Complex> valor usando o <xref:System.Numerics.Complex.ImaginaryOne> propriedade.</span><span class="sxs-lookup"><span data-stu-id="44a32-294">The following example instantiates a <xref:System.Numerics.Complex> value by using the <xref:System.Numerics.Complex.ImaginaryOne> property.</span></span> <span data-ttu-id="44a32-295">Ele então compara esse valor para outro valor que é instanciado, chamando o <xref:System.Numerics.Complex> construtor com uma parte real igual a zero e uma parte imaginária igual a um.</span><span class="sxs-lookup"><span data-stu-id="44a32-295">It then compares this value to another value that is instantiated by calling the <xref:System.Numerics.Complex> constructor with a real part equal to zero and an imaginary part equal to one.</span></span> <span data-ttu-id="44a32-296">Como mostra a saída do exemplo, os dois valores são iguais.</span><span class="sxs-lookup"><span data-stu-id="44a32-296">As the output from the example shows, the two values are equal.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.ImaginaryOne#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.imaginaryone/cs/imaginaryone1.cs#1)]
 [!code-vb[System.Numerics.Complex.ImaginaryOne#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.imaginaryone/vb/imaginaryone1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Numerics.Complex.One" />
        <altmember cref="F:System.Numerics.Complex.Zero" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Log">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="44a32-297">Retorna o logaritmo de um número complexo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-297">Returns the logarithm of a complex number.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Log (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Log(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Log(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Log(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Log : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Log value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="44a32-298">Um número complexo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-298">A complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="44a32-299">Retorna o logaritmo natural (de base <see langword="e" />) de um número complexo especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-299">Returns the natural (base <see langword="e" />) logarithm of a specified complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="44a32-300">O logaritmo natural (de base <see langword="e" />) de <paramref name="value" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-300">The natural (base <see langword="e" />) logarithm of <paramref name="value" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="44a32-301">O <xref:System.Numerics.Complex.Log%28System.Numerics.Complex%29> método para números complexos corresponde à <xref:System.Math.Log%28System.Double%29?displayProperty=nameWithType> método para números reais.</span><span class="sxs-lookup"><span data-stu-id="44a32-301">The <xref:System.Numerics.Complex.Log%28System.Numerics.Complex%29> method for complex numbers corresponds to the <xref:System.Math.Log%28System.Double%29?displayProperty=nameWithType> method for real numbers.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="44a32-302">O exemplo a seguir ilustra o <xref:System.Numerics.Complex.Log%2A> método.</span><span class="sxs-lookup"><span data-stu-id="44a32-302">The following example illustrates the <xref:System.Numerics.Complex.Log%2A> method.</span></span> <span data-ttu-id="44a32-303">Ele mostra que, com algumas franquia a falta de precisão do <xref:System.Double> tipo de dados, passando o valor retornado pela <xref:System.Numerics.Complex.Log%2A> método para o <xref:System.Numerics.Complex.Exp%2A> método retorna o original <xref:System.Numerics.Complex> valor.</span><span class="sxs-lookup"><span data-stu-id="44a32-303">It shows that, with some allowance for the lack of precision of the <xref:System.Double> data type, passing the value returned by the <xref:System.Numerics.Complex.Log%2A> method to the <xref:System.Numerics.Complex.Exp%2A> method returns the original <xref:System.Numerics.Complex> value.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Log#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.log/cs/log1.cs#1)] 
 [!code-vb[System.Numerics.Complex.Log#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.log/vb/log1.vb#1)]   
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Log(System.Double)" />
        <altmember cref="M:System.Numerics.Complex.Exp(System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Log (System.Numerics.Complex value, double baseValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Log(valuetype System.Numerics.Complex value, float64 baseValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Log(System.Numerics.Complex,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log (value As Complex, baseValue As Double) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Log(System::Numerics::Complex value, double baseValue);" />
      <MemberSignature Language="F#" Value="static member Log : System.Numerics.Complex * double -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Log (value, baseValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
        <Parameter Name="baseValue" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="44a32-304">Um número complexo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-304">A complex number.</span>
          </span>
        </param>
        <param name="baseValue">
          <span data-ttu-id="44a32-305">A base do logaritmo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-305">The base of the logarithm.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="44a32-306">Retorna o logaritmo de um número complexo especificado em uma base especificada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-306">Returns the logarithm of a specified complex number in a specified base.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="44a32-307">O logaritmo de <paramref name="value" /> na base <paramref name="baseValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-307">The logarithm of <paramref name="value" /> in base <paramref name="baseValue" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="44a32-308">O <xref:System.Numerics.Complex.Log%28System.Numerics.Complex%2CSystem.Double%29> método para números complexos corresponde à <xref:System.Math.Log%28System.Double%2CSystem.Double%29?displayProperty=nameWithType> método para números reais.</span><span class="sxs-lookup"><span data-stu-id="44a32-308">The <xref:System.Numerics.Complex.Log%28System.Numerics.Complex%2CSystem.Double%29> method for complex numbers corresponds to the <xref:System.Math.Log%28System.Double%2CSystem.Double%29?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Log10">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Log10 (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Log10(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Log10(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log10 (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Log10(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Log10 : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Log10 value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="44a32-309">Um número complexo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-309">A complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="44a32-310">Retorna o logaritmo de base 10 de um número complexo especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-310">Returns the base-10 logarithm of a specified complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="44a32-311">O logaritmo de base 10 de <paramref name="value" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-311">The base-10 logarithm of <paramref name="value" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="44a32-312">O <xref:System.Numerics.Complex.Log10%2A> método para números complexos corresponde à <xref:System.Math.Log10%2A?displayProperty=nameWithType> método para números reais.</span><span class="sxs-lookup"><span data-stu-id="44a32-312">The <xref:System.Numerics.Complex.Log10%2A> method for complex numbers corresponds to the <xref:System.Math.Log10%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Magnitude">
      <MemberSignature Language="C#" Value="public double Magnitude { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Magnitude" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Complex.Magnitude" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Magnitude As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Magnitude { double get(); };" />
      <MemberSignature Language="F#" Value="member this.Magnitude : double" Usage="System.Numerics.Complex.Magnitude" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="44a32-313">Obtém a magnitude (ou valor absoluto) de um número complexo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-313">Gets the magnitude (or absolute value) of a complex number.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="44a32-314">A magnitude da instância atual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-314">The magnitude of the current instance.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="44a32-315">O <xref:System.Numerics.Complex.Magnitude%2A> propriedade é equivalente ao valor absoluto de um número complexo.</span><span class="sxs-lookup"><span data-stu-id="44a32-315">The <xref:System.Numerics.Complex.Magnitude%2A> property is equivalent to the absolute value of a complex number.</span></span> <span data-ttu-id="44a32-316">Ele especifica a distância da origem (a interseção do eixo x e y no sistema de coordenadas cartesianas) para o ponto bidimensional representado por um número complexo.</span><span class="sxs-lookup"><span data-stu-id="44a32-316">It specifies the distance from the origin (the intersection of the x-axis and the y-axis in the Cartesian coordinate system) to the two-dimensional point represented by a complex number.</span></span> <span data-ttu-id="44a32-317">O valor absoluto é calculado da seguinte maneira:</span><span class="sxs-lookup"><span data-stu-id="44a32-317">The absolute value is calculated as follows:</span></span>  
  
 <span data-ttu-id="44a32-318">&#124;um + bi &#124; = <xref:System.Math.Sqrt%2A?displayProperty=nameWithType>(um * um + b * b)</span><span class="sxs-lookup"><span data-stu-id="44a32-318">&#124; a + bi &#124; = <xref:System.Math.Sqrt%2A?displayProperty=nameWithType>(a * a + b * b)</span></span>  
  
 <span data-ttu-id="44a32-319">Se o cálculo do valor absoluto resulta em um estouro, essa propriedade retorna um <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> ou <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="44a32-319">If the calculation of the absolute value results in an overflow, this property returns either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="44a32-320">O <xref:System.Numerics.Complex.Magnitude%2A> e o <xref:System.Numerics.Complex.Phase%2A> propriedades definem a posição de um ponto que representa um número complexo no sistema de coordenadas polares.</span><span class="sxs-lookup"><span data-stu-id="44a32-320">The <xref:System.Numerics.Complex.Magnitude%2A> and the <xref:System.Numerics.Complex.Phase%2A> properties define the position of a point that represents a complex number in the polar coordinate system.</span></span>  
  
 <span data-ttu-id="44a32-321">Você pode criar uma instância de um número complexo com base em suas coordenadas polares, em vez de suas coordenadas cartesianas chamando o <xref:System.Numerics.Complex.FromPolarCoordinates%2A> método.</span><span class="sxs-lookup"><span data-stu-id="44a32-321">You can instantiate a complex number based on its polar coordinates instead of its Cartesian coordinates by calling the <xref:System.Numerics.Complex.FromPolarCoordinates%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="44a32-322">O exemplo a seguir calcula o valor absoluto de um número complexo e demonstra que é equivalente ao valor da <xref:System.Numerics.Complex.Magnitude%2A> propriedade.</span><span class="sxs-lookup"><span data-stu-id="44a32-322">The following example calculates the absolute value of a complex number and demonstrates that it is equivalent to the value of the <xref:System.Numerics.Complex.Magnitude%2A> property.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Abs#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.abs/cs/abs1.cs#1)]
 [!code-vb[System.Numerics.Complex.Abs#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.abs/vb/abs1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Abs(System.Numerics.Complex)" />
        <altmember cref="P:System.Numerics.Complex.Phase" />
      </Docs>
    </Member>
    <Member MemberName="Multiply">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Multiply (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Multiply(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Multiply(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Multiply (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Multiply(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member Multiply : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Multiply (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="44a32-323">O primeiro número complexo a multiplicar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-323">The first complex number to multiply.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="44a32-324">O segundo número complexo a multiplicar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-324">The second complex number to multiply.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="44a32-325">Retorna o produto de dois números complexos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-325">Returns the product of two complex numbers.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="44a32-326">O produto dos parâmetros <paramref name="left" /> e <paramref name="right" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-326">The product of the <paramref name="left" /> and <paramref name="right" /> parameters.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="44a32-327">A multiplicação de um complexo de número, a + bi, e um segundo número complexo, c + injeção de dependência, usa o seguinte formato:</span><span class="sxs-lookup"><span data-stu-id="44a32-327">The multiplication of a complex number, a + bi, and a second complex number, c + di, takes the following form:</span></span>  
  
 <span data-ttu-id="44a32-328">(ac – bd) + (ad + bc),</span><span class="sxs-lookup"><span data-stu-id="44a32-328">(ac - bd) + (ad + bc)i</span></span>  
  
 <span data-ttu-id="44a32-329">Se a multiplicação resulta em um estouro no componente real ou imaginário, o valor desse componente é <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> ou <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="44a32-329">If the multiplication results in an overflow in either the real or imaginary component, the value of that component is either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="44a32-330">O <xref:System.Numerics.Complex.Multiply%2A> método é implementado para idiomas que não dão suporte a operadores personalizados.</span><span class="sxs-lookup"><span data-stu-id="44a32-330">The <xref:System.Numerics.Complex.Multiply%2A> method is implemented for languages that do not support custom operators.</span></span> <span data-ttu-id="44a32-331">Seu comportamento é idêntico a multiplicação usando o operador de multiplicação.</span><span class="sxs-lookup"><span data-stu-id="44a32-331">Its behavior is identical to multiplication using the multiplication operator.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="44a32-332">O exemplo a seguir múltiplos de um número complexo por cada elemento em uma matriz de números complexos.</span><span class="sxs-lookup"><span data-stu-id="44a32-332">The following example multiples a complex number by each element in an array of complex numbers.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Multiply#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.multiply/cs/multiply1.cs#1)]
 [!code-vb[System.Numerics.Complex.Multiply#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.multiply/vb/multiply1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Multiply(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Negate">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Negate (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Negate(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Negate(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Negate (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Negate(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Negate : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Negate value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="44a32-333">Um número complexo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-333">A complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="44a32-334">Retorna o inverso aditivo de um número complexo especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-334">Returns the additive inverse of a specified complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="44a32-335">O resultado dos componentes <see cref="P:System.Numerics.Complex.Real" /> e <see cref="P:System.Numerics.Complex.Imaginary" /> do parâmetro <paramref name="value" /> multiplicado por -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-335">The result of the <see cref="P:System.Numerics.Complex.Real" /> and <see cref="P:System.Numerics.Complex.Imaginary" /> components of the <paramref name="value" /> parameter multiplied by -1.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="44a32-336">O inverso aditivo de um número complexo é um número complexo que produz um valor de <xref:System.Numerics.Complex> quando ele é adicionado para o número complexo original.</span><span class="sxs-lookup"><span data-stu-id="44a32-336">The additive inverse of a complex number is a complex number that produces a value of <xref:System.Numerics.Complex> when it is added to the original complex number.</span></span> <span data-ttu-id="44a32-337">Esse método retorna um número complexo na qual os componentes reais e imaginários do número complexo original são multiplicados por -1.</span><span class="sxs-lookup"><span data-stu-id="44a32-337">This method returns a complex number in which the real and imaginary components of the original complex number are multiplied by -1.</span></span>  
  
 <span data-ttu-id="44a32-338">O <xref:System.Numerics.Complex.Negate%2A> método é implementado para idiomas que não dão suporte a operadores personalizados.</span><span class="sxs-lookup"><span data-stu-id="44a32-338">The <xref:System.Numerics.Complex.Negate%2A> method is implemented for languages that do not support custom operators.</span></span> <span data-ttu-id="44a32-339">Seu comportamento é idêntico a negação usando o operador unário de negação, <xref:System.Numerics.Complex.op_UnaryNegation%2A>.</span><span class="sxs-lookup"><span data-stu-id="44a32-339">Its behavior is identical to negation using the unary negation operator, <xref:System.Numerics.Complex.op_UnaryNegation%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="44a32-340">O exemplo a seguir obtém o inverso aditivo de cada elemento em uma matriz de números complexos.</span><span class="sxs-lookup"><span data-stu-id="44a32-340">The following example obtains the additive inverse of each element in an array of complex numbers.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Negate#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.negate/cs/negate1.cs#1)]
 [!code-vb[System.Numerics.Complex.Negate#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.negate/vb/negate1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_UnaryNegation(System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="One">
      <MemberSignature Language="C#" Value="public static readonly System.Numerics.Complex One;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Numerics.Complex One" />
      <MemberSignature Language="DocId" Value="F:System.Numerics.Complex.One" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly One As Complex " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Numerics::Complex One;" />
      <MemberSignature Language="F#" Value=" staticval mutable One : System.Numerics.Complex" Usage="System.Numerics.Complex.One" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="44a32-341">Retorna uma nova instância do <see cref="T:System.Numerics.Complex" /> com um número real igual a um e um número imaginário igual a zero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-341">Returns a new <see cref="T:System.Numerics.Complex" /> instance with a real number equal to one and an imaginary number equal to zero.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="44a32-342">O exemplo a seguir instancia um <xref:System.Numerics.Complex> valor usando o <xref:System.Numerics.Complex.One> propriedade.</span><span class="sxs-lookup"><span data-stu-id="44a32-342">The following example instantiates a <xref:System.Numerics.Complex> value by using the <xref:System.Numerics.Complex.One> property.</span></span> <span data-ttu-id="44a32-343">Ele então compara esse valor para outro valor que é instanciado, chamando o <xref:System.Numerics.Complex> construtor com uma parte real igual a um e uma parte imaginária igual a zero.</span><span class="sxs-lookup"><span data-stu-id="44a32-343">It then compares this value to another value that is instantiated by calling the <xref:System.Numerics.Complex> constructor with a real part equal to one and an imaginary part equal to zero.</span></span> <span data-ttu-id="44a32-344">Como mostra a saída do exemplo, os dois valores são iguais.</span><span class="sxs-lookup"><span data-stu-id="44a32-344">As the output from the example shows, the two values are equal.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.One#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.one/cs/one1.cs#1)]
 [!code-vb[System.Numerics.Complex.One#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.one/vb/one1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Numerics.Complex.ImaginaryOne" />
        <altmember cref="F:System.Numerics.Complex.Zero" />
      </Docs>
    </Member>
    <Member MemberName="op_Addition">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator + (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Addition(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Addition(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator + (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator +(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member ( + ) : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="left + right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="44a32-345">O primeiro valor a ser adicionado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-345">The first value to add.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="44a32-346">O segundo valor a ser adicionado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-346">The second value to add.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="44a32-347">Adiciona dois números complexos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-347">Adds two complex numbers.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="44a32-348">A soma de <paramref name="left" /> e <paramref name="right" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-348">The sum of <paramref name="left" /> and <paramref name="right" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="44a32-349">O <xref:System.Numerics.Complex.op_Addition%2A> método define a operação de adição de números complexos.</span><span class="sxs-lookup"><span data-stu-id="44a32-349">The <xref:System.Numerics.Complex.op_Addition%2A> method defines the addition operation for complex numbers.</span></span> <span data-ttu-id="44a32-350">Ele permite que o código seja o seguinte:</span><span class="sxs-lookup"><span data-stu-id="44a32-350">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Add#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.add/cs/add3.cs#3)]
 [!code-vb[System.Numerics.Complex.Add#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.add/vb/add3.vb#3)]  
  
 <span data-ttu-id="44a32-351">A adição de um complexo de número, a + bi, e um segundo número complexo, c + injeção de dependência, usa o seguinte formato:</span><span class="sxs-lookup"><span data-stu-id="44a32-351">The addition of a complex number, a + bi, and a second complex number, c + di, takes the following form:</span></span>  
  
 <span data-ttu-id="44a32-352">(a + c) + (b + d),</span><span class="sxs-lookup"><span data-stu-id="44a32-352">(a + c) + (b + d)i</span></span>  
  
 <span data-ttu-id="44a32-353">Se a chamada de método resultados em um estouro no componente real ou imaginário, o valor desse componente é <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> ou <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="44a32-353">If the method call results in an overflow in either the real or imaginary component, the value of that component is either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="44a32-354">Linguagens que não dão suporte a operadores personalizados podem chamar o método <xref:System.Numerics.Complex.Add%2A> em vez disso.</span><span class="sxs-lookup"><span data-stu-id="44a32-354">Languages that do not support custom operators can call the <xref:System.Numerics.Complex.Add%2A> method instead.</span></span>  
  
 <span data-ttu-id="44a32-355">É o método equivalente para esse operador <xref:System.Numerics.Complex.Add%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="44a32-355">The equivalent method for this operator is <xref:System.Numerics.Complex.Add%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType></span></span>  
  
## Examples  
 <span data-ttu-id="44a32-356">O exemplo a seguir ilustra a adição com números complexos.</span><span class="sxs-lookup"><span data-stu-id="44a32-356">The following example illustrates addition with complex numbers.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Add#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.add/cs/add2.cs#2)]
 [!code-vb[System.Numerics.Complex.Add#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.add/vb/add2.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Add(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="op_Division">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator / (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Division(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Division(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator / (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator /(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member ( / ) : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="left / right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="44a32-357">O valor a ser dividido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-357">The value to be divided.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="44a32-358">O valor pelo qual dividir.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-358">The value to divide by.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="44a32-359">Divide um número complexo especificado por outro número complexo especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-359">Divides a specified complex number by another specified complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="44a32-360">O resultado da divisão de <paramref name="left" /> por <paramref name="right" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-360">The result of dividing <paramref name="left" /> by <paramref name="right" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="44a32-361">O <xref:System.Numerics.Complex.op_Division%2A> método define a operação de divisão de números complexos.</span><span class="sxs-lookup"><span data-stu-id="44a32-361">The <xref:System.Numerics.Complex.op_Division%2A> method defines the division operation for complex numbers.</span></span> <span data-ttu-id="44a32-362">Ele permite que o código seja o seguinte:</span><span class="sxs-lookup"><span data-stu-id="44a32-362">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Divide#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.divide/cs/divide2.cs#2)]
 [!code-vb[System.Numerics.Complex.Divide#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.divide/vb/divide2.vb#2)]  
  
 <span data-ttu-id="44a32-363">A divisão de um complexo de número, a + bi, e um segundo número complexo, c + injeção de dependência, usa o seguinte formato:</span><span class="sxs-lookup"><span data-stu-id="44a32-363">The division of a complex number, a + bi, and a second complex number, c + di, takes the following form:</span></span>  
  
 <span data-ttu-id="44a32-364">((AC + BD) / (c<sup>2</sup> + d<sup>2</sup>)) + ((bc-ad) / (c<sup>2</sup> + d<sup>2</sup>),</span><span class="sxs-lookup"><span data-stu-id="44a32-364">((ac + bd) / (c<sup>2</sup> + d<sup>2</sup>)) + ((bc - ad) / (c<sup>2</sup> + d<sup>2</sup>)i</span></span>  
  
 <span data-ttu-id="44a32-365">Se a divisão resulta em um estouro no componente real ou imaginário, o valor desse componente é <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> ou <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="44a32-365">If the division results in an overflow in either the real or imaginary component, the value of that component is either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="44a32-366">Idiomas que não dão suporte a operadores personalizados e sobrecarga de operador podem chamar o <xref:System.Numerics.Complex.Divide%2A> método em vez disso.</span><span class="sxs-lookup"><span data-stu-id="44a32-366">Languages that do not support custom operators and operator overloading can call the <xref:System.Numerics.Complex.Divide%2A> method instead.</span></span>  
  
 <span data-ttu-id="44a32-367">É o método equivalente para esse operador <xref:System.Numerics.Complex.Divide%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="44a32-367">The equivalent method for this operator is <xref:System.Numerics.Complex.Divide%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType></span></span>]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Divide(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Equality(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Complex, right As Complex) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Numerics.Complex * System.Numerics.Complex -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="44a32-368">O primeiro número complexo a ser comparado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-368">The first complex number to compare.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="44a32-369">O segundo número complexo a ser comparado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-369">The second complex number to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="44a32-370">Retorna um valor que indica se dois números complexos são iguais.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-370">Returns a value that indicates whether two complex numbers are equal.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="44a32-371">
            <see langword="true" /> se os parâmetros <paramref name="left" /> e <paramref name="right" /> tiverem o mesmo valor; caso contrário, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-371">
              <see langword="true" /> if the <paramref name="left" /> and <paramref name="right" /> parameters have the same value; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="44a32-372">O <xref:System.Numerics.Complex.op_Equality%2A> método define a operação do operador de igualdade para <xref:System.Numerics.Complex> valores.</span><span class="sxs-lookup"><span data-stu-id="44a32-372">The <xref:System.Numerics.Complex.op_Equality%2A> method defines the operation of the equality operator for <xref:System.Numerics.Complex> values.</span></span> <span data-ttu-id="44a32-373">Ele permite que o código seja o seguinte:</span><span class="sxs-lookup"><span data-stu-id="44a32-373">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Equals#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/eqoperator1.cs#9)]
 [!code-vb[System.Numerics.Complex.Equals#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/eqoperator1.vb#9)]  
  
 <span data-ttu-id="44a32-374">Linguagens que não dão suporte a operadores personalizados podem chamar o método <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> em vez disso.</span><span class="sxs-lookup"><span data-stu-id="44a32-374">Languages that do not support custom operators can call the <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> method instead.</span></span>  
  
 <span data-ttu-id="44a32-375">Dois números complexos são iguais se suas partes reais são iguais e suas partes imaginárias são iguais.</span><span class="sxs-lookup"><span data-stu-id="44a32-375">Two complex numbers are equal if their real parts are equal and their imaginary parts are equal.</span></span> <span data-ttu-id="44a32-376">O <xref:System.Numerics.Complex.op_Equality%2A> método é equivalente à expressão a seguir:</span><span class="sxs-lookup"><span data-stu-id="44a32-376">The <xref:System.Numerics.Complex.op_Equality%2A> method is equivalent to the following expression:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Equals#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/equals1.cs#3)]
 [!code-vb[System.Numerics.Complex.Equals#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/equals1.vb#3)]  
  
 <span data-ttu-id="44a32-377">Observe que, devido às diferenças na precisão, dois números complexos que são equivalentes, aparentemente, podem ser considerados desiguais.</span><span class="sxs-lookup"><span data-stu-id="44a32-377">Note that, because of differences in precision, two complex numbers that are apparently equivalent can be considered unequal.</span></span> <span data-ttu-id="44a32-378">Para obter mais informações e uma possível solução alternativa, consulte o <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> método.</span><span class="sxs-lookup"><span data-stu-id="44a32-378">For more information and a possible workaround, see the <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> method.</span></span>  
  
 <span data-ttu-id="44a32-379">É o método equivalente para esse operador <xref:System.Numerics.Complex.Equals%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="44a32-379">The equivalent method for this operator is <xref:System.Numerics.Complex.Equals%2A?displayProperty=nameWithType></span></span>]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Explicit">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="44a32-380">Define uma conversão explícita entre um objeto <see cref="T:System.Numerics.Complex" /> e outro tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-380">Defines an explicit conversion between a <see cref="T:System.Numerics.Complex" /> object and another type.</span>
          </span>
        </summary>
        <altmember cref="Overload:System.Numerics.Complex.op_Implicit" />
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Numerics.Complex (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Explicit(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Explicit(System.Decimal)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Decimal) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Numerics::Complex(System::Decimal value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : decimal -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="44a32-381">O valor a ser convertido em um número complexo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-381">The value to convert to a complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="44a32-382">Define uma conversão explícita de um valor <see cref="T:System.Decimal" /> para um número complexo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-382">Defines an explicit conversion of a <see cref="T:System.Decimal" /> value to a complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="44a32-383">Um número complexo que tem um componente real igual a <paramref name="value" /> e um componente imaginário igual a zero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-383">A complex number that has a real component equal to <paramref name="value" /> and an imaginary component equal to zero.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="44a32-384">Operadores de conversão explícita definem os tipos que podem ser convertidos em um <xref:System.Numerics.Complex> objeto.</span><span class="sxs-lookup"><span data-stu-id="44a32-384">Explicit conversion operators define types that can be converted to a <xref:System.Numerics.Complex> object.</span></span> <span data-ttu-id="44a32-385">Compiladores de linguagem não realizar essa conversão automaticamente porque ele pode envolver a perda de dados.</span><span class="sxs-lookup"><span data-stu-id="44a32-385">Language compilers do not perform this conversion automatically because it can involve data loss.</span></span> <span data-ttu-id="44a32-386">Em vez disso, eles realizam a conversão somente se um operador de conversão (em c#) ou uma função de conversão (como `CType` no Visual Basic) é usado.</span><span class="sxs-lookup"><span data-stu-id="44a32-386">Instead, they perform the conversion only if a casting operator (in C#) or a conversion function (such as `CType` in Visual Basic) is used.</span></span> <span data-ttu-id="44a32-387">Caso contrário, eles exibem um erro do compilador.</span><span class="sxs-lookup"><span data-stu-id="44a32-387">Otherwise, they display a compiler error.</span></span>

 <span data-ttu-id="44a32-388">A conversão de um <xref:System.Decimal> valor para a parte real de um número complexo pode resultar em perda de precisão, porque uma <xref:System.Double>, que é o tipo do número de complexo <xref:System.Numerics.Complex.Real%2A> propriedade, tem menos dígitos significativos que uma <xref:System.Decimal>.</span><span class="sxs-lookup"><span data-stu-id="44a32-388">The conversion of a <xref:System.Decimal> value to the real part of a complex number can result in a loss of precision because a <xref:System.Double>, which is the type of the complex number's <xref:System.Numerics.Complex.Real%2A> property, has fewer significant digits than a <xref:System.Decimal>.</span></span>



## Examples
 <span data-ttu-id="44a32-389">O exemplo a seguir ilustra a conversão explícita <xref:System.Decimal> valores <xref:System.Numerics.Complex> valores.</span><span class="sxs-lookup"><span data-stu-id="44a32-389">The following example illustrates the explicit conversion of <xref:System.Decimal> values to <xref:System.Numerics.Complex> values.</span></span>

 [!code-csharp[System.Numerics.Complex.Explicit#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.explicit/cs/explicit1.cs#1)]   
 [!code-vb[System.Numerics.Complex.Explicit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.explicit/vb/explicit1.vb#1)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Numerics.Complex (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Explicit(System.Numerics.BigInteger)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Numerics::Complex(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="44a32-390">O valor a ser convertido em um número complexo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-390">The value to convert to a complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="44a32-391">Define uma conversão explícita de um valor <see cref="T:System.Numerics.BigInteger" /> para um número complexo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-391">Defines an explicit conversion of a <see cref="T:System.Numerics.BigInteger" /> value to a complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="44a32-392">Um número complexo que tem um componente real igual a <paramref name="value" /> e um componente imaginário igual a zero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-392">A complex number that has a real component equal to <paramref name="value" /> and an imaginary component equal to zero.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="44a32-393">Operadores de conversão explícita definem os tipos que podem ser convertidos em um <xref:System.Numerics.Complex> objeto.</span><span class="sxs-lookup"><span data-stu-id="44a32-393">Explicit conversion operators define types that can be converted to a <xref:System.Numerics.Complex> object.</span></span> <span data-ttu-id="44a32-394">Compiladores de linguagem não realizar essa conversão automaticamente porque ele pode envolver a perda de dados.</span><span class="sxs-lookup"><span data-stu-id="44a32-394">Language compilers do not perform this conversion automatically because it can involve data loss.</span></span> <span data-ttu-id="44a32-395">Em vez disso, eles realizam a conversão somente se um operador de conversão (em c#) ou uma função de conversão (como `CType` no Visual Basic) é usado.</span><span class="sxs-lookup"><span data-stu-id="44a32-395">Instead, they perform the conversion only if a casting operator (in C#) or a conversion function (such as `CType` in Visual Basic) is used.</span></span> <span data-ttu-id="44a32-396">Caso contrário, eles exibem um erro do compilador.</span><span class="sxs-lookup"><span data-stu-id="44a32-396">Otherwise, they display a compiler error.</span></span>

 <span data-ttu-id="44a32-397">A conversão de um <xref:System.Numerics.BigInteger> valor para a parte real de um número complexo pode resultar em perda de precisão, porque uma <xref:System.Double>, que é o tipo do número de complexo <xref:System.Numerics.Complex.Real%2A> propriedade, tem menos dígitos significativos que uma <xref:System.Numerics.BigInteger>.</span><span class="sxs-lookup"><span data-stu-id="44a32-397">The conversion of a <xref:System.Numerics.BigInteger> value to the real part of a complex number can result in a loss of precision because a <xref:System.Double>, which is the type of the complex number's <xref:System.Numerics.Complex.Real%2A> property, has fewer significant digits than a <xref:System.Numerics.BigInteger>.</span></span>

 <span data-ttu-id="44a32-398">Se a conversão for bem-sucedida porque o <xref:System.Numerics.BigInteger> valor está fora do intervalo da <xref:System.Double> tipo, a operação não é lançado um <xref:System.OverflowException>.</span><span class="sxs-lookup"><span data-stu-id="44a32-398">If the conversion is unsuccessful because the <xref:System.Numerics.BigInteger> value is out of the range of the <xref:System.Double> type, the operation does not throw an <xref:System.OverflowException>.</span></span> <span data-ttu-id="44a32-399">Em vez disso, se `value` é menor que <xref:System.Double.MinValue>, o resultado é um número complexo que tem um <xref:System.Numerics.Complex.Real%2A> igual ao valor da propriedade <xref:System.Double.NegativeInfinity>.</span><span class="sxs-lookup"><span data-stu-id="44a32-399">Instead, if `value` is less than <xref:System.Double.MinValue>, the result is a complex number that has a <xref:System.Numerics.Complex.Real%2A> property value equal to <xref:System.Double.NegativeInfinity>.</span></span> <span data-ttu-id="44a32-400">Se `value` é maior que <xref:System.Double.MaxValue>, o resultado é um número complexo que tem um <xref:System.Numerics.Complex.Real%2A> igual ao valor da propriedade <xref:System.Double.PositiveInfinity>.</span><span class="sxs-lookup"><span data-stu-id="44a32-400">If `value` is greater than <xref:System.Double.MaxValue>, the result is a complex number that has a <xref:System.Numerics.Complex.Real%2A> property value equal to <xref:System.Double.PositiveInfinity>.</span></span>



## Examples
 <span data-ttu-id="44a32-401">O exemplo a seguir ilustra a conversão explícita <xref:System.Numerics.BigInteger> valores <xref:System.Numerics.Complex> valores.</span><span class="sxs-lookup"><span data-stu-id="44a32-401">The following example illustrates the explicit conversion of <xref:System.Numerics.BigInteger> values to <xref:System.Numerics.Complex> values.</span></span>

 [!code-csharp[System.Numerics.Complex.Explicit#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.explicit/cs/explicit1.cs#2)]   
 [!code-vb[System.Numerics.Complex.Explicit#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.explicit/vb/explicit1.vb#2)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Implicit">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="44a32-402">Define uma conversão implícita entre um objeto <see cref="T:System.Numerics.Complex" /> e outro tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-402">Defines an implicit conversion between a <see cref="T:System.Numerics.Complex" /> object and another type.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.Byte)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Byte) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(System::Byte value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : byte -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="44a32-403">O valor a ser convertido em um número complexo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-403">The value to convert to a complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="44a32-404">Define uma conversão implícita de um byte sem sinal em um número complexo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-404">Defines an implicit conversion of an unsigned byte to a complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="44a32-405">Um objeto que contém o valor do parâmetro <paramref name="value" /> como sua parte real e zero como sua parte imaginária.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-405">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="44a32-406">As sobrecargas do <xref:System.Numerics.Complex.op_Implicit%2A> operador definir os tipos do qual um compilador pode converter automaticamente um <xref:System.Numerics.Complex> objeto sem um operador de conversão explícita (em c#) ou uma chamada para uma função de conversão (no Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="44a32-406">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="44a32-407">Elas são conversões de ampliação que não envolvem perda de dados e não geram um <xref:System.OverflowException>.</span><span class="sxs-lookup"><span data-stu-id="44a32-407">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="44a32-408">Essa sobrecarga permite que o compilador trate as conversões de um <xref:System.Byte> valor em um número complexo, como mostra o exemplo a seguir.</span><span class="sxs-lookup"><span data-stu-id="44a32-408">This overload lets the compiler handle conversions from a <xref:System.Byte> value to a complex number, as the following example shows.</span></span> <span data-ttu-id="44a32-409">Observe que o resultado da conversão é um número complexo cuja parte real é igual ao <xref:System.Byte> valor e cuja parte imaginária é igual a zero.</span><span class="sxs-lookup"><span data-stu-id="44a32-409">Note that the result of the conversion is a complex number whose real part is equal to the <xref:System.Byte> value and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#1)]   
 [!code-vb[System.Numerics.Complex.Implicit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#1)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.Double)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Double) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(double value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : double -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="44a32-410">O valor a ser convertido em um número complexo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-410">The value to convert to a complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="44a32-411">Define uma conversão explícita de um número de ponto flutuante de precisão dupla como um número complexo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-411">Defines an implicit conversion of a double-precision floating-point number to a complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="44a32-412">Um objeto que contém o valor do parâmetro <paramref name="value" /> como sua parte real e zero como sua parte imaginária.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-412">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="44a32-413">As sobrecargas do <xref:System.Numerics.Complex.op_Implicit%2A> operador definir os tipos do qual um compilador pode converter automaticamente um <xref:System.Numerics.Complex> objeto sem um operador de conversão explícita (em c#) ou uma chamada para uma função de conversão (no Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="44a32-413">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="44a32-414">Elas são conversões de ampliação que não envolvem perda de dados e não geram um <xref:System.OverflowException>.</span><span class="sxs-lookup"><span data-stu-id="44a32-414">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="44a32-415">Essa sobrecarga permite que o compilador trate as conversões de um <xref:System.Double> valor em um número complexo, como mostra o exemplo a seguir.</span><span class="sxs-lookup"><span data-stu-id="44a32-415">This overload lets the compiler handle conversions from a <xref:System.Double> value to a complex number, as the following example shows.</span></span> <span data-ttu-id="44a32-416">Observe que o resultado da conversão é um número complexo cuja parte real é igual ao <xref:System.Double> valor e cuja parte imaginária é igual a zero.</span><span class="sxs-lookup"><span data-stu-id="44a32-416">Note that the result of the conversion is a complex number whose real part is equal to the <xref:System.Double> value and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#2)]   
 [!code-vb[System.Numerics.Complex.Implicit#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#2)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.Int16)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Short) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(short value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : int16 -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="44a32-417">O valor a ser convertido em um número complexo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-417">The value to convert to a complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="44a32-418">Define uma conversão implícita de um inteiro com sinal de 16 bits em um número complexo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-418">Defines an implicit conversion of a 16-bit signed integer to a complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="44a32-419">Um objeto que contém o valor do parâmetro <paramref name="value" /> como sua parte real e zero como sua parte imaginária.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-419">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="44a32-420">As sobrecargas do <xref:System.Numerics.Complex.op_Implicit%2A> operador definir os tipos do qual um compilador pode converter automaticamente um <xref:System.Numerics.Complex> objeto sem um operador de conversão explícita (em c#) ou uma chamada para uma função de conversão (no Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="44a32-420">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="44a32-421">Elas são conversões de ampliação que não envolvem perda de dados e não geram um <xref:System.OverflowException>.</span><span class="sxs-lookup"><span data-stu-id="44a32-421">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="44a32-422">Essa sobrecarga permite que o compilador trate conversões de um inteiro com sinal de 16 bits em um número complexo, como mostra o exemplo a seguir.</span><span class="sxs-lookup"><span data-stu-id="44a32-422">This overload lets the compiler handle conversions from a signed 16-bit integer to a complex number, as the following example shows.</span></span> <span data-ttu-id="44a32-423">Observe que o resultado da conversão é um número complexo cuja parte real é igual para o inteiro com sinal de 16 bits e cuja parte imaginária é igual a zero.</span><span class="sxs-lookup"><span data-stu-id="44a32-423">Note that the result of the conversion is a complex number whose real part is equal to the signed 16-bit integer and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#3)]   
 [!code-vb[System.Numerics.Complex.Implicit#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#3)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.Int32)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Integer) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(int value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : int -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="44a32-424">O valor a ser convertido em um número complexo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-424">The value to convert to a complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="44a32-425">Define uma conversão implícita de um inteiro com sinal de 32 bits em um número complexo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-425">Defines an implicit conversion of a 32-bit signed integer to a complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="44a32-426">Um objeto que contém o valor do parâmetro <paramref name="value" /> como sua parte real e zero como sua parte imaginária.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-426">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="44a32-427">As sobrecargas do <xref:System.Numerics.Complex.op_Implicit%2A> operador definir os tipos do qual um compilador pode converter automaticamente um <xref:System.Numerics.Complex> objeto sem um operador de conversão explícita (em c#) ou uma chamada para uma função de conversão (no Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="44a32-427">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="44a32-428">Elas são conversões de ampliação que não envolvem perda de dados e não geram um <xref:System.OverflowException>.</span><span class="sxs-lookup"><span data-stu-id="44a32-428">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="44a32-429">Essa sobrecarga permite que o compilador trate conversões de um inteiro com sinal de 32 bits em um número complexo, como mostra o exemplo a seguir.</span><span class="sxs-lookup"><span data-stu-id="44a32-429">This overload lets the compiler handle conversions from a signed 32-bit integer to a complex number, as the following example shows.</span></span> <span data-ttu-id="44a32-430">Observe que o resultado da conversão é um número complexo cuja parte real é igual para o inteiro com sinal de 32 bits e cuja parte imaginária é igual a zero.</span><span class="sxs-lookup"><span data-stu-id="44a32-430">Note that the result of the conversion is a complex number whose real part is equal to the signed 32-bit integer and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#4)]   
 [!code-vb[System.Numerics.Complex.Implicit#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#4)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.Int64)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Long) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(long value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : int64 -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="44a32-431">O valor a ser convertido em um número complexo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-431">The value to convert to a complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="44a32-432">Define uma conversão implícita de um inteiro com sinal de 64 bits em um número complexo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-432">Defines an implicit conversion of a 64-bit signed integer to a complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="44a32-433">Um objeto que contém o valor do parâmetro <paramref name="value" /> como sua parte real e zero como sua parte imaginária.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-433">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="44a32-434">As sobrecargas do <xref:System.Numerics.Complex.op_Implicit%2A> operador definir os tipos do qual um compilador pode converter automaticamente um <xref:System.Numerics.Complex> objeto sem um operador de conversão explícita (em c#) ou uma chamada para uma função de conversão (no Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="44a32-434">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="44a32-435">Elas são conversões de ampliação que não envolvem perda de dados e não geram um <xref:System.OverflowException>.</span><span class="sxs-lookup"><span data-stu-id="44a32-435">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="44a32-436">Essa sobrecarga permite que o compilador trate conversões de um inteiro com sinal de 64 bits em um número complexo, como mostra o exemplo a seguir.</span><span class="sxs-lookup"><span data-stu-id="44a32-436">This overload lets the compiler handle conversions from a signed 64-bit integer to a complex number, as the following example shows.</span></span> <span data-ttu-id="44a32-437">Observe que o resultado da conversão é um número complexo cuja parte real é igual para o inteiro com sinal de 64 bits e cuja parte imaginária é igual a zero.</span><span class="sxs-lookup"><span data-stu-id="44a32-437">Note that the result of the conversion is a complex number whose real part is equal to the signed 64-bit integer and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#5)]   
 [!code-vb[System.Numerics.Complex.Implicit#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#5)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.SByte)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As SByte) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(System::SByte value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : sbyte -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="44a32-438">O valor a ser convertido em um número complexo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-438">The value to convert to a complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="44a32-439">Define uma conversão implícita de um byte com sinal em um número complexo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-439">Defines an implicit conversion of a signed byte to a complex number.</span>
          </span>
          <span data-ttu-id="44a32-440">Esta API não compatível com CLS.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-440">This API is not CLS-compliant.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="44a32-441">Um objeto que contém o valor do parâmetro <paramref name="value" /> como sua parte real e zero como sua parte imaginária.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-441">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="44a32-442">As sobrecargas do <xref:System.Numerics.Complex.op_Implicit%2A> operador definir os tipos do qual um compilador pode converter automaticamente um <xref:System.Numerics.Complex> objeto sem um operador de conversão explícita (em c#) ou uma chamada para uma função de conversão (no Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="44a32-442">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="44a32-443">Elas são conversões de ampliação que não envolvem perda de dados e não geram um <xref:System.OverflowException>.</span><span class="sxs-lookup"><span data-stu-id="44a32-443">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="44a32-444">Essa sobrecarga permite que o compilador trate conversões de um byte com sinal para um número complexo, como mostra o exemplo a seguir.</span><span class="sxs-lookup"><span data-stu-id="44a32-444">This overload lets the compiler handle conversions from a signed byte to a complex number, as the following example shows.</span></span> <span data-ttu-id="44a32-445">Observe que o resultado da conversão é um número complexo cuja parte real é igual para o byte com sinal e cuja parte imaginária é igual a zero.</span><span class="sxs-lookup"><span data-stu-id="44a32-445">Note that the result of the conversion is a complex number whose real part is equal to the signed byte and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#6)]   
 [!code-vb[System.Numerics.Complex.Implicit#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#6)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.Single)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Single) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(float value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : single -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="44a32-446">O valor a ser convertido em um número complexo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-446">The value to convert to a complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="44a32-447">Define uma conversão explícita de um número de ponto flutuante de precisão simples como um número complexo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-447">Defines an implicit conversion of a single-precision floating-point number to a complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="44a32-448">Um objeto que contém o valor do parâmetro <paramref name="value" /> como sua parte real e zero como sua parte imaginária.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-448">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="44a32-449">As sobrecargas do <xref:System.Numerics.Complex.op_Implicit%2A> operador definir os tipos do qual um compilador pode converter automaticamente um <xref:System.Numerics.Complex> objeto sem um operador de conversão explícita (em c#) ou uma chamada para uma função de conversão (no Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="44a32-449">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="44a32-450">Elas são conversões de ampliação que não envolvem perda de dados e não geram um <xref:System.OverflowException>.</span><span class="sxs-lookup"><span data-stu-id="44a32-450">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="44a32-451">Essa sobrecarga permite que o compilador trate as conversões de um <xref:System.Single> valor em um número complexo, como mostra o exemplo a seguir.</span><span class="sxs-lookup"><span data-stu-id="44a32-451">This overload lets the compiler handle conversions from a <xref:System.Single> value to a complex number, as the following example shows.</span></span> <span data-ttu-id="44a32-452">Observe que o resultado da conversão é um número complexo cuja parte real é igual ao <xref:System.Single> valor e cuja parte imaginária é igual a zero.</span><span class="sxs-lookup"><span data-stu-id="44a32-452">Note that the result of the conversion is a complex number whose real part is equal to the <xref:System.Single> value and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#7)]   
 [!code-vb[System.Numerics.Complex.Implicit#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#7)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.UInt16)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As UShort) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(System::UInt16 value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : uint16 -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="44a32-453">O valor a ser convertido em um número complexo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-453">The value to convert to a complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="44a32-454">Define uma conversão implícita de um inteiro sem sinal de 16 bits em um número complexo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-454">Defines an implicit conversion of a 16-bit unsigned integer to a complex number.</span>
          </span>
          <span data-ttu-id="44a32-455">Esta API não compatível com CLS.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-455">This API is not CLS-compliant.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="44a32-456">Um objeto que contém o valor do parâmetro <paramref name="value" /> como sua parte real e zero como sua parte imaginária.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-456">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="44a32-457">As sobrecargas do <xref:System.Numerics.Complex.op_Implicit%2A> operador definir os tipos do qual um compilador pode converter automaticamente um <xref:System.Numerics.Complex> objeto sem um operador de conversão explícita (em c#) ou uma chamada para uma função de conversão (no Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="44a32-457">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="44a32-458">Elas são conversões de ampliação que não envolvem perda de dados e não geram um <xref:System.OverflowException>.</span><span class="sxs-lookup"><span data-stu-id="44a32-458">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="44a32-459">Essa sobrecarga permite que o compilador trate conversões de um inteiro sem sinal de 16 bits em um número complexo, como mostra o exemplo a seguir.</span><span class="sxs-lookup"><span data-stu-id="44a32-459">This overload lets the compiler handle conversions from an unsigned 16-bit integer to a complex number, as the following example shows.</span></span> <span data-ttu-id="44a32-460">Observe que o resultado da conversão é um número complexo cuja parte real é igual para o inteiro sem sinal de 16 bits e cuja parte imaginária é igual a zero.</span><span class="sxs-lookup"><span data-stu-id="44a32-460">Note that the result of the conversion is a complex number whose real part is equal to the unsigned 16-bit integer and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#8)]   
 [!code-vb[System.Numerics.Complex.Implicit#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#8)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.UInt32)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As UInteger) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(System::UInt32 value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : uint32 -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="44a32-461">O valor a ser convertido em um número complexo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-461">The value to convert to a complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="44a32-462">Define uma conversão implícita de um inteiro sem sinal de 32 bits em um número complexo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-462">Defines an implicit conversion of a 32-bit unsigned integer to a complex number.</span>
          </span>
          <span data-ttu-id="44a32-463">Esta API não compatível com CLS.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-463">This API is not CLS-compliant.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="44a32-464">Um objeto que contém o valor do parâmetro <paramref name="value" /> como sua parte real e zero como sua parte imaginária.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-464">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="44a32-465">As sobrecargas do <xref:System.Numerics.Complex.op_Implicit%2A> operador definir os tipos do qual um compilador pode converter automaticamente um <xref:System.Numerics.Complex> objeto sem um operador de conversão explícita (em c#) ou uma chamada para uma função de conversão (no Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="44a32-465">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="44a32-466">Elas são conversões de ampliação que não envolvem perda de dados e não geram um <xref:System.OverflowException>.</span><span class="sxs-lookup"><span data-stu-id="44a32-466">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="44a32-467">Essa sobrecarga permite que o compilador trate conversões de um inteiro sem sinal de 32 bits em um número complexo, como mostra o exemplo a seguir.</span><span class="sxs-lookup"><span data-stu-id="44a32-467">This overload lets the compiler handle conversions from an unsigned 32-bit integer to a complex number, as the following example shows.</span></span> <span data-ttu-id="44a32-468">Observe que o resultado da conversão é um número complexo cuja parte real é igual para o inteiro sem sinal de 32 bits e cuja parte imaginária é igual a zero.</span><span class="sxs-lookup"><span data-stu-id="44a32-468">Note that the result of the conversion is a complex number whose real part is equal to the unsigned 32-bit integer and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#9)]   
 [!code-vb[System.Numerics.Complex.Implicit#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#9)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.UInt64)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As ULong) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(System::UInt64 value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : uint64 -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="44a32-469">O valor a ser convertido em um número complexo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-469">The value to convert to a complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="44a32-470">Define uma conversão implícita de um inteiro sem sinal de 64 bits em um número complexo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-470">Defines an implicit conversion of a 64-bit unsigned integer to a complex number.</span>
          </span>
          <span data-ttu-id="44a32-471">Esta API não compatível com CLS.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-471">This API is not CLS-compliant.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="44a32-472">Um objeto que contém o valor do parâmetro <paramref name="value" /> como sua parte real e zero como sua parte imaginária.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-472">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="44a32-473">As sobrecargas do <xref:System.Numerics.Complex.op_Implicit%2A> operador definir os tipos do qual um compilador pode converter automaticamente um <xref:System.Numerics.Complex> objeto sem um operador de conversão explícita (em c#) ou uma chamada para uma função de conversão (no Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="44a32-473">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="44a32-474">Elas são conversões de ampliação que não envolvem perda de dados e não geram um <xref:System.OverflowException>.</span><span class="sxs-lookup"><span data-stu-id="44a32-474">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="44a32-475">Essa sobrecarga permite que o compilador trate conversões de um inteiro sem sinal de 64 bits em um número complexo, como mostra o exemplo a seguir.</span><span class="sxs-lookup"><span data-stu-id="44a32-475">This overload lets the compiler handle conversions from an unsigned 64-bit integer to a complex number, as the following example shows.</span></span> <span data-ttu-id="44a32-476">Observe que o resultado da conversão é um número complexo cuja parte real é igual para o inteiro sem sinal de 64 bits e cuja parte imaginária é igual a zero.</span><span class="sxs-lookup"><span data-stu-id="44a32-476">Note that the result of the conversion is a complex number whose real part is equal to the unsigned 64-bit integer and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#10)]   
 [!code-vb[System.Numerics.Complex.Implicit#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#10)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Inequality(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Complex, right As Complex) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Numerics.Complex * System.Numerics.Complex -&gt; bool" Usage="System.Numerics.Complex.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="44a32-477">O primeiro valor a ser comparado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-477">The first value to compare.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="44a32-478">O segundo valor a ser comparado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-478">The second value to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="44a32-479">Retorna um valor que indica se dois números complexos não são iguais.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-479">Returns a value that indicates whether two complex numbers are not equal.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="44a32-480">
            <see langword="true" /> se <paramref name="left" /> e <paramref name="right" /> não forem iguais; caso contrário, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-480">
              <see langword="true" /> if <paramref name="left" /> and <paramref name="right" /> are not equal; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="44a32-481">O <xref:System.Numerics.Complex.op_Equality%2A> método define a operação do operador de desigualdade para números complexos.</span><span class="sxs-lookup"><span data-stu-id="44a32-481">The <xref:System.Numerics.Complex.op_Equality%2A> method defines the operation of the inequality operator for complex numbers.</span></span> <span data-ttu-id="44a32-482">Ele permite que o código seja o seguinte:</span><span class="sxs-lookup"><span data-stu-id="44a32-482">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Inequality#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.inequality/cs/inequality1.cs#1)]
 [!code-vb[System.Numerics.Complex.Inequality#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.inequality/vb/inequality1.vb#1)]  
  
 <span data-ttu-id="44a32-483">Idiomas que não dão suporte a operadores personalizados podem testar quanto à desigualdade chamando o <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> método e Revertendo seu valor.</span><span class="sxs-lookup"><span data-stu-id="44a32-483">Languages that do not support custom operators can test for inequality by calling the <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> method and reversing its value.</span></span>  
  
 <span data-ttu-id="44a32-484">Observe que, devido às diferenças na precisão, dois números complexos que são equivalentes, aparentemente, podem ser considerados desiguais.</span><span class="sxs-lookup"><span data-stu-id="44a32-484">Note that, because of differences in precision, two complex numbers that are apparently equivalent can be considered unequal.</span></span> <span data-ttu-id="44a32-485">Uma possível solução alternativa é implementar um método de comparação retorna `true` somente se a diferença entre as duas partes reais e imaginárias de números complexos excede determinado limite (como. 01% do valor do componente real ou imaginário do um dos números complexos).</span><span class="sxs-lookup"><span data-stu-id="44a32-485">One possible workaround is to implement a comparison method that returns `true` only if the difference between the two real and imaginary parts of the complex numbers exceeds a certain threshold (such as .01% of the value of the real or imaginary component of one of the complex numbers).</span></span> <span data-ttu-id="44a32-486">Para obter mais informações, consulte o método <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29>.</span><span class="sxs-lookup"><span data-stu-id="44a32-486">For more information, see the <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> method.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Equality(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="op_Multiply">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator * (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Multiply(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Multiply(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator * (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator *(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member ( * ) : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="left * right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="44a32-487">O primeiro valor a ser multiplicado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-487">The first value to multiply.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="44a32-488">O segundo valor a ser multiplicado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-488">The second value to multiply.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="44a32-489">Multiplica dois números complexos especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-489">Multiplies two specified complex numbers.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="44a32-490">O produto de <paramref name="left" /> e <paramref name="right" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-490">The product of <paramref name="left" /> and <paramref name="right" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="44a32-491">O <xref:System.Numerics.Complex.op_Multiply%2A> método define a operação do operador de multiplicação para números complexos.</span><span class="sxs-lookup"><span data-stu-id="44a32-491">The <xref:System.Numerics.Complex.op_Multiply%2A> method defines the operation of the multiplication operator for complex numbers.</span></span> <span data-ttu-id="44a32-492">Ele permite que o código seja o seguinte:</span><span class="sxs-lookup"><span data-stu-id="44a32-492">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Multiply#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.multiply/cs/multiply2.cs#2)]
 [!code-vb[System.Numerics.Complex.Multiply#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.multiply/vb/multiply2.vb#2)]  
  
 <span data-ttu-id="44a32-493">A multiplicação de um complexo de número, a + bi, e um segundo número complexo, c + injeção de dependência, usa o seguinte formato:</span><span class="sxs-lookup"><span data-stu-id="44a32-493">The multiplication of a complex number, a + bi, and a second complex number, c + di, takes the following form:</span></span>  
  
 <span data-ttu-id="44a32-494">(ac – bd) + (ad + bc),</span><span class="sxs-lookup"><span data-stu-id="44a32-494">(ac - bd) + (ad + bc)i</span></span>  
  
 <span data-ttu-id="44a32-495">Se a multiplicação resulta em um estouro no componente real ou imaginário, o valor desse componente é <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> ou <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="44a32-495">If the multiplication results in an overflow in either the real or imaginary component, the value of that component is either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="44a32-496">Linguagens que não dão suporte a operadores personalizados podem chamar o método <xref:System.Numerics.Complex.Multiply%2A> em vez disso.</span><span class="sxs-lookup"><span data-stu-id="44a32-496">Languages that do not support custom operators can call the <xref:System.Numerics.Complex.Multiply%2A> method instead.</span></span>  
  
 <span data-ttu-id="44a32-497">É o método equivalente para esse operador <xref:System.Numerics.Complex.Multiply%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="44a32-497">The equivalent method for this operator is <xref:System.Numerics.Complex.Multiply%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType></span></span>]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Multiply(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="op_Subtraction">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator - (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Subtraction(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Subtraction(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator - (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator -(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member ( - ) : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="left - right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="44a32-498">O valor do qual um valor será subtraído (o minuendo).</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-498">The value to subtract from (the minuend).</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="44a32-499">O valor a ser subtraído (o subtraendo).</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-499">The value to subtract (the subtrahend).</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="44a32-500">Subtrai um número complexo de outro número complexo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-500">Subtracts a complex number from another complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="44a32-501">O resultado da subtração de <paramref name="right" /> de <paramref name="left" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-501">The result of subtracting <paramref name="right" /> from <paramref name="left" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="44a32-502">O <xref:System.Numerics.Complex.op_Subtraction%2A> método define a operação do operador de subtração para números complexos.</span><span class="sxs-lookup"><span data-stu-id="44a32-502">The <xref:System.Numerics.Complex.op_Subtraction%2A> method defines the operation of the subtraction operator for complex numbers.</span></span> <span data-ttu-id="44a32-503">Ele permite que o código seja o seguinte:</span><span class="sxs-lookup"><span data-stu-id="44a32-503">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Subtract#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.subtract/cs/subtract2.cs#2)]
 [!code-vb[System.Numerics.Complex.Subtract#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.subtract/vb/subtract2.vb#2)]  
  
 <span data-ttu-id="44a32-504">Se a chamada de método resultados em um estouro no componente real ou imaginário, o valor desse componente é <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> ou <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="44a32-504">If the method call results in an overflow in either the real or imaginary component, the value of that component is either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="44a32-505">A subtração de um número complexo, c + injeção de dependência de outro número complexo, um + bi, usa o seguinte formato:</span><span class="sxs-lookup"><span data-stu-id="44a32-505">The subtraction of a complex number, c + di, from another complex number, a + bi, takes the following form:</span></span>  
  
 <span data-ttu-id="44a32-506">(a - c) + (b - 1!d),</span><span class="sxs-lookup"><span data-stu-id="44a32-506">(a - c) + (b - d)i</span></span>  
  
 <span data-ttu-id="44a32-507">Linguagens que não dão suporte a operadores personalizados podem chamar o método <xref:System.Numerics.Complex.Subtract%2A> em vez disso.</span><span class="sxs-lookup"><span data-stu-id="44a32-507">Languages that do not support custom operators can call the <xref:System.Numerics.Complex.Subtract%2A> method instead.</span></span>  
  
 <span data-ttu-id="44a32-508">É o método equivalente para esse operador <xref:System.Numerics.Complex.Subtract%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="44a32-508">The equivalent method for this operator is <xref:System.Numerics.Complex.Subtract%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType></span></span>]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Subtract(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="op_UnaryNegation">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator - (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_UnaryNegation(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_UnaryNegation(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator - (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator -(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member ( ~- ) : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="- value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="44a32-509">O valor a ser negado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-509">The value to negate.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="44a32-510">Retorna o inverso aditivo de um número complexo especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-510">Returns the additive inverse of a specified complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="44a32-511">O resultado dos componentes <see cref="P:System.Numerics.Complex.Real" /> e <see cref="P:System.Numerics.Complex.Imaginary" /> do parâmetro <paramref name="value" /> multiplicado por -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-511">The result of the <see cref="P:System.Numerics.Complex.Real" /> and <see cref="P:System.Numerics.Complex.Imaginary" /> components of the <paramref name="value" /> parameter multiplied by -1.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="44a32-512">O <xref:System.Numerics.Complex.op_UnaryNegation%2A> método define a operação do operador unário de negação (inverso de aditivo) para números complexos.</span><span class="sxs-lookup"><span data-stu-id="44a32-512">The <xref:System.Numerics.Complex.op_UnaryNegation%2A> method defines the operation of the unary negation (additive inverse) operator for complex numbers.</span></span> <span data-ttu-id="44a32-513">Ele permite que o código seja o seguinte:</span><span class="sxs-lookup"><span data-stu-id="44a32-513">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Negate#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.negate/cs/negate2.cs#2)]
 [!code-vb[System.Numerics.Complex.Negate#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.negate/vb/negate2.vb#2)]  
  
 <span data-ttu-id="44a32-514">O número complexo resultante produz um valor de <xref:System.Numerics.Complex> 0 (zero) quando ele é adicionado para o número complexo original.</span><span class="sxs-lookup"><span data-stu-id="44a32-514">The resulting complex number produces a value of <xref:System.Numerics.Complex> 0 (zero) when it is added to the original complex number.</span></span> <span data-ttu-id="44a32-515">Linguagens que não dão suporte a operadores personalizados podem chamar o método <xref:System.Numerics.Complex.Negate%2A> em vez disso.</span><span class="sxs-lookup"><span data-stu-id="44a32-515">Languages that do not support custom operators can call the <xref:System.Numerics.Complex.Negate%2A> method instead.</span></span>  
  
 <span data-ttu-id="44a32-516">É o método equivalente para esse operador <xref:System.Numerics.Complex.Negate%28System.Numerics.Complex%29?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="44a32-516">The equivalent method for this operator is <xref:System.Numerics.Complex.Negate%28System.Numerics.Complex%29?displayProperty=nameWithType></span></span>]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Negate(System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Phase">
      <MemberSignature Language="C#" Value="public double Phase { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Phase" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Complex.Phase" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Phase As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Phase { double get(); };" />
      <MemberSignature Language="F#" Value="member this.Phase : double" Usage="System.Numerics.Complex.Phase" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="44a32-517">Obtém a fase de um número complexo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-517">Gets the phase of a complex number.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="44a32-518">A fase de um número complexo, em radianos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-518">The phase of a complex number, in radians.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="44a32-519">Para um número complexo um + bi, a fase é computada como <xref:System.Math.Atan2%2A?displayProperty=nameWithType>(b, um).</span><span class="sxs-lookup"><span data-stu-id="44a32-519">For a complex number a + bi, the phase is computed as <xref:System.Math.Atan2%2A?displayProperty=nameWithType>(b, a).</span></span>  
  
 <span data-ttu-id="44a32-520">Você pode identificar um número complexo por suas coordenadas cartesianas no plano complexo ou por suas coordenadas polares.</span><span class="sxs-lookup"><span data-stu-id="44a32-520">You can identify a complex number by its Cartesian coordinates on the complex plane or by its polar coordinates.</span></span> <span data-ttu-id="44a32-521">A fase (argumentos) de um número complexo é o ângulo e o eixo real de uma linha desenhada do ponto de origem (a interseção do eixo x e y) para o ponto representado por um número complexo.</span><span class="sxs-lookup"><span data-stu-id="44a32-521">The phase (argument) of a complex number is the angle to the real axis of a line drawn from the point of origin (the intersection of the x-axis and the y-axis) to the point represented by the complex number.</span></span> <span data-ttu-id="44a32-522">A magnitude (representado pelo <xref:System.Numerics.Complex.Magnitude%2A> propriedade) é a distância entre o ponto de origem e o ponto que é representado por um número complexo.</span><span class="sxs-lookup"><span data-stu-id="44a32-522">The magnitude (represented by the <xref:System.Numerics.Complex.Magnitude%2A> property) is the distance from the point of origin to the point that is represented by the complex number.</span></span>  
  
 <span data-ttu-id="44a32-523">Você pode criar uma instância de um número complexo com base em suas coordenadas polares, em vez de suas coordenadas cartesianas chamando o <xref:System.Numerics.Complex.FromPolarCoordinates%2A> método.</span><span class="sxs-lookup"><span data-stu-id="44a32-523">You can instantiate a complex number based on its polar coordinates instead of its Cartesian coordinates by calling the <xref:System.Numerics.Complex.FromPolarCoordinates%2A> method.</span></span>  
  
 <span data-ttu-id="44a32-524">Para converter a fase de radianos em graus, multiplique-o por 180 /<xref:System.Math.PI?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="44a32-524">To convert the phase from radians to degrees, multiply it by 180/<xref:System.Math.PI?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="44a32-525">O exemplo a seguir usa o <xref:System.Numerics.Complex.FromPolarCoordinates%2A> método para criar uma instância de um número complexo com base em suas coordenadas polares e, em seguida, exibe o valor do seu <xref:System.Numerics.Complex.Magnitude%2A> e <xref:System.Numerics.Complex.Phase%2A> propriedades.</span><span class="sxs-lookup"><span data-stu-id="44a32-525">The following example uses the <xref:System.Numerics.Complex.FromPolarCoordinates%2A> method to instantiate a complex number based on its polar coordinates, and then displays the value of its <xref:System.Numerics.Complex.Magnitude%2A> and <xref:System.Numerics.Complex.Phase%2A> properties.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Phase#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.phase/cs/phase1.cs#1)]
 [!code-vb[System.Numerics.Complex.Phase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.phase/vb/phase1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.Complex.Magnitude" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Pow">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="44a32-526">Retorna um número complexo especificado elevado a uma potência especificada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-526">Returns a specified complex number raised to a specified power.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Pow">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Pow (System.Numerics.Complex value, double power);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Pow(valuetype System.Numerics.Complex value, float64 power) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Pow(System.Numerics.Complex,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Pow (value As Complex, power As Double) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Pow(System::Numerics::Complex value, double power);" />
      <MemberSignature Language="F#" Value="static member Pow : System.Numerics.Complex * double -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Pow (value, power)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
        <Parameter Name="power" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="44a32-527">Um número complexo a ser elevado a uma potência.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-527">A complex number to be raised to a power.</span>
          </span>
        </param>
        <param name="power">
          <span data-ttu-id="44a32-528">Um número de ponto flutuante de precisão dupla que especifica uma potência.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-528">A double-precision floating-point number that specifies a power.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="44a32-529">Retorna um número complexo especificado elevado a uma potência especificada por um número de ponto flutuante de precisão dupla.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-529">Returns a specified complex number raised to a power specified by a double-precision floating-point number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="44a32-530">O número complexo <paramref name="value" /> elevado à potência <paramref name="power" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-530">The complex number <paramref name="value" /> raised to the power <paramref name="power" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="44a32-531">Se `value` for <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType>, o método retornará <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="44a32-531">If `value` is <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType>, the method returns <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType>.</span></span> <span data-ttu-id="44a32-532">Para outros valores, se `power` for 0, o método retornará <xref:System.Numerics.Complex.One?displayProperty=nameWithType>e se `power` for 1, ele retorna `value`.</span><span class="sxs-lookup"><span data-stu-id="44a32-532">For other values, if `power` is 0, the method returns <xref:System.Numerics.Complex.One?displayProperty=nameWithType>, and if `power` is 1, it returns `value`.</span></span>  
  
 <span data-ttu-id="44a32-533">Esse método corresponde à <xref:System.Math.Pow%2A?displayProperty=nameWithType> método para tipos numéricos primitivos.</span><span class="sxs-lookup"><span data-stu-id="44a32-533">This method corresponds to the <xref:System.Math.Pow%2A?displayProperty=nameWithType> method for primitive numeric types.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="44a32-534">O exemplo a seguir ilustra a exponenciação usando um número complexo e um expoente cuja valor varia de -1 a 10.</span><span class="sxs-lookup"><span data-stu-id="44a32-534">The following example illustrates exponentiation using a complex number and an exponent whose value ranges from -1 to 10.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Pow#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.pow/cs/pow1.cs#1)]
 [!code-vb[System.Numerics.Complex.Pow#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.pow/vb/pow1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Pow">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Pow (System.Numerics.Complex value, System.Numerics.Complex power);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Pow(valuetype System.Numerics.Complex value, valuetype System.Numerics.Complex power) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Pow(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Pow (value As Complex, power As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Pow(System::Numerics::Complex value, System::Numerics::Complex power);" />
      <MemberSignature Language="F#" Value="static member Pow : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Pow (value, power)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
        <Parameter Name="power" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="44a32-535">Um número complexo a ser elevado a uma potência.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-535">A complex number to be raised to a power.</span>
          </span>
        </param>
        <param name="power">
          <span data-ttu-id="44a32-536">Um número complexo que especifica uma potência.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-536">A complex number that specifies a power.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="44a32-537">Retorna um número complexo especificado elevado a uma potência especificada por um número complexo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-537">Returns a specified complex number raised to a power specified by a complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="44a32-538">O número complexo <paramref name="value" /> elevado à potência <paramref name="power" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-538">The complex number <paramref name="value" /> raised to the power <paramref name="power" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Real">
      <MemberSignature Language="C#" Value="public double Real { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Real" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Complex.Real" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Real As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Real { double get(); };" />
      <MemberSignature Language="F#" Value="member this.Real : double" Usage="System.Numerics.Complex.Real" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="44a32-539">Obtém o componente real do objeto <see cref="T:System.Numerics.Complex" /> atual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-539">Gets the real component of the current <see cref="T:System.Numerics.Complex" /> object.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="44a32-540">O componente real de um número complexo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-540">The real component of a complex number.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="44a32-541">Dado um número complexo a + bi, o <xref:System.Numerics.Complex.Real%2A> propriedade retorna o valor de um.</span><span class="sxs-lookup"><span data-stu-id="44a32-541">Given a complex number a + bi, the <xref:System.Numerics.Complex.Real%2A> property returns the value of a.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="44a32-542">O exemplo a seguir cria uma matriz de <xref:System.Numerics.Complex> objetos e exibe os componentes reais e imaginários de cada um no formulário a + bi.</span><span class="sxs-lookup"><span data-stu-id="44a32-542">The following example instantiates an array of <xref:System.Numerics.Complex> objects and displays the real and imaginary components of each in the form a + bi.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Real#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.real/cs/real1.cs#1)]
 [!code-vb[System.Numerics.Complex.Real#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.real/vb/real1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.Complex.Imaginary" />
      </Docs>
    </Member>
    <Member MemberName="Reciprocal">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Reciprocal (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Reciprocal(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Reciprocal(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Reciprocal (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Reciprocal(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Reciprocal : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Reciprocal value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="44a32-543">Um número complexo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-543">A complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="44a32-544">Retorna o inverso multiplicativo de um número complexo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-544">Returns the multiplicative inverse of a complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="44a32-545">O recíproco de <paramref name="value" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-545">The reciprocal of <paramref name="value" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="44a32-546">O inverso de multiplicação, de um número ou o recíproco *x* é um número *y* onde *x* multiplicado por *y* resulta em 1.</span><span class="sxs-lookup"><span data-stu-id="44a32-546">The reciprocal, or multiplicative inverse, of a number *x* is a number *y* where *x* multiplied by *y* yields 1.</span></span> <span data-ttu-id="44a32-547">O recíproco de um número complexo é o número complexo que produz <xref:System.Numerics.Complex.One?displayProperty=nameWithType> quando os dois números são multiplicados.</span><span class="sxs-lookup"><span data-stu-id="44a32-547">The reciprocal of a complex number is the complex number that produces <xref:System.Numerics.Complex.One?displayProperty=nameWithType> when the two numbers are multiplied.</span></span> <span data-ttu-id="44a32-548">Se um número complexo é representado por um + bi, sua recíproco é representado pela expressão uma / (um<sup>2</sup>+ b<sup>2</sup>) + b-/ (um<sup>2</sup> + b<sup>2</sup>).</span><span class="sxs-lookup"><span data-stu-id="44a32-548">If a complex number is represented by a +bi, its reciprocal is represented by the expression a/(a<sup>2</sup>+b<sup>2</sup>) + -b/(a<sup>2</sup> + b<sup>2</sup>).</span></span>  
  
 <span data-ttu-id="44a32-549">Se o valor será <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType>, o método retorna <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="44a32-549">If value is <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType>, the method returns <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType>.</span></span> <span data-ttu-id="44a32-550">Caso contrário, ele retorna o resultado da expressão <xref:System.Numerics.Complex.One?displayProperty=nameWithType> / `value`.</span><span class="sxs-lookup"><span data-stu-id="44a32-550">Otherwise, it returns the result of the expression <xref:System.Numerics.Complex.One?displayProperty=nameWithType>/`value`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="44a32-551">O exemplo a seguir usa o <xref:System.Numerics.Complex.Reciprocal%2A> método para calcular os recíprocos valores de vários números complexos.</span><span class="sxs-lookup"><span data-stu-id="44a32-551">The following example uses the <xref:System.Numerics.Complex.Reciprocal%2A> method to calculate the reciprocal values of several complex numbers.</span></span> <span data-ttu-id="44a32-552">Ele também demonstra que o resultado da multiplicação de um número complexo pelo seu recíproco é <xref:System.Numerics.Complex.One?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="44a32-552">It also demonstrates that the result of multiplying a complex number by its reciprocal is <xref:System.Numerics.Complex.One?displayProperty=nameWithType>.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Reciprocal#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.reciprocal/cs/reciprocal1.cs#1)]
 [!code-vb[System.Numerics.Complex.Reciprocal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.reciprocal/vb/reciprocal1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sin">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Sin (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Sin(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Sin(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sin (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Sin(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Sin : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Sin value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="44a32-553">Um número complexo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-553">A complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="44a32-554">Retorna o seno do número complexo especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-554">Returns the sine of the specified complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="44a32-555">O seno de <paramref name="value" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-555">The sine of <paramref name="value" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="44a32-556">O <xref:System.Numerics.Complex.Sin%2A> método para números complexos corresponde à <xref:System.Math.Sin%2A?displayProperty=nameWithType> método para números reais.</span><span class="sxs-lookup"><span data-stu-id="44a32-556">The <xref:System.Numerics.Complex.Sin%2A> method for complex numbers corresponds to the <xref:System.Math.Sin%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="44a32-557">O <xref:System.Numerics.Complex.Sin%2A> método usa a seguinte fórmula para calcular o seno do número complexo a + bi:</span><span class="sxs-lookup"><span data-stu-id="44a32-557">The <xref:System.Numerics.Complex.Sin%2A> method uses the following formula to calculate the sine of the complex number a + bi:</span></span>  
  
 <span data-ttu-id="44a32-558">(<xref:System.Math.Sin%2A>(a) * <xref:System.Math.Cosh%2A>(b), <xref:System.Math.Cos%2A>(a) * <xref:System.Math.Sinh%2A>(b))</span><span class="sxs-lookup"><span data-stu-id="44a32-558">(<xref:System.Math.Sin%2A>(a) * <xref:System.Math.Cosh%2A>(b), <xref:System.Math.Cos%2A>(a) * <xref:System.Math.Sinh%2A>(b))</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="44a32-559">O exemplo a seguir ilustra o <xref:System.Numerics.Complex.Sin%2A> método.</span><span class="sxs-lookup"><span data-stu-id="44a32-559">The following example illustrates the <xref:System.Numerics.Complex.Sin%2A> method.</span></span> <span data-ttu-id="44a32-560">Ele mostra que o valor retornado por passando o <xref:System.Numerics.Complex.Asin%2A> método para o <xref:System.Numerics.Complex.Sin%2A> método retorna o original <xref:System.Numerics.Complex> valor.</span><span class="sxs-lookup"><span data-stu-id="44a32-560">It shows that passing the value returned by the <xref:System.Numerics.Complex.Asin%2A> method to the <xref:System.Numerics.Complex.Sin%2A> method returns the original <xref:System.Numerics.Complex> value.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Asin#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.asin/cs/asin1.cs#1)]
 [!code-vb[System.Numerics.Complex.Asin#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.asin/vb/asin1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Asin(System.Double)" />
        <altmember cref="M:System.Numerics.Complex.Sin(System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Sinh">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Sinh (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Sinh(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Sinh(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sinh (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Sinh(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Sinh : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Sinh value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="44a32-561">Um número complexo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-561">A complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="44a32-562">Retorna o seno hiperbólico do número complexo especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-562">Returns the hyperbolic sine of the specified complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="44a32-563">O seno hiperbólico de <paramref name="value" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-563">The hyperbolic sine of <paramref name="value" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="44a32-564">O <xref:System.Numerics.Complex.Sinh%2A> método para números complexos corresponde à <xref:System.Math.Sinh%2A?displayProperty=nameWithType> método para números reais.</span><span class="sxs-lookup"><span data-stu-id="44a32-564">The <xref:System.Numerics.Complex.Sinh%2A> method for complex numbers corresponds to the <xref:System.Math.Sinh%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="44a32-565">O <xref:System.Numerics.Complex.Sinh%2A> método usa a seguinte fórmula para calcular o seno hiperbólico do número complexo a + bi:</span><span class="sxs-lookup"><span data-stu-id="44a32-565">The <xref:System.Numerics.Complex.Sinh%2A> method uses the following formula to calculate the hyperbolic sine of the complex number a + bi:</span></span>  
  
 <span data-ttu-id="44a32-566">(<xref:System.Math.Sinh%2A>(a) * <xref:System.Math.Cos%2A>(b), <xref:System.Math.Cosh%2A>(a) * <xref:System.Math.Sin%2A>(b))</span><span class="sxs-lookup"><span data-stu-id="44a32-566">(<xref:System.Math.Sinh%2A>(a) * <xref:System.Math.Cos%2A>(b), <xref:System.Math.Cosh%2A>(a) * <xref:System.Math.Sin%2A>(b))</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Sinh(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Sqrt">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Sqrt (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Sqrt(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Sqrt(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sqrt (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Sqrt(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Sqrt : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Sqrt value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="44a32-567">Um número complexo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-567">A complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="44a32-568">Retorna a raiz quadrada de um número complexo especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-568">Returns the square root of a specified complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="44a32-569">A raiz quadrada de <paramref name="value" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-569">The square root of <paramref name="value" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="44a32-570">A raiz quadrada do número complexo `value` é calculado usando a fórmula a seguir:</span><span class="sxs-lookup"><span data-stu-id="44a32-570">The square root of the complex number `value` is calculated by using the following formula:</span></span>  
  
 <span data-ttu-id="44a32-571"><xref:System.Numerics.Complex.FromPolarCoordinates%2A?displayProperty=nameWithType>(<xref:System.Math.Sqrt%2A?displayProperty=nameWithType>(`value`.<xref:System.Numerics.Complex.Magnitude%2A>), `value`.<xref:System.Numerics.Complex.Phase%2A>/2.0)</span><span class="sxs-lookup"><span data-stu-id="44a32-571"><xref:System.Numerics.Complex.FromPolarCoordinates%2A?displayProperty=nameWithType>(<xref:System.Math.Sqrt%2A?displayProperty=nameWithType>(`value`.<xref:System.Numerics.Complex.Magnitude%2A>), `value`.<xref:System.Numerics.Complex.Phase%2A>/2.0)</span></span>   
  
 <span data-ttu-id="44a32-572">O <xref:System.Numerics.Complex.Sqrt%2A> método para números complexos corresponde à <xref:System.Math.Sqrt%2A?displayProperty=nameWithType> método para números reais.</span><span class="sxs-lookup"><span data-stu-id="44a32-572">The <xref:System.Numerics.Complex.Sqrt%2A> method for complex numbers corresponds to the <xref:System.Math.Sqrt%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Subtract">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Subtract (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Subtract(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Subtract(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Subtract (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Subtract(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member Subtract : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Subtract (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="44a32-573">O valor do qual um valor será subtraído (o minuendo).</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-573">The value to subtract from (the minuend).</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="44a32-574">O valor a ser subtraído (o subtraendo).</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-574">The value to subtract (the subtrahend).</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="44a32-575">Subtrai um número complexo de outro e retorna o resultado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-575">Subtracts one complex number from another and returns the result.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="44a32-576">O resultado da subtração de <paramref name="right" /> de <paramref name="left" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-576">The result of subtracting <paramref name="right" /> from <paramref name="left" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="44a32-577">A subtração de um número complexo, c + injeção de dependência de outro número complexo, um + bi, usa o seguinte formato:</span><span class="sxs-lookup"><span data-stu-id="44a32-577">The subtraction of a complex number, c + di, from another complex number, a + bi, takes the following form:</span></span>  
  
 <span data-ttu-id="44a32-578">(a - c) + (b - 1!d),</span><span class="sxs-lookup"><span data-stu-id="44a32-578">(a - c) + (b - d)i</span></span>  
  
 <span data-ttu-id="44a32-579">Se a chamada de método resultados em um estouro no componente real ou imaginário, o valor desse componente é <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> ou <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="44a32-579">If the method call results in an overflow in either the real or imaginary component, the value of that component is either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="44a32-580">Idiomas que não dão suporte a operadores personalizados podem usar o <xref:System.Numerics.Complex.Subtract%2A> método para executar a subtração usando números complexos.</span><span class="sxs-lookup"><span data-stu-id="44a32-580">Languages that do not support custom operators can use the <xref:System.Numerics.Complex.Subtract%2A> method to perform subtraction using complex numbers.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="44a32-581">O exemplo a seguir subtrai cada número complexo em uma matriz de um número complexo.</span><span class="sxs-lookup"><span data-stu-id="44a32-581">The following example subtracts each complex number in an array from a complex number.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Subtract#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.subtract/cs/subtract1.cs#1)]
 [!code-vb[System.Numerics.Complex.Subtract#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.subtract/vb/subtract1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Subtraction(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Tan">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Tan (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Tan(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Tan(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Tan (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Tan(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Tan : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Tan value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="44a32-582">Um número complexo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-582">A complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="44a32-583">Retorna a tangente do número complexo especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-583">Returns the tangent of the specified complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="44a32-584">A tangente de <paramref name="value" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-584">The tangent of <paramref name="value" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="44a32-585">O <xref:System.Numerics.Complex.Tan%2A> método para números complexos corresponde à <xref:System.Math.Tan%2A?displayProperty=nameWithType> método para números reais.</span><span class="sxs-lookup"><span data-stu-id="44a32-585">The <xref:System.Numerics.Complex.Tan%2A> method for complex numbers corresponds to the <xref:System.Math.Tan%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="44a32-586">O <xref:System.Numerics.Complex.Tan%2A> método usa a seguinte fórmula para calcular a tangente do número complexo `value`:</span><span class="sxs-lookup"><span data-stu-id="44a32-586">The <xref:System.Numerics.Complex.Tan%2A> method uses the following formula to calculate the tangent of the complex number `value`:</span></span>  
  
 <span data-ttu-id="44a32-587"><xref:System.Numerics.Complex.Sin%2A>(`value`) / <xref:System.Numerics.Complex.Cos%2A>(`value`)</span><span class="sxs-lookup"><span data-stu-id="44a32-587"><xref:System.Numerics.Complex.Sin%2A>(`value`) / <xref:System.Numerics.Complex.Cos%2A>(`value`)</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="44a32-588">O exemplo a seguir ilustra o <xref:System.Numerics.Complex.Tan%2A> método.</span><span class="sxs-lookup"><span data-stu-id="44a32-588">The following example illustrates the <xref:System.Numerics.Complex.Tan%2A> method.</span></span> <span data-ttu-id="44a32-589">Ele mostra que o valor retornado por passando o <xref:System.Numerics.Complex.Atan%2A> método para o <xref:System.Numerics.Complex.Tan%2A> método retorna o original <xref:System.Numerics.Complex> valor.</span><span class="sxs-lookup"><span data-stu-id="44a32-589">It shows that passing the value returned by the <xref:System.Numerics.Complex.Atan%2A> method to the <xref:System.Numerics.Complex.Tan%2A> method returns the original <xref:System.Numerics.Complex> value.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Atan#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.atan/cs/atan1.cs#1)]
 [!code-vb[System.Numerics.Complex.Atan#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.atan/vb/atan1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Atan(System.Numerics.Complex)" />
        <altmember cref="M:System.Math.Tan(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Tanh">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Tanh (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Tanh(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Tanh(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Tanh (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Tanh(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Tanh : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Tanh value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="44a32-590">Um número complexo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-590">A complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="44a32-591">Retorna a tangente hiperbólico do número complexo especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-591">Returns the hyperbolic tangent of the specified complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="44a32-592">A tangente hiperbólica de <paramref name="value" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-592">The hyperbolic tangent of <paramref name="value" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="44a32-593">O <xref:System.Numerics.Complex.Tanh%2A> método para números complexos corresponde à <xref:System.Math.Tanh%2A?displayProperty=nameWithType> método para números reais.</span><span class="sxs-lookup"><span data-stu-id="44a32-593">The <xref:System.Numerics.Complex.Tanh%2A> method for complex numbers corresponds to the <xref:System.Math.Tanh%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="44a32-594">O <xref:System.Numerics.Complex.Tanh%2A> método usa a seguinte fórmula para calcular a tangente hiperbólica do número complexo `value`:</span><span class="sxs-lookup"><span data-stu-id="44a32-594">The <xref:System.Numerics.Complex.Tanh%2A> method uses the following formula to calculate the hyperbolic tangent of the complex number `value`:</span></span>  
  
 <span data-ttu-id="44a32-595"><xref:System.Numerics.Complex.Sinh%2A>(`value`) / <xref:System.Numerics.Complex.Cosh%2A>(`value`)</span><span class="sxs-lookup"><span data-stu-id="44a32-595"><xref:System.Numerics.Complex.Sinh%2A>(`value`) / <xref:System.Numerics.Complex.Cosh%2A>(`value`)</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Tanh(System.Double)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="44a32-596">Converte o valor do número complexo na representação de cadeia de caracteres equivalente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-596">Converts the value of a complex number to its equivalent string representation.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="complex.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="44a32-597">Converte o valor do número complexo atual em sua representação de cadeia de caracteres equivalente usando o formato cartesiano.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-597">Converts the value of the current complex number to its equivalent string representation in Cartesian form.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="44a32-598">A representação de cadeia de caracteres da instância atual em formato cartesiano.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-598">The string representation of the current instance in Cartesian form.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="44a32-599">A representação de cadeia de caracteres de padrão de um número complexo exibe o número com suas coordenadas cartesianas no formulário `(` *um* `,` *b*`)`, em que *uma* é a parte real do número complexo, e *b* é sua parte imaginária.</span><span class="sxs-lookup"><span data-stu-id="44a32-599">The default string representation of a complex number displays the number using its Cartesian coordinates in the form `(`*a*`,` *b*`)`, where *a* is the real part of the complex number, and *b* is its imaginary part.</span></span> <span data-ttu-id="44a32-600">Ambos *uma* e *b* são formatados usando o especificador de formato geral ("G") e as convenções da cultura atual do sistema.</span><span class="sxs-lookup"><span data-stu-id="44a32-600">Both *a* and *b* are formatted using the general format specifier ("G") and the conventions of the current system culture.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="44a32-601">O exemplo a seguir exibe a representação de cadeia de caracteres de vários números complexos.</span><span class="sxs-lookup"><span data-stu-id="44a32-601">The following example displays the string representation of several complex numbers.</span></span> <span data-ttu-id="44a32-602">A saída usa as convenções de formatação do inglês - Estados Unidos ("en-US") cultura, que, nesse caso, é a cultura atual do sistema.</span><span class="sxs-lookup"><span data-stu-id="44a32-602">The output uses the formatting conventions of the English - United States ("en-US") culture, which, in this case, is the current system culture.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.tostring/cs/tostring1.cs#1)]
 [!code-vb[System.Numerics.Complex.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.tostring/vb/tostring1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : IFormatProvider -&gt; string" Usage="complex.ToString provider" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">
          <span data-ttu-id="44a32-603">Um objeto que fornece informações de formatação específicas de cultura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-603">An object that supplies culture-specific formatting information.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="44a32-604">Converte o valor do número complexo atual na representação de cadeia de caracteres equivalente em formato cartesiano usando as informações especificadas de formatação específica à cultura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-604">Converts the value of the current complex number to its equivalent string representation in Cartesian form by using the specified culture-specific formatting information.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="44a32-605">A representação de cadeia de caracteres da instância atual em formato cartesiano, conforme especificado por <paramref name="provider" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-605">The string representation of the current instance in Cartesian form, as specified by <paramref name="provider" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="44a32-606">A representação de cadeia de caracteres do número complexo retornado por esse método exibe o número com suas coordenadas cartesianas no formulário `(` *um* `,` *b*`)`, em que *uma* é a parte real do número complexo, e *b* é sua parte imaginária.</span><span class="sxs-lookup"><span data-stu-id="44a32-606">The string representation of the complex number returned by this method displays the number using its Cartesian coordinates in the form `(`*a*`,` *b*`)`, where *a* is the real part of the complex number, and *b* is its imaginary part.</span></span> <span data-ttu-id="44a32-607">Ambos *uma* e *b* são formatados usando o especificador de formato geral ("G") e as convenções da cultura definido pelo `provider`.</span><span class="sxs-lookup"><span data-stu-id="44a32-607">Both *a* and *b* are formatted using the general format specifier ("G") and the conventions of the culture defined by `provider`.</span></span>  
  
 <span data-ttu-id="44a32-608">O parâmetro `provider` é uma implementação de <xref:System.IFormatProvider>.</span><span class="sxs-lookup"><span data-stu-id="44a32-608">The `provider` parameter is an <xref:System.IFormatProvider> implementation.</span></span> <span data-ttu-id="44a32-609">Sua <xref:System.IFormatProvider.GetFormat%2A> método retorna um <xref:System.Globalization.NumberFormatInfo> objeto que fornece informações específicas da cultura, sobre o formato do real e imaginário números na cadeia de caracteres retornada.</span><span class="sxs-lookup"><span data-stu-id="44a32-609">Its <xref:System.IFormatProvider.GetFormat%2A> method returns a <xref:System.Globalization.NumberFormatInfo> object that provides culture-specific information about the format of the real and imaginary numbers in the returned string.</span></span> <span data-ttu-id="44a32-610">Se `provider` está `null`, a cadeia de caracteres retornada é formatada usando o <xref:System.Globalization.NumberFormatInfo> objeto da cultura atual.</span><span class="sxs-lookup"><span data-stu-id="44a32-610">If `provider` is `null`, the returned string is formatted using the <xref:System.Globalization.NumberFormatInfo> object of the current culture.</span></span>  
  
 <span data-ttu-id="44a32-611">O parâmetro `provider` pode ser um dos seguintes:</span><span class="sxs-lookup"><span data-stu-id="44a32-611">The `provider` parameter can be one of the following:</span></span>  
  
-   <span data-ttu-id="44a32-612">Um <xref:System.Globalization.CultureInfo> objeto que representa a cultura que fornece informações de formatação</span><span class="sxs-lookup"><span data-stu-id="44a32-612">A <xref:System.Globalization.CultureInfo> object that represents the culture that supplies formatting information</span></span>  
  
-   <span data-ttu-id="44a32-613">O objeto <xref:System.Globalization.NumberFormatInfo> que fornece informações de formatação.</span><span class="sxs-lookup"><span data-stu-id="44a32-613">The <xref:System.Globalization.NumberFormatInfo> object that supplies formatting information.</span></span>  
  
-   <span data-ttu-id="44a32-614">Um objeto personalizado que implementa a interface <xref:System.IFormatProvider>.</span><span class="sxs-lookup"><span data-stu-id="44a32-614">A custom object that implements the <xref:System.IFormatProvider> interface.</span></span> <span data-ttu-id="44a32-615">O método <xref:System.IFormatProvider.GetFormat%2A> retorna o objeto <xref:System.Globalization.NumberFormatInfo> que fornece informações de formatação.</span><span class="sxs-lookup"><span data-stu-id="44a32-615">Its <xref:System.IFormatProvider.GetFormat%2A> method returns the <xref:System.Globalization.NumberFormatInfo> object that supplies formatting information.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="44a32-616">O exemplo a seguir exibe a representação de cadeia de caracteres de vários números complexos.</span><span class="sxs-lookup"><span data-stu-id="44a32-616">The following example displays the string representation of several complex numbers.</span></span> <span data-ttu-id="44a32-617">O resultado usa as convenções de formatação do inglês - Estados Unidos ("en-US") e francês - culturas França ("fr-FR").</span><span class="sxs-lookup"><span data-stu-id="44a32-617">The result uses the formatting conventions of the English - United States ("en-US") and French - France ("fr-FR") cultures.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.ToString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.tostring/cs/tostring2.cs#2)]
 [!code-vb[System.Numerics.Complex.ToString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.tostring/vb/tostring2.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(string format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.ToString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(System::String ^ format);" />
      <MemberSignature Language="F#" Value="override this.ToString : string -&gt; string" Usage="complex.ToString format" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="format">
          <span data-ttu-id="44a32-618">Uma cadeia de caracteres padrão ou de formato numérico personalizado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-618">A standard or custom numeric format string.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="44a32-619">Converte o valor do número complexo atual na representação de cadeia de caracteres equivalente em formato cartesiano, usando o formato especificado para suas partes reais e imaginárias.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-619">Converts the value of the current complex number to its equivalent string representation in Cartesian form by using the specified format for its real and imaginary parts.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="44a32-620">A representação de cadeia de caracteres da instância atual em formato cartesiano.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-620">The string representation of the current instance in Cartesian form.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="44a32-621">A representação de cadeia de caracteres do número complexo retornado por esse método exibe o número com suas coordenadas cartesianas no formulário `(` *um* `,` *b*`)`, em que *uma* é a parte real do número complexo, e *b* é sua parte imaginária.</span><span class="sxs-lookup"><span data-stu-id="44a32-621">The string representation of the complex number returned by this method displays the number using its Cartesian coordinates in the form `(`*a*`,` *b*`)`, where *a* is the real part of the complex number, and *b* is its imaginary part.</span></span> <span data-ttu-id="44a32-622">Ambos *uma* e *b* são formatados usando a cadeia de caracteres de formato especificada pelo `format`.</span><span class="sxs-lookup"><span data-stu-id="44a32-622">Both *a* and *b* are formatted using the format string specified by `format`.</span></span> <span data-ttu-id="44a32-623">O parâmetro `format` pode ser qualquer especificador de formato numérico padrão válido, ou uma combinação de especificadores de formato numérico personalizado.</span><span class="sxs-lookup"><span data-stu-id="44a32-623">The `format` parameter can be any valid standard numeric format specifier, or any combination of custom numeric format specifiers.</span></span> <span data-ttu-id="44a32-624">Se `format` é igual a <xref:System.String.Empty?displayProperty=nameWithType> ou é `null`, as partes reais e imaginárias do número complexo são formatadas com o especificador de formato geral ("G").</span><span class="sxs-lookup"><span data-stu-id="44a32-624">If `format` is equal to <xref:System.String.Empty?displayProperty=nameWithType> or is `null`, the real and imaginary parts of the complex number are formatted with the general format specifier ("G").</span></span> <span data-ttu-id="44a32-625">Caso `format` tenha qualquer outro valor, o método lança um <xref:System.FormatException>.</span><span class="sxs-lookup"><span data-stu-id="44a32-625">If `format` is any other value, the method throws a <xref:System.FormatException>.</span></span>  
  
 <span data-ttu-id="44a32-626">O .NET Framework fornece suporte extenso à formatação, que é descrito mais detalhadamente nos tópicos a seguir:</span><span class="sxs-lookup"><span data-stu-id="44a32-626">The .NET Framework provides extensive formatting support, which is described in greater detail in the following topics:</span></span>  
  
-   <span data-ttu-id="44a32-627">Para obter mais informações sobre cadeias de caracteres de formato numérico, consulte [cadeias de caracteres de formato numérico padrão](~/docs/standard/base-types/standard-numeric-format-strings.md) e [às cadeias de caracteres de formato numérico personalizado](~/docs/standard/base-types/custom-numeric-format-strings.md).</span><span class="sxs-lookup"><span data-stu-id="44a32-627">For more information about numeric format strings, see [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) and [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md).</span></span>  
  
-   <span data-ttu-id="44a32-628">Para obter mais informações sobre a formatação no .NET Framework, consulte [tipos de formatação](~/docs/standard/base-types/formatting-types.md).</span><span class="sxs-lookup"><span data-stu-id="44a32-628">For more information about formatting in the .NET Framework, see [Formatting Types](~/docs/standard/base-types/formatting-types.md).</span></span>  
  
 <span data-ttu-id="44a32-629">O formato da cadeia de caracteres retornada é determinado pelo objeto <xref:System.Globalization.NumberFormatInfo> para a cultura atual.</span><span class="sxs-lookup"><span data-stu-id="44a32-629">The format of the returned string is determined by the <xref:System.Globalization.NumberFormatInfo> object for the current culture.</span></span> <span data-ttu-id="44a32-630">Dependendo do parâmetro `format`, esse objeto controla símbolos como o sinal negativo, o separador do grupo e o símbolo da vírgula decimal na cadeia de caracteres de saída.</span><span class="sxs-lookup"><span data-stu-id="44a32-630">Depending on the `format` parameter, this object controls symbols such as the negative sign, the group separator, and the decimal point symbol in the output string.</span></span> <span data-ttu-id="44a32-631">Para fornecer informações de formatação para culturas diferentes da cultura atual, chame o <xref:System.Numerics.Complex.ToString%28System.String%2CSystem.IFormatProvider%29> de sobrecarga.</span><span class="sxs-lookup"><span data-stu-id="44a32-631">To provide formatting information for cultures other than the current culture, call the <xref:System.Numerics.Complex.ToString%28System.String%2CSystem.IFormatProvider%29> overload.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="44a32-632">O exemplo a seguir inicializa um número complexo e exibe-a usando várias cadeias de caracteres de formato padrão.</span><span class="sxs-lookup"><span data-stu-id="44a32-632">The following example initializes a complex number and displays it using several standard format strings.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.ToString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.tostring/cs/tostring3.cs#3)]
 [!code-vb[System.Numerics.Complex.ToString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.tostring/vb/tostring3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <span data-ttu-id="44a32-633">
            <paramref name="format" /> não é uma cadeia de caracteres de formato válida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-633">
              <paramref name="format" /> is not a valid format string.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(string format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.ToString(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String, provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(System::String ^ format, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : string * IFormatProvider -&gt; string" Usage="complex.ToString (format, provider)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IFormattable.ToString(System.String,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="format">
          <span data-ttu-id="44a32-634">Uma cadeia de caracteres padrão ou de formato numérico personalizado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-634">A standard or custom numeric format string.</span>
          </span>
        </param>
        <param name="provider">
          <span data-ttu-id="44a32-635">Um objeto que fornece informações de formatação específicas de cultura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-635">An object that supplies culture-specific formatting information.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="44a32-636">Converte o valor do número complexo atual na representação de cadeia de caracteres equivalente em formato cartesiano, usando o formato especificado e as informações de formato específicas à cultura para suas partes reais e imaginárias.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-636">Converts the value of the current complex number to its equivalent string representation in Cartesian form by using the specified format and culture-specific format information for its real and imaginary parts.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="44a32-637">A representação de cadeia de caracteres da instância atual em formato cartesiano, conforme especificado por <paramref name="format" /> e <paramref name="provider" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-637">The string representation of the current instance in Cartesian form, as specified by <paramref name="format" /> and <paramref name="provider" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="44a32-638">A representação de cadeia de caracteres do número complexo retornado por esse método exibe o número com suas coordenadas cartesianas no formulário `(` *um* `,` *b*`)`, em que *uma* é a parte real do número complexo, e *b* é sua parte imaginária.</span><span class="sxs-lookup"><span data-stu-id="44a32-638">The string representation of the complex number returned by this method displays the number using its Cartesian coordinates in the form `(`*a*`,` *b*`)`, where *a* is the real part of the complex number, and *b* is its imaginary part.</span></span> <span data-ttu-id="44a32-639">Ambos *uma* e *b* são formatados usando a cadeia de caracteres de formato especificada pelo `format`.</span><span class="sxs-lookup"><span data-stu-id="44a32-639">Both *a* and *b* are formatted using the format string specified by `format`.</span></span> <span data-ttu-id="44a32-640">O parâmetro `format` pode ser qualquer especificador de formato numérico padrão válido, ou uma combinação de especificadores de formato numérico personalizado.</span><span class="sxs-lookup"><span data-stu-id="44a32-640">The `format` parameter can be any valid standard numeric format specifier, or any combination of custom numeric format specifiers.</span></span> <span data-ttu-id="44a32-641">Se `format` é igual a <xref:System.String.Empty?displayProperty=nameWithType> ou é `null`, as partes reais e imaginárias do número complexo são formatadas com o especificador de formato geral ("G").</span><span class="sxs-lookup"><span data-stu-id="44a32-641">If `format` is equal to <xref:System.String.Empty?displayProperty=nameWithType> or is `null`, the real and imaginary parts of the complex number are formatted with the general format specifier ("G").</span></span> <span data-ttu-id="44a32-642">Caso `format` tenha qualquer outro valor, o método lança um <xref:System.FormatException>.</span><span class="sxs-lookup"><span data-stu-id="44a32-642">If `format` is any other value, the method throws a <xref:System.FormatException>.</span></span>  
  
 <span data-ttu-id="44a32-643">O .NET Framework fornece suporte extenso à formatação, que é descrito mais detalhadamente nos tópicos a seguir:</span><span class="sxs-lookup"><span data-stu-id="44a32-643">The .NET Framework provides extensive formatting support, which is described in greater detail in the following topics:</span></span>  
  
-   <span data-ttu-id="44a32-644">Para obter mais informações sobre cadeias de caracteres de formato numérico, consulte [cadeias de caracteres de formato numérico padrão](~/docs/standard/base-types/standard-numeric-format-strings.md) e [às cadeias de caracteres de formato numérico personalizado](~/docs/standard/base-types/custom-numeric-format-strings.md).</span><span class="sxs-lookup"><span data-stu-id="44a32-644">For more information about numeric format strings, see [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) and [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md).</span></span>  
  
-   <span data-ttu-id="44a32-645">Para obter mais informações sobre a formatação no .NET Framework, consulte [tipos de formatação](~/docs/standard/base-types/formatting-types.md).</span><span class="sxs-lookup"><span data-stu-id="44a32-645">For more information about formatting in the .NET Framework, see [Formatting Types](~/docs/standard/base-types/formatting-types.md).</span></span>  
  
 <span data-ttu-id="44a32-646">O parâmetro `provider` é uma implementação de <xref:System.IFormatProvider>.</span><span class="sxs-lookup"><span data-stu-id="44a32-646">The `provider` parameter is an <xref:System.IFormatProvider> implementation.</span></span> <span data-ttu-id="44a32-647">Sua <xref:System.IFormatProvider.GetFormat%2A> método retorna um <xref:System.Globalization.NumberFormatInfo> objeto que fornece informações específicas da cultura, sobre o formato do real e imaginário números na cadeia de caracteres retornada.</span><span class="sxs-lookup"><span data-stu-id="44a32-647">Its <xref:System.IFormatProvider.GetFormat%2A> method returns a <xref:System.Globalization.NumberFormatInfo> object that provides culture-specific information about the format of the real and imaginary numbers in the returned string.</span></span> <span data-ttu-id="44a32-648">Dependendo do parâmetro `format`, esse objeto controla símbolos como o sinal negativo, o separador do grupo e o símbolo da vírgula decimal na cadeia de caracteres de saída.</span><span class="sxs-lookup"><span data-stu-id="44a32-648">Depending on the `format` parameter, this object controls symbols such as the negative sign, the group separator, and the decimal point symbol in the output string.</span></span> <span data-ttu-id="44a32-649">Se `provider` está `null`, a cadeia de caracteres retornada é formatada usando o <xref:System.Globalization.NumberFormatInfo> objeto da cultura atual.</span><span class="sxs-lookup"><span data-stu-id="44a32-649">If `provider` is `null`, the returned string is formatted using the <xref:System.Globalization.NumberFormatInfo> object of the current culture.</span></span>  
  
 <span data-ttu-id="44a32-650">O parâmetro `provider` pode ser um dos seguintes:</span><span class="sxs-lookup"><span data-stu-id="44a32-650">The `provider` parameter can be one of the following:</span></span>  
  
-   <span data-ttu-id="44a32-651">Um <xref:System.Globalization.CultureInfo> objeto que representa a cultura que fornece informações de formatação</span><span class="sxs-lookup"><span data-stu-id="44a32-651">A <xref:System.Globalization.CultureInfo> object that represents the culture that supplies formatting information</span></span>  
  
-   <span data-ttu-id="44a32-652">O objeto <xref:System.Globalization.NumberFormatInfo> que fornece informações de formatação.</span><span class="sxs-lookup"><span data-stu-id="44a32-652">The <xref:System.Globalization.NumberFormatInfo> object that supplies formatting information.</span></span>  
  
-   <span data-ttu-id="44a32-653">Um objeto personalizado que implementa a interface <xref:System.IFormatProvider>.</span><span class="sxs-lookup"><span data-stu-id="44a32-653">A custom object that implements the <xref:System.IFormatProvider> interface.</span></span> <span data-ttu-id="44a32-654">O método <xref:System.IFormatProvider.GetFormat%2A> retorna o objeto <xref:System.Globalization.NumberFormatInfo> que fornece informações de formatação.</span><span class="sxs-lookup"><span data-stu-id="44a32-654">Its <xref:System.IFormatProvider.GetFormat%2A> method returns the <xref:System.Globalization.NumberFormatInfo> object that supplies formatting information.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="44a32-655">O exemplo a seguir cria uma matriz de números complexos e exibe cada usando várias cadeias de caracteres de formato padrão, bem como <xref:System.Globalization.CultureInfo> objetos que representam as culturas de inglês - Estados Unidos ("en-US") e francês - França ("fr-FR").</span><span class="sxs-lookup"><span data-stu-id="44a32-655">The following example creates an array of complex numbers, and displays each using several standard format strings as well as <xref:System.Globalization.CultureInfo> objects that represent the English - United States ("en-US") and French - France ("fr-FR") cultures.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.ToString#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.tostring/cs/tostring4.cs#4)]
 [!code-vb[System.Numerics.Complex.ToString#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.tostring/vb/tostring4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <span data-ttu-id="44a32-656">
            <paramref name="format" /> não é uma cadeia de caracteres de formato válida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-656">
              <paramref name="format" /> is not a valid format string.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Zero">
      <MemberSignature Language="C#" Value="public static readonly System.Numerics.Complex Zero;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Numerics.Complex Zero" />
      <MemberSignature Language="DocId" Value="F:System.Numerics.Complex.Zero" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Zero As Complex " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Numerics::Complex Zero;" />
      <MemberSignature Language="F#" Value=" staticval mutable Zero : System.Numerics.Complex" Usage="System.Numerics.Complex.Zero" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="44a32-657">Retorna uma nova instância do <see cref="T:System.Numerics.Complex" /> com um número real igual a zero e um número imaginário igual a zero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44a32-657">Returns a new <see cref="T:System.Numerics.Complex" /> instance with a real number equal to zero and an imaginary number equal to zero.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="44a32-658">O <xref:System.Numerics.Complex.Zero> propriedade é usada com mais frequência para comparar um <xref:System.Numerics.Complex> valor como zero.</span><span class="sxs-lookup"><span data-stu-id="44a32-658">The <xref:System.Numerics.Complex.Zero> property is most frequently used to compare a <xref:System.Numerics.Complex> value to zero.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="44a32-659">O exemplo a seguir instancia um <xref:System.Numerics.Complex> valor usando o <xref:System.Numerics.Complex.Zero> propriedade.</span><span class="sxs-lookup"><span data-stu-id="44a32-659">The following example instantiates a <xref:System.Numerics.Complex> value by using the <xref:System.Numerics.Complex.Zero> property.</span></span> <span data-ttu-id="44a32-660">Ele então compara esse valor para outro valor que é instanciado, chamando o <xref:System.Numerics.Complex> construtor com uma parte real igual a zero e uma parte imaginária igual a zero.</span><span class="sxs-lookup"><span data-stu-id="44a32-660">It then compares this value to another value that is instantiated by calling the <xref:System.Numerics.Complex> constructor with a real part equal to zero and an imaginary part equal to zero.</span></span> <span data-ttu-id="44a32-661">Como mostra a saída do exemplo, os dois valores são iguais.</span><span class="sxs-lookup"><span data-stu-id="44a32-661">As the output from the example shows, the two values are equal.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Zero#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.zero/cs/zero1.cs#1)]
 [!code-vb[System.Numerics.Complex.Zero#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.zero/vb/zero1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Numerics.Complex.ImaginaryOne" />
        <altmember cref="F:System.Numerics.Complex.One" />
      </Docs>
    </Member>
  </Members>
</Type>