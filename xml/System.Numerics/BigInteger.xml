<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="BigInteger.xml" source-language="en-US" target-language="pt-BR">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac57d0dcda34bb31112c320daec112f3dd4b818dc43.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">7d0dcda34bb31112c320daec112f3dd4b818dc43</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Numerics.BigInteger">
          <source>Represents an arbitrarily large signed integer.</source>
          <target state="translated">Representa um inteiro com sinal arbitrariamente grande.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.BigInteger">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> type is an immutable type that represents an arbitrarily large integer whose value in theory has no upper or lower bounds.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> tipo é um tipo imutável que representa um inteiro arbitrariamente grande cujo valor teoricamente não tem nenhum limite superior ou inferior.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.BigInteger">
          <source>The members of the <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> type closely parallel those of other integral types (the <ph id="ph2">&lt;xref:System.Byte&gt;</ph>, <ph id="ph3">&lt;xref:System.Int16&gt;</ph>, <ph id="ph4">&lt;xref:System.Int32&gt;</ph>, <ph id="ph5">&lt;xref:System.Int64&gt;</ph>, <ph id="ph6">&lt;xref:System.SByte&gt;</ph>, <ph id="ph7">&lt;xref:System.UInt16&gt;</ph>, <ph id="ph8">&lt;xref:System.UInt32&gt;</ph>, and <ph id="ph9">&lt;xref:System.UInt64&gt;</ph> types).</source>
          <target state="translated">Os membros do <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> tipo paralelo perto de outros tipos integrais (o <ph id="ph2">&lt;xref:System.Byte&gt;</ph>, <ph id="ph3">&lt;xref:System.Int16&gt;</ph>, <ph id="ph4">&lt;xref:System.Int32&gt;</ph>, <ph id="ph5">&lt;xref:System.Int64&gt;</ph>, <ph id="ph6">&lt;xref:System.SByte&gt;</ph>, <ph id="ph7">&lt;xref:System.UInt16&gt;</ph>, <ph id="ph8">&lt;xref:System.UInt32&gt;</ph>, e <ph id="ph9">&lt;xref:System.UInt64&gt;</ph> tipos).</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.BigInteger">
          <source>This type differs from the other integral types in the <ph id="ph1">[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]</ph>, which have a range indicated by their <ph id="ph2">`MinValue`</ph> and <ph id="ph3">`MaxValue`</ph> properties.</source>
          <target state="translated">Esse tipo difere de outros tipos integrais no <ph id="ph1">[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]</ph>, que tem um intervalo indicado por seus <ph id="ph2">`MinValue`</ph> e <ph id="ph3">`MaxValue`</ph> propriedades.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.BigInteger">
          <source>Because the <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> type is immutable (see <bpt id="p1">[</bpt>Mutability and the BigInteger Structure<ept id="p1">](#mutability)</ept>) and because it has no upper or lower bounds, an <ph id="ph2">&lt;xref:System.OutOfMemoryException&gt;</ph> can be thrown for any operation that causes a <ph id="ph3">&lt;xref:System.Numerics.BigInteger&gt;</ph> value to grow too large.</source>
          <target state="translated">Porque o <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> tipo é imutável (consulte <bpt id="p1">[</bpt>Mutabilidade e a estrutura BigInteger<ept id="p1">](#mutability)</ept>) e porque ela tem nenhum limite superior ou inferior, um <ph id="ph2">&lt;xref:System.OutOfMemoryException&gt;</ph> pode ser gerada para qualquer operação que faz com que um <ph id="ph3">&lt;xref:System.Numerics.BigInteger&gt;</ph> valor aumentar muito grande.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.BigInteger">
          <source>Instantiating a BigInteger Object</source>
          <target state="translated">Criando uma instância de um objeto BigInteger</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.BigInteger">
          <source>You can instantiate a <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> object in several ways:</source>
          <target state="translated">Você pode instanciar uma <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> objeto de várias maneiras:</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.BigInteger">
          <source>You can use the <ph id="ph1">`new`</ph> keyword and provide any integral or floating-point value as a parameter to the <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> constructor.</source>
          <target state="translated">Você pode usar o <ph id="ph1">`new`</ph> palavra-chave e forneça qualquer valor integral ou de ponto flutuante como um parâmetro para o <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> construtor.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.BigInteger">
          <source>(Floating-point values are truncated before they are assigned to the <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph>.) The following example illustrates how to use the <ph id="ph2">`new`</ph> keyword to instantiate <ph id="ph3">&lt;xref:System.Numerics.BigInteger&gt;</ph> values.</source>
          <target state="translated">(Valores de ponto flutuante são truncados antes que eles forem atribuídos a <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph>.) O exemplo a seguir ilustra como usar o <ph id="ph2">`new`</ph> palavra-chave para instanciar <ph id="ph3">&lt;xref:System.Numerics.BigInteger&gt;</ph> valores.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.BigInteger">
          <source>You can declare a <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> variable and assign it a value just as you would any numeric type, as long as that value is an integral type.</source>
          <target state="translated">Você pode declarar uma <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> variável e atribuir um valor exatamente como você faria qualquer tipo numérico, desde que esse valor é um tipo integral.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.BigInteger">
          <source>The following example uses assignment to create a <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> value from an <ph id="ph2">&lt;xref:System.Int64&gt;</ph>.</source>
          <target state="translated">O exemplo a seguir usa a atribuição para criar um <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> valor de um <ph id="ph2">&lt;xref:System.Int64&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.BigInteger">
          <source>You can assign a decimal or floating-point value to a <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> object if you cast the value or convert it first.</source>
          <target state="translated">Você pode atribuir um valor decimal ou flutuante para um <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> de objeto se você converter o valor ou convertê-la primeiro.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.BigInteger">
          <source>The following example explicitly casts (in C#) or converts (in Visual Basic) a <ph id="ph1">&lt;xref:System.Double&gt;</ph> and a <ph id="ph2">&lt;xref:System.Decimal&gt;</ph> value to a <ph id="ph3">&lt;xref:System.Numerics.BigInteger&gt;</ph>.</source>
          <target state="translated">O exemplo a seguir converte (em c#) ou converte (no Visual Basic) explicitamente um <ph id="ph1">&lt;xref:System.Double&gt;</ph> e um <ph id="ph2">&lt;xref:System.Decimal&gt;</ph> valor para um <ph id="ph3">&lt;xref:System.Numerics.BigInteger&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.BigInteger">
          <source>These methods enable you to instantiate a <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> object whose value is in the range of one of the existing numeric types only.</source>
          <target state="translated">Esses métodos permitem que você criar uma instância de um <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> somente a tipos de objeto cujo valor está no intervalo de um numérico existente.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.BigInteger">
          <source>You can instantiate a <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> object whose value can exceed the range of the existing numeric types in one of three ways:</source>
          <target state="translated">Você pode instanciar uma <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> objeto cujo valor pode exceder o intervalo dos tipos numéricos existentes em uma das três maneiras:</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.BigInteger">
          <source>You can use the <ph id="ph1">`new`</ph> keyword and provide a byte array of any size to the <ph id="ph2">&lt;xref:System.Numerics.BigInteger.%23ctor%2A?displayProperty=nameWithType&gt;</ph> constructor.</source>
          <target state="translated">Você pode usar o <ph id="ph1">`new`</ph> palavra-chave e forneça uma matriz de bytes de qualquer tamanho de <ph id="ph2">&lt;xref:System.Numerics.BigInteger.%23ctor%2A?displayProperty=nameWithType&gt;</ph> construtor.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.BigInteger">
          <source>For example:</source>
          <target state="translated">Por exemplo:</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.BigInteger">
          <source>You can call the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Parse%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Numerics.BigInteger.TryParse%2A&gt;</ph> methods to convert the string representation of a number to a <ph id="ph3">&lt;xref:System.Numerics.BigInteger&gt;</ph>.</source>
          <target state="translated">Você pode chamar o <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Parse%2A&gt;</ph> ou <ph id="ph2">&lt;xref:System.Numerics.BigInteger.TryParse%2A&gt;</ph> métodos para converter a representação de cadeia de caracteres de um número para um <ph id="ph3">&lt;xref:System.Numerics.BigInteger&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.BigInteger">
          <source>For example:</source>
          <target state="translated">Por exemplo:</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.BigInteger">
          <source>You can call a <ph id="ph1">`static`</ph> (<ph id="ph2">`Shared`</ph> in Visual Basic) <ph id="ph3">&lt;xref:System.Numerics.BigInteger&gt;</ph> method that performs some operation on a numeric expression and returns a calculated <ph id="ph4">&lt;xref:System.Numerics.BigInteger&gt;</ph> result.</source>
          <target state="translated">Você pode chamar um <ph id="ph1">`static`</ph> (<ph id="ph2">`Shared`</ph> no Visual Basic) <ph id="ph3">&lt;xref:System.Numerics.BigInteger&gt;</ph> método que executa alguma operação em uma expressão numérica e retorna um calculado <ph id="ph4">&lt;xref:System.Numerics.BigInteger&gt;</ph> resultados.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.BigInteger">
          <source>The following example does this by cubing <ph id="ph1">&lt;xref:System.UInt64.MaxValue?displayProperty=nameWithType&gt;</ph> and assigning the result to a <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph>.</source>
          <target state="translated">O exemplo a seguir faz isso por cubing <ph id="ph1">&lt;xref:System.UInt64.MaxValue?displayProperty=nameWithType&gt;</ph> e atribuir o resultado a um <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.BigInteger">
          <source>The uninitialized value of a <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> is <ph id="ph2">&lt;xref:System.Numerics.BigInteger.Zero%2A&gt;</ph>.</source>
          <target state="translated">O valor não inicializado de um <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> é <ph id="ph2">&lt;xref:System.Numerics.BigInteger.Zero%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.BigInteger">
          <source>Performing Operations on BigInteger Values</source>
          <target state="translated">Realizando operações em valores BigInteger</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.BigInteger">
          <source>You can use a <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> instance as you would use any other integral type.</source>
          <target state="translated">Você pode usar um <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> como você usaria qualquer outro tipo integral de instância.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.BigInteger">
          <source><ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> overloads the standard numeric operators to enable you to perform basic mathematical operations such as addition, subtraction, division, multiplication, subtraction, negation, and unary negation.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> sobrecargas de operadores numéricos padrão para que você possa executar operações matemáticas básicas, como adição, subtração, divisão, multiplicação, subtração, negação e negação unário.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.BigInteger">
          <source>You can also use the standard numeric operators to compare two <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> values with each other.</source>
          <target state="translated">Você também pode usar os operadores numéricos padrão para comparar dois <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> valores entre si.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.BigInteger">
          <source>Like the other integral types, <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> also supports the bitwise <ph id="ph2">`And`</ph>, <ph id="ph3">`Or`</ph>, <ph id="ph4">`XOr`</ph>, left shift, and right shift operators.</source>
          <target state="translated">Como os outros tipos integrais <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> também suporta o bit a bit <ph id="ph2">`And`</ph>, <ph id="ph3">`Or`</ph>, <ph id="ph4">`XOr`</ph>, esquerdo shift e operadores de deslocamento para a direita.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.BigInteger">
          <source>For languages that do not support custom operators, the <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> structure also provides equivalent methods for performing mathematical operations.</source>
          <target state="translated">Para idiomas que não dão suporte a operadores personalizados, o <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> estrutura também fornece métodos equivalentes para executar operações matemáticas.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.BigInteger">
          <source>These include <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Add%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Numerics.BigInteger.Divide%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Numerics.BigInteger.Multiply%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Numerics.BigInteger.Negate%2A&gt;</ph>, <ph id="ph5">&lt;xref:System.Numerics.BigInteger.Subtract%2A&gt;</ph>, and several others.</source>
          <target state="translated">Isso inclui <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Add%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Numerics.BigInteger.Divide%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Numerics.BigInteger.Multiply%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Numerics.BigInteger.Negate%2A&gt;</ph>, <ph id="ph5">&lt;xref:System.Numerics.BigInteger.Subtract%2A&gt;</ph>e vários outros.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.BigInteger">
          <source>Many members of the <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> structure correspond directly to members of the other integral types.</source>
          <target state="translated">Número de membros do <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> estrutura corresponde diretamente aos membros de outros tipos integrais.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.BigInteger">
          <source>In addition, <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> adds members such as the following:</source>
          <target state="translated">Além disso, <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> adiciona membros como o seguinte:</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.BigInteger">
          <source><ph id="ph1">&lt;xref:System.Numerics.BigInteger.Sign%2A&gt;</ph>, which returns a value that indicates the sign of a <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> value.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Numerics.BigInteger.Sign%2A&gt;</ph>, que retorna um valor que indica o sinal de um <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> valor.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.BigInteger">
          <source><ph id="ph1">&lt;xref:System.Numerics.BigInteger.Abs%2A&gt;</ph>, which returns the absolute value of a <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> value.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Numerics.BigInteger.Abs%2A&gt;</ph>, que retorna o valor absoluto de um <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> valor.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.BigInteger">
          <source><ph id="ph1">&lt;xref:System.Numerics.BigInteger.DivRem%2A&gt;</ph>, which returns both the quotient and remainder of a division operation.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Numerics.BigInteger.DivRem%2A&gt;</ph>, que retorna o quociente e o resto de uma operação de divisão.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.BigInteger">
          <source><ph id="ph1">&lt;xref:System.Numerics.BigInteger.GreatestCommonDivisor%2A&gt;</ph>, which returns the greatest common divisor of two <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Numerics.BigInteger.GreatestCommonDivisor%2A&gt;</ph>, que retorna o máximo divisor comum de dois <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> valores.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.BigInteger">
          <source>Many of these additional members correspond to the members of the <ph id="ph1">&lt;xref:System.Math&gt;</ph> class, which provides the functionality to work with the primitive numeric types.</source>
          <target state="translated">Muitos desses membros adicionais correspondem aos membros a <ph id="ph1">&lt;xref:System.Math&gt;</ph> classe, que fornece a funcionalidade para trabalhar com os tipos numéricos primitivo.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.BigInteger">
          <source>Mutability and the BigInteger Structure</source>
          <target state="translated">Mutabilidade e a estrutura de BigInteger</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.BigInteger">
          <source>The following example instantiates a <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> object and then increments its value by one.</source>
          <target state="translated">O exemplo a seguir cria um <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> de objeto e, em seguida, incrementa o valor em um.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.BigInteger">
          <source>Although this example appears to modify the value of the existing object, this is not the case.</source>
          <target state="translated">Embora esse exemplo é exibido modificar o valor do objeto existente, isso não é o caso.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.BigInteger">
          <source><ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> objects are immutable, which means that internally, the common language runtime actually creates a new <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> object and assigns it a value one greater than its previous value.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> objetos são imutáveis, o que significa que, internamente, o common language runtime, na verdade, cria um novo <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> de objeto e atribui um valor maior do que seu valor anterior.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.BigInteger">
          <source>This new object is then returned to the caller.</source>
          <target state="translated">Esse novo objeto é retornado ao chamador.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.BigInteger">
          <source>The other numeric types in the .NET Framework are also immutable.</source>
          <target state="translated">Os tipos numéricos do .NET Framework também são imutáveis.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.BigInteger">
          <source>However, because the <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> type has no upper or lower bounds, its values can grow extremely large and have a measurable impact on performance.</source>
          <target state="translated">No entanto, como o <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> tipo não tem nenhum limite superior ou inferior, seus valores podem ficar muito grandes e exerce um impacto significativo no desempenho.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.BigInteger">
          <source>Although this process is transparent to the caller, it does incur a performance penalty.</source>
          <target state="translated">Embora esse processo é transparente para o chamador, ele pode incorrer em uma penalidade de desempenho.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.BigInteger">
          <source>In some cases, especially when repeated operations are performed in a loop on very large <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> values, that performance penalty can be significant.</source>
          <target state="translated">Em alguns casos, especialmente quando várias operações são executadas em um loop em grandes <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> valores, que penalidade de desempenho pode ser significativa.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.BigInteger">
          <source>For example, in the following example, an operation is performed repetitively up to a million times, and a <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> value is incremented by one every time the operation succeeds.</source>
          <target state="translated">Por exemplo, no exemplo a seguir, uma operação é executada repetidamente até um milhão de vezes e um <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> valor é incrementado em um cada vez que a operação for bem-sucedida.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.BigInteger">
          <source>In such a case, you can improve performance by performing all intermediate assignments to an <ph id="ph1">&lt;xref:System.Int32&gt;</ph> variable.</source>
          <target state="translated">Nesse caso, você pode melhorar o desempenho executando todas as atribuições de intermediárias para um <ph id="ph1">&lt;xref:System.Int32&gt;</ph> variável.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.BigInteger">
          <source>The final value of the variable can then be assigned to the <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> object when the loop exits.</source>
          <target state="translated">O valor final da variável, em seguida, pode ser atribuído para o <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> objeto quando o loop será encerrado.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.BigInteger">
          <source>The following example provides an illustration.</source>
          <target state="translated">O exemplo a seguir fornece uma ilustração.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.BigInteger">
          <source>Working with Byte Arrays and Hexadecimal Strings</source>
          <target state="translated">Trabalhando com matrizes de bytes e cadeias de caracteres hexadecimais</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.BigInteger">
          <source>If you convert <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> values to byte arrays, or if you convert byte arrays to <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> values, you must consider the order of bytes.</source>
          <target state="translated">Se você converter <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> valores para matrizes de bytes, ou se você converter matrizes de bytes para <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> valores, você deve considerar a ordem de bytes.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.BigInteger">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> structure expects the individual bytes in a byte array to appear in little-endian order (that is, the lower-order bytes of the value precede the higher-order bytes).</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> estrutura espera os bytes individuais em uma matriz de bytes para aparecer na ordem little endian (ou seja, os bytes de ordem inferior do valor precedem os bytes de ordem superior).</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.BigInteger">
          <source>You can round-trip a <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> value by calling the <ph id="ph2">&lt;xref:System.Numerics.BigInteger.ToByteArray%2A&gt;</ph> method and then passing the resulting byte array to the <ph id="ph3">&lt;xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29&gt;</ph> constructor, as the following example shows.</source>
          <target state="translated">Você pode viagem um <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> valor chamando o <ph id="ph2">&lt;xref:System.Numerics.BigInteger.ToByteArray%2A&gt;</ph> método e, em seguida, passando o byte resultante de matriz para o <ph id="ph3">&lt;xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29&gt;</ph> construtor, como mostra o exemplo a seguir.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.BigInteger">
          <source>To instantiate a <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> value from a byte array that represents a value of some other integral type, you can pass the integral value to the <ph id="ph2">&lt;xref:System.BitConverter.GetBytes%2A?displayProperty=nameWithType&gt;</ph> method, and then pass the resulting byte array to the <ph id="ph3">&lt;xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29&gt;</ph> constructor.</source>
          <target state="translated">Para criar uma instância de um <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> valor de uma matriz de bytes que representa um valor de outro tipo integral, você pode passar o valor inteiro para o <ph id="ph2">&lt;xref:System.BitConverter.GetBytes%2A?displayProperty=nameWithType&gt;</ph> método e, em seguida, passe o byte resultante de matriz para o <ph id="ph3">&lt;xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29&gt;</ph> construtor.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.BigInteger">
          <source>The following example instantiates a <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> value from a byte array that represents an <ph id="ph2">&lt;xref:System.Int16&gt;</ph> value.</source>
          <target state="translated">O exemplo a seguir cria um <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> valor de uma matriz de bytes que representa um <ph id="ph2">&lt;xref:System.Int16&gt;</ph> valor.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.BigInteger">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> structure assumes that negative values are stored by using two's complement representation.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> estrutura pressupõe que os valores negativos são armazenados usando a representação de complemento de dois.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.BigInteger">
          <source>Because the <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> structure represents a numeric value with no fixed length, the <ph id="ph2">&lt;xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29&gt;</ph> constructor always interprets the most significant bit of the last byte in the array as a sign bit.</source>
          <target state="translated">Porque o <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> estrutura representa um valor numérico com nenhum comprimento fixo, o <ph id="ph2">&lt;xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29&gt;</ph> construtor sempre interpreta o bit mais significativo do último byte na matriz como uma entrada.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.BigInteger">
          <source>To prevent the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29&gt;</ph> constructor from confusing the two's complement representation of a negative value with the sign and magnitude representation of a positive value, positive values in which the most significant bit of the last byte in the byte array would ordinarily be set should include an additional byte whose value is 0.</source>
          <target state="translated">Para evitar o <ph id="ph1">&lt;xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29&gt;</ph> construtor da confuso de dois complemento representação de um valor negativo com a representação de entrada e a magnitude de um valor positivo, positivo de valores que o bit mais significativo do último byte na matriz de bytes será normalmente definido devem incluir um byte adicional cujo valor é 0.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.BigInteger">
          <source>For example, 0xC0 0xBD 0xF0 0xFF is the little-endian hexadecimal representation of either -1,000,000 or 4,293,967,296.</source>
          <target state="translated">Por exemplo, 0xC0 0xBD 0xF0 0xFF é a representação hexadecimal little endian de-1,000,000 ou 4,293,967,296.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.BigInteger">
          <source>Because the most significant bit of the last byte in this array is on, the value of the byte array would be interpreted by the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29&gt;</ph> constructor as -1,000,000.</source>
          <target state="translated">Como o bit mais significativo do último byte nessa matriz é ativado, o valor da matriz de bytes deve ser interpretado pelo <ph id="ph1">&lt;xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29&gt;</ph> construtor como-1,000,000.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.BigInteger">
          <source>To instantiate a <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> whose value is positive, a byte array whose elements are 0xC0 0xBD 0xF0 0xFF 0x00 must be passed to the constructor.</source>
          <target state="translated">Para criar uma instância de um <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> cujo valor é positivo, uma matriz de bytes cujos elementos são 0xC0 0xBD 0xF0 0xFF 0x00 devem ser passados para o construtor.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.BigInteger">
          <source>The following example illustrates this.</source>
          <target state="translated">O exemplo a seguir ilustra essa situação.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.BigInteger">
          <source>Byte arrays created by the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.ToByteArray%2A&gt;</ph> method from positive values include this extra zero-value byte.</source>
          <target state="translated">Matrizes de bytes criados pelo <ph id="ph1">&lt;xref:System.Numerics.BigInteger.ToByteArray%2A&gt;</ph> método de valores positivos incluir essa extra do valor de zero bytes.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.BigInteger">
          <source>Therefore, the <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> structure can successfully round-trip values by assigning them to, and then restoring them from, byte arrays, as the following example shows.</source>
          <target state="translated">Portanto, o <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> estrutura pode valores de ida e volta com êxito, atribuindo-lhes para e, em seguida, restaurá-los de matrizes de bytes, como mostra o exemplo a seguir.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.BigInteger">
          <source>However, you may need to add this additional zero-value byte to byte arrays that are created dynamically by the developer or that are returned by methods that convert unsigned integers to byte arrays (such as <ph id="ph1">&lt;xref:System.BitConverter.GetBytes%28System.UInt16%29?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.BitConverter.GetBytes%28System.UInt32%29?displayProperty=nameWithType&gt;</ph>, and <ph id="ph3">&lt;xref:System.BitConverter.GetBytes%28System.UInt64%29?displayProperty=nameWithType&gt;</ph>).</source>
          <target state="translated">No entanto, você precisará adicionar essa bytes adicional do valor de zero para matrizes de bytes que são criados dinamicamente pelo desenvolvedor ou que são retornados por métodos que convertem inteiros sem sinal em matrizes de bytes (como <ph id="ph1">&lt;xref:System.BitConverter.GetBytes%28System.UInt16%29?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.BitConverter.GetBytes%28System.UInt32%29?displayProperty=nameWithType&gt;</ph>, e <ph id="ph3">&lt;xref:System.BitConverter.GetBytes%28System.UInt64%29?displayProperty=nameWithType&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.BigInteger">
          <source>When parsing a hexadecimal string, the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%29?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29?displayProperty=nameWithType&gt;</ph> methods assume that if the most significant bit of the first byte in the string is set, or if the first hexadecimal digit of the string represents the lower four bits of a byte value, the value is represented by using two's complement representation.</source>
          <target state="translated">Ao analisar uma cadeia de caracteres hexadecimal de <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%29?displayProperty=nameWithType&gt;</ph> e <ph id="ph2">&lt;xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29?displayProperty=nameWithType&gt;</ph> métodos supõem que, se o bit mais significativo do primeiro byte na cadeia de caracteres é definido ou se o primeiro dígito hexadecimal da cadeia de caracteres representa quatro bits inferiores de um valor de byte, o valor é representado usando a representação de complemento de dois.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.BigInteger">
          <source>For example, both "FF01" and "F01" represent the decimal value -255.</source>
          <target state="translated">Por exemplo, "FF01" e "F01" representam o valor decimal-255.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.BigInteger">
          <source>To differentiate positive from negative values, positive values should include a leading zero.</source>
          <target state="translated">Para diferenciar positivo de valores negativos, a valores positivos devem incluir um zero à esquerda.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.BigInteger">
          <source>The relevant overloads of the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.ToString%2A&gt;</ph> method, when they are passed the "X" format string, add a leading zero to the returned hexadecimal string for positive values.</source>
          <target state="translated">As sobrecargas relevantes do <ph id="ph1">&lt;xref:System.Numerics.BigInteger.ToString%2A&gt;</ph> método, quando eles são passados de cadeia de caracteres de formato "X", adicione um zero à esquerda para a cadeia de caracteres hexadecimal retornado para valores positivos.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.BigInteger">
          <source>This makes it possible to round-trip <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> values by using the <ph id="ph2">&lt;xref:System.Numerics.BigInteger.ToString%2A&gt;</ph> and <ph id="ph3">&lt;xref:System.Numerics.BigInteger.Parse%2A&gt;</ph> methods, as the following example shows.</source>
          <target state="translated">Isso possibilita a viagem <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> valores usando o <ph id="ph2">&lt;xref:System.Numerics.BigInteger.ToString%2A&gt;</ph> e <ph id="ph3">&lt;xref:System.Numerics.BigInteger.Parse%2A&gt;</ph> métodos, como mostra o exemplo a seguir.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.BigInteger">
          <source>However, the hexadecimal strings created by calling the <ph id="ph1">`ToString`</ph> methods of the other integral types or the overloads of the <ph id="ph2">&lt;xref:System.Convert.ToString%2A&gt;</ph> method that include a <ph id="ph3">`toBase`</ph> parameter do not indicate the sign of the value or the source data type from which the hexadecimal string was derived.</source>
          <target state="translated">No entanto, as cadeias de caracteres hexadecimais é criado chamando o <ph id="ph1">`ToString`</ph> métodos de outros tipos integrais ou as sobrecargas do <ph id="ph2">&lt;xref:System.Convert.ToString%2A&gt;</ph> método que incluem um <ph id="ph3">`toBase`</ph> parâmetro não indicam o sinal do valor ou o tipo de dados de origem da qual deriva a cadeia de caracteres hexadecimal.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.BigInteger">
          <source>Successfully instantiating a <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> value from such a string requires some additional logic.</source>
          <target state="translated">Criando com êxito um <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> valor de uma cadeia de caracteres requer lógica adicional.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Numerics.BigInteger">
          <source>The following example provides one possible implementation.</source>
          <target state="translated">O exemplo a seguir fornece uma possível implementação.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" uid="T:System.Numerics.BigInteger">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> structure.</source>
          <target state="translated">Inicializa uma nova instância da estrutura <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.#ctor(System.Byte[])">
          <source>An array of byte values in little-endian order.</source>
          <target state="translated">Uma matriz de valores de bytes em ordem little endian.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.#ctor(System.Byte[])">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> structure using the values in a byte array.</source>
          <target state="translated">Inicializa uma nova instância da estrutura <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> usando os valores de uma matriz de bytes.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.#ctor(System.Byte[])">
          <source>The individual bytes in the <ph id="ph1">`value`</ph> array should be in little-endian order, from lowest-order byte to highest-order byte.</source>
          <target state="translated">Os bytes individuais a <ph id="ph1">`value`</ph> matriz deve estar na ordem de little endian, de byte de ordem inferior para byte de ordem mais alta.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.#ctor(System.Byte[])">
          <source>For example, the numeric value 1,000,000,000,000 is represented as shown in the following table:</source>
          <target state="translated">Por exemplo, o valor numérico 1.000.000.000.000 é representado como mostrado na tabela a seguir:</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.#ctor(System.Byte[])">
          <source>Hexadecimal string</source>
          <target state="translated">Cadeia de caracteres hexadecimal</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.#ctor(System.Byte[])">
          <source>E8D4A51000</source>
          <target state="translated">E8D4A51000</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.#ctor(System.Byte[])">
          <source>Byte array (lowest index first)</source>
          <target state="translated">Matriz de bytes (menor índice primeiro)</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.#ctor(System.Byte[])">
          <source>00 10 A5 D4 E8 00</source>
          <target state="translated">00 10 A5 D4 E8 00</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.#ctor(System.Byte[])">
          <source>Most methods that convert numeric values to byte arrays, such as <ph id="ph1">&lt;xref:System.Numerics.BigInteger.ToByteArray%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.BitConverter.GetBytes%2A?displayProperty=nameWithType&gt;</ph>, return byte arrays in little-endian order.</source>
          <target state="translated">A maioria dos métodos que convertem valores numéricos em matrizes de bytes, como <ph id="ph1">&lt;xref:System.Numerics.BigInteger.ToByteArray%2A?displayProperty=nameWithType&gt;</ph> e <ph id="ph2">&lt;xref:System.BitConverter.GetBytes%2A?displayProperty=nameWithType&gt;</ph>, retornam matrizes de bytes na ordem little endian.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.#ctor(System.Byte[])">
          <source>The constructor expects positive values in the byte array to use sign-and-magnitude representation, and negative values to use two's complement representation.</source>
          <target state="translated">O construtor espera valores positivos da matriz de bytes para usar representação de magnitude sinal e valores negativos para usar representação de complemento de dois.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.#ctor(System.Byte[])">
          <source>In other words, if the highest-order bit of the highest-order byte in <ph id="ph1">`value`</ph> is set, the resulting <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> value is negative.</source>
          <target state="translated">Em outras palavras, se a ordem mais alta de bits do byte de ordem mais alta no <ph id="ph1">`value`</ph> for definida, o resultante <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> valor é negativo.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.#ctor(System.Byte[])">
          <source>Depending on the source of the byte array, this may cause a positive value to be misinterpreted as a negative value.</source>
          <target state="translated">Dependendo da fonte da matriz do byte, isso pode causar um valor positivo para ser considerado como um valor negativo.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.#ctor(System.Byte[])">
          <source>Byte arrays are typically generated in the following ways:</source>
          <target state="translated">Matrizes de bytes normalmente são gerados das seguintes maneiras:</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.#ctor(System.Byte[])">
          <source>By calling the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.ToByteArray%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Chamando o <ph id="ph1">&lt;xref:System.Numerics.BigInteger.ToByteArray%2A?displayProperty=nameWithType&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.#ctor(System.Byte[])">
          <source>Because this method returns a byte array with the highest-order bit of the highest-order byte in the array set to zero for positive values, there is no chance of misinterpreting a positive value as negative.</source>
          <target state="translated">Como esse método retorna uma matriz de bytes com o bit de ordem mais alta do que o byte de ordem mais alta no conjunto de matriz para zero para valores positivos, não há nenhuma possibilidade de má interpretação um valor positivo como negativo.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.#ctor(System.Byte[])">
          <source>Unmodified byte arrays created by the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.ToByteArray%2A&gt;</ph> method always successfully round-trip when they are passed to the <ph id="ph2">&lt;xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29&gt;</ph> constructor.</source>
          <target state="translated">Sem modificações matrizes de bytes criados pelo <ph id="ph1">&lt;xref:System.Numerics.BigInteger.ToByteArray%2A&gt;</ph> método sempre com êxito ida e volta quando eles são passados para o <ph id="ph2">&lt;xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29&gt;</ph> construtor.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.#ctor(System.Byte[])">
          <source>By calling the <ph id="ph1">&lt;xref:System.BitConverter.GetBytes%2A?displayProperty=nameWithType&gt;</ph> method and passing it a signed integer as a parameter.</source>
          <target state="translated">Chamando o <ph id="ph1">&lt;xref:System.BitConverter.GetBytes%2A?displayProperty=nameWithType&gt;</ph> método e passá-lo em um inteiro com sinal como um parâmetro.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.#ctor(System.Byte[])">
          <source>Because signed integers handle both sign-and-magnitude representation and two's complement representation, there is no chance of misinterpreting a positive value as negative.</source>
          <target state="translated">Como inteiros com sinal de manipular a representação de magnitude logon e a representação de complemento de dois, não há nenhuma possibilidade de má interpretação um valor positivo como negativo.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.#ctor(System.Byte[])">
          <source>By calling the <ph id="ph1">&lt;xref:System.BitConverter.GetBytes%2A?displayProperty=nameWithType&gt;</ph> method and passing it an unsigned integer as a parameter.</source>
          <target state="translated">Chamando o <ph id="ph1">&lt;xref:System.BitConverter.GetBytes%2A?displayProperty=nameWithType&gt;</ph> método e passá-lo em um inteiro sem sinal como um parâmetro.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.#ctor(System.Byte[])">
          <source>Because unsigned integers are represented by their magnitude only, positive values can be misinterpreted as negative values.</source>
          <target state="translated">Como inteiros sem sinal são representados por sua magnitude apenas, valores positivos podem ser mal interpretados como valores negativos.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.#ctor(System.Byte[])">
          <source>To prevent this misinterpretation, you can add a zero-byte value to the end of the array.</source>
          <target state="translated">Para evitar essa interpretação incorreta, você pode adicionar um valor de zero bytes até o final da matriz.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.#ctor(System.Byte[])">
          <source>The example in the next section provides an illustration.</source>
          <target state="translated">O exemplo na próxima seção fornece uma ilustração.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.#ctor(System.Byte[])">
          <source>By creating a byte array either dynamically or statically without necessarily calling any of the previous methods, or by modifying an existing byte array.</source>
          <target state="translated">Criando uma matriz de bytes ou estática ou dinamicamente, sem necessariamente chamar qualquer um dos métodos anteriores ou modificando uma matriz de bytes existente.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.#ctor(System.Byte[])">
          <source>To prevent positive values from being misinterpreted as negative values, you can add a zero-byte value to the end of the array.</source>
          <target state="translated">Para impedir que valores positivos sejam interpretados incorretamente como valores negativos, você pode adicionar um valor de zero bytes até o final da matriz.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.#ctor(System.Byte[])">
          <source>If <ph id="ph1">`value`</ph> is an empty <ph id="ph2">&lt;xref:System.Byte&gt;</ph> array, the new <ph id="ph3">&lt;xref:System.Numerics.BigInteger&gt;</ph> object is initialized to a value of <ph id="ph4">&lt;xref:System.Numerics.BigInteger.Zero%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Se <ph id="ph1">`value`</ph> está vazio <ph id="ph2">&lt;xref:System.Byte&gt;</ph> matriz, o novo <ph id="ph3">&lt;xref:System.Numerics.BigInteger&gt;</ph> objeto é inicializado com um valor de <ph id="ph4">&lt;xref:System.Numerics.BigInteger.Zero%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.#ctor(System.Byte[])">
          <source>If <ph id="ph1">`value`</ph> is <ph id="ph2">`null`</ph>, the constructor throws an <ph id="ph3">&lt;xref:System.ArgumentNullException&gt;</ph>.</source>
          <target state="translated">Se <ph id="ph1">`value`</ph> é <ph id="ph2">`null`</ph>, o construtor lançará um <ph id="ph3">&lt;xref:System.ArgumentNullException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.#ctor(System.Byte[])">
          <source>The following example instantiates a <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> object from a 5-element byte array whose value is {5, 4, 3, 2, 1}.</source>
          <target state="translated">O exemplo a seguir cria um <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> objeto a partir de uma matriz de bytes de 5 elemento cujo valor é {5, 4, 3, 2, 1}.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.#ctor(System.Byte[])">
          <source>It then displays the <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> value, represented as both decimal and hexadecimal numbers, to the console.</source>
          <target state="translated">Em seguida, exibe o <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> valor, representado como números decimais e hexadecimais, no console.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.#ctor(System.Byte[])">
          <source>A comparison of the input array with the text output makes it clear why this overload of the <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> class constructor creates a <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> object whose value is 4328719365 (or 0x102030405).</source>
          <target state="translated">Uma comparação de matriz de entrada com a saída de texto deixa claro por que esta sobrecarga do <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> construtor da classe cria um <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> objeto cujo valor é 4328719365 (ou 0x102030405).</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.#ctor(System.Byte[])">
          <source>The first element of the byte array, whose value is 5, defines the value of the lowest-order byte of the <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> object, which is 0x05.</source>
          <target state="translated">O primeiro elemento da matriz de bytes, cujo valor é 5, define o valor do byte de ordem inferior a <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> objeto, que é 0x05.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.#ctor(System.Byte[])">
          <source>The second element of the byte array, whose value is 4, defines the value of the second byte of the <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> object, which is 0x04, and so on.</source>
          <target state="translated">O segundo elemento da matriz de bytes, cujo valor é 4, define o valor do byte do segundo o <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> objeto, que é 0x04 e assim por diante.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.#ctor(System.Byte[])">
          <source>The following example instantiates a positive and a negative <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> value, passes them to the <ph id="ph2">&lt;xref:System.Numerics.BigInteger.ToByteArray%2A&gt;</ph> method, and then restores the original <ph id="ph3">&lt;xref:System.Numerics.BigInteger&gt;</ph> values from the resulting byte array.</source>
          <target state="translated">O exemplo a seguir cria um positivo e um negativo <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> valor, passa para o <ph id="ph2">&lt;xref:System.Numerics.BigInteger.ToByteArray%2A&gt;</ph> método e, em seguida, restaura o original <ph id="ph3">&lt;xref:System.Numerics.BigInteger&gt;</ph> valores da matriz de bytes resultante.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.#ctor(System.Byte[])">
          <source>Note that the two values are represented by identical byte arrays.</source>
          <target state="translated">Observe que os dois valores são representados pelo matrizes de bytes idênticos.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.#ctor(System.Byte[])">
          <source>The only difference between them is in the most significant bit of the last element in the byte array.</source>
          <target state="translated">A única diferença entre eles é em que o bit mais significativo do último elemento da matriz de bytes.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.#ctor(System.Byte[])">
          <source>This bit is set (the value of the byte is 0xFF) if the array is created from a negative <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> value.</source>
          <target state="translated">Esse bit estiver definido (o valor do byte é 0xFF) se a matriz é criada a partir de um resultado negativo <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> valor.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.#ctor(System.Byte[])">
          <source>The bit is not set (the value of the byte is zero), if the array is created from a positive <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> value.</source>
          <target state="translated">O bits não estiver definido (o valor do byte será zero), se a matriz é criada a partir de um positivo <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> valor.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.#ctor(System.Byte[])">
          <source>The following example illustrates how to make sure that a positive value is not incorrectly instantiated as a negative value by adding a byte whose value is zero to the end of the array.</source>
          <target state="translated">O exemplo a seguir ilustra como certificar-se de que um valor positivo não é incorretamente instanciado como um valor negativo, adicionando um byte cujo valor é zero para o final da matriz.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.#ctor(System.Byte[])">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.#ctor(System.Decimal)">
          <source>A decimal number.</source>
          <target state="translated">Um número decimal.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.#ctor(System.Decimal)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> structure using a <ph id="ph2">&lt;see cref="T:System.Decimal" /&gt;</ph> value.</source>
          <target state="translated">Inicializa uma nova instância da estrutura <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> usando um valor <ph id="ph2">&lt;see cref="T:System.Decimal" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.#ctor(System.Decimal)">
          <source>The result of calling this constructor is identical to explicitly assigning a <ph id="ph1">&lt;xref:System.Decimal&gt;</ph> value to a <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> variable.</source>
          <target state="translated">O resultado de chamar este construtor é idêntico ao atribuir explicitamente um <ph id="ph1">&lt;xref:System.Decimal&gt;</ph> valor para um <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> variável.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.#ctor(System.Decimal)">
          <source>Calling this constructor can cause data loss; any fractional part of <ph id="ph1">`value`</ph> is truncated when instantiating a <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> object.</source>
          <target state="translated">Chamar este construtor pode causar perda de dados; qualquer parte fracionária <ph id="ph1">`value`</ph> é truncado ao instanciar um <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.#ctor(System.Decimal)">
          <source>The following example illustrates the use of the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.%23ctor%28System.Decimal%29&gt;</ph> constructor to instantiate a <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> object.</source>
          <target state="translated">O exemplo a seguir ilustra o uso do <ph id="ph1">&lt;xref:System.Numerics.BigInteger.%23ctor%28System.Decimal%29&gt;</ph> construtor para instanciar um <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.#ctor(System.Decimal)">
          <source>It defines an array of <ph id="ph1">&lt;xref:System.Decimal&gt;</ph> values, and then passes each value to the <ph id="ph2">&lt;xref:System.Numerics.BigInteger.%23ctor%28System.Decimal%29&gt;</ph> constructor.</source>
          <target state="translated">Define uma matriz de <ph id="ph1">&lt;xref:System.Decimal&gt;</ph> valores e, em seguida, passa cada valor com o <ph id="ph2">&lt;xref:System.Numerics.BigInteger.%23ctor%28System.Decimal%29&gt;</ph> construtor.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.#ctor(System.Decimal)">
          <source>Note that the <ph id="ph1">&lt;xref:System.Decimal&gt;</ph> value is truncated instead of rounded when it is assigned to the <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> object.</source>
          <target state="translated">Observe que o <ph id="ph1">&lt;xref:System.Decimal&gt;</ph> valor é truncado em vez de arredondado quando ele está atribuído a <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.#ctor(System.Double)">
          <source>A double-precision floating-point value.</source>
          <target state="translated">Um valor de ponto flutuante de precisão dupla.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.#ctor(System.Double)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> structure using a double-precision floating-point value.</source>
          <target state="translated">Inicializa uma nova instância de estrutura <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> usando um valor de ponto flutuante de precisão dupla.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.#ctor(System.Double)">
          <source>Any fractional part of the <ph id="ph1">`value`</ph> parameter is truncated when instantiating a <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> object.</source>
          <target state="translated">Qualquer parte fracionária do <ph id="ph1">`value`</ph> parâmetro será truncado ao instanciar um <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.#ctor(System.Double)">
          <source>Because of the lack of precision of the <ph id="ph1">&lt;xref:System.Double&gt;</ph> data type, calling this constructor can cause data loss.</source>
          <target state="translated">Devido à falta de precisão do <ph id="ph1">&lt;xref:System.Double&gt;</ph> tipo de dados, chamar este construtor pode causar perda de dados.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.#ctor(System.Double)">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> value that results from calling this constructor is identical to the value that results from explicitly assigning a <ph id="ph2">&lt;xref:System.Double&gt;</ph> value to a <ph id="ph3">&lt;xref:System.Numerics.BigInteger&gt;</ph>.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> valor resultante da chamada a este construtor é idêntico ao valor resultante da atribuição explicitamente um <ph id="ph2">&lt;xref:System.Double&gt;</ph> valor para um <ph id="ph3">&lt;xref:System.Numerics.BigInteger&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.#ctor(System.Double)">
          <source>The following example illustrates the use of the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.%23ctor%28System.Double%29&gt;</ph> constructor to instantiate a <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> object.</source>
          <target state="translated">O exemplo a seguir ilustra o uso do <ph id="ph1">&lt;xref:System.Numerics.BigInteger.%23ctor%28System.Double%29&gt;</ph> construtor para instanciar um <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.#ctor(System.Double)">
          <source>It also illustrates the loss of precision that may occur when you use the <ph id="ph1">&lt;xref:System.Double&gt;</ph> data type.</source>
          <target state="translated">Ele também ilustra a perda de precisão que pode ocorrer quando você usa o <ph id="ph1">&lt;xref:System.Double&gt;</ph> tipo de dados.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.#ctor(System.Double)">
          <source>A <ph id="ph1">&lt;xref:System.Double&gt;</ph> is assigned a large value, which is then assigned to a <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> object.</source>
          <target state="translated">Um <ph id="ph1">&lt;xref:System.Double&gt;</ph> é atribuído um valor grande, que é atribuído a um <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.#ctor(System.Double)">
          <source>As the output shows, this assignment involves a loss of precision.</source>
          <target state="translated">Como mostra a saída, essa atribuição envolve uma perda de precisão.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.#ctor(System.Double)">
          <source>Both values are then incremented by one.</source>
          <target state="translated">Os dois valores, em seguida, são incrementados em um.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.#ctor(System.Double)">
          <source>The output shows that the <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> object reflects the changed value, whereas the <ph id="ph2">&lt;xref:System.Double&gt;</ph> object does not.</source>
          <target state="translated">A saída mostra que o <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> objeto reflete o valor alterado, enquanto o <ph id="ph2">&lt;xref:System.Double&gt;</ph> objeto não.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.#ctor(System.Double)">
          <source>The value of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see cref="F:System.Double.NaN" /&gt;</ph>.</source>
          <target state="translated">O valor de <ph id="ph1">&lt;paramref name="value" /&gt;</ph> é <ph id="ph2">&lt;see cref="F:System.Double.NaN" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.#ctor(System.Double)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.#ctor(System.Double)">
          <source>The value of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see cref="F:System.Double.NegativeInfinity" /&gt;</ph>.</source>
          <target state="translated">O valor de <ph id="ph1">&lt;paramref name="value" /&gt;</ph> é <ph id="ph2">&lt;see cref="F:System.Double.NegativeInfinity" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.#ctor(System.Double)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.#ctor(System.Double)">
          <source>The value of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see cref="F:System.Double.PositiveInfinity" /&gt;</ph>.</source>
          <target state="translated">O valor de <ph id="ph1">&lt;paramref name="value" /&gt;</ph> é <ph id="ph2">&lt;see cref="F:System.Double.PositiveInfinity" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.#ctor(System.Int32)">
          <source>A 32-bit signed integer.</source>
          <target state="translated">Um inteiro com sinal de 32 bits.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.#ctor(System.Int32)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> structure using a 32-bit signed integer value.</source>
          <target state="translated">Inicializa uma nova instância da estrutura <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> usando um valor inteiro com sinal de 32 bits.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.#ctor(System.Int32)">
          <source>There is no loss of precision when instantiating a <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> object by using this constructor.</source>
          <target state="translated">Há nenhuma perda de precisão ao instanciar um <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> objeto usando este construtor.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.#ctor(System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> value that results from calling this constructor is identical to the value that results from assigning an <ph id="ph2">&lt;xref:System.Int32&gt;</ph> value to a <ph id="ph3">&lt;xref:System.Numerics.BigInteger&gt;</ph>.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> valor resultante da chamada a este construtor é idêntico ao valor resultante da atribuição de um <ph id="ph2">&lt;xref:System.Int32&gt;</ph> valor para um <ph id="ph3">&lt;xref:System.Numerics.BigInteger&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.#ctor(System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> structure does not include constructors with a parameter of type <ph id="ph2">&lt;xref:System.Byte&gt;</ph>, <ph id="ph3">&lt;xref:System.Int16&gt;</ph>, <ph id="ph4">&lt;xref:System.SByte&gt;</ph>, or <ph id="ph5">&lt;xref:System.UInt16&gt;</ph>.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> estrutura não tem construtores com um parâmetro de tipo <ph id="ph2">&lt;xref:System.Byte&gt;</ph>, <ph id="ph3">&lt;xref:System.Int16&gt;</ph>, <ph id="ph4">&lt;xref:System.SByte&gt;</ph>, ou <ph id="ph5">&lt;xref:System.UInt16&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.#ctor(System.Int32)">
          <source>However, the <ph id="ph1">&lt;xref:System.Int32&gt;</ph> type supports the implicit conversion of 8-bit and 16-bit signed and unsigned integers to signed 32-bit integers.</source>
          <target state="translated">No entanto, o <ph id="ph1">&lt;xref:System.Int32&gt;</ph> tipo oferece suporte à conversão implícita de 8 e 16 bits inteiros assinados e para inteiros de 32 bits com sinal.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.#ctor(System.Int32)">
          <source>As a result, this constructor is called if <ph id="ph1">`value`</ph> is any one of these four integral types.</source>
          <target state="translated">Como resultado, este construtor é chamado se <ph id="ph1">`value`</ph> é qualquer um destes quatro tipos integrais.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.#ctor(System.Int32)">
          <source>The following example calls the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.%23ctor%28System.Int32%29&gt;</ph> constructor to instantiate <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> values from an array of 32-bit integers.</source>
          <target state="translated">A exemplo a seguir chama o <ph id="ph1">&lt;xref:System.Numerics.BigInteger.%23ctor%28System.Int32%29&gt;</ph> construtor para instanciar <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> valores de uma matriz de inteiros de 32 bits.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.#ctor(System.Int32)">
          <source>It also uses implicit conversion to assign each 32-bit integer value to a <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> variable.</source>
          <target state="translated">Ele também usa a conversão implícita para atribuir a cada valor de inteiro de 32 bits para um <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> variável.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.#ctor(System.Int32)">
          <source>It then compares the two values to establish that the resulting <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> values are the same.</source>
          <target state="translated">Ele então compara os dois valores para estabelecer que resultante <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> valores são os mesmos.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.#ctor(System.Int64)">
          <source>A 64-bit signed integer.</source>
          <target state="translated">Um inteiro com sinal de 64 bits.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.#ctor(System.Int64)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> structure using a 64-bit signed integer value.</source>
          <target state="translated">Inicializa uma nova instância da estrutura <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> usando um valor inteiro com sinal de 64 bits.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.#ctor(System.Int64)">
          <source>There is no loss of precision when instantiating a <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> object by using this constructor.</source>
          <target state="translated">Há nenhuma perda de precisão ao instanciar um <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> objeto usando este construtor.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.#ctor(System.Int64)">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> value that results from calling this constructor is identical to the value that results from assigning an <ph id="ph2">&lt;xref:System.Int64&gt;</ph> value to a <ph id="ph3">&lt;xref:System.Numerics.BigInteger&gt;</ph>.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> valor resultante da chamada a este construtor é idêntico ao valor resultante da atribuição de um <ph id="ph2">&lt;xref:System.Int64&gt;</ph> valor para um <ph id="ph3">&lt;xref:System.Numerics.BigInteger&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.#ctor(System.Int64)">
          <source>The following example calls the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.%23ctor%28System.Int64%29&gt;</ph> constructor to instantiate <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> values from an array of 64-bit integers.</source>
          <target state="translated">A exemplo a seguir chama o <ph id="ph1">&lt;xref:System.Numerics.BigInteger.%23ctor%28System.Int64%29&gt;</ph> construtor para instanciar <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> valores de uma matriz de inteiros de 64 bits.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.#ctor(System.Int64)">
          <source>It also uses implicit conversion to assign each 64-bit integer value to a <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> variable.</source>
          <target state="translated">Ele também usa a conversão implícita para atribuir a cada valor de inteiro de 64 bits com um <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> variável.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.#ctor(System.Int64)">
          <source>It then compares the two values to establish that the resulting <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> values are the same.</source>
          <target state="translated">Ele então compara os dois valores para estabelecer que resultante <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> valores são os mesmos.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.#ctor(System.Single)">
          <source>A single-precision floating-point value.</source>
          <target state="translated">Um valor de ponto flutuante de precisão simples.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.#ctor(System.Single)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> structure using a single-precision floating-point value.</source>
          <target state="translated">Inicializa uma nova instância da estrutura <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> usando um valor de ponto flutuante de precisão simples.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.#ctor(System.Single)">
          <source>Any fractional part of the <ph id="ph1">`value`</ph> parameter is truncated when instantiating a <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> object.</source>
          <target state="translated">Qualquer parte fracionária do <ph id="ph1">`value`</ph> parâmetro será truncado ao instanciar um <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.#ctor(System.Single)">
          <source>Because of the lack of precision of the <ph id="ph1">&lt;xref:System.Single&gt;</ph> data type, calling this constructor can result in data loss.</source>
          <target state="translated">Devido à falta de precisão do <ph id="ph1">&lt;xref:System.Single&gt;</ph> tipo de dados, chamar este construtor pode resultar em perda de dados.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.#ctor(System.Single)">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> value that results from calling this constructor is identical to the value that results from explicitly assigning a <ph id="ph2">&lt;xref:System.Single&gt;</ph> value to a <ph id="ph3">&lt;xref:System.Numerics.BigInteger&gt;</ph>.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> valor resultante da chamada a este construtor é idêntico ao valor resultante da atribuição explicitamente um <ph id="ph2">&lt;xref:System.Single&gt;</ph> valor para um <ph id="ph3">&lt;xref:System.Numerics.BigInteger&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.#ctor(System.Single)">
          <source>The following example illustrates the use of the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.%23ctor%28System.Single%29&gt;</ph> constructor to instantiate a <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> object.</source>
          <target state="translated">O exemplo a seguir ilustra o uso do <ph id="ph1">&lt;xref:System.Numerics.BigInteger.%23ctor%28System.Single%29&gt;</ph> construtor para instanciar um <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.#ctor(System.Single)">
          <source>It also illustrates the loss of precision that may occur when you use the <ph id="ph1">&lt;xref:System.Single&gt;</ph> data type.</source>
          <target state="translated">Ele também ilustra a perda de precisão que pode ocorrer quando você usa o <ph id="ph1">&lt;xref:System.Single&gt;</ph> tipo de dados.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.#ctor(System.Single)">
          <source>A <ph id="ph1">&lt;xref:System.Single&gt;</ph> is assigned a large negative value, which is then assigned to a <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> object.</source>
          <target state="translated">Um <ph id="ph1">&lt;xref:System.Single&gt;</ph> é atribuído um valor negativo grande, que é atribuído a um <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.#ctor(System.Single)">
          <source>As the output shows, this assignment involves a loss of precision.</source>
          <target state="translated">Como mostra a saída, essa atribuição envolve uma perda de precisão.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.#ctor(System.Single)">
          <source>Both values are then incremented by one.</source>
          <target state="translated">Os dois valores, em seguida, são incrementados em um.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.#ctor(System.Single)">
          <source>The output shows that the <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> object reflects the changed value, whereas the <ph id="ph2">&lt;xref:System.Single&gt;</ph> object does not.</source>
          <target state="translated">A saída mostra que o <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> objeto reflete o valor alterado, enquanto o <ph id="ph2">&lt;xref:System.Single&gt;</ph> objeto não.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.#ctor(System.Single)">
          <source>The value of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see cref="F:System.Single.NaN" /&gt;</ph>.</source>
          <target state="translated">O valor de <ph id="ph1">&lt;paramref name="value" /&gt;</ph> é <ph id="ph2">&lt;see cref="F:System.Single.NaN" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.#ctor(System.Single)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.#ctor(System.Single)">
          <source>The value of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see cref="F:System.Single.NegativeInfinity" /&gt;</ph>.</source>
          <target state="translated">O valor de <ph id="ph1">&lt;paramref name="value" /&gt;</ph> é <ph id="ph2">&lt;see cref="F:System.Single.NegativeInfinity" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.#ctor(System.Single)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.#ctor(System.Single)">
          <source>The value of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see cref="F:System.Single.PositiveInfinity" /&gt;</ph>.</source>
          <target state="translated">O valor de <ph id="ph1">&lt;paramref name="value" /&gt;</ph> é <ph id="ph2">&lt;see cref="F:System.Single.PositiveInfinity" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.#ctor(System.UInt32)">
          <source>An unsigned 32-bit integer value.</source>
          <target state="translated">Um valor inteiro de 32 bits sem sinal.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.#ctor(System.UInt32)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> structure using an unsigned 32-bit integer value.</source>
          <target state="translated">Inicializa uma nova instância da estrutura <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> usando um valor inteiro de 32 bits sem sinal.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.#ctor(System.UInt32)">
          <source>There is no loss of precision when instantiating a <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> using this constructor.</source>
          <target state="translated">Há nenhuma perda de precisão ao instanciar um <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> usando este construtor.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.#ctor(System.UInt32)">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> value that results from calling this constructor is identical to the value that results from assigning a <ph id="ph2">&lt;xref:System.UInt32&gt;</ph> value to a <ph id="ph3">&lt;xref:System.Numerics.BigInteger&gt;</ph>.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> valor resultante da chamada a este construtor é idêntico ao valor resultante da atribuição de um <ph id="ph2">&lt;xref:System.UInt32&gt;</ph> valor para um <ph id="ph3">&lt;xref:System.Numerics.BigInteger&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.#ctor(System.UInt32)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.%23ctor%28System.UInt32%29&gt;</ph> constructor and an assignment statement to initialize <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> values from an array of unsigned 32-bit integers.</source>
          <target state="translated">O exemplo a seguir usa o <ph id="ph1">&lt;xref:System.Numerics.BigInteger.%23ctor%28System.UInt32%29&gt;</ph> construtor e uma instrução de atribuição para inicializar <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> valores de uma matriz de inteiros de 32 bits sem sinal.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.#ctor(System.UInt32)">
          <source>It then compares the two values to demonstrate that the two methods of initializing a <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> value produce identical results.</source>
          <target state="translated">Em seguida, compara os dois valores para demonstrar que os dois métodos de inicializar um <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> valor produzir resultados idênticos.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.#ctor(System.UInt64)">
          <source>An unsigned 64-bit integer.</source>
          <target state="translated">Um inteiro de 64 bits sem sinal.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.#ctor(System.UInt64)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> structure with an unsigned 64-bit integer value.</source>
          <target state="translated">Inicializa uma nova instância da estrutura <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> com um valor inteiro de 64 bits sem sinal.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.#ctor(System.UInt64)">
          <source>There is no loss of precision when instantiating a <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> using this constructor.</source>
          <target state="translated">Há nenhuma perda de precisão ao instanciar um <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> usando este construtor.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.#ctor(System.UInt64)">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> value that results from calling this constructor is identical to the value that results from assigning a <ph id="ph2">&lt;xref:System.UInt64&gt;</ph> value to a <ph id="ph3">&lt;xref:System.Numerics.BigInteger&gt;</ph>.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> valor resultante da chamada a este construtor é idêntico ao valor resultante da atribuição de um <ph id="ph2">&lt;xref:System.UInt64&gt;</ph> valor para um <ph id="ph3">&lt;xref:System.Numerics.BigInteger&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.#ctor(System.UInt64)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.%23ctor%28System.UInt64%29&gt;</ph> constructor to instantiate a <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> object whose value is equal to <ph id="ph3">&lt;xref:System.UInt64.MaxValue&gt;</ph>.</source>
          <target state="translated">O exemplo a seguir usa o <ph id="ph1">&lt;xref:System.Numerics.BigInteger.%23ctor%28System.UInt64%29&gt;</ph> construtor para instanciar um <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> objeto cujo valor é igual a <ph id="ph3">&lt;xref:System.UInt64.MaxValue&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.Abs(System.Numerics.BigInteger)">
          <source>A number.</source>
          <target state="translated">Um número.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.Abs(System.Numerics.BigInteger)">
          <source>Gets the absolute value of a <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> object.</source>
          <target state="translated">Obtém o valor absoluto de um objeto <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.Abs(System.Numerics.BigInteger)">
          <source>The absolute value of <ph id="ph1">&lt;paramref name="value" /&gt;</ph>.</source>
          <target state="translated">O valor absoluto de <ph id="ph1">&lt;paramref name="value" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Abs(System.Numerics.BigInteger)">
          <source>The absolute value of a number is that number without its sign, as shown in the following table.</source>
          <target state="translated">O valor absoluto de um número é o número sem sinal, como mostrado na tabela a seguir.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Abs(System.Numerics.BigInteger)">
          <source><ph id="ph1">`value`</ph> parameter</source>
          <target state="translated">Parâmetro <ph id="ph1">`value`</ph></target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Abs(System.Numerics.BigInteger)">
          <source>Return value</source>
          <target state="translated">Valor retornado</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Abs(System.Numerics.BigInteger)">
          <source><ph id="ph1">`value`</ph> &gt;= 0</source>
          <target state="translated"><ph id="ph1">`value`</ph> &gt;= 0</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Abs(System.Numerics.BigInteger)">
          <source><ph id="ph1">`value`</ph> &lt; 0</source>
          <target state="translated"><ph id="ph1">`value`</ph> &lt; 0</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Abs(System.Numerics.BigInteger)">
          <source><ph id="ph1">`value`</ph> * -1</source>
          <target state="translated"><ph id="ph1">`value`</ph> * -1</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Abs(System.Numerics.BigInteger)">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Abs%2A&gt;</ph> method is equivalent to the <ph id="ph2">&lt;xref:System.Math.Abs%2A?displayProperty=nameWithType&gt;</ph> method for the primitive numeric types.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Abs%2A&gt;</ph> método é equivalente a <ph id="ph2">&lt;xref:System.Math.Abs%2A?displayProperty=nameWithType&gt;</ph> método para os tipos numéricos primitivo.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Abs(System.Numerics.BigInteger)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Abs%2A&gt;</ph> method to convert a <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> value from two's complement representation to sign-and-magnitude representation before serializing it to a file.</source>
          <target state="translated">O exemplo a seguir usa o <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Abs%2A&gt;</ph> método para converter um <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> valor de representação de complemento de dois a representação de entrada e magnitude antes serializá-lo para um arquivo.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Abs(System.Numerics.BigInteger)">
          <source>Data in the file is then deserialized and assigned to a new <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> object.</source>
          <target state="translated">Os dados no arquivo são desserializados e atribuídos a um novo <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.Add(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>The first value to add.</source>
          <target state="translated">O primeiro valor a ser adicionado.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.Add(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>The second value to add.</source>
          <target state="translated">O segundo valor a ser adicionado.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.Add(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>Adds two <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> values and returns the result.</source>
          <target state="translated">Adiciona dois valores de <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> e retorna o resultado.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.Add(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>The sum of <ph id="ph1">&lt;paramref name="left" /&gt;</ph> and <ph id="ph2">&lt;paramref name="right" /&gt;</ph>.</source>
          <target state="translated">A soma de <ph id="ph1">&lt;paramref name="left" /&gt;</ph> e <ph id="ph2">&lt;paramref name="right" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Add(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>Languages that do not support operator overloading or custom operators can use the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Add%2A&gt;</ph> method to perform addition using <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> values.</source>
          <target state="translated">Idiomas que não dão suporte a sobrecarga de operador ou operadores personalizados podem usar o <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Add%2A&gt;</ph> método para executar a adição usando <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> valores.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Add(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Add%2A&gt;</ph> method is a useful substitute for the addition operator when instantiating a <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> variable by assigning it a sum that results from addition, as shown in the following example.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Add%2A&gt;</ph> método é um substituto úteis para o operador de adição ao instanciar um <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> variável atribuindo a ele uma soma resultante da adição, conforme mostrado no exemplo a seguir.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.Compare(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>The first value to compare.</source>
          <target state="translated">O primeiro valor a ser comparado.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.Compare(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>The second value to compare.</source>
          <target state="translated">O segundo valor a ser comparado.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.Compare(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>Compares two <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> values and returns an integer that indicates whether the first value is less than, equal to, or greater than the second value.</source>
          <target state="translated">Compara dois valores <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> e retorna um inteiro que indica se o primeiro valor é menor que, igual a ou maior que o segundo valor.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.Compare(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>A signed integer that indicates the relative values of <ph id="ph1">&lt;paramref name="left" /&gt;</ph> and <ph id="ph2">&lt;paramref name="right" /&gt;</ph>, as shown in the following table.</source>
          <target state="translated">Um inteiro assinado que indica os valores relativos de <ph id="ph1">&lt;paramref name="left" /&gt;</ph> e <ph id="ph2">&lt;paramref name="right" /&gt;</ph>, conforme mostrado na tabela a seguir.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.Compare(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Value</source>
          <target state="translated"><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Valor</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.Compare(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Condition</source>
          <target state="translated">Condição <ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph></target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.Compare(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Less than zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Menor que zero</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.Compare(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="left" /&gt;</ph> is less than <ph id="ph4">&lt;paramref name="right" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="left" /&gt;</ph> é menor que <ph id="ph4">&lt;paramref name="right" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.Compare(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Zero</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.Compare(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="left" /&gt;</ph> equals <ph id="ph4">&lt;paramref name="right" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="left" /&gt;</ph> é igual a <ph id="ph4">&lt;paramref name="right" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.Compare(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Greater than zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Maior que zero</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.Compare(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="left" /&gt;</ph> is greater than <ph id="ph4">&lt;paramref name="right" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="left" /&gt;</ph> é maior que <ph id="ph4">&lt;paramref name="right" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Compare(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>Although the <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> type has no fixed range, comparisons of <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> values are not characterized by the lack of precision that characterizes the comparison of floating-point numbers.</source>
          <target state="translated">Embora o <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> tipo não tem nenhum intervalo fixo, as comparações de <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> valores não são caracterizados por falta de precisão que caracteriza a comparação de números de ponto flutuante.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Compare(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>The following example compares two <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> values that differ by one and that each have 1,896 digits.</source>
          <target state="translated">O exemplo a seguir compara dois <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> valores que diferenciam um e que cada um tem 1,896 dígitos.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Compare(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Compare%2A&gt;</ph> method correctly reports that the two values are not equal.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Compare%2A&gt;</ph> método corretamente relata que os dois valores não são iguais.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" uid="T:System.Numerics.BigInteger">
          <source>Compares the value of this instance with another value and returns an integer that indicates whether the value of this instance is less than, equal to, or greater than the other value.</source>
          <target state="translated">Compara o valor desta instância com outro valor e retorna um inteiro que indica se o valor desta instância é menor, igual ou maior que o outro valor.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.CompareTo(System.Int64)">
          <source>The signed 64-bit integer to compare.</source>
          <target state="translated">O inteiro com sinal de 64 bits para comparar.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.CompareTo(System.Int64)">
          <source>Compares this instance to a signed 64-bit integer and returns an integer that indicates whether the value of this instance is less than, equal to, or greater than the value of the signed 64-bit integer.</source>
          <target state="translated">Compara essa instância a um inteiro com sinal de 64 bits e retorna um inteiro que indica se o valor dessa instância é menor, igual ou maior que o valor do inteiro com sinal de 64 bits.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.CompareTo(System.Int64)">
          <source>A signed integer value that indicates the relationship of this instance to <ph id="ph1">&lt;paramref name="other" /&gt;</ph>, as shown in the following table.</source>
          <target state="translated">Um valor de inteiro com sinal que indica a relação desta instância com <ph id="ph1">&lt;paramref name="other" /&gt;</ph>, conforme mostrado na tabela a seguir.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.CompareTo(System.Int64)">
          <source><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Return value</source>
          <target state="translated"><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Valor retornado</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.CompareTo(System.Int64)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Description</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Descrição</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.CompareTo(System.Int64)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Less than zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Menor que zero</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.CompareTo(System.Int64)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> The current instance is less than <ph id="ph3">&lt;paramref name="other" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> A instância atual é menor que <ph id="ph3">&lt;paramref name="other" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.CompareTo(System.Int64)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Zero</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.CompareTo(System.Int64)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> The current instance equals <ph id="ph3">&lt;paramref name="other" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> A instância atual é igual a <ph id="ph3">&lt;paramref name="other" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.CompareTo(System.Int64)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Greater than zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Maior que zero</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.CompareTo(System.Int64)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> The current instance is greater than <ph id="ph3">&lt;paramref name="other" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> A instância atual é maior que <ph id="ph3">&lt;paramref name="other" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.CompareTo(System.Int64)">
          <source>If <ph id="ph1">`other`</ph> is a <ph id="ph2">&lt;xref:System.Byte&gt;</ph>, <ph id="ph3">&lt;xref:System.Int16&gt;</ph>, <ph id="ph4">&lt;xref:System.Int32&gt;</ph>, <ph id="ph5">&lt;xref:System.SByte&gt;</ph>, <ph id="ph6">&lt;xref:System.UInt16&gt;</ph>, or <ph id="ph7">&lt;xref:System.UInt32&gt;</ph> value, it is implicitly converted to an <ph id="ph8">&lt;xref:System.Int64&gt;</ph> value when the <ph id="ph9">&lt;xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29&gt;</ph> method is called.</source>
          <target state="translated">Se <ph id="ph1">`other`</ph> é um <ph id="ph2">&lt;xref:System.Byte&gt;</ph>, <ph id="ph3">&lt;xref:System.Int16&gt;</ph>, <ph id="ph4">&lt;xref:System.Int32&gt;</ph>, <ph id="ph5">&lt;xref:System.SByte&gt;</ph>, <ph id="ph6">&lt;xref:System.UInt16&gt;</ph>, ou <ph id="ph7">&lt;xref:System.UInt32&gt;</ph> valor, ele é convertido implicitamente em um <ph id="ph8">&lt;xref:System.Int64&gt;</ph> valor quando o <ph id="ph9">&lt;xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29&gt;</ph> método é chamado.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.CompareTo(System.Int64)">
          <source>The following example illustrates the result of calling the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29&gt;</ph> method with integral values.</source>
          <target state="translated">O exemplo a seguir ilustra o resultado de chamar o <ph id="ph1">&lt;xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29&gt;</ph> método com valores inteiros.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.CompareTo(System.Numerics.BigInteger)">
          <source>The object to compare.</source>
          <target state="translated">O objeto a ser comparado.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.CompareTo(System.Numerics.BigInteger)">
          <source>Compares this instance to a second <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> and returns an integer that indicates whether the value of this instance is less than, equal to, or greater than the value of the specified object.</source>
          <target state="translated">Compara esta instância a um segundo <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> e retorna um inteiro que indica se o valor desta instância é menor, igual ou maior que o valor do objeto especificado.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.CompareTo(System.Numerics.BigInteger)">
          <source>A signed integer value that indicates the relationship of this instance to <ph id="ph1">&lt;paramref name="other" /&gt;</ph>, as shown in the following table.</source>
          <target state="translated">Um valor de inteiro com sinal que indica a relação desta instância com <ph id="ph1">&lt;paramref name="other" /&gt;</ph>, conforme mostrado na tabela a seguir.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.CompareTo(System.Numerics.BigInteger)">
          <source><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Return value</source>
          <target state="translated"><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Valor retornado</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.CompareTo(System.Numerics.BigInteger)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Description</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Descrição</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.CompareTo(System.Numerics.BigInteger)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Less than zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Menor que zero</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.CompareTo(System.Numerics.BigInteger)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> The current instance is less than <ph id="ph3">&lt;paramref name="other" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> A instância atual é menor que <ph id="ph3">&lt;paramref name="other" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.CompareTo(System.Numerics.BigInteger)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Zero</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.CompareTo(System.Numerics.BigInteger)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> The current instance equals <ph id="ph3">&lt;paramref name="other" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> A instância atual é igual a <ph id="ph3">&lt;paramref name="other" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.CompareTo(System.Numerics.BigInteger)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Greater than zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Maior que zero</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.CompareTo(System.Numerics.BigInteger)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> The current instance is greater than <ph id="ph3">&lt;paramref name="other" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> A instância atual é maior que <ph id="ph3">&lt;paramref name="other" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.CompareTo(System.Numerics.BigInteger)">
          <source>This overload of the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.CompareTo%2A&gt;</ph> method implements the <ph id="ph2">&lt;xref:System.IComparable%601.CompareTo%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Esta sobrecarga do <ph id="ph1">&lt;xref:System.Numerics.BigInteger.CompareTo%2A&gt;</ph> método implementa o <ph id="ph2">&lt;xref:System.IComparable%601.CompareTo%2A?displayProperty=nameWithType&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.CompareTo(System.Numerics.BigInteger)">
          <source>It is used by generic collection objects to order the items in the collection.</source>
          <target state="translated">Ele é usado pelos objetos de coleção genérica para ordenar os itens na coleção.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.CompareTo(System.Numerics.BigInteger)">
          <source>The following example illustrates the use of the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.CompareTo%28System.Numerics.BigInteger%29&gt;</ph> method to order a list of <ph id="ph2">`StarInfo`</ph> objects.</source>
          <target state="translated">O exemplo a seguir ilustra o uso do <ph id="ph1">&lt;xref:System.Numerics.BigInteger.CompareTo%28System.Numerics.BigInteger%29&gt;</ph> método para solicitar uma lista de <ph id="ph2">`StarInfo`</ph> objetos.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.CompareTo(System.Numerics.BigInteger)">
          <source>Each <ph id="ph1">`StarInfo`</ph> object provides information about a star's name and its distance from the Earth in miles.</source>
          <target state="translated">Cada <ph id="ph1">`StarInfo`</ph> objeto fornece informações sobre o nome de uma estrela e sua distância da Terra em milhas.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.CompareTo(System.Numerics.BigInteger)">
          <source><ph id="ph1">`StarInfo`</ph> implements the <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> interface, which enables <ph id="ph3">`StarInfo`</ph> objects to be sorted by generic collection classes.</source>
          <target state="translated"><ph id="ph1">`StarInfo`</ph> implementa o <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> interface, que permite <ph id="ph3">`StarInfo`</ph> objetos a serem classificados por classes de coleção genérica.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.CompareTo(System.Numerics.BigInteger)">
          <source>Its <ph id="ph1">&lt;xref:System.IComparable%601.CompareTo%2A?displayProperty=nameWithType&gt;</ph> implementation just wraps a call to <ph id="ph2">&lt;xref:System.Numerics.BigInteger.CompareTo%28System.Numerics.BigInteger%29&gt;</ph>.</source>
          <target state="translated">Seu <ph id="ph1">&lt;xref:System.IComparable%601.CompareTo%2A?displayProperty=nameWithType&gt;</ph> implementação empacota apenas uma chamada para <ph id="ph2">&lt;xref:System.Numerics.BigInteger.CompareTo%28System.Numerics.BigInteger%29&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.CompareTo(System.Numerics.BigInteger)">
          <source>The following code then instantiates four <ph id="ph1">`StarInfo`</ph> objects and stores them in a generic <ph id="ph2">&lt;xref:System.Collections.Generic.List%601&gt;</ph> object.</source>
          <target state="translated">Em seguida, o código a seguir cria quatro <ph id="ph1">`StarInfo`</ph> objetos e os armazena em um genérico <ph id="ph2">&lt;xref:System.Collections.Generic.List%601&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.CompareTo(System.Numerics.BigInteger)">
          <source>After the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Sort%2A?displayProperty=nameWithType&gt;</ph> method is called, <ph id="ph2">`StarInfo`</ph> objects are displayed in order of their distance from the Earth.</source>
          <target state="translated">Após o <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Sort%2A?displayProperty=nameWithType&gt;</ph> método é chamado, <ph id="ph2">`StarInfo`</ph> objetos são exibidos em ordem de sua distância da Terra.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.CompareTo(System.Object)">
          <source>The object to compare.</source>
          <target state="translated">O objeto a ser comparado.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.CompareTo(System.Object)">
          <source>Compares this instance to a specified object and returns an integer that indicates whether the value of this instance is less than, equal to, or greater than the value of the specified object.</source>
          <target state="translated">Compara esta instância a um objeto especificado e retorna um inteiro que indica se o valor desta instância é menor, igual ou maior que o valor do objeto especificado.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.CompareTo(System.Object)">
          <source>A signed integer that indicates the relationship of the current instance to the <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> parameter, as shown in the following table.</source>
          <target state="translated">Um inteiro com sinal que indica a relação da instância atual com o parâmetro <ph id="ph1">&lt;paramref name="obj" /&gt;</ph>, conforme mostrado na tabela a seguir.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.CompareTo(System.Object)">
          <source><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Return value</source>
          <target state="translated"><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Valor retornado</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.CompareTo(System.Object)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Description</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Descrição</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.CompareTo(System.Object)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Less than zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Menor que zero</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.CompareTo(System.Object)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> The current instance is less than <ph id="ph3">&lt;paramref name="obj" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> A instância atual é menor que <ph id="ph3">&lt;paramref name="obj" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.CompareTo(System.Object)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Zero</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.CompareTo(System.Object)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> The current instance equals <ph id="ph3">&lt;paramref name="obj" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> A instância atual é igual a <ph id="ph3">&lt;paramref name="obj" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.CompareTo(System.Object)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Greater than zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Maior que zero</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.CompareTo(System.Object)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> The current instance is greater than <ph id="ph3">&lt;paramref name="obj" /&gt;</ph>, or the <ph id="ph4">&lt;paramref name="obj" /&gt;</ph> parameter is <ph id="ph5">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> A instância atual é maior do que <ph id="ph3">&lt;paramref name="obj" /&gt;</ph> ou o parâmetro <ph id="ph4">&lt;paramref name="obj" /&gt;</ph> é <ph id="ph5">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.CompareTo(System.Object)">
          <source>This overload of the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.CompareTo%2A&gt;</ph> method implements the <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Esta sobrecarga do <ph id="ph1">&lt;xref:System.Numerics.BigInteger.CompareTo%2A&gt;</ph> método implementa o <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A?displayProperty=nameWithType&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.CompareTo(System.Object)">
          <source>It is used by non-generic collection objects to order the items in the collection.</source>
          <target state="translated">Ele é usado pelos objetos de coleção não genérica para ordenar os itens na coleção.</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.CompareTo(System.Object)">
          <source>The <ph id="ph1">`obj`</ph> parameter must be one of the following:</source>
          <target state="translated">O <ph id="ph1">`obj`</ph> parâmetro deve ser um dos seguintes:</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.CompareTo(System.Object)">
          <source>An object whose run-time type is <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph>.</source>
          <target state="translated">Um objeto cujo tipo de tempo de execução é <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.CompareTo(System.Object)">
          <source>An <ph id="ph1">&lt;xref:System.Object&gt;</ph> variable whose value is <ph id="ph2">`null`</ph>.</source>
          <target state="translated">Um <ph id="ph1">&lt;xref:System.Object&gt;</ph> variável cujo valor é <ph id="ph2">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.CompareTo(System.Object)">
          <source>If the value of the <ph id="ph1">`obj`</ph> parameter is <ph id="ph2">`null`</ph>, the method returns 1, which indicates that that the current instance is greater than <ph id="ph3">`obj`</ph>.</source>
          <target state="translated">Se o valor de <ph id="ph1">`obj`</ph> parâmetro é <ph id="ph2">`null`</ph>, o método retorna 1, que indica que a instância atual é maior do que <ph id="ph3">`obj`</ph>.</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.CompareTo(System.Object)">
          <source>The following example calls the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.CompareTo%28System.Object%29&gt;</ph> method to compare a <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> value with each element in an object array</source>
          <target state="translated">A exemplo a seguir chama o <ph id="ph1">&lt;xref:System.Numerics.BigInteger.CompareTo%28System.Object%29&gt;</ph> método para comparar um <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> valor com cada elemento em uma matriz de objetos</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.CompareTo(System.Object)">
          <source><ph id="ph1">&lt;paramref name="obj" /&gt;</ph> is not a <ph id="ph2">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="obj" /&gt;</ph> não é um <ph id="ph2">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.CompareTo(System.UInt64)">
          <source>The unsigned 64-bit integer to compare.</source>
          <target state="translated">O inteiro sem sinal de 64 bits para comparar.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.CompareTo(System.UInt64)">
          <source>Compares this instance to an unsigned 64-bit integer and returns an integer that indicates whether the value of this instance is less than, equal to, or greater than the value of the unsigned 64-bit integer.</source>
          <target state="translated">Compara essa instância a um inteiro sem sinal de 64 bits e retorna um inteiro que indica se o valor dessa instância é menor, igual ou maior que o valor do inteiro sem sinal de 64 bits.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.CompareTo(System.UInt64)">
          <source>A signed integer that indicates the relative value of this instance and <ph id="ph1">&lt;paramref name="other" /&gt;</ph>, as shown in the following table.</source>
          <target state="translated">Um inteiro com sinal que indica o valor relativo dessa instância e <ph id="ph1">&lt;paramref name="other" /&gt;</ph>, conforme mostrado na tabela a seguir.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.CompareTo(System.UInt64)">
          <source><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Return value</source>
          <target state="translated"><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Valor retornado</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.CompareTo(System.UInt64)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Description</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Descrição</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.CompareTo(System.UInt64)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Less than zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Menor que zero</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.CompareTo(System.UInt64)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> The current instance is less than <ph id="ph3">&lt;paramref name="other" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> A instância atual é menor que <ph id="ph3">&lt;paramref name="other" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.CompareTo(System.UInt64)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Zero</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.CompareTo(System.UInt64)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> The current instance equals <ph id="ph3">&lt;paramref name="other" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> A instância atual é igual a <ph id="ph3">&lt;paramref name="other" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.CompareTo(System.UInt64)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Greater than zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Maior que zero</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.CompareTo(System.UInt64)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> The current instance is greater than <ph id="ph3">&lt;paramref name="other" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> A instância atual é maior que <ph id="ph3">&lt;paramref name="other" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.Divide(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>The value to be divided.</source>
          <target state="translated">O valor a ser dividido.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.Divide(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>The value to divide by.</source>
          <target state="translated">O valor pelo qual dividir.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.Divide(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>Divides one <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> value by another and returns the result.</source>
          <target state="translated">Divide um valor <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> em outro e retorna o resultado.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.Divide(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>The quotient of the division.</source>
          <target state="translated">O quociente da divisão.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Divide(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Divide%2A&gt;</ph> method performs integer division; any remainder that results from the division is discarded.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Divide%2A&gt;</ph> método executa uma divisão de inteiro; todo o restante que resulta da divisão é descartado.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Divide(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>To perform integer division while preserving the remainder, call the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.DivRem%2A&gt;</ph> method.</source>
          <target state="translated">Para executar a divisão, enquanto preserva o resto, chamar o <ph id="ph1">&lt;xref:System.Numerics.BigInteger.DivRem%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Divide(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>To retrieve only the remainder, call the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Remainder%2A&gt;</ph> method.</source>
          <target state="translated">Para recuperar apenas o resto, chame o <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Remainder%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Divide(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Divide%2A&gt;</ph> method can be used by languages that do not support operator overloading.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Divide%2A&gt;</ph> método pode ser usado pelas linguagens que não dão suporte a sobrecarga de operador.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Divide(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>Its behavior is identical to division using the division operator.</source>
          <target state="translated">Seu comportamento é idêntico a divisão usando o operador de divisão.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Divide(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>The following example creates an array of <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> values.</source>
          <target state="translated">O exemplo a seguir cria uma matriz de <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> valores.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Divide(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>It then uses each element as the quotient in a division operation that uses the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Divide%2A&gt;</ph> method, the division operator (/), and the <ph id="ph2">&lt;xref:System.Numerics.BigInteger.DivRem%2A&gt;</ph> method.</source>
          <target state="translated">Ele usa, em seguida, cada elemento como o quociente em uma operação de divisão que usa o <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Divide%2A&gt;</ph> método, o operador de divisão (/) e o <ph id="ph2">&lt;xref:System.Numerics.BigInteger.DivRem%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.Divide(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source><ph id="ph1">&lt;paramref name="divisor" /&gt;</ph> is 0 (zero).</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="divisor" /&gt;</ph> é 0 (zero).</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.DivRem(System.Numerics.BigInteger,System.Numerics.BigInteger,System.Numerics.BigInteger@)">
          <source>The value to be divided.</source>
          <target state="translated">O valor a ser dividido.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.DivRem(System.Numerics.BigInteger,System.Numerics.BigInteger,System.Numerics.BigInteger@)">
          <source>The value to divide by.</source>
          <target state="translated">O valor pelo qual dividir.</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.DivRem(System.Numerics.BigInteger,System.Numerics.BigInteger,System.Numerics.BigInteger@)">
          <source>When this method returns, contains a <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> value that represents the remainder from the division.</source>
          <target state="translated">Quando este método retorna, contém um valor <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> que representa o restante da divisão.</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.DivRem(System.Numerics.BigInteger,System.Numerics.BigInteger,System.Numerics.BigInteger@)">
          <source>This parameter is passed uninitialized.</source>
          <target state="translated">Este parâmetro é passado não inicializado.</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.DivRem(System.Numerics.BigInteger,System.Numerics.BigInteger,System.Numerics.BigInteger@)">
          <source>Divides one <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> value by another, returns the result, and returns the remainder in an output parameter.</source>
          <target state="translated">Divide um valor <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> por outro, retorna o resultado e retorna o restante em um parâmetro de saída.</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.DivRem(System.Numerics.BigInteger,System.Numerics.BigInteger,System.Numerics.BigInteger@)">
          <source>The quotient of the division.</source>
          <target state="translated">O quociente da divisão.</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.DivRem(System.Numerics.BigInteger,System.Numerics.BigInteger,System.Numerics.BigInteger@)">
          <source>This method preserves both the quotient and the remainder that results from integer division.</source>
          <target state="translated">Esse método preserva o quociente e o resto resultante da divisão de inteiro.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.DivRem(System.Numerics.BigInteger,System.Numerics.BigInteger,System.Numerics.BigInteger@)">
          <source>If you are not interested in the remainder, use the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Divide%2A&gt;</ph> method or the division operator; if you are only interested in the remainder, use the <ph id="ph2">&lt;xref:System.Numerics.BigInteger.Remainder%2A&gt;</ph> method.</source>
          <target state="translated">Se você não estiver interessado no restante, use o <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Divide%2A&gt;</ph> método ou o operador de divisão; se você está apenas interessado no restante, use o <ph id="ph2">&lt;xref:System.Numerics.BigInteger.Remainder%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.DivRem(System.Numerics.BigInteger,System.Numerics.BigInteger,System.Numerics.BigInteger@)">
          <source>The sign of the returned <ph id="ph1">`remainder`</ph> value is the same as the sign of the <ph id="ph2">`dividend`</ph> parameter.</source>
          <target state="translated">O sinal do retornado <ph id="ph1">`remainder`</ph> valor é o mesmo que o sinal do <ph id="ph2">`dividend`</ph> parâmetro.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.DivRem(System.Numerics.BigInteger,System.Numerics.BigInteger,System.Numerics.BigInteger@)">
          <source>The behavior of the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.DivRem%2A&gt;</ph> method is identical to that of the <ph id="ph2">&lt;xref:System.Math.DivRem%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">O comportamento do <ph id="ph1">&lt;xref:System.Numerics.BigInteger.DivRem%2A&gt;</ph> método é idêntico do <ph id="ph2">&lt;xref:System.Math.DivRem%2A?displayProperty=nameWithType&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.DivRem(System.Numerics.BigInteger,System.Numerics.BigInteger,System.Numerics.BigInteger@)">
          <source>The following example creates an array of <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> values.</source>
          <target state="translated">O exemplo a seguir cria uma matriz de <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> valores.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.DivRem(System.Numerics.BigInteger,System.Numerics.BigInteger,System.Numerics.BigInteger@)">
          <source>It then uses each element as the quotient in a division operation that uses the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Divide%2A&gt;</ph> method, the division operator (/), and the <ph id="ph2">&lt;xref:System.Numerics.BigInteger.DivRem%2A&gt;</ph> method.</source>
          <target state="translated">Ele usa, em seguida, cada elemento como o quociente em uma operação de divisão que usa o <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Divide%2A&gt;</ph> método, o operador de divisão (/) e o <ph id="ph2">&lt;xref:System.Numerics.BigInteger.DivRem%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.DivRem(System.Numerics.BigInteger,System.Numerics.BigInteger,System.Numerics.BigInteger@)">
          <source><ph id="ph1">&lt;paramref name="divisor" /&gt;</ph> is 0 (zero).</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="divisor" /&gt;</ph> é 0 (zero).</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" uid="T:System.Numerics.BigInteger">
          <source>Returns a value that indicates whether two numeric values are equal.</source>
          <target state="translated">Retorna um valor que indica se dois valores numéricos são iguais.</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.Equals(System.Int64)">
          <source>The signed 64-bit integer value to compare.</source>
          <target state="translated">O valor inteiro com sinal de 64 bits para comparar.</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.Equals(System.Int64)">
          <source>Returns a value that indicates whether the current instance and a signed 64-bit integer have the same value.</source>
          <target state="translated">Retorna um valor que indica se a instância atual e um inteiro com sinal de 64 bits têm o mesmo valor.</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.Equals(System.Int64)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the signed 64-bit integer and the current instance have the same value; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se o inteiro com sinal de 64 bits e a instância atual tiverem o mesmo valor; caso contrário, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Equals(System.Int64)">
          <source>If <ph id="ph1">`other`</ph> is a <ph id="ph2">&lt;xref:System.Byte&gt;</ph>, <ph id="ph3">&lt;xref:System.Int16&gt;</ph>, <ph id="ph4">&lt;xref:System.Int32&gt;</ph>, <ph id="ph5">&lt;xref:System.SByte&gt;</ph>, <ph id="ph6">&lt;xref:System.UInt16&gt;</ph>, or <ph id="ph7">&lt;xref:System.UInt32&gt;</ph> value, it is implicitly converted to an <ph id="ph8">&lt;xref:System.Int64&gt;</ph> value when the method is called.</source>
          <target state="translated">Se <ph id="ph1">`other`</ph> é um <ph id="ph2">&lt;xref:System.Byte&gt;</ph>, <ph id="ph3">&lt;xref:System.Int16&gt;</ph>, <ph id="ph4">&lt;xref:System.Int32&gt;</ph>, <ph id="ph5">&lt;xref:System.SByte&gt;</ph>, <ph id="ph6">&lt;xref:System.UInt16&gt;</ph>, ou <ph id="ph7">&lt;xref:System.UInt32&gt;</ph> valor, ele é convertido implicitamente em um <ph id="ph8">&lt;xref:System.Int64&gt;</ph> valor quando o método é chamado.</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Equals(System.Int64)">
          <source>To determine the relationship between the two objects instead of just testing for equality, call the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Para determinar a relação entre os dois objetos em vez de testar apenas para fins de igualdade, chame o <ph id="ph1">&lt;xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Equals(System.Int64)">
          <source>The following example instantiates a <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> object from each integral type except <ph id="ph2">&lt;xref:System.UInt64&gt;</ph>.</source>
          <target state="translated">O exemplo a seguir cria um <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> objeto de cada tipo integral exceto <ph id="ph2">&lt;xref:System.UInt64&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Equals(System.Int64)">
          <source>It then calls the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Equals%28System.Int64%29&gt;</ph> method to compare the <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> value with the original integer value that was passed to the <ph id="ph3">&lt;xref:System.Numerics.BigInteger&gt;</ph> constructor.</source>
          <target state="translated">Depois, ele chama o <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Equals%28System.Int64%29&gt;</ph> método para comparar o <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> valor com o valor de inteiro original que foi passado para o <ph id="ph3">&lt;xref:System.Numerics.BigInteger&gt;</ph> construtor.</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Equals(System.Int64)">
          <source>As the output shows, the values are equal in each case.</source>
          <target state="translated">Como mostra a saída, os valores são iguais em cada caso.</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.Equals(System.Numerics.BigInteger)">
          <source>The object to compare.</source>
          <target state="translated">O objeto a ser comparado.</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.Equals(System.Numerics.BigInteger)">
          <source>Returns a value that indicates whether the current instance and a specified <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> object have the same value.</source>
          <target state="translated">Retorna um valor que indica se a instância atual e um objeto <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> especificado têm o mesmo valor.</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.Equals(System.Numerics.BigInteger)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if this <ph id="ph2">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> object and <ph id="ph3">&lt;paramref name="other" /&gt;</ph> have the same value; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se este objeto <ph id="ph2">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> e <ph id="ph3">&lt;paramref name="other" /&gt;</ph> tiverem o mesmo valor; caso contrário, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Equals(System.Numerics.BigInteger)">
          <source>This method implements the <ph id="ph1">&lt;xref:System.IEquatable%601&gt;</ph> interface and performs slightly better than <ph id="ph2">&lt;xref:System.Numerics.BigInteger.Equals%28System.Object%29&gt;</ph> because it does not have to convert the <ph id="ph3">`other`</ph> parameter to a <ph id="ph4">&lt;xref:System.Numerics.BigInteger&gt;</ph> object.</source>
          <target state="translated">Implementa esse método de <ph id="ph1">&lt;xref:System.IEquatable%601&gt;</ph> interface e executa um pouco melhor do que <ph id="ph2">&lt;xref:System.Numerics.BigInteger.Equals%28System.Object%29&gt;</ph> porque ele não tem que converter a <ph id="ph3">`other`</ph> parâmetro para um <ph id="ph4">&lt;xref:System.Numerics.BigInteger&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Equals(System.Numerics.BigInteger)">
          <source>To determine the relationship between the two <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> objects instead of just testing for equality, call the <ph id="ph2">&lt;xref:System.Numerics.BigInteger.CompareTo%28System.Numerics.BigInteger%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Para determinar a relação entre os dois <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> objetos em vez de testar apenas para fins de igualdade, chamar o <ph id="ph2">&lt;xref:System.Numerics.BigInteger.CompareTo%28System.Numerics.BigInteger%29?displayProperty=nameWithType&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Equals(System.Numerics.BigInteger)">
          <source>The following example compares the approximate distance of several stars from Earth with the distance of Epsilon Indi from Earth to determine whether they are equal.</source>
          <target state="translated">O exemplo a seguir compara a distância aproximada de vários estrelas de Terra com a distância do i Épsilon de terra para determinar se eles são iguais.</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Equals(System.Numerics.BigInteger)">
          <source>The example uses each overload of the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Equals%2A&gt;</ph> method to test for equality.</source>
          <target state="translated">O exemplo usa cada sobrecarga o <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Equals%2A&gt;</ph> método de teste de igualdade.</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.Equals(System.Object)">
          <source>The object to compare.</source>
          <target state="translated">O objeto a ser comparado.</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.Equals(System.Object)">
          <source>Returns a value that indicates whether the current instance and a specified object have the same value.</source>
          <target state="translated">Retorna um valor que indica se a instância atual e um objeto especificado têm o mesmo valor.</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.Equals(System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;paramref name="obj" /&gt;</ph> argument is a <ph id="ph3">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> object, and its value is equal to the value of the current <ph id="ph4">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> instance; otherwise, <ph id="ph5">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se o <ph id="ph2">&lt;paramref name="obj" /&gt;</ph> argumento for um objeto <ph id="ph3">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> e seu valor for igual ao valor da instância <ph id="ph4">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> atual; caso contrário, <ph id="ph5">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Equals(System.Object)">
          <source>If the <ph id="ph1">`obj`</ph> argument is not a <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> value, the method returns <ph id="ph3">`false`</ph>.</source>
          <target state="translated">Se o <ph id="ph1">`obj`</ph> argumento não é um <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> de valor, o método retornará <ph id="ph3">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Equals(System.Object)">
          <source>The method returns <ph id="ph1">`true`</ph> only if <ph id="ph2">`obj`</ph> is a <ph id="ph3">&lt;xref:System.Numerics.BigInteger&gt;</ph> instance whose value is equal to the current instance.</source>
          <target state="translated">O método retorna <ph id="ph1">`true`</ph> somente se <ph id="ph2">`obj`</ph> é um <ph id="ph3">&lt;xref:System.Numerics.BigInteger&gt;</ph> instância cujo valor é igual à instância atual.</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Equals(System.Object)">
          <source>To determine the relationship between the two objects instead of just testing for equality, call the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.CompareTo%28System.Object%29&gt;</ph> method.</source>
          <target state="translated">Para determinar a relação entre os dois objetos em vez de testar apenas para fins de igualdade, chame o <ph id="ph1">&lt;xref:System.Numerics.BigInteger.CompareTo%28System.Object%29&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Equals(System.Object)">
          <source>The following example defines parallel <ph id="ph1">&lt;xref:System.Object&gt;</ph> and <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> arrays.</source>
          <target state="translated">O exemplo a seguir define paralelo <ph id="ph1">&lt;xref:System.Object&gt;</ph> e <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> matrizes.</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Equals(System.Object)">
          <source>Each element of one array has the same value as the corresponding element of the second array.</source>
          <target state="translated">Cada elemento de uma matriz tem o mesmo valor que o elemento correspondente da segunda matriz.</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Equals(System.Object)">
          <source>As the output from the example shows, the instance in the <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> array is considered to be equal to the instance in the <ph id="ph2">&lt;xref:System.Object&gt;</ph> array only if the latter is a <ph id="ph3">&lt;xref:System.Numerics.BigInteger&gt;</ph> and their values are equal.</source>
          <target state="translated">Como a saída mostra o exemplo, a instância no <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> matriz é considerada igual à instância no <ph id="ph2">&lt;xref:System.Object&gt;</ph> matriz somente se for o último um <ph id="ph3">&lt;xref:System.Numerics.BigInteger&gt;</ph> e seus valores são iguais.</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.Equals(System.UInt64)">
          <source>The unsigned 64-bit integer to compare.</source>
          <target state="translated">O inteiro sem sinal de 64 bits para comparar.</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.Equals(System.UInt64)">
          <source>Returns a value that indicates whether the current instance and an unsigned 64-bit integer have the same value.</source>
          <target state="translated">Retorna um valor que indica se a instância atual e um inteiro sem sinal de 64 bits têm o mesmo valor.</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.Equals(System.UInt64)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current instance and the unsigned 64-bit integer have the same value; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se a instância atual e o inteiro sem sinal de 64 bits tiverem o mesmo valor; caso contrário, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Equals(System.UInt64)">
          <source>To determine the relationship between the two objects instead of just testing for equality, call the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Para determinar a relação entre os dois objetos em vez de testar apenas para fins de igualdade, chame o <ph id="ph1">&lt;xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Equals(System.UInt64)">
          <source>The following example compares the approximate distance of several stars from Earth with the distance of Epsilon Indi from Earth to determine whether they are equal.</source>
          <target state="translated">O exemplo a seguir compara a distância aproximada de vários estrelas de Terra com a distância do i Épsilon de terra para determinar se eles são iguais.</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Equals(System.UInt64)">
          <source>The example uses each overload of the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Equals%2A&gt;</ph> method to test for equality.</source>
          <target state="translated">O exemplo usa cada sobrecarga o <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Equals%2A&gt;</ph> método de teste de igualdade.</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.GetHashCode">
          <source>Returns the hash code for the current <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> object.</source>
          <target state="translated">Retorna o código hash para o objeto <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> atual.</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.GetHashCode">
          <source>A 32-bit signed integer hash code.</source>
          <target state="translated">Um código de hash do inteiro assinado de 32 bits.</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.GreatestCommonDivisor(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>The first value.</source>
          <target state="translated">O primeiro valor.</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.GreatestCommonDivisor(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>The second value.</source>
          <target state="translated">O segundo valor.</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.GreatestCommonDivisor(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>Finds the greatest common divisor of two <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> values.</source>
          <target state="translated">Localiza o maior divisor comum de dois valores <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.GreatestCommonDivisor(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>The greatest common divisor of <ph id="ph1">&lt;paramref name="left" /&gt;</ph> and <ph id="ph2">&lt;paramref name="right" /&gt;</ph>.</source>
          <target state="translated">O maior divisor comum de <ph id="ph1">&lt;paramref name="left" /&gt;</ph> e <ph id="ph2">&lt;paramref name="right" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.GreatestCommonDivisor(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>The greatest common divisor is the largest number into which the two <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> values can be divided without returning a remainder.</source>
          <target state="translated">O máximo divisor comum é o maior número na qual as duas <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> valores podem ser divididos sem retornar um resto.</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.GreatestCommonDivisor(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>If the <ph id="ph1">`left`</ph> and <ph id="ph2">`right`</ph> parameters are non-zero numbers, the method always returns at least a value of 1 because all numbers can be divided by 1.</source>
          <target state="translated">Se o <ph id="ph1">`left`</ph> e <ph id="ph2">`right`</ph> parâmetros são números diferentes de zero, o método sempre retorna pelo menos um valor de 1, porque todos os números podem ser divididos em 1.</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.GreatestCommonDivisor(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>If either parameter is zero, the method returns the absolute value of the non-zero parameter.</source>
          <target state="translated">Se um parâmetro for zero, o método retorna o valor absoluto de parâmetro diferente de zero.</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.GreatestCommonDivisor(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>If both values are zero, the method returns zero.</source>
          <target state="translated">Se os dois valores forem zero, o método retornará zero.</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.GreatestCommonDivisor(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>Computing the greatest common divisor of very large values of <ph id="ph1">`left`</ph> and <ph id="ph2">`right`</ph> can be a very time-consuming operation.</source>
          <target state="translated">Calculando o máximo divisor comum de valores muito grandes de <ph id="ph1">`left`</ph> e <ph id="ph2">`right`</ph> pode ser uma operação demorada.</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.GreatestCommonDivisor(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>The value returned by the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.GreatestCommonDivisor%2A&gt;</ph> method is always positive regardless of the sign of the <ph id="ph2">`left`</ph> and <ph id="ph3">`right`</ph> parameters.</source>
          <target state="translated">O valor retornado pelo <ph id="ph1">&lt;xref:System.Numerics.BigInteger.GreatestCommonDivisor%2A&gt;</ph> método sempre é positivo, independentemente do sinal do <ph id="ph2">`left`</ph> e <ph id="ph3">`right`</ph> parâmetros.</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.GreatestCommonDivisor(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>The following example illustrates a call to the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.GreatestCommonDivisor%2A&gt;</ph> method and the exception handling necessary to provide useful information about an <ph id="ph2">&lt;xref:System.ArgumentOutOfRangeException&gt;</ph>.</source>
          <target state="translated">O exemplo a seguir ilustra uma chamada para o <ph id="ph1">&lt;xref:System.Numerics.BigInteger.GreatestCommonDivisor%2A&gt;</ph> método e a exceção tratamento necessários para fornecer informações úteis sobre um <ph id="ph2">&lt;xref:System.ArgumentOutOfRangeException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.GreatestCommonDivisor(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>The result indicates that the greatest common divisor of these two numbers is 1.</source>
          <target state="translated">O resultado indica que o máximo divisor comum desses dois números é 1.</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" uid="P:System.Numerics.BigInteger.IsEven">
          <source>Indicates whether the value of the current <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> object is an even number.</source>
          <target state="translated">Indica se o valor do objeto <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> atual é um número par.</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Numerics.BigInteger.IsEven">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the value of the <ph id="ph2">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> object is an even number; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se o valor do objeto <ph id="ph2">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> é um número par; caso contrário, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Numerics.BigInteger.IsEven">
          <source>This property is a convenience feature that indicates whether a <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> value is evenly divisible by two.</source>
          <target state="translated">Essa propriedade é um recurso de conveniência que indica se um <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> valor for divisível por dois.</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Numerics.BigInteger.IsEven">
          <source>It is equivalent to the following expression:</source>
          <target state="translated">É equivalente a seguinte expressão:</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Numerics.BigInteger.IsEven">
          <source>If the value of the current <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> object is <ph id="ph2">&lt;xref:System.Numerics.BigInteger.Zero%2A?displayProperty=nameWithType&gt;</ph>, the property returns <ph id="ph3">`true`</ph>.</source>
          <target state="translated">Se o valor atual <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> objeto <ph id="ph2">&lt;xref:System.Numerics.BigInteger.Zero%2A?displayProperty=nameWithType&gt;</ph>, a propriedade retornará <ph id="ph3">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" uid="P:System.Numerics.BigInteger.IsOne">
          <source>Indicates whether the value of the current <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> object is <ph id="ph2">&lt;see cref="P:System.Numerics.BigInteger.One" /&gt;</ph>.</source>
          <target state="translated">Indica se o valor do objeto <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> atual é <ph id="ph2">&lt;see cref="P:System.Numerics.BigInteger.One" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Numerics.BigInteger.IsOne">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the value of the <ph id="ph2">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> object is <ph id="ph3">&lt;see cref="P:System.Numerics.BigInteger.One" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> Se o valor de <ph id="ph2">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> objeto <ph id="ph3">&lt;see cref="P:System.Numerics.BigInteger.One" /&gt;</ph>; caso contrário, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Numerics.BigInteger.IsOne">
          <source>This property offers significantly better performance than other comparisons with one, such as <ph id="ph1">`thisBigInteger.Equals(BigInteger.One)`</ph>.</source>
          <target state="translated">Essa propriedade oferece um desempenho significativamente melhor que outros comparações com um, como <ph id="ph1">`thisBigInteger.Equals(BigInteger.One)`</ph>.</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" uid="P:System.Numerics.BigInteger.IsPowerOfTwo">
          <source>Indicates whether the value of the current <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> object is a power of two.</source>
          <target state="translated">Indica se o valor do objeto <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> atual é uma potência de dois.</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Numerics.BigInteger.IsPowerOfTwo">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the value of the <ph id="ph2">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> object is a power of two; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> Se o valor de <ph id="ph2">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> objeto seja uma potência de dois; caso contrário, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Numerics.BigInteger.IsPowerOfTwo">
          <source>This property determines whether a <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> value has a single non-zero bit set.</source>
          <target state="translated">Essa propriedade determina se um <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> valor tem um único bit diferente de zero definido.</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Numerics.BigInteger.IsPowerOfTwo">
          <source>This means that it returns <ph id="ph1">`true`</ph> if the value of the current <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> object is 1 (that is, 2<bpt id="p1">&lt;sup&gt;</bpt>0<ept id="p1">&lt;/sup&gt;</ept>) or any greater power of two.</source>
          <target state="translated">Isso significa que ela retorna <ph id="ph1">`true`</ph> se o valor atual <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> objeto é 1 (ou seja, 2<bpt id="p1">&lt;sup&gt;</bpt>0<ept id="p1">&lt;/sup&gt;</ept>) ou qualquer maior potência de dois.</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Numerics.BigInteger.IsPowerOfTwo">
          <source>It returns <ph id="ph1">`false`</ph> if the value of the current <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> object is 0.</source>
          <target state="translated">Ele retorna <ph id="ph1">`false`</ph> se o valor atual <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> objeto é 0.</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" uid="P:System.Numerics.BigInteger.IsZero">
          <source>Indicates whether the value of the current <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> object is <ph id="ph2">&lt;see cref="P:System.Numerics.BigInteger.Zero" /&gt;</ph>.</source>
          <target state="translated">Indica se o valor do objeto <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> atual é <ph id="ph2">&lt;see cref="P:System.Numerics.BigInteger.Zero" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Numerics.BigInteger.IsZero">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the value of the <ph id="ph2">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> object is <ph id="ph3">&lt;see cref="P:System.Numerics.BigInteger.Zero" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> Se o valor de <ph id="ph2">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> objeto <ph id="ph3">&lt;see cref="P:System.Numerics.BigInteger.Zero" /&gt;</ph>; caso contrário, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Numerics.BigInteger.IsZero">
          <source>This property offers significantly better performance than <ph id="ph1">`BigInteger.Equals(BigInteger.Zero)`</ph>.</source>
          <target state="translated">Essa propriedade oferece um desempenho significativamente melhor que <ph id="ph1">`BigInteger.Equals(BigInteger.Zero)`</ph>.</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" uid="T:System.Numerics.BigInteger">
          <source>Returns the logarithm of a specified number.</source>
          <target state="translated">Retorna o logaritmo de um número especificado.</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.Log(System.Numerics.BigInteger)">
          <source>The number whose logarithm is to be found.</source>
          <target state="translated">O número cujo logaritmo deve ser encontrado.</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.Log(System.Numerics.BigInteger)">
          <source>Returns the natural (base <ph id="ph1">&lt;see langword="e" /&gt;</ph>) logarithm of a specified number.</source>
          <target state="translated">Retorna o logaritmo natural (de base <ph id="ph1">&lt;see langword="e" /&gt;</ph>) de um número especificado.</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.Log(System.Numerics.BigInteger)">
          <source>The natural (base <ph id="ph1">&lt;see langword="e" /&gt;</ph>) logarithm of <ph id="ph2">&lt;paramref name="value" /&gt;</ph>, as shown in the table in the Remarks section.</source>
          <target state="translated">O logaritmo natural (base <ph id="ph1">&lt;see langword="e" /&gt;</ph>) de <ph id="ph2">&lt;paramref name="value" /&gt;</ph>, conforme mostrado na tabela na seção Comentários.</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Log(System.Numerics.BigInteger)">
          <source>The <ph id="ph1">`value`</ph> parameter is specified as a base 10 number.</source>
          <target state="translated">O <ph id="ph1">`value`</ph> parâmetro for especificado como um número de base 10.</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Log(System.Numerics.BigInteger)">
          <source>The precise return value of this method depends on the sign of <ph id="ph1">`value`</ph>, as the following table shows.</source>
          <target state="translated">O precisa retorna o valor desse método depende do sinal de <ph id="ph1">`value`</ph>, como mostra a tabela a seguir.</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Log(System.Numerics.BigInteger)">
          <source>Sign of <ph id="ph1">`value`</ph> parameter</source>
          <target state="translated">Logon de <ph id="ph1">`value`</ph> parâmetro</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Log(System.Numerics.BigInteger)">
          <source>Return value</source>
          <target state="translated">Valor retornado</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Log(System.Numerics.BigInteger)">
          <source>Positive</source>
          <target state="translated">Positivo</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Log(System.Numerics.BigInteger)">
          <source>The natural logarithm of <ph id="ph1">`value`</ph>; that is, ln <ph id="ph2">`value`</ph>, or log e<ph id="ph3">`value`</ph>.</source>
          <target state="translated">O logaritmo natural de <ph id="ph1">`value`</ph>; ou seja, ln <ph id="ph2">`value`</ph>, ou de log e<ph id="ph3">`value`</ph>.</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Log(System.Numerics.BigInteger)">
          <source>Zero</source>
          <target state="translated">Zero</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Log(System.Numerics.BigInteger)">
          <source><ph id="ph1">&lt;xref:System.Double.NegativeInfinity&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Double.NegativeInfinity&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Log(System.Numerics.BigInteger)">
          <source>Negative</source>
          <target state="translated">Negativo</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Log(System.Numerics.BigInteger)">
          <source><ph id="ph1">&lt;xref:System.Double.NaN&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Double.NaN&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Log(System.Numerics.BigInteger)">
          <source>To calculate the base 10 logarithm of a <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> value, call the <ph id="ph2">&lt;xref:System.Numerics.BigInteger.Log10%2A&gt;</ph> method.</source>
          <target state="translated">Para calcular o logaritmo de base 10 de um <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> valor, chame o <ph id="ph2">&lt;xref:System.Numerics.BigInteger.Log10%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Log(System.Numerics.BigInteger)">
          <source>To calculate the logarithm of a number in another base, call the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Log%28System.Numerics.BigInteger%2CSystem.Double%29&gt;</ph> method.</source>
          <target state="translated">Para calcular o logaritmo de um número em outra base, chame o <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Log%28System.Numerics.BigInteger%2CSystem.Double%29&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Log(System.Numerics.BigInteger)">
          <source>You can find the square root of a number by calling the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Log%2A&gt;</ph> method along with the <ph id="ph2">&lt;xref:System.Math.Exp%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Você pode encontrar a raiz quadrada de um número chamando o <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Log%2A&gt;</ph> método junto com o <ph id="ph2">&lt;xref:System.Math.Exp%2A?displayProperty=nameWithType&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Log(System.Numerics.BigInteger)">
          <source>Note that the result is <ph id="ph1">&lt;xref:System.Double.PositiveInfinity?displayProperty=nameWithType&gt;</ph> if the result is greater than <ph id="ph2">&lt;xref:System.Double.MaxValue?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Observe que o resultado é <ph id="ph1">&lt;xref:System.Double.PositiveInfinity?displayProperty=nameWithType&gt;</ph> se o resultado for maior do que <ph id="ph2">&lt;xref:System.Double.MaxValue?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Log(System.Numerics.BigInteger)">
          <source>The following example calculates the square root of each element in an array of <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> values.</source>
          <target state="translated">O exemplo a seguir calcula a raiz quadrada de cada elemento em uma matriz de <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> valores.</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Log(System.Numerics.BigInteger)">
          <source>This method corresponds to the <ph id="ph1">&lt;xref:System.Math.Log%28System.Double%29?displayProperty=nameWithType&gt;</ph> method for the primitive numeric types.</source>
          <target state="translated">Esse método corresponde do <ph id="ph1">&lt;xref:System.Math.Log%28System.Double%29?displayProperty=nameWithType&gt;</ph> método para os tipos numéricos primitivo.</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.Log(System.Numerics.BigInteger)">
          <source>The natural log of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is out of range of the <ph id="ph2">&lt;see cref="T:System.Double" /&gt;</ph> data type.</source>
          <target state="translated">O log natural de <ph id="ph1">&lt;paramref name="value" /&gt;</ph> está fora do intervalo do tipo de dados <ph id="ph2">&lt;see cref="T:System.Double" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.Log(System.Numerics.BigInteger,System.Double)">
          <source>A number whose logarithm is to be found.</source>
          <target state="translated">Um número cujo logaritmo deve ser localizado.</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.Log(System.Numerics.BigInteger,System.Double)">
          <source>The base of the logarithm.</source>
          <target state="translated">A base do logaritmo.</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.Log(System.Numerics.BigInteger,System.Double)">
          <source>Returns the logarithm of a specified number in a specified base.</source>
          <target state="translated">Retorna o logaritmo de um número especificado em uma base especificada.</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.Log(System.Numerics.BigInteger,System.Double)">
          <source>The base <ph id="ph1">&lt;paramref name="baseValue" /&gt;</ph> logarithm of <ph id="ph2">&lt;paramref name="value" /&gt;</ph>, as shown in the table in the Remarks section.</source>
          <target state="translated">O logaritmo de base <ph id="ph1">&lt;paramref name="baseValue" /&gt;</ph> de <ph id="ph2">&lt;paramref name="value" /&gt;</ph>, conforme mostrado na tabela na seção Comentários.</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Log(System.Numerics.BigInteger,System.Double)">
          <source>The <ph id="ph1">`value`</ph> and <ph id="ph2">`baseValue`</ph> parameters are specified as base 10 numbers.</source>
          <target state="translated">O <ph id="ph1">`value`</ph> e <ph id="ph2">`baseValue`</ph> parâmetros são especificados como base 10 números.</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Log(System.Numerics.BigInteger,System.Double)">
          <source>The precise return value of the method depends on the sign of <ph id="ph1">`value`</ph> and on the sign and value of <ph id="ph2">`baseValue`</ph>, as the following table shows.</source>
          <target state="translated">O precisa retorna o valor do método depende do sinal de <ph id="ph1">`value`</ph> e de entrada e o valor de <ph id="ph2">`baseValue`</ph>, como mostra a tabela a seguir.</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Log(System.Numerics.BigInteger,System.Double)">
          <source><ph id="ph1">`value`</ph> parameter</source>
          <target state="translated">Parâmetro <ph id="ph1">`value`</ph></target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Log(System.Numerics.BigInteger,System.Double)">
          <source><ph id="ph1">`baseValue`</ph> parameter</source>
          <target state="translated">Parâmetro <ph id="ph1">`baseValue`</ph></target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Log(System.Numerics.BigInteger,System.Double)">
          <source>Return value</source>
          <target state="translated">Valor retornado</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Log(System.Numerics.BigInteger,System.Double)">
          <source><ph id="ph1">`value`</ph> &gt; 0</source>
          <target state="translated"><ph id="ph1">`value`</ph> &gt; 0</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Log(System.Numerics.BigInteger,System.Double)">
          <source>(0 &lt; <ph id="ph1">`baseValue`</ph> &lt; 1) -or-(<ph id="ph2">`baseValue`</ph> &gt; 1)</source>
          <target state="translated">(0 &lt; <ph id="ph1">`baseValue`</ph> &lt; 1) - ou -(<ph id="ph2">`baseValue`</ph> &gt; 1)</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Log(System.Numerics.BigInteger,System.Double)">
          <source>logbaseValue(<ph id="ph1">`value`</ph>)</source>
          <target state="translated">logbaseValue(<ph id="ph1">`value`</ph>)</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Log(System.Numerics.BigInteger,System.Double)">
          <source><ph id="ph1">`value`</ph> &lt; 0</source>
          <target state="translated"><ph id="ph1">`value`</ph> &lt; 0</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Log(System.Numerics.BigInteger,System.Double)">
          <source>(any value)</source>
          <target state="translated">(nenhum valor)</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Log(System.Numerics.BigInteger,System.Double)">
          <source>(any value)</source>
          <target state="translated">(nenhum valor)</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Log(System.Numerics.BigInteger,System.Double)">
          <source><ph id="ph1">`baseValue`</ph> &lt; 0</source>
          <target state="translated"><ph id="ph1">`baseValue`</ph> &lt; 0</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Log(System.Numerics.BigInteger,System.Double)">
          <source><ph id="ph1">`value`</ph> != 1</source>
          <target state="translated"><ph id="ph1">`value`</ph> != 1</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Log(System.Numerics.BigInteger,System.Double)">
          <source><ph id="ph1">`baseValue`</ph> = 0</source>
          <target state="translated"><ph id="ph1">`baseValue`</ph> = 0</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Log(System.Numerics.BigInteger,System.Double)">
          <source><ph id="ph1">`value`</ph> != 1</source>
          <target state="translated"><ph id="ph1">`value`</ph> != 1</target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Log(System.Numerics.BigInteger,System.Double)">
          <source>(any value)</source>
          <target state="translated">(nenhum valor)</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Log(System.Numerics.BigInteger,System.Double)">
          <source>(any value)</source>
          <target state="translated">(nenhum valor)</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Log(System.Numerics.BigInteger,System.Double)">
          <source><ph id="ph1">`baseValue`</ph> = 1</source>
          <target state="translated"><ph id="ph1">`baseValue`</ph> = 1</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Log(System.Numerics.BigInteger,System.Double)">
          <source><ph id="ph1">`value`</ph> = 0</source>
          <target state="translated"><ph id="ph1">`value`</ph> = 0</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Log(System.Numerics.BigInteger,System.Double)">
          <source>0 &lt; <ph id="ph1">`baseValue`</ph> &lt; 1</source>
          <target state="translated">0 &lt; <ph id="ph1">`baseValue`</ph> &lt; 1</target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Log(System.Numerics.BigInteger,System.Double)">
          <source><ph id="ph1">`value`</ph> = 0</source>
          <target state="translated"><ph id="ph1">`value`</ph> = 0</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Log(System.Numerics.BigInteger,System.Double)">
          <source><ph id="ph1">`baseValue`</ph> &gt; 1</source>
          <target state="translated"><ph id="ph1">`baseValue`</ph> &gt; 1</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Log(System.Numerics.BigInteger,System.Double)">
          <source><ph id="ph1">`value`</ph> = 1</source>
          <target state="translated"><ph id="ph1">`value`</ph> = 1</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Log(System.Numerics.BigInteger,System.Double)">
          <source><ph id="ph1">`baseValue`</ph> = 0</source>
          <target state="translated"><ph id="ph1">`baseValue`</ph> = 0</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Log(System.Numerics.BigInteger,System.Double)">
          <source>0</source>
          <target state="translated">0</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Log(System.Numerics.BigInteger,System.Double)">
          <source><ph id="ph1">`value`</ph> = 1</source>
          <target state="translated"><ph id="ph1">`value`</ph> = 1</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Log(System.Numerics.BigInteger,System.Double)">
          <source>0</source>
          <target state="translated">0</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Log(System.Numerics.BigInteger,System.Double)">
          <source>To calculate the base 10 logarithm of a <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> value, call the <ph id="ph2">&lt;xref:System.Numerics.BigInteger.Log10%2A&gt;</ph> method.</source>
          <target state="translated">Para calcular o logaritmo de base 10 de um <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> valor, chame o <ph id="ph2">&lt;xref:System.Numerics.BigInteger.Log10%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Log(System.Numerics.BigInteger,System.Double)">
          <source>To calculate the natural logarithm of a number, call the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Log%28System.Numerics.BigInteger%29&gt;</ph> method.</source>
          <target state="translated">Para calcular o logaritmo natural de um número, chame o <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Log%28System.Numerics.BigInteger%29&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Log(System.Numerics.BigInteger,System.Double)">
          <source>This method corresponds to the <ph id="ph1">&lt;xref:System.Math.Log%2A?displayProperty=nameWithType&gt;</ph> method for the primitive numeric types.</source>
          <target state="translated">Esse método corresponde do <ph id="ph1">&lt;xref:System.Math.Log%2A?displayProperty=nameWithType&gt;</ph> método para os tipos numéricos primitivo.</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.Log(System.Numerics.BigInteger,System.Double)">
          <source>The log of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is out of range of the <ph id="ph2">&lt;see cref="T:System.Double" /&gt;</ph> data type.</source>
          <target state="translated">O log de <ph id="ph1">&lt;paramref name="value" /&gt;</ph> está fora do intervalo do tipo de dados <ph id="ph2">&lt;see cref="T:System.Double" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.Log10(System.Numerics.BigInteger)">
          <source>A number whose logarithm is to be found.</source>
          <target state="translated">Um número cujo logaritmo deve ser localizado.</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.Log10(System.Numerics.BigInteger)">
          <source>Returns the base 10 logarithm of a specified number.</source>
          <target state="translated">Retorna o logaritmo de base 10 de um número especificado.</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.Log10(System.Numerics.BigInteger)">
          <source>The base 10 logarithm of <ph id="ph1">&lt;paramref name="value" /&gt;</ph>, as shown in the table in the Remarks section.</source>
          <target state="translated">O logaritmo de base 10 de <ph id="ph1">&lt;paramref name="value" /&gt;</ph>, conforme mostrado na tabela na seção Comentários.</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Log10(System.Numerics.BigInteger)">
          <source>The <ph id="ph1">`value`</ph> parameter is specified as a base 10 number.</source>
          <target state="translated">O <ph id="ph1">`value`</ph> parâmetro for especificado como um número de base 10.</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Log10(System.Numerics.BigInteger)">
          <source>The precise return value of the method depends on the sign of <ph id="ph1">`value`</ph>, as the following table shows.</source>
          <target state="translated">O precisa retorna o valor do método depende do sinal de <ph id="ph1">`value`</ph>, como mostra a tabela a seguir.</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Log10(System.Numerics.BigInteger)">
          <source>Sign of value parameter</source>
          <target state="translated">Entrada do parâmetro de valor</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Log10(System.Numerics.BigInteger)">
          <source>Return value</source>
          <target state="translated">Valor retornado</target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Log10(System.Numerics.BigInteger)">
          <source>Positive</source>
          <target state="translated">Positivo</target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Log10(System.Numerics.BigInteger)">
          <source>The base 10 log of <ph id="ph1">`value`</ph>; that is, log10<ph id="ph2">`value`</ph>.</source>
          <target state="translated">O log de base 10 de <ph id="ph1">`value`</ph>; ou seja, log10<ph id="ph2">`value`</ph>.</target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Log10(System.Numerics.BigInteger)">
          <source>Zero</source>
          <target state="translated">Zero</target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Log10(System.Numerics.BigInteger)">
          <source><ph id="ph1">&lt;xref:System.Double.NegativeInfinity?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Double.NegativeInfinity?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Log10(System.Numerics.BigInteger)">
          <source>Negative</source>
          <target state="translated">Negativo</target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Log10(System.Numerics.BigInteger)">
          <source><ph id="ph1">&lt;xref:System.Double.NaN?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Double.NaN?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Log10(System.Numerics.BigInteger)">
          <source>To calculate the natural logarithm of a <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> value, call the <ph id="ph2">&lt;xref:System.Numerics.BigInteger.Log%28System.Numerics.BigInteger%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Para calcular o logaritmo natural de um <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> valor, chame o <ph id="ph2">&lt;xref:System.Numerics.BigInteger.Log%28System.Numerics.BigInteger%29?displayProperty=nameWithType&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Log10(System.Numerics.BigInteger)">
          <source>To calculate the logarithm of a number in another base, call the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Log%28System.Numerics.BigInteger%2CSystem.Double%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Para calcular o logaritmo de um número em outra base, chame o <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Log%28System.Numerics.BigInteger%2CSystem.Double%29?displayProperty=nameWithType&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Log10(System.Numerics.BigInteger)">
          <source>This method corresponds to the <ph id="ph1">&lt;xref:System.Math.Log10%2A?displayProperty=nameWithType&gt;</ph> method for the primitive numeric types.</source>
          <target state="translated">Esse método corresponde do <ph id="ph1">&lt;xref:System.Math.Log10%2A?displayProperty=nameWithType&gt;</ph> método para os tipos numéricos primitivo.</target>       </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.Log10(System.Numerics.BigInteger)">
          <source>The base 10 log of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is out of range of the <ph id="ph2">&lt;see cref="T:System.Double" /&gt;</ph> data type.</source>
          <target state="translated">O log de base 10 de <ph id="ph1">&lt;paramref name="value" /&gt;</ph> está fora do intervalo do tipo de dados <ph id="ph2">&lt;see cref="T:System.Double" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.Max(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>The first value to compare.</source>
          <target state="translated">O primeiro valor a ser comparado.</target>       </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.Max(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>The second value to compare.</source>
          <target state="translated">O segundo valor a ser comparado.</target>       </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.Max(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>Returns the larger of two <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> values.</source>
          <target state="translated">Retorna o maior dos dois valores <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.Max(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>The <ph id="ph1">&lt;paramref name="left" /&gt;</ph> or <ph id="ph2">&lt;paramref name="right" /&gt;</ph> parameter, whichever is larger.</source>
          <target state="translated">O parâmetro <ph id="ph1">&lt;paramref name="left" /&gt;</ph> ou <ph id="ph2">&lt;paramref name="right" /&gt;</ph>, o que for maior.</target>       </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Max(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>This method corresponds to the <ph id="ph1">&lt;xref:System.Math.Max%2A?displayProperty=nameWithType&gt;</ph> method for primitive numeric types.</source>
          <target state="translated">Esse método corresponde do <ph id="ph1">&lt;xref:System.Math.Max%2A?displayProperty=nameWithType&gt;</ph> método para tipos numéricos primitivos.</target>       </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Max(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Max%2A&gt;</ph> method to select the largest number in an array of <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> values.</source>
          <target state="translated">O exemplo a seguir usa o <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Max%2A&gt;</ph> método para selecionar o maior número em uma matriz de <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> valores.</target>       </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.Min(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>The first value to compare.</source>
          <target state="translated">O primeiro valor a ser comparado.</target>       </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.Min(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>The second value to compare.</source>
          <target state="translated">O segundo valor a ser comparado.</target>       </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.Min(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>Returns the smaller of two <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> values.</source>
          <target state="translated">Retorna o menor de dois valores <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.Min(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>The <ph id="ph1">&lt;paramref name="left" /&gt;</ph> or <ph id="ph2">&lt;paramref name="right" /&gt;</ph> parameter, whichever is smaller.</source>
          <target state="translated">O parâmetro <ph id="ph1">&lt;paramref name="left" /&gt;</ph> ou <ph id="ph2">&lt;paramref name="right" /&gt;</ph>, o que for menor.</target>       </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Min(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>This method corresponds to the <ph id="ph1">&lt;xref:System.Math.Min%2A?displayProperty=nameWithType&gt;</ph> method for primitive numeric types.</source>
          <target state="translated">Esse método corresponde do <ph id="ph1">&lt;xref:System.Math.Min%2A?displayProperty=nameWithType&gt;</ph> método para tipos numéricos primitivos.</target>       </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Min(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Min%2A&gt;</ph> method to select the smallest number in an array of <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> values.</source>
          <target state="translated">O exemplo a seguir usa o <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Min%2A&gt;</ph> método para selecionar o menor número em uma matriz de <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> valores.</target>       </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" uid="P:System.Numerics.BigInteger.MinusOne">
          <source>Gets a value that represents the number negative one (-1).</source>
          <target state="translated">Obtém um valor que representa o número um negativo (-1).</target>       </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Numerics.BigInteger.MinusOne">
          <source>An integer whose value is negative one (-1).</source>
          <target state="translated">Um inteiro cujo valor é negativo (-1).</target>       </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Numerics.BigInteger.MinusOne">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.MinusOne%2A&gt;</ph> property is used to compare a <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> value to -1 or to assign -1 to a <ph id="ph3">&lt;xref:System.Numerics.BigInteger&gt;</ph> object.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Numerics.BigInteger.MinusOne%2A&gt;</ph> propriedade é usada para comparar um <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> valor -1 ou -1 para atribuir um <ph id="ph3">&lt;xref:System.Numerics.BigInteger&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.ModPow(System.Numerics.BigInteger,System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>The number to raise to the <bpt id="p1">&lt;c&gt;</bpt>exponent<ept id="p1">&lt;/c&gt;</ept> power.</source>
          <target state="translated">O número a elevar à potência <bpt id="p1">&lt;c&gt;</bpt>expoente<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.ModPow(System.Numerics.BigInteger,System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>The exponent to raise <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept> by.</source>
          <target state="translated">O expoente pelo qual <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept> será elevado.</target>       </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.ModPow(System.Numerics.BigInteger,System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>The number by which to divide <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept> raised to the <bpt id="p2">&lt;c&gt;</bpt>exponent<ept id="p2">&lt;/c&gt;</ept> power.</source>
          <target state="translated">O número pelo qual dividir o <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept> elevado à potência <bpt id="p2">&lt;c&gt;</bpt>exponent<ept id="p2">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.ModPow(System.Numerics.BigInteger,System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>Performs modulus division on a number raised to the power of another number.</source>
          <target state="translated">Executa a divisão de módulo em um número elevado à potência de outro número.</target>       </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.ModPow(System.Numerics.BigInteger,System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>The remainder after dividing <ph id="ph1">&lt;paramref name="value" /&gt;</ph><bpt id="p1">&lt;sup&gt;</bpt>exponent<ept id="p1">&lt;/sup&gt;</ept> by <ph id="ph2">&lt;paramref name="modulus" /&gt;</ph>.</source>
          <target state="translated">O resto após dividir o <ph id="ph1">&lt;paramref name="value" /&gt;</ph><bpt id="p1">&lt;sup&gt;</bpt>exponente<ept id="p1">&lt;/sup&gt;</ept> por <ph id="ph2">&lt;paramref name="modulus" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.ModPow(System.Numerics.BigInteger,System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.ModPow%2A&gt;</ph> method evaluates the following expression:</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Numerics.BigInteger.ModPow%2A&gt;</ph> método avalia a expressão a seguir:</target>       </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.ModPow(System.Numerics.BigInteger,System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>(baseValue ^ exponent) Mod modulus</source>
          <target state="translated">(baseValue ^ expoente) Módulo mod</target>       </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.ModPow(System.Numerics.BigInteger,System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>To perform exponentiation on <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> values without modulus division, use the <ph id="ph2">&lt;xref:System.Numerics.BigInteger.Pow%2A&gt;</ph> method.</source>
          <target state="translated">Para executar o expoente em <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> valores sem divisão do módulo, use o <ph id="ph2">&lt;xref:System.Numerics.BigInteger.Pow%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.ModPow(System.Numerics.BigInteger,System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>The following example provides a simple illustration of calling the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.ModPow%2A&gt;</ph> method.</source>
          <target state="translated">O exemplo a seguir fornece uma ilustração simple de chamar o <ph id="ph1">&lt;xref:System.Numerics.BigInteger.ModPow%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.ModPow(System.Numerics.BigInteger,System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source><ph id="ph1">&lt;paramref name="modulus" /&gt;</ph> is zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="modulus" /&gt;</ph> é zero.</target>       </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.ModPow(System.Numerics.BigInteger,System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source><ph id="ph1">&lt;paramref name="exponent" /&gt;</ph> is negative.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="exponent" /&gt;</ph> é negativo.</target>       </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.Multiply(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>The first number to multiply.</source>
          <target state="translated">O primeiro número a multiplicar.</target>       </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.Multiply(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>The second number to multiply.</source>
          <target state="translated">O segundo número a multiplicar.</target>       </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.Multiply(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>Returns the product of two <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> values.</source>
          <target state="translated">Retorna o produto de dois valores <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.Multiply(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>The product of the <ph id="ph1">&lt;paramref name="left" /&gt;</ph> and <ph id="ph2">&lt;paramref name="right" /&gt;</ph> parameters.</source>
          <target state="translated">O produto dos parâmetros <ph id="ph1">&lt;paramref name="left" /&gt;</ph> e <ph id="ph2">&lt;paramref name="right" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Multiply(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Multiply%2A&gt;</ph> method is implemented for languages that do not support operator overloading.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Multiply%2A&gt;</ph> método é implementado para os idiomas que não oferecem suporte a sobrecarga de operador.</target>       </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Multiply(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>Its behavior is identical to multiplication using the multiplication operator.</source>
          <target state="translated">Seu comportamento é idêntico a multiplicação usando o operador de multiplicação.</target>       </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Multiply(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>In addition, the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Multiply%2A&gt;</ph> method is a useful substitute for the multiplication operator when instantiating a <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> variable by assigning it a product that results from multiplication, as shown in the following example.</source>
          <target state="translated">Além disso, o <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Multiply%2A&gt;</ph> método é um substituto úteis para o operador de multiplicação ao instanciar um <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> variável atribuindo a ele um produto que resulta da multiplicação, conforme mostrado no exemplo a seguir.</target>       </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Multiply(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>If necessary, this method automatically performs implicit conversion of other integral types to <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> objects.</source>
          <target state="translated">Se necessário, esse método executa automaticamente a conversão implícita de outros tipos integrais <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> objetos.</target>       </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Multiply(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>This is illustrated in the example in the next section, where the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Multiply%2A&gt;</ph> method is passed two <ph id="ph2">&lt;xref:System.Int64&gt;</ph> values.</source>
          <target state="translated">Isso é ilustrado no exemplo na próxima seção, onde o <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Multiply%2A&gt;</ph> método é passado duas <ph id="ph2">&lt;xref:System.Int64&gt;</ph> valores.</target>       </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Multiply(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>The following example tries to perform multiplication with two long integers.</source>
          <target state="translated">O exemplo a seguir tenta executar multiplicação com dois inteiros longos.</target>       </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Multiply(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>Because the result exceeds the range of a long integer, an <ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown, and the <ph id="ph2">&lt;xref:System.Numerics.BigInteger.Multiply%2A&gt;</ph> method is called to handle the multiplication.</source>
          <target state="translated">Porque o resultado excede o intervalo de um inteiro longo, um <ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> é acionada e o <ph id="ph2">&lt;xref:System.Numerics.BigInteger.Multiply%2A&gt;</ph> método é chamado para manipular a multiplicação.</target>       </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Multiply(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>Note that C# requires that you use either the <ph id="ph1">`checked`</ph> keyword (as in this example) or the <ph id="ph2">`/checked+`</ph> compiler option to make sure an exception is thrown on a numeric overflow.</source>
          <target state="translated">Observe que c# requer que você use o <ph id="ph1">`checked`</ph> palavra-chave (como neste exemplo) ou o <ph id="ph2">`/checked+`</ph> a opção de compilador para verificar se uma exceção será lançada em um estouro numéricos.</target>       </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.Negate(System.Numerics.BigInteger)">
          <source>The value to negate.</source>
          <target state="translated">O valor a ser negado.</target>       </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.Negate(System.Numerics.BigInteger)">
          <source>Negates a specified <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> value.</source>
          <target state="translated">Nega um valor <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> especificado.</target>       </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.Negate(System.Numerics.BigInteger)">
          <source>The result of the <ph id="ph1">&lt;paramref name="value" /&gt;</ph> parameter multiplied by negative one (-1).</source>
          <target state="translated">O resultado do parâmetro <ph id="ph1">&lt;paramref name="value" /&gt;</ph> multiplicado por um negativo (-1).</target>       </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Negate(System.Numerics.BigInteger)">
          <source>Negation obtains the additive inverse of a number.</source>
          <target state="translated">Negação obtém o inverso aditivo de um número.</target>       </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Negate(System.Numerics.BigInteger)">
          <source>The additive inverse of a number is a number that produces a value of zero when it is added to the original number.</source>
          <target state="translated">O inverso aditivo de um número é um número que produz um valor de zero quando ela é adicionada ao número original.</target>       </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Negate(System.Numerics.BigInteger)">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Negate%2A&gt;</ph> method is implemented for languages that do not support custom operators.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Negate%2A&gt;</ph> método é implementado para os idiomas que não dão suporte a operadores personalizados.</target>       </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Negate(System.Numerics.BigInteger)">
          <source>Its behavior is identical to negation using the unary negation operator.</source>
          <target state="translated">Seu comportamento é idêntico ao usando o operador de negação unário de negação.</target>       </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Negate(System.Numerics.BigInteger)">
          <source>In addition, the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Negate%2A&gt;</ph> method is a useful substitute for the negation operator when instantiating a <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> variable, as shown in the following example.</source>
          <target state="translated">Além disso, o <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Negate%2A&gt;</ph> método é um substituto úteis para o operador de negação ao instanciar um <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> variável, conforme mostrado no exemplo a seguir.</target>       </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Negate(System.Numerics.BigInteger)">
          <source>The following example illustrates three ways to negate the value of a <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> object.</source>
          <target state="translated">O exemplo a seguir ilustra três maneiras para negar o valor de uma <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve" uid="P:System.Numerics.BigInteger.One">
          <source>Gets a value that represents the number one (1).</source>
          <target state="translated">Obtém um valor que representa o número um (1).</target>       </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Numerics.BigInteger.One">
          <source>An object whose value is one (1).</source>
          <target state="translated">Um objeto cujo valor é um (1).</target>       </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Numerics.BigInteger.One">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.One%2A&gt;</ph> property is usually used to compare a <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> value to 1 or to assign 1 to a <ph id="ph3">&lt;xref:System.Numerics.BigInteger&gt;</ph> object.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Numerics.BigInteger.One%2A&gt;</ph> propriedade normalmente é usada para comparar um <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> valor como 1 ou atribuir 1 para uma <ph id="ph3">&lt;xref:System.Numerics.BigInteger&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Addition(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>The first value to add.</source>
          <target state="translated">O primeiro valor a ser adicionado.</target>       </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Addition(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>The second value to add.</source>
          <target state="translated">O segundo valor a ser adicionado.</target>       </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Addition(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>Adds the values of two specified <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> objects.</source>
          <target state="translated">Adiciona os valores dos dois objetos <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> especificados.</target>       </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Addition(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>The sum of <ph id="ph1">&lt;paramref name="left" /&gt;</ph> and <ph id="ph2">&lt;paramref name="right" /&gt;</ph>.</source>
          <target state="translated">A soma de <ph id="ph1">&lt;paramref name="left" /&gt;</ph> e <ph id="ph2">&lt;paramref name="right" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Addition(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_Addition%2A&gt;</ph> method defines the addition operation for <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> values.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_Addition%2A&gt;</ph> método define a operação de adição para <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> valores.</target>       </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Addition(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>It enables code such as the following:</source>
          <target state="translated">Ele permite que o código seja o seguinte:</target>       </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Addition(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>Languages that do not support custom operators can call the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Add%2A&gt;</ph> method instead.</source>
          <target state="translated">Linguagens que não dão suporte a operadores personalizados podem chamar o método <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Add%2A&gt;</ph> em vez disso.</target>       </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_BitwiseAnd(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>The first value.</source>
          <target state="translated">O primeiro valor.</target>       </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_BitwiseAnd(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>The second value.</source>
          <target state="translated">O segundo valor.</target>       </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_BitwiseAnd(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>Performs a bitwise <ph id="ph1">&lt;see langword="And" /&gt;</ph> operation on two <ph id="ph2">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> values.</source>
          <target state="translated">Executa uma operação <ph id="ph1">&lt;see langword="And" /&gt;</ph> bit a bit em dois valores <ph id="ph2">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_BitwiseAnd(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>The result of the bitwise <ph id="ph1">&lt;see langword="And" /&gt;</ph> operation.</source>
          <target state="translated">O resultado da operação <ph id="ph1">&lt;see langword="And" /&gt;</ph> bit a bit.</target>       </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_BitwiseAnd(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_BitwiseAnd%2A&gt;</ph> method defines the bitwise <ph id="ph2">`And`</ph> operation for <ph id="ph3">&lt;xref:System.Numerics.BigInteger&gt;</ph> values.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_BitwiseAnd%2A&gt;</ph> método define o bit a bit <ph id="ph2">`And`</ph> operação para <ph id="ph3">&lt;xref:System.Numerics.BigInteger&gt;</ph> valores.</target>       </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_BitwiseAnd(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>The bitwise <ph id="ph1">`And`</ph> operation sets a result bit only if the corresponding bits in <ph id="ph2">`left`</ph> and <ph id="ph3">`right`</ph> are also set, as shown in the following table.</source>
          <target state="translated">Bit a bit <ph id="ph1">`And`</ph> operação define um se apenas de bit de resultado os bits correspondentes em <ph id="ph2">`left`</ph> e <ph id="ph3">`right`</ph> também são definidas, conforme mostrado na tabela a seguir.</target>       </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_BitwiseAnd(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>Bit in <ph id="ph1">`left`</ph></source>
          <target state="translated">Bit no <ph id="ph1">`left`</ph></target>       </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_BitwiseAnd(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>Bit in <ph id="ph1">`right`</ph></source>
          <target state="translated">Bit no <ph id="ph1">`right`</ph></target>       </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_BitwiseAnd(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>Bit in result</source>
          <target state="translated">Bit no resultado</target>       </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_BitwiseAnd(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>0</source>
          <target state="translated">0</target>       </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_BitwiseAnd(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>0</source>
          <target state="translated">0</target>       </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_BitwiseAnd(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>0</source>
          <target state="translated">0</target>       </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_BitwiseAnd(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>1</source>
          <target state="translated">1</target>       </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_BitwiseAnd(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>0</source>
          <target state="translated">0</target>       </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_BitwiseAnd(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>0</source>
          <target state="translated">0</target>       </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_BitwiseAnd(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>1</source>
          <target state="translated">1</target>       </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_BitwiseAnd(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>1</source>
          <target state="translated">1</target>       </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_BitwiseAnd(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>1</source>
          <target state="translated">1</target>       </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_BitwiseAnd(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>0</source>
          <target state="translated">0</target>       </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_BitwiseAnd(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>1</source>
          <target state="translated">1</target>       </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_BitwiseAnd(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>0</source>
          <target state="translated">0</target>       </trans-unit>
        <trans-unit id="613" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_BitwiseAnd(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_BitwiseAnd%2A&gt;</ph> method enables code such as the following:</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_BitwiseAnd%2A&gt;</ph> método permite que o código como o seguinte:</target>       </trans-unit>
        <trans-unit id="614" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_BitwiseAnd(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_BitwiseAnd%2A&gt;</ph> method performs the bitwise <ph id="ph2">`And`</ph> operation on two <ph id="ph3">&lt;xref:System.Numerics.BigInteger&gt;</ph> values as if they were both in two's complement representation with virtual sign extension.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_BitwiseAnd%2A&gt;</ph> método executa bit a bit <ph id="ph2">`And`</ph> operação em dois <ph id="ph3">&lt;xref:System.Numerics.BigInteger&gt;</ph> valores como se estivesse em dois complemento representação com extensão de entrada virtual.</target>       </trans-unit>
        <trans-unit id="615" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_BitwiseOr(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>The first value.</source>
          <target state="translated">O primeiro valor.</target>       </trans-unit>
        <trans-unit id="616" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_BitwiseOr(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>The second value.</source>
          <target state="translated">O segundo valor.</target>       </trans-unit>
        <trans-unit id="617" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_BitwiseOr(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>Performs a bitwise <ph id="ph1">&lt;see langword="Or" /&gt;</ph> operation on two <ph id="ph2">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> values.</source>
          <target state="translated">Executa uma operação <ph id="ph1">&lt;see langword="Or" /&gt;</ph> bit a bit em dois valores <ph id="ph2">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="618" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_BitwiseOr(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>The result of the bitwise <ph id="ph1">&lt;see langword="Or" /&gt;</ph> operation.</source>
          <target state="translated">O resultado da operação <ph id="ph1">&lt;see langword="Or" /&gt;</ph> bit a bit.</target>       </trans-unit>
        <trans-unit id="619" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_BitwiseOr(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_BitwiseOr%2A&gt;</ph> method defines the bitwise <ph id="ph2">`Or`</ph> operation for <ph id="ph3">&lt;xref:System.Numerics.BigInteger&gt;</ph> values.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_BitwiseOr%2A&gt;</ph> método define o bit a bit <ph id="ph2">`Or`</ph> operação para <ph id="ph3">&lt;xref:System.Numerics.BigInteger&gt;</ph> valores.</target>       </trans-unit>
        <trans-unit id="620" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_BitwiseOr(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>The bitwise <ph id="ph1">`Or`</ph> operation sets a result bit only if either or both of the corresponding bits in <ph id="ph2">`left`</ph> and <ph id="ph3">`right`</ph> are set, as shown in the following table.</source>
          <target state="translated">Bit a bit <ph id="ph1">`Or`</ph> operação define um se apenas de bit de resultado de um ou ambos os bits correspondentes em <ph id="ph2">`left`</ph> e <ph id="ph3">`right`</ph> estiverem definidas, conforme mostrado na tabela a seguir.</target>       </trans-unit>
        <trans-unit id="621" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_BitwiseOr(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>Bit in <ph id="ph1">`left`</ph></source>
          <target state="translated">Bit no <ph id="ph1">`left`</ph></target>       </trans-unit>
        <trans-unit id="622" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_BitwiseOr(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>Bit in <ph id="ph1">`right`</ph></source>
          <target state="translated">Bit no <ph id="ph1">`right`</ph></target>       </trans-unit>
        <trans-unit id="623" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_BitwiseOr(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>Bit in result</source>
          <target state="translated">Bit no resultado</target>       </trans-unit>
        <trans-unit id="624" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_BitwiseOr(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>0</source>
          <target state="translated">0</target>       </trans-unit>
        <trans-unit id="625" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_BitwiseOr(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>0</source>
          <target state="translated">0</target>       </trans-unit>
        <trans-unit id="626" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_BitwiseOr(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>0</source>
          <target state="translated">0</target>       </trans-unit>
        <trans-unit id="627" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_BitwiseOr(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>1</source>
          <target state="translated">1</target>       </trans-unit>
        <trans-unit id="628" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_BitwiseOr(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>0</source>
          <target state="translated">0</target>       </trans-unit>
        <trans-unit id="629" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_BitwiseOr(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>1</source>
          <target state="translated">1</target>       </trans-unit>
        <trans-unit id="630" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_BitwiseOr(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>1</source>
          <target state="translated">1</target>       </trans-unit>
        <trans-unit id="631" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_BitwiseOr(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>1</source>
          <target state="translated">1</target>       </trans-unit>
        <trans-unit id="632" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_BitwiseOr(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>1</source>
          <target state="translated">1</target>       </trans-unit>
        <trans-unit id="633" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_BitwiseOr(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>0</source>
          <target state="translated">0</target>       </trans-unit>
        <trans-unit id="634" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_BitwiseOr(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>1</source>
          <target state="translated">1</target>       </trans-unit>
        <trans-unit id="635" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_BitwiseOr(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>1</source>
          <target state="translated">1</target>       </trans-unit>
        <trans-unit id="636" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_BitwiseOr(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_BitwiseOr%2A&gt;</ph> method enables code such as the following:</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_BitwiseOr%2A&gt;</ph> método permite que o código como o seguinte:</target>       </trans-unit>
        <trans-unit id="637" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_BitwiseOr(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_BitwiseOr%2A&gt;</ph> method performs the bitwise <ph id="ph2">`Or`</ph> operation on two <ph id="ph3">&lt;xref:System.Numerics.BigInteger&gt;</ph> values as if they were both in two's complement representation with virtual sign extension.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_BitwiseOr%2A&gt;</ph> método executa bit a bit <ph id="ph2">`Or`</ph> operação em dois <ph id="ph3">&lt;xref:System.Numerics.BigInteger&gt;</ph> valores como se estivesse em dois complemento representação com extensão de entrada virtual.</target>       </trans-unit>
        <trans-unit id="638" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Decrement(System.Numerics.BigInteger)">
          <source>The value to decrement.</source>
          <target state="translated">O valor a ser diminuído.</target>       </trans-unit>
        <trans-unit id="639" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Decrement(System.Numerics.BigInteger)">
          <source>Decrements a <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> value by 1.</source>
          <target state="translated">Diminui um valor <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> em 1.</target>       </trans-unit>
        <trans-unit id="640" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Decrement(System.Numerics.BigInteger)">
          <source>The value of the <ph id="ph1">&lt;paramref name="value" /&gt;</ph> parameter decremented by 1.</source>
          <target state="translated">O valor do parâmetro <ph id="ph1">&lt;paramref name="value" /&gt;</ph> diminuído em 1.</target>       </trans-unit>
        <trans-unit id="641" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Decrement(System.Numerics.BigInteger)">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_Decrement%2A&gt;</ph> method defines the decrement operation for <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> values.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_Decrement%2A&gt;</ph> método define a operação de decremento para <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> valores.</target>       </trans-unit>
        <trans-unit id="642" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Decrement(System.Numerics.BigInteger)">
          <source>It enables code such as the following:</source>
          <target state="translated">Ele permite que o código seja o seguinte:</target>       </trans-unit>
        <trans-unit id="643" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Decrement(System.Numerics.BigInteger)">
          <source>Languages that do not support custom operators can call the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Subtract%2A&gt;</ph> method instead.</source>
          <target state="translated">Linguagens que não dão suporte a operadores personalizados podem chamar o método <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Subtract%2A&gt;</ph> em vez disso.</target>       </trans-unit>
        <trans-unit id="644" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Decrement(System.Numerics.BigInteger)">
          <source>For example:</source>
          <target state="translated">Por exemplo:</target>       </trans-unit>
        <trans-unit id="645" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Decrement(System.Numerics.BigInteger)">
          <source>Because <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> objects are immutable, the <ph id="ph2">&lt;xref:System.Numerics.BigInteger.op_Decrement%2A&gt;</ph> operator creates a new <ph id="ph3">&lt;xref:System.Numerics.BigInteger&gt;</ph> object whose value is one less than the <ph id="ph4">&lt;xref:System.Numerics.BigInteger&gt;</ph> object represented by <ph id="ph5">`value`</ph>.</source>
          <target state="translated">Porque <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> objetos são imutáveis, a <ph id="ph2">&lt;xref:System.Numerics.BigInteger.op_Decrement%2A&gt;</ph> operador cria um novo <ph id="ph3">&lt;xref:System.Numerics.BigInteger&gt;</ph> objeto cujo valor é um menor do que o <ph id="ph4">&lt;xref:System.Numerics.BigInteger&gt;</ph> objeto representado pelo <ph id="ph5">`value`</ph>.</target>       </trans-unit>
        <trans-unit id="646" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Decrement(System.Numerics.BigInteger)">
          <source>This means that repeated calls to <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_Decrement%2A&gt;</ph> may be expensive.</source>
          <target state="translated">Isso significa que repetidas chamadas para <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_Decrement%2A&gt;</ph> pode ser cara.</target>       </trans-unit>
        <trans-unit id="647" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Decrement(System.Numerics.BigInteger)">
          <source>The equivalent method for this operator is <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Subtract%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">O método equivalente para esse operador é <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Subtract%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="648" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Division(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>The value to be divided.</source>
          <target state="translated">O valor a ser dividido.</target>       </trans-unit>
        <trans-unit id="649" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Division(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>The value to divide by.</source>
          <target state="translated">O valor pelo qual dividir.</target>       </trans-unit>
        <trans-unit id="650" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Division(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>Divides a specified <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> value by another specified <ph id="ph2">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> value by using integer division.</source>
          <target state="translated">Divide um valor <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> especificado por outro valor <ph id="ph2">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> especificado usando a divisão de inteiros.</target>       </trans-unit>
        <trans-unit id="651" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Division(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>The integral result of the division.</source>
          <target state="translated">O resultado integral da divisão.</target>       </trans-unit>
        <trans-unit id="652" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Division(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_Division%2A&gt;</ph> method defines the division operation for <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> values.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_Division%2A&gt;</ph> método define a operação de divisão para <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> valores.</target>       </trans-unit>
        <trans-unit id="653" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Division(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>It enables code such as the following:</source>
          <target state="translated">Ele permite que o código seja o seguinte:</target>       </trans-unit>
        <trans-unit id="654" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Division(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>Languages that do not support custom operators and operator overloading can call the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Divide%2A&gt;</ph> method instead.</source>
          <target state="translated">Idiomas que dão suporte a operadores personalizados e sobrecarga de operador podem chamar o <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Divide%2A&gt;</ph> método em vez disso.</target>       </trans-unit>
        <trans-unit id="655" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Division(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>The equivalent method for this operator is <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Divide%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType&gt;</ph></source>
          <target state="translated">O método equivalente para esse operador é <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Divide%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType&gt;</ph></target>       </trans-unit>
        <trans-unit id="656" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Division(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>The following example creates an array of <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> values.</source>
          <target state="translated">O exemplo a seguir cria uma matriz de <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> valores.</target>       </trans-unit>
        <trans-unit id="657" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Division(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>It then uses each element as the quotient in a division operation that uses the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Divide%2A&gt;</ph> method, the division operator (/), and the <ph id="ph2">&lt;xref:System.Numerics.BigInteger.DivRem%2A&gt;</ph> method.</source>
          <target state="translated">Ele usa, em seguida, cada elemento como o quociente em uma operação de divisão que usa o <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Divide%2A&gt;</ph> método, o operador de divisão (/) e o <ph id="ph2">&lt;xref:System.Numerics.BigInteger.DivRem%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="658" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Division(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source><ph id="ph1">&lt;paramref name="divisor" /&gt;</ph> is 0 (zero).</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="divisor" /&gt;</ph> é 0 (zero).</target>       </trans-unit>
        <trans-unit id="659" translate="yes" xml:space="preserve" uid="T:System.Numerics.BigInteger">
          <source>Returns a value that indicates whether two values are equal.</source>
          <target state="translated">Retorna um valor que indica se dois valores são iguais.</target>       </trans-unit>
        <trans-unit id="660" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Equality(System.Int64,System.Numerics.BigInteger)">
          <source>The first value to compare.</source>
          <target state="translated">O primeiro valor a ser comparado.</target>       </trans-unit>
        <trans-unit id="661" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Equality(System.Int64,System.Numerics.BigInteger)">
          <source>The second value to compare.</source>
          <target state="translated">O segundo valor a ser comparado.</target>       </trans-unit>
        <trans-unit id="662" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Equality(System.Int64,System.Numerics.BigInteger)">
          <source>Returns a value that indicates whether a signed long integer value and a <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> value are equal.</source>
          <target state="translated">Retorna um valor que indica se um valor inteiro longo com sinal e um valor <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> são iguais.</target>       </trans-unit>
        <trans-unit id="663" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Equality(System.Int64,System.Numerics.BigInteger)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;paramref name="left" /&gt;</ph> and <ph id="ph3">&lt;paramref name="right" /&gt;</ph> parameters have the same value; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se os parâmetros <ph id="ph2">&lt;paramref name="left" /&gt;</ph> e <ph id="ph3">&lt;paramref name="right" /&gt;</ph> tiverem o mesmo valor; caso contrário, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="664" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Equality(System.Int64,System.Numerics.BigInteger)">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_Equality%28System.Int64%2CSystem.Numerics.BigInteger%29&gt;</ph> method defines the equality comparison operation for <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> values.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_Equality%28System.Int64%2CSystem.Numerics.BigInteger%29&gt;</ph> método define a operação de comparação de igualdade para <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> valores.</target>       </trans-unit>
        <trans-unit id="665" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Equality(System.Int64,System.Numerics.BigInteger)">
          <source>It enables code such as the following:</source>
          <target state="translated">Ele permite que o código seja o seguinte:</target>       </trans-unit>
        <trans-unit id="666" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Equality(System.Int64,System.Numerics.BigInteger)">
          <source>Languages that do not support custom operators can call the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType&gt;</ph> instance method instead.</source>
          <target state="translated">Idiomas que dão suporte a operadores personalizados podem chamar o <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType&gt;</ph> em vez disso, o método de instância.</target>       </trans-unit>
        <trans-unit id="667" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Equality(System.Int64,System.Numerics.BigInteger)">
          <source>If <ph id="ph1">`left`</ph> is a <ph id="ph2">&lt;xref:System.Byte&gt;</ph>, <ph id="ph3">&lt;xref:System.Int16&gt;</ph>, <ph id="ph4">&lt;xref:System.Int32&gt;</ph>, <ph id="ph5">&lt;xref:System.SByte&gt;</ph>, <ph id="ph6">&lt;xref:System.UInt16&gt;</ph>, or <ph id="ph7">&lt;xref:System.UInt32&gt;</ph> value, it is implicitly converted to an <ph id="ph8">&lt;xref:System.Int64&gt;</ph> value when the operation is performed.</source>
          <target state="translated">Se <ph id="ph1">`left`</ph> é um <ph id="ph2">&lt;xref:System.Byte&gt;</ph>, <ph id="ph3">&lt;xref:System.Int16&gt;</ph>, <ph id="ph4">&lt;xref:System.Int32&gt;</ph>, <ph id="ph5">&lt;xref:System.SByte&gt;</ph>, <ph id="ph6">&lt;xref:System.UInt16&gt;</ph>, ou <ph id="ph7">&lt;xref:System.UInt32&gt;</ph> valor, ele é convertido implicitamente em um <ph id="ph8">&lt;xref:System.Int64&gt;</ph> valor quando a operação é executada.</target>       </trans-unit>
        <trans-unit id="668" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Equality(System.Int64,System.Numerics.BigInteger)">
          <source>The equivalent method for this operator is <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">O método equivalente para esse operador é <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="669" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Equality(System.Numerics.BigInteger,System.Int64)">
          <source>The first value to compare.</source>
          <target state="translated">O primeiro valor a ser comparado.</target>       </trans-unit>
        <trans-unit id="670" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Equality(System.Numerics.BigInteger,System.Int64)">
          <source>The second value to compare.</source>
          <target state="translated">O segundo valor a ser comparado.</target>       </trans-unit>
        <trans-unit id="671" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Equality(System.Numerics.BigInteger,System.Int64)">
          <source>Returns a value that indicates whether a <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> value and a signed long integer value are equal.</source>
          <target state="translated">Retorna um valor que indica se um valor <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> e um valor inteiro longo com sinal são iguais.</target>       </trans-unit>
        <trans-unit id="672" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Equality(System.Numerics.BigInteger,System.Int64)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;paramref name="left" /&gt;</ph> and <ph id="ph3">&lt;paramref name="right" /&gt;</ph> parameters have the same value; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se os parâmetros <ph id="ph2">&lt;paramref name="left" /&gt;</ph> e <ph id="ph3">&lt;paramref name="right" /&gt;</ph> tiverem o mesmo valor; caso contrário, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="673" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Equality(System.Numerics.BigInteger,System.Int64)">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_Equality%28System.Numerics.BigInteger%2CSystem.Int64%29&gt;</ph> method defines the equality comparison operation for <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> values.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_Equality%28System.Numerics.BigInteger%2CSystem.Int64%29&gt;</ph> método define a operação de comparação de igualdade para <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> valores.</target>       </trans-unit>
        <trans-unit id="674" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Equality(System.Numerics.BigInteger,System.Int64)">
          <source>It enables code such as the following:</source>
          <target state="translated">Ele permite que o código seja o seguinte:</target>       </trans-unit>
        <trans-unit id="675" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Equality(System.Numerics.BigInteger,System.Int64)">
          <source>Languages that do not support custom operators can call the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType&gt;</ph> instance method instead.</source>
          <target state="translated">Idiomas que dão suporte a operadores personalizados podem chamar o <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType&gt;</ph> em vez disso, o método de instância.</target>       </trans-unit>
        <trans-unit id="676" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Equality(System.Numerics.BigInteger,System.Int64)">
          <source>If <ph id="ph1">`right`</ph> is a <ph id="ph2">&lt;xref:System.Byte&gt;</ph>, <ph id="ph3">&lt;xref:System.Int16&gt;</ph>, <ph id="ph4">&lt;xref:System.Int32&gt;</ph>, <ph id="ph5">&lt;xref:System.SByte&gt;</ph>, <ph id="ph6">&lt;xref:System.UInt16&gt;</ph>, or <ph id="ph7">&lt;xref:System.UInt32&gt;</ph> value, it is implicitly converted to an <ph id="ph8">&lt;xref:System.Int64&gt;</ph> value when the operation is performed.</source>
          <target state="translated">Se <ph id="ph1">`right`</ph> é um <ph id="ph2">&lt;xref:System.Byte&gt;</ph>, <ph id="ph3">&lt;xref:System.Int16&gt;</ph>, <ph id="ph4">&lt;xref:System.Int32&gt;</ph>, <ph id="ph5">&lt;xref:System.SByte&gt;</ph>, <ph id="ph6">&lt;xref:System.UInt16&gt;</ph>, ou <ph id="ph7">&lt;xref:System.UInt32&gt;</ph> valor, ele é convertido implicitamente em um <ph id="ph8">&lt;xref:System.Int64&gt;</ph> valor quando a operação é executada.</target>       </trans-unit>
        <trans-unit id="677" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Equality(System.Numerics.BigInteger,System.Int64)">
          <source>The equivalent method for this operator is <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">O método equivalente para esse operador é <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="678" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Equality(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>The first value to compare.</source>
          <target state="translated">O primeiro valor a ser comparado.</target>       </trans-unit>
        <trans-unit id="679" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Equality(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>The second value to compare.</source>
          <target state="translated">O segundo valor a ser comparado.</target>       </trans-unit>
        <trans-unit id="680" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Equality(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>Returns a value that indicates whether the values of two <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> objects are equal.</source>
          <target state="translated">Retorna um valor que indica se os valores de dois objetos <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> são iguais.</target>       </trans-unit>
        <trans-unit id="681" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Equality(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;paramref name="left" /&gt;</ph> and <ph id="ph3">&lt;paramref name="right" /&gt;</ph> parameters have the same value; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se os parâmetros <ph id="ph2">&lt;paramref name="left" /&gt;</ph> e <ph id="ph3">&lt;paramref name="right" /&gt;</ph> tiverem o mesmo valor; caso contrário, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="682" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Equality(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_Equality%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29&gt;</ph> method defines the operation of the equality operator for <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> values.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_Equality%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29&gt;</ph> método define a operação do operador de igualdade para <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> valores.</target>       </trans-unit>
        <trans-unit id="683" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Equality(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>It enables code such as the following:</source>
          <target state="translated">Ele permite que o código seja o seguinte:</target>       </trans-unit>
        <trans-unit id="684" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Equality(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>Languages that do not support custom operators can call the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Equals%28System.Numerics.BigInteger%29?displayProperty=nameWithType&gt;</ph> instance method instead.</source>
          <target state="translated">Idiomas que dão suporte a operadores personalizados podem chamar o <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Equals%28System.Numerics.BigInteger%29?displayProperty=nameWithType&gt;</ph> em vez disso, o método de instância.</target>       </trans-unit>
        <trans-unit id="685" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Equality(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>The equivalent method for this operator is <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Equals%28System.Numerics.BigInteger%29?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">O método equivalente para esse operador é <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Equals%28System.Numerics.BigInteger%29?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="686" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Equality(System.Numerics.BigInteger,System.UInt64)">
          <source>The first value to compare.</source>
          <target state="translated">O primeiro valor a ser comparado.</target>       </trans-unit>
        <trans-unit id="687" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Equality(System.Numerics.BigInteger,System.UInt64)">
          <source>The second value to compare.</source>
          <target state="translated">O segundo valor a ser comparado.</target>       </trans-unit>
        <trans-unit id="688" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Equality(System.Numerics.BigInteger,System.UInt64)">
          <source>Returns a value that indicates whether a <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> value and an unsigned long integer value are equal.</source>
          <target state="translated">Retorna um valor que indica se um valor <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> e um valor inteiro longo sem sinal são iguais.</target>       </trans-unit>
        <trans-unit id="689" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Equality(System.Numerics.BigInteger,System.UInt64)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;paramref name="left" /&gt;</ph> and <ph id="ph3">&lt;paramref name="right" /&gt;</ph> parameters have the same value; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se os parâmetros <ph id="ph2">&lt;paramref name="left" /&gt;</ph> e <ph id="ph3">&lt;paramref name="right" /&gt;</ph> tiverem o mesmo valor; caso contrário, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="690" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Equality(System.Numerics.BigInteger,System.UInt64)">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_Equality%28System.Numerics.BigInteger%2CSystem.UInt64%29&gt;</ph> method defines the equality comparison operation for <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> values.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_Equality%28System.Numerics.BigInteger%2CSystem.UInt64%29&gt;</ph> método define a operação de comparação de igualdade para <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> valores.</target>       </trans-unit>
        <trans-unit id="691" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Equality(System.Numerics.BigInteger,System.UInt64)">
          <source>It enables code such as the following:</source>
          <target state="translated">Ele permite que o código seja o seguinte:</target>       </trans-unit>
        <trans-unit id="692" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Equality(System.Numerics.BigInteger,System.UInt64)">
          <source>Languages that do not support custom operators can call the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Equals%28System.UInt64%29?displayProperty=nameWithType&gt;</ph> instance method instead.</source>
          <target state="translated">Idiomas que dão suporte a operadores personalizados podem chamar o <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Equals%28System.UInt64%29?displayProperty=nameWithType&gt;</ph> em vez disso, o método de instância.</target>       </trans-unit>
        <trans-unit id="693" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Equality(System.UInt64,System.Numerics.BigInteger)">
          <source>The first value to compare.</source>
          <target state="translated">O primeiro valor a ser comparado.</target>       </trans-unit>
        <trans-unit id="694" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Equality(System.UInt64,System.Numerics.BigInteger)">
          <source>The second value to compare.</source>
          <target state="translated">O segundo valor a ser comparado.</target>       </trans-unit>
        <trans-unit id="695" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Equality(System.UInt64,System.Numerics.BigInteger)">
          <source>Returns a value that indicates whether an unsigned long integer value and a <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> value are equal.</source>
          <target state="translated">Retorna um valor que indica se um valor inteiro longo sem sinal e um valor <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> são iguais.</target>       </trans-unit>
        <trans-unit id="696" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Equality(System.UInt64,System.Numerics.BigInteger)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;paramref name="left" /&gt;</ph> and <ph id="ph3">&lt;paramref name="right" /&gt;</ph> parameters have the same value; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se os parâmetros <ph id="ph2">&lt;paramref name="left" /&gt;</ph> e <ph id="ph3">&lt;paramref name="right" /&gt;</ph> tiverem o mesmo valor; caso contrário, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="697" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Equality(System.UInt64,System.Numerics.BigInteger)">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_Equality%28System.UInt64%2CSystem.Numerics.BigInteger%29&gt;</ph> method defines the equality comparison operation for <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> values.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_Equality%28System.UInt64%2CSystem.Numerics.BigInteger%29&gt;</ph> método define a operação de comparação de igualdade para <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> valores.</target>       </trans-unit>
        <trans-unit id="698" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Equality(System.UInt64,System.Numerics.BigInteger)">
          <source>It enables code such as the following:</source>
          <target state="translated">Ele permite que o código seja o seguinte:</target>       </trans-unit>
        <trans-unit id="699" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Equality(System.UInt64,System.Numerics.BigInteger)">
          <source>Languages that do not support custom operators can call the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Equals%28System.UInt64%29?displayProperty=nameWithType&gt;</ph> instance method instead.</source>
          <target state="translated">Idiomas que dão suporte a operadores personalizados podem chamar o <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Equals%28System.UInt64%29?displayProperty=nameWithType&gt;</ph> em vez disso, o método de instância.</target>       </trans-unit>
        <trans-unit id="700" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_ExclusiveOr(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>The first value.</source>
          <target state="translated">O primeiro valor.</target>       </trans-unit>
        <trans-unit id="701" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_ExclusiveOr(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>The second value.</source>
          <target state="translated">O segundo valor.</target>       </trans-unit>
        <trans-unit id="702" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_ExclusiveOr(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>Performs a bitwise exclusive <ph id="ph1">&lt;see langword="Or" /&gt;</ph> (<ph id="ph2">&lt;see langword="XOr" /&gt;</ph>) operation on two <ph id="ph3">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> values.</source>
          <target state="translated">Executa uma operação exclusiva <ph id="ph1">&lt;see langword="Or" /&gt;</ph> bit a bit (<ph id="ph2">&lt;see langword="XOr" /&gt;</ph>) em dois valores <ph id="ph3">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="703" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_ExclusiveOr(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>The result of the bitwise <ph id="ph1">&lt;see langword="Or" /&gt;</ph> operation.</source>
          <target state="translated">O resultado da operação <ph id="ph1">&lt;see langword="Or" /&gt;</ph> bit a bit.</target>       </trans-unit>
        <trans-unit id="704" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_ExclusiveOr(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>The result of a bitwise exclusive <ph id="ph1">`Or`</ph> operation is <ph id="ph2">`true`</ph> if the values of the two bits are different; otherwise, it is <ph id="ph3">`false`</ph>.</source>
          <target state="translated">O resultado de um bit a bit exclusivo <ph id="ph1">`Or`</ph> operação <ph id="ph2">`true`</ph> se os valores dos dois bits forem diferentes; caso contrário, é <ph id="ph3">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="705" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_ExclusiveOr(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>The following table illustrates the exclusive <ph id="ph1">`Or`</ph> operation.</source>
          <target state="translated">A tabela a seguir ilustra o exclusivo <ph id="ph1">`Or`</ph> operação.</target>       </trans-unit>
        <trans-unit id="706" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_ExclusiveOr(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>Bit x in <ph id="ph1">`left`</ph></source>
          <target state="translated">Bit x <ph id="ph1">`left`</ph></target>       </trans-unit>
        <trans-unit id="707" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_ExclusiveOr(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>Bit x in <ph id="ph1">`right`</ph></source>
          <target state="translated">Bit x <ph id="ph1">`right`</ph></target>       </trans-unit>
        <trans-unit id="708" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_ExclusiveOr(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>Return value</source>
          <target state="translated">Valor retornado</target>       </trans-unit>
        <trans-unit id="709" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_ExclusiveOr(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>0</source>
          <target state="translated">0</target>       </trans-unit>
        <trans-unit id="710" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_ExclusiveOr(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>0</source>
          <target state="translated">0</target>       </trans-unit>
        <trans-unit id="711" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_ExclusiveOr(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>0</source>
          <target state="translated">0</target>       </trans-unit>
        <trans-unit id="712" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_ExclusiveOr(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>0</source>
          <target state="translated">0</target>       </trans-unit>
        <trans-unit id="713" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_ExclusiveOr(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>1</source>
          <target state="translated">1</target>       </trans-unit>
        <trans-unit id="714" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_ExclusiveOr(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>1</source>
          <target state="translated">1</target>       </trans-unit>
        <trans-unit id="715" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_ExclusiveOr(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>1</source>
          <target state="translated">1</target>       </trans-unit>
        <trans-unit id="716" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_ExclusiveOr(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>0</source>
          <target state="translated">0</target>       </trans-unit>
        <trans-unit id="717" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_ExclusiveOr(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>1</source>
          <target state="translated">1</target>       </trans-unit>
        <trans-unit id="718" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_ExclusiveOr(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>1</source>
          <target state="translated">1</target>       </trans-unit>
        <trans-unit id="719" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_ExclusiveOr(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>1</source>
          <target state="translated">1</target>       </trans-unit>
        <trans-unit id="720" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_ExclusiveOr(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>0</source>
          <target state="translated">0</target>       </trans-unit>
        <trans-unit id="721" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_ExclusiveOr(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_ExclusiveOr%2A&gt;</ph> method enables code such as the following:</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_ExclusiveOr%2A&gt;</ph> método permite que o código como o seguinte:</target>       </trans-unit>
        <trans-unit id="722" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_ExclusiveOr(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_ExclusiveOr%2A&gt;</ph> method performs the bitwise exclusive <ph id="ph2">`Or`</ph> operation on two <ph id="ph3">&lt;xref:System.Numerics.BigInteger&gt;</ph> values as if they were both in two's complement representation with virtual sign extension.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_ExclusiveOr%2A&gt;</ph> método executa bit a bit exclusiva <ph id="ph2">`Or`</ph> operação em dois <ph id="ph3">&lt;xref:System.Numerics.BigInteger&gt;</ph> valores como se estivesse em dois complemento representação com extensão de entrada virtual.</target>       </trans-unit>
        <trans-unit id="723" translate="yes" xml:space="preserve" uid="T:System.Numerics.BigInteger">
          <source>Defines an explicit conversion between a <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> object and another type.</source>
          <target state="translated">Define uma conversão explícita entre um objeto <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> e outro tipo.</target>       </trans-unit>
        <trans-unit id="724" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger">
          <source>The value to convert to a <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph>.</source>
          <target state="translated">O valor a ser convertido para um <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="725" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger">
          <source>Defines an explicit conversion of a <ph id="ph1">&lt;see cref="T:System.Decimal" /&gt;</ph> object to a <ph id="ph2">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> value.</source>
          <target state="translated">Define uma conversão explícita de um objeto <ph id="ph1">&lt;see cref="T:System.Decimal" /&gt;</ph> em um valor <ph id="ph2">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="726" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger">
          <source>An object that contains the value of the <ph id="ph1">&lt;paramref name="value" /&gt;</ph> parameter.</source>
          <target state="translated">Um objeto que contém o valor do parâmetro <ph id="ph1">&lt;paramref name="value" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="727" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger">
          <source>Any fractional part of the <ph id="ph1">`value`</ph> parameter is truncated before conversion.</source>
          <target state="translated">Qualquer parte fracionária do <ph id="ph1">`value`</ph> parâmetro será truncado antes da conversão.</target>       </trans-unit>
        <trans-unit id="728" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger">
          <source>The overloads of the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger&gt;</ph> method define the types to which or from which a <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> object can be converted.</source>
          <target state="translated">As sobrecargas do <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger&gt;</ph> método definem os tipos para o qual ou do qual um <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> objeto pode ser convertido.</target>       </trans-unit>
        <trans-unit id="729" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger">
          <source>Because the conversion from <ph id="ph1">&lt;xref:System.Decimal&gt;</ph> to <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> can involve truncating any fractional part of <ph id="ph3">`value`</ph>, language compilers do not perform this conversion automatically.</source>
          <target state="translated">Porque a conversão de <ph id="ph1">&lt;xref:System.Decimal&gt;</ph> para <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> pode envolver truncar qualquer parte fracionária do <ph id="ph3">`value`</ph>, os compiladores de linguagem não realizar essa conversão automaticamente.</target>       </trans-unit>
        <trans-unit id="730" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger">
          <source>Instead, they perform the conversion only if a casting operator (in C#) or a conversion function (such as <ph id="ph1">`CType`</ph> in Visual Basic) is used.</source>
          <target state="translated">Em vez disso, eles executarem a conversão somente se um operador de conversão (em c#) ou uma função de conversão (como <ph id="ph1">`CType`</ph> no Visual Basic) é usado.</target>       </trans-unit>
        <trans-unit id="731" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger">
          <source>Otherwise, they display a compiler error.</source>
          <target state="translated">Caso contrário, eles exibem um erro do compilador.</target>       </trans-unit>
        <trans-unit id="732" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger">
          <source>For languages that do not support custom operators, the alternative method is <ph id="ph1">&lt;xref:System.Numerics.BigInteger.%23ctor%28System.Decimal%29?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Para idiomas que não dão suporte a operadores personalizados, o método alternativo é <ph id="ph1">&lt;xref:System.Numerics.BigInteger.%23ctor%28System.Decimal%29?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="733" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger">
          <source>The following example converts the individual elements in an array of <ph id="ph1">&lt;xref:System.Decimal&gt;</ph> values to <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> objects, and then displays the result of each conversion.</source>
          <target state="translated">O exemplo a seguir converte os elementos individuais em uma matriz de <ph id="ph1">&lt;xref:System.Decimal&gt;</ph> valores <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> objetos e, em seguida, exibe o resultado de cada conversão.</target>       </trans-unit>
        <trans-unit id="734" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger">
          <source>Note that any fractional part of a <ph id="ph1">&lt;xref:System.Decimal&gt;</ph> value is truncated during the conversion.</source>
          <target state="translated">Observe que qualquer fracionários faz parte de uma <ph id="ph1">&lt;xref:System.Decimal&gt;</ph> valor é truncado durante a conversão.</target>       </trans-unit>
        <trans-unit id="735" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Explicit(System.Double)~System.Numerics.BigInteger">
          <source>The value to convert to a <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph>.</source>
          <target state="translated">O valor a ser convertido para um <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="736" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Explicit(System.Double)~System.Numerics.BigInteger">
          <source>Defines an explicit conversion of a <ph id="ph1">&lt;see cref="T:System.Double" /&gt;</ph> value to a <ph id="ph2">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> value.</source>
          <target state="translated">Define uma conversão explícita de um valor <ph id="ph1">&lt;see cref="T:System.Double" /&gt;</ph> para um valor <ph id="ph2">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="737" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Explicit(System.Double)~System.Numerics.BigInteger">
          <source>An object that contains the value of the <ph id="ph1">&lt;paramref name="value" /&gt;</ph> parameter.</source>
          <target state="translated">Um objeto que contém o valor do parâmetro <ph id="ph1">&lt;paramref name="value" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="738" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Explicit(System.Double)~System.Numerics.BigInteger">
          <source>Any fractional part of the <ph id="ph1">`value`</ph> parameter is truncated before conversion.</source>
          <target state="translated">Qualquer parte fracionária do <ph id="ph1">`value`</ph> parâmetro será truncado antes da conversão.</target>       </trans-unit>
        <trans-unit id="739" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Explicit(System.Double)~System.Numerics.BigInteger">
          <source>The overloads of the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger&gt;</ph> method define the types to which or from which a <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> object can be converted.</source>
          <target state="translated">As sobrecargas do <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger&gt;</ph> método definem os tipos para o qual ou do qual um <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> objeto pode ser convertido.</target>       </trans-unit>
        <trans-unit id="740" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Explicit(System.Double)~System.Numerics.BigInteger">
          <source>Because the conversion from <ph id="ph1">&lt;xref:System.Double&gt;</ph> to <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> can involve truncating any fractional part of <ph id="ph3">`value`</ph>, language compilers do not perform this conversion automatically.</source>
          <target state="translated">Porque a conversão de <ph id="ph1">&lt;xref:System.Double&gt;</ph> para <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> pode envolver truncar qualquer parte fracionária do <ph id="ph3">`value`</ph>, os compiladores de linguagem não realizar essa conversão automaticamente.</target>       </trans-unit>
        <trans-unit id="741" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Explicit(System.Double)~System.Numerics.BigInteger">
          <source>Instead, they perform the conversion only if a casting operator (in C#) or a conversion function (such as <ph id="ph1">`CType`</ph> in Visual Basic) is used.</source>
          <target state="translated">Em vez disso, eles executarem a conversão somente se um operador de conversão (em c#) ou uma função de conversão (como <ph id="ph1">`CType`</ph> no Visual Basic) é usado.</target>       </trans-unit>
        <trans-unit id="742" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Explicit(System.Double)~System.Numerics.BigInteger">
          <source>Otherwise, they display a compiler error.</source>
          <target state="translated">Caso contrário, eles exibem um erro do compilador.</target>       </trans-unit>
        <trans-unit id="743" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Explicit(System.Double)~System.Numerics.BigInteger">
          <source>For languages that do not support custom operators, the alternative method is <ph id="ph1">&lt;xref:System.Numerics.BigInteger.%23ctor%28System.Double%29?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Para idiomas que não dão suporte a operadores personalizados, o método alternativo é <ph id="ph1">&lt;xref:System.Numerics.BigInteger.%23ctor%28System.Double%29?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="744" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Explicit(System.Double)~System.Numerics.BigInteger">
          <source>The following example converts the individual elements in an array of <ph id="ph1">&lt;xref:System.Double&gt;</ph> values to <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> objects, and then displays the result of each conversion.</source>
          <target state="translated">O exemplo a seguir converte os elementos individuais em uma matriz de <ph id="ph1">&lt;xref:System.Double&gt;</ph> valores <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> objetos e, em seguida, exibe o resultado de cada conversão.</target>       </trans-unit>
        <trans-unit id="745" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Explicit(System.Double)~System.Numerics.BigInteger">
          <source>Note that any fractional part of a <ph id="ph1">&lt;xref:System.Double&gt;</ph> value is truncated during the conversion.</source>
          <target state="translated">Observe que qualquer fracionários faz parte de uma <ph id="ph1">&lt;xref:System.Double&gt;</ph> valor é truncado durante a conversão.</target>       </trans-unit>
        <trans-unit id="746" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Explicit(System.Double)~System.Numerics.BigInteger">
          <source>The value of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see cref="F:System.Double.NaN" /&gt;</ph>.</source>
          <target state="translated">O valor de <ph id="ph1">&lt;paramref name="value" /&gt;</ph> é <ph id="ph2">&lt;see cref="F:System.Double.NaN" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="747" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Explicit(System.Double)~System.Numerics.BigInteger">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="748" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Explicit(System.Double)~System.Numerics.BigInteger">
          <source>The value of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see cref="F:System.Double.PositiveInfinity" /&gt;</ph>.</source>
          <target state="translated">O valor de <ph id="ph1">&lt;paramref name="value" /&gt;</ph> é <ph id="ph2">&lt;see cref="F:System.Double.PositiveInfinity" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="749" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Explicit(System.Double)~System.Numerics.BigInteger">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="750" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Explicit(System.Double)~System.Numerics.BigInteger">
          <source>The value of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see cref="F:System.Double.NegativeInfinity" /&gt;</ph>.</source>
          <target state="translated">O valor de <ph id="ph1">&lt;paramref name="value" /&gt;</ph> é <ph id="ph2">&lt;see cref="F:System.Double.NegativeInfinity" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="751" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Byte">
          <source>The value to convert to a <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph>.</source>
          <target state="translated">O valor a ser convertido para um <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="752" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Byte">
          <source>Defines an explicit conversion of a <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> object to an unsigned byte value.</source>
          <target state="translated">Define uma conversão explícita de um objeto <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> em um valor de byte sem sinal.</target>       </trans-unit>
        <trans-unit id="753" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Byte">
          <source>An object that contains the value of the <ph id="ph1">&lt;paramref name="value" /&gt;</ph> parameter.</source>
          <target state="translated">Um objeto que contém o valor do parâmetro <ph id="ph1">&lt;paramref name="value" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="754" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Byte">
          <source>The overloads of the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger&gt;</ph> method define the types to which or from which a <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> object can be converted.</source>
          <target state="translated">As sobrecargas do <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger&gt;</ph> método definem os tipos para o qual ou do qual um <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> objeto pode ser convertido.</target>       </trans-unit>
        <trans-unit id="755" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Byte">
          <source>Language compilers do not perform this conversion automatically because it can involve data loss.</source>
          <target state="translated">Compiladores de linguagem não realizar essa conversão automaticamente porque ele pode envolver a perda de dados.</target>       </trans-unit>
        <trans-unit id="756" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Byte">
          <source>Instead, they perform the conversion only if a casting operator (in C#) or a conversion function (such as <ph id="ph1">`CType`</ph> or <ph id="ph2">`CByte`</ph> in Visual Basic) is used.</source>
          <target state="translated">Em vez disso, eles executarem a conversão somente se um operador de conversão (em c#) ou uma função de conversão (como <ph id="ph1">`CType`</ph> ou <ph id="ph2">`CByte`</ph> no Visual Basic) é usado.</target>       </trans-unit>
        <trans-unit id="757" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Byte">
          <source>Otherwise, they display a compiler error.</source>
          <target state="translated">Caso contrário, eles exibem um erro do compilador.</target>       </trans-unit>
        <trans-unit id="758" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Byte">
          <source>Because this operation defines a narrowing conversion, it can throw an <ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> at run time if the <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> value is outside the range of the <ph id="ph3">&lt;xref:System.Byte&gt;</ph> data type.</source>
          <target state="translated">Como essa operação define uma conversão de restrição, ela pode lançar um <ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> em tempo de execução se o <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> valor está fora do intervalo da <ph id="ph3">&lt;xref:System.Byte&gt;</ph> tipo de dados.</target>       </trans-unit>
        <trans-unit id="759" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Byte">
          <source>There is no loss of precision in the resulting <ph id="ph1">&lt;xref:System.Byte&gt;</ph> value if the conversion is successful.</source>
          <target state="translated">Não há nenhuma perda de precisão na resultante <ph id="ph1">&lt;xref:System.Byte&gt;</ph> valor se a conversão for bem-sucedida.</target>       </trans-unit>
        <trans-unit id="760" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Byte">
          <source>The following example illustrates the conversion of <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> to <ph id="ph2">&lt;xref:System.Byte&gt;</ph> values.</source>
          <target state="translated">O exemplo a seguir ilustra a conversão de <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> para <ph id="ph2">&lt;xref:System.Byte&gt;</ph> valores.</target>       </trans-unit>
        <trans-unit id="761" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Byte">
          <source>It also handles an <ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> that is thrown because the <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> value is outside the range of the <ph id="ph3">&lt;xref:System.Byte&gt;</ph> data type.</source>
          <target state="translated">Ele também lida com um <ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> que foi lançado porque o <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> valor está fora do intervalo da <ph id="ph3">&lt;xref:System.Byte&gt;</ph> tipo de dados.</target>       </trans-unit>
        <trans-unit id="762" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Byte">
          <source>The value of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is less than <ph id="ph2">&lt;see cref="F:System.Byte.MinValue" /&gt;</ph>.</source>
          <target state="translated">O valor de <ph id="ph1">&lt;paramref name="value" /&gt;</ph> é menor que <ph id="ph2">&lt;see cref="F:System.Byte.MinValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="763" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Byte">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="764" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Byte">
          <source>The value of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is greater than <ph id="ph2">&lt;see cref="F:System.Byte.MaxValue" /&gt;</ph>.</source>
          <target state="translated">O valor de <ph id="ph1">&lt;paramref name="value" /&gt;</ph> é maior que <ph id="ph2">&lt;see cref="F:System.Byte.MaxValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="765" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Decimal">
          <source>The value to convert to a <ph id="ph1">&lt;see cref="T:System.Decimal" /&gt;</ph>.</source>
          <target state="translated">O valor a ser convertido para um <ph id="ph1">&lt;see cref="T:System.Decimal" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="766" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Decimal">
          <source>Defines an explicit conversion of a <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> object to a <ph id="ph2">&lt;see cref="T:System.Decimal" /&gt;</ph> value.</source>
          <target state="translated">Define uma conversão explícita de um objeto <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> em um valor <ph id="ph2">&lt;see cref="T:System.Decimal" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="767" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Decimal">
          <source>An object that contains the value of the <ph id="ph1">&lt;paramref name="value" /&gt;</ph> parameter.</source>
          <target state="translated">Um objeto que contém o valor do parâmetro <ph id="ph1">&lt;paramref name="value" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="768" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Decimal">
          <source>The overloads of the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger&gt;</ph> method define the types to which or from which a <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> object can be converted.</source>
          <target state="translated">As sobrecargas do <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger&gt;</ph> método definem os tipos para o qual ou do qual um <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> objeto pode ser convertido.</target>       </trans-unit>
        <trans-unit id="769" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Decimal">
          <source>Language compilers do not perform this conversion automatically because it can involve data loss.</source>
          <target state="translated">Compiladores de linguagem não realizar essa conversão automaticamente porque ele pode envolver a perda de dados.</target>       </trans-unit>
        <trans-unit id="770" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Decimal">
          <source>Instead, they perform the conversion only if a casting operator (in C#) or a conversion function (such as <ph id="ph1">`CType`</ph> or <ph id="ph2">`CDec`</ph> in Visual Basic) is used.</source>
          <target state="translated">Em vez disso, eles executarem a conversão somente se um operador de conversão (em c#) ou uma função de conversão (como <ph id="ph1">`CType`</ph> ou <ph id="ph2">`CDec`</ph> no Visual Basic) é usado.</target>       </trans-unit>
        <trans-unit id="771" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Decimal">
          <source>Because this operation defines a narrowing conversion, it can throw an <ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> at run time if the <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> value is outside the range of the <ph id="ph3">&lt;xref:System.Decimal&gt;</ph> data type.</source>
          <target state="translated">Como essa operação define uma conversão de restrição, ela pode lançar um <ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> em tempo de execução se o <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> valor está fora do intervalo da <ph id="ph3">&lt;xref:System.Decimal&gt;</ph> tipo de dados.</target>       </trans-unit>
        <trans-unit id="772" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Decimal">
          <source>The following example illustrates the conversion of <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> to <ph id="ph2">&lt;xref:System.Decimal&gt;</ph> values.</source>
          <target state="translated">O exemplo a seguir ilustra a conversão de <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> para <ph id="ph2">&lt;xref:System.Decimal&gt;</ph> valores.</target>       </trans-unit>
        <trans-unit id="773" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Decimal">
          <source>It also handles an <ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> that is thrown because the <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> value is outside the range of the <ph id="ph3">&lt;xref:System.Decimal&gt;</ph> data type.</source>
          <target state="translated">Ele também lida com um <ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> que foi lançado porque o <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> valor está fora do intervalo da <ph id="ph3">&lt;xref:System.Decimal&gt;</ph> tipo de dados.</target>       </trans-unit>
        <trans-unit id="774" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Decimal">
          <source>The value of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is less than <ph id="ph2">&lt;see cref="F:System.Decimal.MinValue" /&gt;</ph>.</source>
          <target state="translated">O valor de <ph id="ph1">&lt;paramref name="value" /&gt;</ph> é menor que <ph id="ph2">&lt;see cref="F:System.Decimal.MinValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="775" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Decimal">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="776" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Decimal">
          <source>The value of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is greater than <ph id="ph2">&lt;see cref="F:System.Decimal.MaxValue" /&gt;</ph>.</source>
          <target state="translated">O valor de <ph id="ph1">&lt;paramref name="value" /&gt;</ph> é maior que <ph id="ph2">&lt;see cref="F:System.Decimal.MaxValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="777" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Double">
          <source>The value to convert to a <ph id="ph1">&lt;see cref="T:System.Double" /&gt;</ph>.</source>
          <target state="translated">O valor a ser convertido para um <ph id="ph1">&lt;see cref="T:System.Double" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="778" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Double">
          <source>Defines an explicit conversion of a <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> object to a <ph id="ph2">&lt;see cref="T:System.Double" /&gt;</ph> value.</source>
          <target state="translated">Define uma conversão explícita de um objeto <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> em um valor <ph id="ph2">&lt;see cref="T:System.Double" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="779" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Double">
          <source>An object that contains the value of the <ph id="ph1">&lt;paramref name="value" /&gt;</ph> parameter.</source>
          <target state="translated">Um objeto que contém o valor do parâmetro <ph id="ph1">&lt;paramref name="value" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="780" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Double">
          <source>The overloads of the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger&gt;</ph> method define the types to which or from which a <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> object can be converted.</source>
          <target state="translated">As sobrecargas do <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger&gt;</ph> método definem os tipos para o qual ou do qual um <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> objeto pode ser convertido.</target>       </trans-unit>
        <trans-unit id="781" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Double">
          <source>Language compilers do not perform this conversion automatically because it can involve data loss.</source>
          <target state="translated">Compiladores de linguagem não realizar essa conversão automaticamente porque ele pode envolver a perda de dados.</target>       </trans-unit>
        <trans-unit id="782" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Double">
          <source>Instead, they perform the conversion only if a casting operator (in C#) or a conversion function (such as <ph id="ph1">`CType`</ph> or <ph id="ph2">`CDbl`</ph> in Visual Basic) is used.</source>
          <target state="translated">Em vez disso, eles executarem a conversão somente se um operador de conversão (em c#) ou uma função de conversão (como <ph id="ph1">`CType`</ph> ou <ph id="ph2">`CDbl`</ph> no Visual Basic) é usado.</target>       </trans-unit>
        <trans-unit id="783" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Double">
          <source>Because the <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> value can be outside the range of the <ph id="ph2">&lt;xref:System.Double&gt;</ph> data type, this operation is a narrowing conversion.</source>
          <target state="translated">Porque o <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> valor pode estar fora do intervalo da <ph id="ph2">&lt;xref:System.Double&gt;</ph> tipo de dados, esta operação é uma conversão de restrição.</target>       </trans-unit>
        <trans-unit id="784" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Double">
          <source>If the conversion is unsuccessful, it does not throw an <ph id="ph1">&lt;xref:System.OverflowException&gt;</ph>.</source>
          <target state="translated">Se a conversão falhar, ele não gerará um <ph id="ph1">&lt;xref:System.OverflowException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="785" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Double">
          <source>Instead, if the <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> value is less than <ph id="ph2">&lt;xref:System.Double.MinValue?displayProperty=nameWithType&gt;</ph>, the resulting <ph id="ph3">&lt;xref:System.Double&gt;</ph> value is <ph id="ph4">&lt;xref:System.Double.NegativeInfinity?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Em vez disso, se o <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> valor é menor que <ph id="ph2">&lt;xref:System.Double.MinValue?displayProperty=nameWithType&gt;</ph>, resultante <ph id="ph3">&lt;xref:System.Double&gt;</ph> valor é <ph id="ph4">&lt;xref:System.Double.NegativeInfinity?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="786" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Double">
          <source>If the <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> value is greater than <ph id="ph2">&lt;xref:System.Double.MaxValue?displayProperty=nameWithType&gt;</ph>, the resulting <ph id="ph3">&lt;xref:System.Double&gt;</ph> value is <ph id="ph4">&lt;xref:System.Double.PositiveInfinity?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Se o <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> valor é maior que <ph id="ph2">&lt;xref:System.Double.MaxValue?displayProperty=nameWithType&gt;</ph>, resultante <ph id="ph3">&lt;xref:System.Double&gt;</ph> valor é <ph id="ph4">&lt;xref:System.Double.PositiveInfinity?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="787" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Double">
          <source>The conversion of a <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> to a <ph id="ph2">&lt;xref:System.Double&gt;</ph> may involve a loss of precision.</source>
          <target state="translated">A conversão de um <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> para um <ph id="ph2">&lt;xref:System.Double&gt;</ph> pode envolver uma perda de precisão.</target>       </trans-unit>
        <trans-unit id="788" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Double">
          <source>In some cases, the loss of precision may cause the casting or conversion operation to succeed even if the <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> value is outside the range of the <ph id="ph2">&lt;xref:System.Double&gt;</ph> data type.</source>
          <target state="translated">Em alguns casos, a perda de precisão pode fazer com que a operação de conversão ou tenha êxito mesmo se o <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> valor está fora do intervalo da <ph id="ph2">&lt;xref:System.Double&gt;</ph> tipo de dados.</target>       </trans-unit>
        <trans-unit id="789" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Double">
          <source>The following example provides an illustration.</source>
          <target state="translated">O exemplo a seguir fornece uma ilustração.</target>       </trans-unit>
        <trans-unit id="790" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Double">
          <source>It assigns the maximum value of a <ph id="ph1">&lt;xref:System.Double&gt;</ph> to two <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> variables, increments one <ph id="ph3">&lt;xref:System.Numerics.BigInteger&gt;</ph> variable by 9.999e291, and tests the two variables for equality.</source>
          <target state="translated">Ele atribui o valor máximo de um <ph id="ph1">&lt;xref:System.Double&gt;</ph> duas <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> variáveis, em incrementos de um <ph id="ph3">&lt;xref:System.Numerics.BigInteger&gt;</ph> variável 9.999e291 e as duas variáveis de testes de igualdade.</target>       </trans-unit>
        <trans-unit id="791" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Double">
          <source>As expected, the call to the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Equals%28System.Numerics.BigInteger%29?displayProperty=nameWithType&gt;</ph> method shows that they are unequal.</source>
          <target state="translated">Conforme o esperado, a chamada para o <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Equals%28System.Numerics.BigInteger%29?displayProperty=nameWithType&gt;</ph> método mostra que elas são diferentes.</target>       </trans-unit>
        <trans-unit id="792" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Double">
          <source>However, the conversion of the larger <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> value back to a <ph id="ph2">&lt;xref:System.Double&gt;</ph> succeeds, although the <ph id="ph3">&lt;xref:System.Numerics.BigInteger&gt;</ph> value now exceeds <ph id="ph4">&lt;xref:System.Double.MaxValue?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">No entanto, a conversão do maior <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> valor de volta para um <ph id="ph2">&lt;xref:System.Double&gt;</ph> for bem-sucedida, embora o <ph id="ph3">&lt;xref:System.Numerics.BigInteger&gt;</ph> agora excede o valor <ph id="ph4">&lt;xref:System.Double.MaxValue?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="793" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Double">
          <source>The following example illustrates the conversion of <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> to <ph id="ph2">&lt;xref:System.Double&gt;</ph> values.</source>
          <target state="translated">O exemplo a seguir ilustra a conversão de <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> para <ph id="ph2">&lt;xref:System.Double&gt;</ph> valores.</target>       </trans-unit>
        <trans-unit id="794" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Int16">
          <source>The value to convert to a 16-bit signed integer.</source>
          <target state="translated">O valor a ser convertido em um inteiro com sinal de 16 bits.</target>       </trans-unit>
        <trans-unit id="795" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Int16">
          <source>Defines an explicit conversion of a <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> object to a 16-bit signed integer value.</source>
          <target state="translated">Define uma conversão explícita de um objeto <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> em um valor inteiro com sinal de 16 bits.</target>       </trans-unit>
        <trans-unit id="796" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Int16">
          <source>An object that contains the value of the <ph id="ph1">&lt;paramref name="value" /&gt;</ph> parameter.</source>
          <target state="translated">Um objeto que contém o valor do parâmetro <ph id="ph1">&lt;paramref name="value" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="797" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Int16">
          <source>The overloads of the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger&gt;</ph> method define the types to which or from which a <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> object can be converted.</source>
          <target state="translated">As sobrecargas do <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger&gt;</ph> método definem os tipos para o qual ou do qual um <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> objeto pode ser convertido.</target>       </trans-unit>
        <trans-unit id="798" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Int16">
          <source>Language compilers do not perform this conversion automatically because it can involve data loss.</source>
          <target state="translated">Compiladores de linguagem não realizar essa conversão automaticamente porque ele pode envolver a perda de dados.</target>       </trans-unit>
        <trans-unit id="799" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Int16">
          <source>Instead, they perform the conversion only if a casting operator (in C#) or a conversion function (such as <ph id="ph1">`CType`</ph> or <ph id="ph2">`CShort`</ph> in Visual Basic) is used.</source>
          <target state="translated">Em vez disso, eles executarem a conversão somente se um operador de conversão (em c#) ou uma função de conversão (como <ph id="ph1">`CType`</ph> ou <ph id="ph2">`CShort`</ph> no Visual Basic) é usado.</target>       </trans-unit>
        <trans-unit id="800" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Int16">
          <source>Otherwise, they display a compiler error.</source>
          <target state="translated">Caso contrário, eles exibem um erro do compilador.</target>       </trans-unit>
        <trans-unit id="801" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Int16">
          <source>Because this operation defines a narrowing conversion, it can throw an <ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> at run time if the <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> value is outside the range of the <ph id="ph3">&lt;xref:System.Int16&gt;</ph> data type.</source>
          <target state="translated">Como essa operação define uma conversão de restrição, ela pode lançar um <ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> em tempo de execução se o <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> valor está fora do intervalo da <ph id="ph3">&lt;xref:System.Int16&gt;</ph> tipo de dados.</target>       </trans-unit>
        <trans-unit id="802" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Int16">
          <source>There is no loss of precision in the resulting <ph id="ph1">&lt;xref:System.Int16&gt;</ph> value if the conversion is successful.</source>
          <target state="translated">Não há nenhuma perda de precisão na resultante <ph id="ph1">&lt;xref:System.Int16&gt;</ph> valor se a conversão for bem-sucedida.</target>       </trans-unit>
        <trans-unit id="803" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Int16">
          <source>The following example illustrates the conversion of <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> to <ph id="ph2">&lt;xref:System.Int16&gt;</ph> values.</source>
          <target state="translated">O exemplo a seguir ilustra a conversão de <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> para <ph id="ph2">&lt;xref:System.Int16&gt;</ph> valores.</target>       </trans-unit>
        <trans-unit id="804" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Int16">
          <source>It also handles an <ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> that is thrown because the <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> value is outside the range of the <ph id="ph3">&lt;xref:System.Int16&gt;</ph> data type.</source>
          <target state="translated">Ele também lida com um <ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> que foi lançado porque o <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> valor está fora do intervalo da <ph id="ph3">&lt;xref:System.Int16&gt;</ph> tipo de dados.</target>       </trans-unit>
        <trans-unit id="805" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Int16">
          <source>The value of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is less than <ph id="ph2">&lt;see cref="F:System.Int16.MinValue" /&gt;</ph>.</source>
          <target state="translated">O valor de <ph id="ph1">&lt;paramref name="value" /&gt;</ph> é menor que <ph id="ph2">&lt;see cref="F:System.Int16.MinValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="806" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Int16">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="807" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Int16">
          <source>The value of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is greater than <ph id="ph2">&lt;see cref="F:System.Int16.MaxValue" /&gt;</ph>.</source>
          <target state="translated">O valor de <ph id="ph1">&lt;paramref name="value" /&gt;</ph> é maior que <ph id="ph2">&lt;see cref="F:System.Int16.MaxValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="808" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Int32">
          <source>The value to convert to a 32-bit signed integer.</source>
          <target state="translated">O valor a ser convertido em um inteiro com sinal de 32 bits.</target>       </trans-unit>
        <trans-unit id="809" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Int32">
          <source>Defines an explicit conversion of a <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> object to a 32-bit signed integer value.</source>
          <target state="translated">Define uma conversão explícita de um objeto <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> para um valor inteiro com sinal de 32 bits.</target>       </trans-unit>
        <trans-unit id="810" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Int32">
          <source>An object that contains the value of the <ph id="ph1">&lt;paramref name="value" /&gt;</ph> parameter.</source>
          <target state="translated">Um objeto que contém o valor do parâmetro <ph id="ph1">&lt;paramref name="value" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="811" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Int32">
          <source>The overloads of the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger&gt;</ph> method define the types to which or from which a <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> object can be converted.</source>
          <target state="translated">As sobrecargas do <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger&gt;</ph> método definem os tipos para o qual ou do qual um <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> objeto pode ser convertido.</target>       </trans-unit>
        <trans-unit id="812" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Int32">
          <source>Language compilers do not perform this conversion automatically because it can involve data loss.</source>
          <target state="translated">Compiladores de linguagem não realizar essa conversão automaticamente porque ele pode envolver a perda de dados.</target>       </trans-unit>
        <trans-unit id="813" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Int32">
          <source>Instead, they perform the conversion only if a casting operator (in C#) or a conversion function (such as <ph id="ph1">`CType`</ph> or <ph id="ph2">`CInt`</ph> in Visual Basic) is used.</source>
          <target state="translated">Em vez disso, eles executarem a conversão somente se um operador de conversão (em c#) ou uma função de conversão (como <ph id="ph1">`CType`</ph> ou <ph id="ph2">`CInt`</ph> no Visual Basic) é usado.</target>       </trans-unit>
        <trans-unit id="814" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Int32">
          <source>Otherwise, they display a compiler error.</source>
          <target state="translated">Caso contrário, eles exibem um erro do compilador.</target>       </trans-unit>
        <trans-unit id="815" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Int32">
          <source>Because this operation defines a narrowing conversion, it can throw an <ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> at run time if the <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> value is outside the range of the <ph id="ph3">&lt;xref:System.Int32&gt;</ph> data type.</source>
          <target state="translated">Como essa operação define uma conversão de restrição, ela pode lançar um <ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> em tempo de execução se o <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> valor está fora do intervalo da <ph id="ph3">&lt;xref:System.Int32&gt;</ph> tipo de dados.</target>       </trans-unit>
        <trans-unit id="816" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Int32">
          <source>There is no loss of precision in the resulting <ph id="ph1">&lt;xref:System.Int16&gt;</ph> value if the conversion is successful.</source>
          <target state="translated">Não há nenhuma perda de precisão na resultante <ph id="ph1">&lt;xref:System.Int16&gt;</ph> valor se a conversão for bem-sucedida.</target>       </trans-unit>
        <trans-unit id="817" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Int32">
          <source>The following example illustrates the conversion of <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> to <ph id="ph2">&lt;xref:System.Int32&gt;</ph> values.</source>
          <target state="translated">O exemplo a seguir ilustra a conversão de <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> para <ph id="ph2">&lt;xref:System.Int32&gt;</ph> valores.</target>       </trans-unit>
        <trans-unit id="818" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Int32">
          <source>It also handles an <ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> that is thrown because the <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> value is outside the range of the <ph id="ph3">&lt;xref:System.Int32&gt;</ph> data type.</source>
          <target state="translated">Ele também lida com um <ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> que foi lançado porque o <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> valor está fora do intervalo da <ph id="ph3">&lt;xref:System.Int32&gt;</ph> tipo de dados.</target>       </trans-unit>
        <trans-unit id="819" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Int32">
          <source>The value of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is less than <ph id="ph2">&lt;see cref="F:System.Int32.MinValue" /&gt;</ph>.</source>
          <target state="translated">O valor de <ph id="ph1">&lt;paramref name="value" /&gt;</ph> é menor que <ph id="ph2">&lt;see cref="F:System.Int32.MinValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="820" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Int32">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="821" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Int32">
          <source>The value of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is greater than <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</source>
          <target state="translated">O valor de <ph id="ph1">&lt;paramref name="value" /&gt;</ph> é maior que <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="822" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Int64">
          <source>The value to convert to a 64-bit signed integer.</source>
          <target state="translated">O valor a ser convertido em um inteiro com sinal de 64 bits.</target>       </trans-unit>
        <trans-unit id="823" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Int64">
          <source>Defines an explicit conversion of a <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> object to a 64-bit signed integer value.</source>
          <target state="translated">Define uma conversão explícita de um objeto <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> para um valor inteiro com sinal de 64 bits.</target>       </trans-unit>
        <trans-unit id="824" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Int64">
          <source>An object that contains the value of the <ph id="ph1">&lt;paramref name="value" /&gt;</ph> parameter.</source>
          <target state="translated">Um objeto que contém o valor do parâmetro <ph id="ph1">&lt;paramref name="value" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="825" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Int64">
          <source>The overloads of the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger&gt;</ph> method define the types to which or from which a <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> object can be converted.</source>
          <target state="translated">As sobrecargas do <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger&gt;</ph> método definem os tipos para o qual ou do qual um <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> objeto pode ser convertido.</target>       </trans-unit>
        <trans-unit id="826" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Int64">
          <source>Language compilers do not perform this conversion automatically because it can involve data loss.</source>
          <target state="translated">Compiladores de linguagem não realizar essa conversão automaticamente porque ele pode envolver a perda de dados.</target>       </trans-unit>
        <trans-unit id="827" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Int64">
          <source>Instead, they perform the conversion only if a casting operator (in C#) or a conversion function (such as <ph id="ph1">`CType`</ph> or <ph id="ph2">`CLng`</ph> in Visual Basic) is used.</source>
          <target state="translated">Em vez disso, eles executarem a conversão somente se um operador de conversão (em c#) ou uma função de conversão (como <ph id="ph1">`CType`</ph> ou <ph id="ph2">`CLng`</ph> no Visual Basic) é usado.</target>       </trans-unit>
        <trans-unit id="828" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Int64">
          <source>Otherwise, they display a compiler error.</source>
          <target state="translated">Caso contrário, eles exibem um erro do compilador.</target>       </trans-unit>
        <trans-unit id="829" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Int64">
          <source>Because this operation defines a narrowing conversion, it can throw an <ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> at run time if the <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> value is outside the range of the <ph id="ph3">&lt;xref:System.Int64&gt;</ph> data type.</source>
          <target state="translated">Como essa operação define uma conversão de restrição, ela pode lançar um <ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> em tempo de execução se o <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> valor está fora do intervalo da <ph id="ph3">&lt;xref:System.Int64&gt;</ph> tipo de dados.</target>       </trans-unit>
        <trans-unit id="830" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Int64">
          <source>The following example illustrates the conversion of <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> to <ph id="ph2">&lt;xref:System.Int64&gt;</ph> values.</source>
          <target state="translated">O exemplo a seguir ilustra a conversão de <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> para <ph id="ph2">&lt;xref:System.Int64&gt;</ph> valores.</target>       </trans-unit>
        <trans-unit id="831" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Int64">
          <source>It also handles an <ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> that is thrown because the <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> value is outside the range of the <ph id="ph3">&lt;xref:System.Int64&gt;</ph> data type.</source>
          <target state="translated">Ele também lida com um <ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> que foi lançado porque o <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> valor está fora do intervalo da <ph id="ph3">&lt;xref:System.Int64&gt;</ph> tipo de dados.</target>       </trans-unit>
        <trans-unit id="832" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Int64">
          <source>The value of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is less than <ph id="ph2">&lt;see cref="F:System.Int64.MinValue" /&gt;</ph>.</source>
          <target state="translated">O valor de <ph id="ph1">&lt;paramref name="value" /&gt;</ph> é menor que <ph id="ph2">&lt;see cref="F:System.Int64.MinValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="833" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Int64">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="834" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Int64">
          <source>The value of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is greater than <ph id="ph2">&lt;see cref="F:System.Int64.MaxValue" /&gt;</ph>.</source>
          <target state="translated">O valor de <ph id="ph1">&lt;paramref name="value" /&gt;</ph> é maior que <ph id="ph2">&lt;see cref="F:System.Int64.MaxValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="835" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.SByte">
          <source>The value to convert to a signed 8-bit value.</source>
          <target state="translated">O valor a ser convertido em um valor de 8 bits com sinal.</target>       </trans-unit>
        <trans-unit id="836" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.SByte">
          <source>Defines an explicit conversion of a <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> object to a signed 8-bit value.</source>
          <target state="translated">Define uma conversão explícita de um objeto <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> em um valor de 8 bits com sinal.</target>       </trans-unit>
        <trans-unit id="837" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.SByte">
          <source>This API is not CLS-compliant.</source>
          <target state="translated">Esta API não compatível com CLS.</target>       </trans-unit>
        <trans-unit id="838" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.SByte">
          <source>The compliant alternative is <ph id="ph1">&lt;see cref="T:System.Int16" /&gt;</ph>.</source>
          <target state="translated">A alternativa em conformidade é <ph id="ph1">&lt;see cref="T:System.Int16" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="839" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.SByte">
          <source>An object that contains the value of the <ph id="ph1">&lt;paramref name="value" /&gt;</ph> parameter.</source>
          <target state="translated">Um objeto que contém o valor do parâmetro <ph id="ph1">&lt;paramref name="value" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="840" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.SByte">
          <source>The overloads of the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger&gt;</ph> method define the types to which or from which a <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> object can be converted.</source>
          <target state="translated">As sobrecargas do <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger&gt;</ph> método definem os tipos para o qual ou do qual um <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> objeto pode ser convertido.</target>       </trans-unit>
        <trans-unit id="841" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.SByte">
          <source>Language compilers do not perform this conversion automatically because it can involve data loss.</source>
          <target state="translated">Compiladores de linguagem não realizar essa conversão automaticamente porque ele pode envolver a perda de dados.</target>       </trans-unit>
        <trans-unit id="842" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.SByte">
          <source>Instead, they perform the conversion only if a casting operator (in C#) or a conversion function (such as <ph id="ph1">`CType`</ph> or <ph id="ph2">`CSByte`</ph> in Visual Basic) is used.</source>
          <target state="translated">Em vez disso, eles executarem a conversão somente se um operador de conversão (em c#) ou uma função de conversão (como <ph id="ph1">`CType`</ph> ou <ph id="ph2">`CSByte`</ph> no Visual Basic) é usado.</target>       </trans-unit>
        <trans-unit id="843" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.SByte">
          <source>Otherwise, they display a compiler error.</source>
          <target state="translated">Caso contrário, eles exibem um erro do compilador.</target>       </trans-unit>
        <trans-unit id="844" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.SByte">
          <source>Because this operation defines a narrowing conversion, it can throw an <ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> at run time if the <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> value is outside the range of the <ph id="ph3">&lt;xref:System.SByte&gt;</ph> data type.</source>
          <target state="translated">Como essa operação define uma conversão de restrição, ela pode lançar um <ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> em tempo de execução se o <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> valor está fora do intervalo da <ph id="ph3">&lt;xref:System.SByte&gt;</ph> tipo de dados.</target>       </trans-unit>
        <trans-unit id="845" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.SByte">
          <source>There is no loss of precision in the resulting <ph id="ph1">&lt;xref:System.SByte&gt;</ph> value if the conversion is successful.</source>
          <target state="translated">Não há nenhuma perda de precisão na resultante <ph id="ph1">&lt;xref:System.SByte&gt;</ph> valor se a conversão for bem-sucedida.</target>       </trans-unit>
        <trans-unit id="846" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.SByte">
          <source>The following example illustrates the conversion of <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> to <ph id="ph2">&lt;xref:System.SByte&gt;</ph> values.</source>
          <target state="translated">O exemplo a seguir ilustra a conversão de <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> para <ph id="ph2">&lt;xref:System.SByte&gt;</ph> valores.</target>       </trans-unit>
        <trans-unit id="847" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.SByte">
          <source>It also handles an <ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> that is thrown because the <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> value is outside the range of the <ph id="ph3">&lt;xref:System.SByte&gt;</ph> data type.</source>
          <target state="translated">Ele também lida com um <ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> que foi lançado porque o <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> valor está fora do intervalo da <ph id="ph3">&lt;xref:System.SByte&gt;</ph> tipo de dados.</target>       </trans-unit>
        <trans-unit id="848" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.SByte">
          <source>The value of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is less than <ph id="ph2">&lt;see cref="F:System.SByte.MinValue" /&gt;</ph>.</source>
          <target state="translated">O valor de <ph id="ph1">&lt;paramref name="value" /&gt;</ph> é menor que <ph id="ph2">&lt;see cref="F:System.SByte.MinValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="849" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.SByte">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="850" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.SByte">
          <source>The value of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is greater than <ph id="ph2">&lt;see cref="F:System.SByte.MaxValue" /&gt;</ph>.</source>
          <target state="translated">O valor de <ph id="ph1">&lt;paramref name="value" /&gt;</ph> é maior que <ph id="ph2">&lt;see cref="F:System.SByte.MaxValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="851" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Single">
          <source>The value to convert to a single-precision floating-point value.</source>
          <target state="translated">O valor a ser convertido em um ponto flutuante de precisão simples.</target>       </trans-unit>
        <trans-unit id="852" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Single">
          <source>Defines an explicit conversion of a <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> object to a single-precision floating-point value.</source>
          <target state="translated">Define uma conversão explícita de um objeto <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> em um valor de ponto flutuante de precisão simples.</target>       </trans-unit>
        <trans-unit id="853" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Single">
          <source>An object that contains the closest possible representation of the <ph id="ph1">&lt;paramref name="value" /&gt;</ph> parameter.</source>
          <target state="translated">Um objeto que contém a representação mais próxima possível do parâmetro <ph id="ph1">&lt;paramref name="value" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="854" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Single">
          <source>The overloads of the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger&gt;</ph> method define the types to which or from which a <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> object can be converted.</source>
          <target state="translated">As sobrecargas do <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger&gt;</ph> método definem os tipos para o qual ou do qual um <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> objeto pode ser convertido.</target>       </trans-unit>
        <trans-unit id="855" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Single">
          <source>Language compilers do not perform this conversion automatically because it can involve data loss or a loss of precision.</source>
          <target state="translated">Compiladores de linguagem não realizar essa conversão automaticamente porque ele pode envolver a perda de dados ou uma perda de precisão.</target>       </trans-unit>
        <trans-unit id="856" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Single">
          <source>Instead, they perform the conversion only if a casting operator (in C#) or a conversion function (such as <ph id="ph1">`CType`</ph> or <ph id="ph2">`CSng`</ph> in Visual Basic) is used.</source>
          <target state="translated">Em vez disso, eles executarem a conversão somente se um operador de conversão (em c#) ou uma função de conversão (como <ph id="ph1">`CType`</ph> ou <ph id="ph2">`CSng`</ph> no Visual Basic) é usado.</target>       </trans-unit>
        <trans-unit id="857" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Single">
          <source>Otherwise, they display a compiler error.</source>
          <target state="translated">Caso contrário, eles exibem um erro do compilador.</target>       </trans-unit>
        <trans-unit id="858" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Single">
          <source>Because the <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> value can be outside the range of the <ph id="ph2">&lt;xref:System.Single&gt;</ph> data type, this operation is a narrowing conversion.</source>
          <target state="translated">Porque o <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> valor pode estar fora do intervalo da <ph id="ph2">&lt;xref:System.Single&gt;</ph> tipo de dados, esta operação é uma conversão de restrição.</target>       </trans-unit>
        <trans-unit id="859" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Single">
          <source>If the conversion is unsuccessful, it does not throw an <ph id="ph1">&lt;xref:System.OverflowException&gt;</ph>.</source>
          <target state="translated">Se a conversão falhar, ele não gerará um <ph id="ph1">&lt;xref:System.OverflowException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="860" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Single">
          <source>Instead, if the <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> value is less than <ph id="ph2">&lt;xref:System.Single.MinValue?displayProperty=nameWithType&gt;</ph>, the resulting <ph id="ph3">&lt;xref:System.Single&gt;</ph> value is <ph id="ph4">&lt;xref:System.Single.NegativeInfinity?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Em vez disso, se o <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> valor é menor que <ph id="ph2">&lt;xref:System.Single.MinValue?displayProperty=nameWithType&gt;</ph>, resultante <ph id="ph3">&lt;xref:System.Single&gt;</ph> valor é <ph id="ph4">&lt;xref:System.Single.NegativeInfinity?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="861" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Single">
          <source>If the <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> value is greater than <ph id="ph2">&lt;xref:System.Single.MaxValue?displayProperty=nameWithType&gt;</ph>, the resulting <ph id="ph3">&lt;xref:System.Single&gt;</ph> value is <ph id="ph4">&lt;xref:System.Single.PositiveInfinity?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Se o <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> valor é maior que <ph id="ph2">&lt;xref:System.Single.MaxValue?displayProperty=nameWithType&gt;</ph>, resultante <ph id="ph3">&lt;xref:System.Single&gt;</ph> valor é <ph id="ph4">&lt;xref:System.Single.PositiveInfinity?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="862" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Single">
          <source>The conversion of a <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> to a <ph id="ph2">&lt;xref:System.Single&gt;</ph> may involve a loss of precision.</source>
          <target state="translated">A conversão de um <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> para um <ph id="ph2">&lt;xref:System.Single&gt;</ph> pode envolver uma perda de precisão.</target>       </trans-unit>
        <trans-unit id="863" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Single">
          <source>In some cases, the loss of precision may cause the casting or conversion operation to succeed even if the <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> value is outside the range of the <ph id="ph2">&lt;xref:System.Single&gt;</ph> data type.</source>
          <target state="translated">Em alguns casos, a perda de precisão pode fazer com que a operação de conversão ou tenha êxito mesmo se o <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> valor está fora do intervalo da <ph id="ph2">&lt;xref:System.Single&gt;</ph> tipo de dados.</target>       </trans-unit>
        <trans-unit id="864" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Single">
          <source>The following example provides an illustration.</source>
          <target state="translated">O exemplo a seguir fornece uma ilustração.</target>       </trans-unit>
        <trans-unit id="865" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Single">
          <source>It assigns the maximum value of a <ph id="ph1">&lt;xref:System.Single&gt;</ph> to two <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> variables, increments one <ph id="ph3">&lt;xref:System.Numerics.BigInteger&gt;</ph> variable by 9.999e291, and tests the two variables for equality.</source>
          <target state="translated">Ele atribui o valor máximo de um <ph id="ph1">&lt;xref:System.Single&gt;</ph> duas <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> variáveis, em incrementos de um <ph id="ph3">&lt;xref:System.Numerics.BigInteger&gt;</ph> variável 9.999e291 e as duas variáveis de testes de igualdade.</target>       </trans-unit>
        <trans-unit id="866" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Single">
          <source>As expected, the call to the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Equals%28System.Numerics.BigInteger%29?displayProperty=nameWithType&gt;</ph> method shows that they are unequal.</source>
          <target state="translated">Conforme o esperado, a chamada para o <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Equals%28System.Numerics.BigInteger%29?displayProperty=nameWithType&gt;</ph> método mostra que elas são diferentes.</target>       </trans-unit>
        <trans-unit id="867" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Single">
          <source>However, the conversion of the larger <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> value back to a <ph id="ph2">&lt;xref:System.Single&gt;</ph> succeeds, although the <ph id="ph3">&lt;xref:System.Numerics.BigInteger&gt;</ph> value now exceeds <ph id="ph4">&lt;xref:System.Single.MaxValue?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">No entanto, a conversão do maior <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> valor de volta para um <ph id="ph2">&lt;xref:System.Single&gt;</ph> for bem-sucedida, embora o <ph id="ph3">&lt;xref:System.Numerics.BigInteger&gt;</ph> agora excede o valor <ph id="ph4">&lt;xref:System.Single.MaxValue?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="868" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Single">
          <source>The following example illustrates the conversion of <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> to <ph id="ph2">&lt;xref:System.Single&gt;</ph> values.</source>
          <target state="translated">O exemplo a seguir ilustra a conversão de <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> para <ph id="ph2">&lt;xref:System.Single&gt;</ph> valores.</target>       </trans-unit>
        <trans-unit id="869" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.UInt16">
          <source>The value to convert to an unsigned 16-bit integer.</source>
          <target state="translated">O valor a ser convertido em um inteiro sem sinal de 16 bits.</target>       </trans-unit>
        <trans-unit id="870" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.UInt16">
          <source>Defines an explicit conversion of a <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> object to an unsigned 16-bit integer value.</source>
          <target state="translated">Define uma conversão explícita de um objeto <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> em um valor inteiro sem sinal de 16 bits.</target>       </trans-unit>
        <trans-unit id="871" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.UInt16">
          <source>This API is not CLS-compliant.</source>
          <target state="translated">Esta API não compatível com CLS.</target>       </trans-unit>
        <trans-unit id="872" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.UInt16">
          <source>The compliant alternative is <ph id="ph1">&lt;see cref="T:System.Int32" /&gt;</ph>.</source>
          <target state="translated">A alternativa em conformidade é <ph id="ph1">&lt;see cref="T:System.Int32" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="873" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.UInt16">
          <source>An object that contains the value of the <ph id="ph1">&lt;paramref name="value" /&gt;</ph> parameter.</source>
          <target state="translated">Um objeto que contém o valor do parâmetro <ph id="ph1">&lt;paramref name="value" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="874" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.UInt16">
          <source>The overloads of the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger&gt;</ph> method define the types to which or from which a <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> object can be converted.</source>
          <target state="translated">As sobrecargas do <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger&gt;</ph> método definem os tipos para o qual ou do qual um <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> objeto pode ser convertido.</target>       </trans-unit>
        <trans-unit id="875" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.UInt16">
          <source>Language compilers do not perform this conversion automatically because it can involve data loss.</source>
          <target state="translated">Compiladores de linguagem não realizar essa conversão automaticamente porque ele pode envolver a perda de dados.</target>       </trans-unit>
        <trans-unit id="876" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.UInt16">
          <source>Instead, they perform the conversion only if a casting operator (in C#) or a conversion function (such as <ph id="ph1">`CType`</ph> or <ph id="ph2">`CUShort`</ph> in Visual Basic) is used.</source>
          <target state="translated">Em vez disso, eles executarem a conversão somente se um operador de conversão (em c#) ou uma função de conversão (como <ph id="ph1">`CType`</ph> ou <ph id="ph2">`CUShort`</ph> no Visual Basic) é usado.</target>       </trans-unit>
        <trans-unit id="877" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.UInt16">
          <source>Otherwise, they display a compiler error.</source>
          <target state="translated">Caso contrário, eles exibem um erro do compilador.</target>       </trans-unit>
        <trans-unit id="878" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.UInt16">
          <source>Because this operation defines a narrowing conversion, it can throw an <ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> at run time if the <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> value is outside the range of the <ph id="ph3">&lt;xref:System.UInt16&gt;</ph> data type.</source>
          <target state="translated">Como essa operação define uma conversão de restrição, ela pode lançar um <ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> em tempo de execução se o <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> valor está fora do intervalo da <ph id="ph3">&lt;xref:System.UInt16&gt;</ph> tipo de dados.</target>       </trans-unit>
        <trans-unit id="879" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.UInt16">
          <source>There is no loss of precision in the resulting <ph id="ph1">&lt;xref:System.UInt16&gt;</ph> value if the conversion is successful.</source>
          <target state="translated">Não há nenhuma perda de precisão na resultante <ph id="ph1">&lt;xref:System.UInt16&gt;</ph> valor se a conversão for bem-sucedida.</target>       </trans-unit>
        <trans-unit id="880" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.UInt16">
          <source>The following example illustrates the conversion of <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> to <ph id="ph2">&lt;xref:System.UInt16&gt;</ph> values.</source>
          <target state="translated">O exemplo a seguir ilustra a conversão de <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> para <ph id="ph2">&lt;xref:System.UInt16&gt;</ph> valores.</target>       </trans-unit>
        <trans-unit id="881" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.UInt16">
          <source>It also handles an <ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> that is thrown because the <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> value is outside the range of the <ph id="ph3">&lt;xref:System.UInt16&gt;</ph> data type.</source>
          <target state="translated">Ele também lida com um <ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> que foi lançado porque o <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> valor está fora do intervalo da <ph id="ph3">&lt;xref:System.UInt16&gt;</ph> tipo de dados.</target>       </trans-unit>
        <trans-unit id="882" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.UInt16">
          <source>The value of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is less than <ph id="ph2">&lt;see cref="F:System.UInt16.MinValue" /&gt;</ph>.</source>
          <target state="translated">O valor de <ph id="ph1">&lt;paramref name="value" /&gt;</ph> é menor que <ph id="ph2">&lt;see cref="F:System.UInt16.MinValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="883" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.UInt16">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="884" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.UInt16">
          <source>The value of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is greater than <ph id="ph2">&lt;see cref="F:System.UInt16.MaxValue" /&gt;</ph>.</source>
          <target state="translated">O valor de <ph id="ph1">&lt;paramref name="value" /&gt;</ph> é maior que <ph id="ph2">&lt;see cref="F:System.UInt16.MaxValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="885" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.UInt32">
          <source>The value to convert to an unsigned 32-bit integer.</source>
          <target state="translated">O valor a ser convertido em um inteiro sem sinal de 32 bits.</target>       </trans-unit>
        <trans-unit id="886" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.UInt32">
          <source>Defines an explicit conversion of a <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> object to an unsigned 32-bit integer value.</source>
          <target state="translated">Define uma conversão explícita de um objeto <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> em um valor inteiro sem sinal de 32 bits.</target>       </trans-unit>
        <trans-unit id="887" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.UInt32">
          <source>This API is not CLS-compliant.</source>
          <target state="translated">Esta API não compatível com CLS.</target>       </trans-unit>
        <trans-unit id="888" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.UInt32">
          <source>The compliant alternative is <ph id="ph1">&lt;see cref="T:System.Int64" /&gt;</ph>.</source>
          <target state="translated">A alternativa em conformidade é <ph id="ph1">&lt;see cref="T:System.Int64" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="889" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.UInt32">
          <source>An object that contains the value of the <ph id="ph1">&lt;paramref name="value" /&gt;</ph> parameter.</source>
          <target state="translated">Um objeto que contém o valor do parâmetro <ph id="ph1">&lt;paramref name="value" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="890" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.UInt32">
          <source>The overloads of the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger&gt;</ph> method define the types to which or from which a <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> object can be converted.</source>
          <target state="translated">As sobrecargas do <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger&gt;</ph> método definem os tipos para o qual ou do qual um <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> objeto pode ser convertido.</target>       </trans-unit>
        <trans-unit id="891" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.UInt32">
          <source>Language compilers do not perform this conversion automatically because it can involve data loss.</source>
          <target state="translated">Compiladores de linguagem não realizar essa conversão automaticamente porque ele pode envolver a perda de dados.</target>       </trans-unit>
        <trans-unit id="892" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.UInt32">
          <source>Instead, they perform the conversion only if a casting operator (in C#) or a conversion function (such as <ph id="ph1">`CType`</ph> or <ph id="ph2">`CUInt`</ph> in Visual Basic) is used.</source>
          <target state="translated">Em vez disso, eles executarem a conversão somente se um operador de conversão (em c#) ou uma função de conversão (como <ph id="ph1">`CType`</ph> ou <ph id="ph2">`CUInt`</ph> no Visual Basic) é usado.</target>       </trans-unit>
        <trans-unit id="893" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.UInt32">
          <source>Otherwise, they display a compiler error.</source>
          <target state="translated">Caso contrário, eles exibem um erro do compilador.</target>       </trans-unit>
        <trans-unit id="894" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.UInt32">
          <source>Because this operation defines a narrowing conversion, it can throw an <ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> at run time if the <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> value is outside the range of the <ph id="ph3">&lt;xref:System.UInt32&gt;</ph> data type.</source>
          <target state="translated">Como essa operação define uma conversão de restrição, ela pode lançar um <ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> em tempo de execução se o <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> valor está fora do intervalo da <ph id="ph3">&lt;xref:System.UInt32&gt;</ph> tipo de dados.</target>       </trans-unit>
        <trans-unit id="895" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.UInt32">
          <source>There is no loss of precision in the resulting <ph id="ph1">&lt;xref:System.UInt32&gt;</ph> value if the conversion is successful.</source>
          <target state="translated">Não há nenhuma perda de precisão na resultante <ph id="ph1">&lt;xref:System.UInt32&gt;</ph> valor se a conversão for bem-sucedida.</target>       </trans-unit>
        <trans-unit id="896" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.UInt32">
          <source>The following example illustrates the conversion of <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> to <ph id="ph2">&lt;xref:System.UInt32&gt;</ph> values.</source>
          <target state="translated">O exemplo a seguir ilustra a conversão de <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> para <ph id="ph2">&lt;xref:System.UInt32&gt;</ph> valores.</target>       </trans-unit>
        <trans-unit id="897" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.UInt32">
          <source>It also handles an <ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> that is thrown because the <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> value is outside the range of the <ph id="ph3">&lt;xref:System.UInt32&gt;</ph> data type.</source>
          <target state="translated">Ele também lida com um <ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> que foi lançado porque o <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> valor está fora do intervalo da <ph id="ph3">&lt;xref:System.UInt32&gt;</ph> tipo de dados.</target>       </trans-unit>
        <trans-unit id="898" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.UInt32">
          <source>The value of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is less than <ph id="ph2">&lt;see cref="F:System.UInt32.MinValue" /&gt;</ph>.</source>
          <target state="translated">O valor de <ph id="ph1">&lt;paramref name="value" /&gt;</ph> é menor que <ph id="ph2">&lt;see cref="F:System.UInt32.MinValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="899" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.UInt32">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="900" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.UInt32">
          <source>The value of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is greater than <ph id="ph2">&lt;see cref="F:System.UInt32.MaxValue" /&gt;</ph>.</source>
          <target state="translated">O valor de <ph id="ph1">&lt;paramref name="value" /&gt;</ph> é maior que <ph id="ph2">&lt;see cref="F:System.UInt32.MaxValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="901" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.UInt64">
          <source>The value to convert to an unsigned 64-bit integer.</source>
          <target state="translated">O valor a ser convertido em um inteiro sem sinal de 64 bits.</target>       </trans-unit>
        <trans-unit id="902" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.UInt64">
          <source>Defines an explicit conversion of a <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> object to an unsigned 64-bit integer value.</source>
          <target state="translated">Define uma conversão explícita de um objeto <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> em um valor inteiro sem sinal de 64 bits.</target>       </trans-unit>
        <trans-unit id="903" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.UInt64">
          <source>This API is not CLS-compliant.</source>
          <target state="translated">Esta API não compatível com CLS.</target>       </trans-unit>
        <trans-unit id="904" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.UInt64">
          <source>The compliant alternative is <ph id="ph1">&lt;see cref="T:System.Double" /&gt;</ph>.</source>
          <target state="translated">A alternativa em conformidade é <ph id="ph1">&lt;see cref="T:System.Double" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="905" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.UInt64">
          <source>An object that contains the value of the <ph id="ph1">&lt;paramref name="value" /&gt;</ph> parameter.</source>
          <target state="translated">Um objeto que contém o valor do parâmetro <ph id="ph1">&lt;paramref name="value" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="906" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.UInt64">
          <source>The overloads of the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger&gt;</ph> method define the types to which or from which a <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> object can be converted.</source>
          <target state="translated">As sobrecargas do <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger&gt;</ph> método definem os tipos para o qual ou do qual um <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> objeto pode ser convertido.</target>       </trans-unit>
        <trans-unit id="907" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.UInt64">
          <source>Language compilers do not perform this conversion automatically because it can involve data loss.</source>
          <target state="translated">Compiladores de linguagem não realizar essa conversão automaticamente porque ele pode envolver a perda de dados.</target>       </trans-unit>
        <trans-unit id="908" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.UInt64">
          <source>Instead, they perform the conversion only if a casting operator (in C#) or a conversion function (such as <ph id="ph1">`CType`</ph> or <ph id="ph2">`CULng`</ph> in Visual Basic) is used.</source>
          <target state="translated">Em vez disso, eles executarem a conversão somente se um operador de conversão (em c#) ou uma função de conversão (como <ph id="ph1">`CType`</ph> ou <ph id="ph2">`CULng`</ph> no Visual Basic) é usado.</target>       </trans-unit>
        <trans-unit id="909" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.UInt64">
          <source>Otherwise, they display a compiler error.</source>
          <target state="translated">Caso contrário, eles exibem um erro do compilador.</target>       </trans-unit>
        <trans-unit id="910" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.UInt64">
          <source>Because this operation defines a narrowing conversion, it can throw an <ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> at run time if the <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> value is outside the range of the <ph id="ph3">&lt;xref:System.UInt64&gt;</ph> data type.</source>
          <target state="translated">Como essa operação define uma conversão de restrição, ela pode lançar um <ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> em tempo de execução se o <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> valor está fora do intervalo da <ph id="ph3">&lt;xref:System.UInt64&gt;</ph> tipo de dados.</target>       </trans-unit>
        <trans-unit id="911" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.UInt64">
          <source>There is no loss of precision in the resulting <ph id="ph1">&lt;xref:System.UInt64&gt;</ph> value if the conversion is successful.</source>
          <target state="translated">Não há nenhuma perda de precisão na resultante <ph id="ph1">&lt;xref:System.UInt64&gt;</ph> valor se a conversão for bem-sucedida.</target>       </trans-unit>
        <trans-unit id="912" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.UInt64">
          <source>The following example illustrates the conversion of <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> to <ph id="ph2">&lt;xref:System.UInt64&gt;</ph> values.</source>
          <target state="translated">O exemplo a seguir ilustra a conversão de <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> para <ph id="ph2">&lt;xref:System.UInt64&gt;</ph> valores.</target>       </trans-unit>
        <trans-unit id="913" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.UInt64">
          <source>It also handles an <ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> that is thrown because the <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> value is outside the range of the <ph id="ph3">&lt;xref:System.UInt64&gt;</ph> data type.</source>
          <target state="translated">Ele também lida com um <ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> que foi lançado porque o <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> valor está fora do intervalo da <ph id="ph3">&lt;xref:System.UInt64&gt;</ph> tipo de dados.</target>       </trans-unit>
        <trans-unit id="914" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.UInt64">
          <source>The value of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is less than <ph id="ph2">&lt;see cref="F:System.UInt64.MinValue" /&gt;</ph>.</source>
          <target state="translated">O valor de <ph id="ph1">&lt;paramref name="value" /&gt;</ph> é menor que <ph id="ph2">&lt;see cref="F:System.UInt64.MinValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="915" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.UInt64">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="916" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.UInt64">
          <source>The value of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is greater than <ph id="ph2">&lt;see cref="F:System.UInt64.MaxValue" /&gt;</ph>.</source>
          <target state="translated">O valor de <ph id="ph1">&lt;paramref name="value" /&gt;</ph> é maior que <ph id="ph2">&lt;see cref="F:System.UInt64.MaxValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="917" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Explicit(System.Single)~System.Numerics.BigInteger">
          <source>The value to convert to a <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph>.</source>
          <target state="translated">O valor a ser convertido para um <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="918" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Explicit(System.Single)~System.Numerics.BigInteger">
          <source>Defines an explicit conversion of a <ph id="ph1">&lt;see cref="T:System.Single" /&gt;</ph> value to a <ph id="ph2">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> value.</source>
          <target state="translated">Define uma conversão explícita de um valor <ph id="ph1">&lt;see cref="T:System.Single" /&gt;</ph> para um valor <ph id="ph2">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="919" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Explicit(System.Single)~System.Numerics.BigInteger">
          <source>An object that contains the value of the <ph id="ph1">&lt;paramref name="value" /&gt;</ph> parameter.</source>
          <target state="translated">Um objeto que contém o valor do parâmetro <ph id="ph1">&lt;paramref name="value" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="920" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Explicit(System.Single)~System.Numerics.BigInteger">
          <source>Any fractional part of the <ph id="ph1">`value`</ph> parameter is truncated before conversion.</source>
          <target state="translated">Qualquer parte fracionária do <ph id="ph1">`value`</ph> parâmetro será truncado antes da conversão.</target>       </trans-unit>
        <trans-unit id="921" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Explicit(System.Single)~System.Numerics.BigInteger">
          <source>The overloads of the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger&gt;</ph> method define the types to which or from which a <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> object can be converted.</source>
          <target state="translated">As sobrecargas do <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger&gt;</ph> método definem os tipos para o qual ou do qual um <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> objeto pode ser convertido.</target>       </trans-unit>
        <trans-unit id="922" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Explicit(System.Single)~System.Numerics.BigInteger">
          <source>Because the conversion from <ph id="ph1">&lt;xref:System.Single&gt;</ph> to <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> can involve truncating any fractional part of <ph id="ph3">`value`</ph>, language compilers do not perform this conversion automatically.</source>
          <target state="translated">Porque a conversão de <ph id="ph1">&lt;xref:System.Single&gt;</ph> para <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> pode envolver truncar qualquer parte fracionária do <ph id="ph3">`value`</ph>, os compiladores de linguagem não realizar essa conversão automaticamente.</target>       </trans-unit>
        <trans-unit id="923" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Explicit(System.Single)~System.Numerics.BigInteger">
          <source>Instead, they perform the conversion only if a casting operator (in C#) or a conversion function (such as <ph id="ph1">`CType`</ph> in Visual Basic) is used.</source>
          <target state="translated">Em vez disso, eles executarem a conversão somente se um operador de conversão (em c#) ou uma função de conversão (como <ph id="ph1">`CType`</ph> no Visual Basic) é usado.</target>       </trans-unit>
        <trans-unit id="924" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Explicit(System.Single)~System.Numerics.BigInteger">
          <source>Otherwise, they display a compiler error.</source>
          <target state="translated">Caso contrário, eles exibem um erro do compilador.</target>       </trans-unit>
        <trans-unit id="925" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Explicit(System.Single)~System.Numerics.BigInteger">
          <source>For languages that do not support custom operators, the alternative method is <ph id="ph1">&lt;xref:System.Numerics.BigInteger.%23ctor%28System.Single%29?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Para idiomas que não dão suporte a operadores personalizados, o método alternativo é <ph id="ph1">&lt;xref:System.Numerics.BigInteger.%23ctor%28System.Single%29?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="926" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Explicit(System.Single)~System.Numerics.BigInteger">
          <source>The following example converts the individual elements in an array of <ph id="ph1">&lt;xref:System.Single&gt;</ph> values to <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> objects, and then displays the result of each conversion.</source>
          <target state="translated">O exemplo a seguir converte os elementos individuais em uma matriz de <ph id="ph1">&lt;xref:System.Single&gt;</ph> valores <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> objetos e, em seguida, exibe o resultado de cada conversão.</target>       </trans-unit>
        <trans-unit id="927" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Explicit(System.Single)~System.Numerics.BigInteger">
          <source>Note that any fractional part of a <ph id="ph1">&lt;xref:System.Single&gt;</ph> value is truncated during the conversion.</source>
          <target state="translated">Observe que qualquer fracionários faz parte de uma <ph id="ph1">&lt;xref:System.Single&gt;</ph> valor é truncado durante a conversão.</target>       </trans-unit>
        <trans-unit id="928" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Explicit(System.Single)~System.Numerics.BigInteger">
          <source>The value of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see cref="F:System.Single.NaN" /&gt;</ph>.</source>
          <target state="translated">O valor de <ph id="ph1">&lt;paramref name="value" /&gt;</ph> é <ph id="ph2">&lt;see cref="F:System.Single.NaN" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="929" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Explicit(System.Single)~System.Numerics.BigInteger">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="930" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Explicit(System.Single)~System.Numerics.BigInteger">
          <source>The value of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see cref="F:System.Single.PositiveInfinity" /&gt;</ph>.</source>
          <target state="translated">O valor de <ph id="ph1">&lt;paramref name="value" /&gt;</ph> é <ph id="ph2">&lt;see cref="F:System.Single.PositiveInfinity" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="931" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Explicit(System.Single)~System.Numerics.BigInteger">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="932" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Explicit(System.Single)~System.Numerics.BigInteger">
          <source>The value of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see cref="F:System.Single.NegativeInfinity" /&gt;</ph>.</source>
          <target state="translated">O valor de <ph id="ph1">&lt;paramref name="value" /&gt;</ph> é <ph id="ph2">&lt;see cref="F:System.Single.NegativeInfinity" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="933" translate="yes" xml:space="preserve" uid="T:System.Numerics.BigInteger">
          <source>Returns a value that indicates whether a specified value is greater than another specified value.</source>
          <target state="translated">Retorna um valor que indica se um valor especificado é maior que outro valor especificado.</target>       </trans-unit>
        <trans-unit id="934" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_GreaterThan(System.Int64,System.Numerics.BigInteger)">
          <source>The first value to compare.</source>
          <target state="translated">O primeiro valor a ser comparado.</target>       </trans-unit>
        <trans-unit id="935" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_GreaterThan(System.Int64,System.Numerics.BigInteger)">
          <source>The second value to compare.</source>
          <target state="translated">O segundo valor a ser comparado.</target>       </trans-unit>
        <trans-unit id="936" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_GreaterThan(System.Int64,System.Numerics.BigInteger)">
          <source>Returns a value that indicates whether a 64-bit signed integer is greater than a <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> value.</source>
          <target state="translated">Retorna um valor que indica se um inteiro com sinal de 64 bits é maior que um valor <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="937" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_GreaterThan(System.Int64,System.Numerics.BigInteger)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="left" /&gt;</ph> is greater than <ph id="ph3">&lt;paramref name="right" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> caso <ph id="ph2">&lt;paramref name="left" /&gt;</ph> seja maior que <ph id="ph3">&lt;paramref name="right" /&gt;</ph>; do contrário, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="938" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_GreaterThan(System.Int64,System.Numerics.BigInteger)">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_GreaterThan%2A&gt;</ph> method defines the operation of the greater than operator for <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> values.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_GreaterThan%2A&gt;</ph> método define a operação de maior que o operador para <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> valores.</target>       </trans-unit>
        <trans-unit id="939" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_GreaterThan(System.Int64,System.Numerics.BigInteger)">
          <source>It enables code such as the following:</source>
          <target state="translated">Ele permite que o código seja o seguinte:</target>       </trans-unit>
        <trans-unit id="940" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_GreaterThan(System.Int64,System.Numerics.BigInteger)">
          <source>Languages that do not support custom operators can call the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType&gt;</ph> instance method instead.</source>
          <target state="translated">Idiomas que dão suporte a operadores personalizados podem chamar o <ph id="ph1">&lt;xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType&gt;</ph> em vez disso, o método de instância.</target>       </trans-unit>
        <trans-unit id="941" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_GreaterThan(System.Int64,System.Numerics.BigInteger)">
          <source>Some languages can also call the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_GreaterThan%28System.Int64%2CSystem.Numerics.BigInteger%29&gt;</ph> method directly, as the following example shows.</source>
          <target state="translated">Alguns idiomas também podem chamar o <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_GreaterThan%28System.Int64%2CSystem.Numerics.BigInteger%29&gt;</ph> método diretamente, como o exemplo a seguir mostra.</target>       </trans-unit>
        <trans-unit id="942" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_GreaterThan(System.Int64,System.Numerics.BigInteger)">
          <source>If <ph id="ph1">`left`</ph> is a <ph id="ph2">&lt;xref:System.Byte&gt;</ph>, <ph id="ph3">&lt;xref:System.Int16&gt;</ph>, <ph id="ph4">&lt;xref:System.Int32&gt;</ph>, <ph id="ph5">&lt;xref:System.SByte&gt;</ph>, <ph id="ph6">&lt;xref:System.UInt16&gt;</ph>, or <ph id="ph7">&lt;xref:System.UInt32&gt;</ph> value, it is implicitly converted to an <ph id="ph8">&lt;xref:System.Int64&gt;</ph> value when the operation is performed.</source>
          <target state="translated">Se <ph id="ph1">`left`</ph> é um <ph id="ph2">&lt;xref:System.Byte&gt;</ph>, <ph id="ph3">&lt;xref:System.Int16&gt;</ph>, <ph id="ph4">&lt;xref:System.Int32&gt;</ph>, <ph id="ph5">&lt;xref:System.SByte&gt;</ph>, <ph id="ph6">&lt;xref:System.UInt16&gt;</ph>, ou <ph id="ph7">&lt;xref:System.UInt32&gt;</ph> valor, ele é convertido implicitamente em um <ph id="ph8">&lt;xref:System.Int64&gt;</ph> valor quando a operação é executada.</target>       </trans-unit>
        <trans-unit id="943" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_GreaterThan(System.Int64,System.Numerics.BigInteger)">
          <source>The equivalent method for this operator is <ph id="ph1">&lt;xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">O método equivalente para esse operador é <ph id="ph1">&lt;xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="944" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_GreaterThan(System.Numerics.BigInteger,System.Int64)">
          <source>The first value to compare.</source>
          <target state="translated">O primeiro valor a ser comparado.</target>       </trans-unit>
        <trans-unit id="945" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_GreaterThan(System.Numerics.BigInteger,System.Int64)">
          <source>The second value to compare.</source>
          <target state="translated">O segundo valor a ser comparado.</target>       </trans-unit>
        <trans-unit id="946" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_GreaterThan(System.Numerics.BigInteger,System.Int64)">
          <source>Returns a value that indicates whether a <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> is greater than a 64-bit signed integer value.</source>
          <target state="translated">Retorna um valor que indica se um <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> é maior que um valor inteiro com sinal de 64 bits.</target>       </trans-unit>
        <trans-unit id="947" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_GreaterThan(System.Numerics.BigInteger,System.Int64)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="left" /&gt;</ph> is greater than <ph id="ph3">&lt;paramref name="right" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> caso <ph id="ph2">&lt;paramref name="left" /&gt;</ph> seja maior que <ph id="ph3">&lt;paramref name="right" /&gt;</ph>; do contrário, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="948" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_GreaterThan(System.Numerics.BigInteger,System.Int64)">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_GreaterThan%2A&gt;</ph> method defines the operation of the greater than operator for <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> values.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_GreaterThan%2A&gt;</ph> método define a operação de maior que o operador para <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> valores.</target>       </trans-unit>
        <trans-unit id="949" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_GreaterThan(System.Numerics.BigInteger,System.Int64)">
          <source>It enables code such as the following:</source>
          <target state="translated">Ele permite que o código seja o seguinte:</target>       </trans-unit>
        <trans-unit id="950" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_GreaterThan(System.Numerics.BigInteger,System.Int64)">
          <source>Languages that do not support custom operators can call the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType&gt;</ph> method instead.</source>
          <target state="translated">Linguagens que não dão suporte a operadores personalizados podem chamar o método <ph id="ph1">&lt;xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType&gt;</ph> em vez disso.</target>       </trans-unit>
        <trans-unit id="951" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_GreaterThan(System.Numerics.BigInteger,System.Int64)">
          <source>Some languages can also call the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_GreaterThan%28System.Numerics.BigInteger%2CSystem.Int64%29&gt;</ph> method directly, as the following example shows.</source>
          <target state="translated">Alguns idiomas também podem chamar o <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_GreaterThan%28System.Numerics.BigInteger%2CSystem.Int64%29&gt;</ph> método diretamente, como o exemplo a seguir mostra.</target>       </trans-unit>
        <trans-unit id="952" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_GreaterThan(System.Numerics.BigInteger,System.Int64)">
          <source>If <ph id="ph1">`right`</ph> is a <ph id="ph2">&lt;xref:System.Byte&gt;</ph>, <ph id="ph3">&lt;xref:System.Int16&gt;</ph>, <ph id="ph4">&lt;xref:System.Int32&gt;</ph>, <ph id="ph5">&lt;xref:System.SByte&gt;</ph>, <ph id="ph6">&lt;xref:System.UInt16&gt;</ph>, or <ph id="ph7">&lt;xref:System.UInt32&gt;</ph> value, it is implicitly converted to an <ph id="ph8">&lt;xref:System.Int64&gt;</ph> value when the operation is performed.</source>
          <target state="translated">Se <ph id="ph1">`right`</ph> é um <ph id="ph2">&lt;xref:System.Byte&gt;</ph>, <ph id="ph3">&lt;xref:System.Int16&gt;</ph>, <ph id="ph4">&lt;xref:System.Int32&gt;</ph>, <ph id="ph5">&lt;xref:System.SByte&gt;</ph>, <ph id="ph6">&lt;xref:System.UInt16&gt;</ph>, ou <ph id="ph7">&lt;xref:System.UInt32&gt;</ph> valor, ele é convertido implicitamente em um <ph id="ph8">&lt;xref:System.Int64&gt;</ph> valor quando a operação é executada.</target>       </trans-unit>
        <trans-unit id="953" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_GreaterThan(System.Numerics.BigInteger,System.Int64)">
          <source>The equivalent method for this operator is <ph id="ph1">&lt;xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">O método equivalente para esse operador é <ph id="ph1">&lt;xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="954" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_GreaterThan(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>The first value to compare.</source>
          <target state="translated">O primeiro valor a ser comparado.</target>       </trans-unit>
        <trans-unit id="955" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_GreaterThan(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>The second value to compare.</source>
          <target state="translated">O segundo valor a ser comparado.</target>       </trans-unit>
        <trans-unit id="956" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_GreaterThan(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>Returns a value that indicates whether a <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> value is greater than another <ph id="ph2">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> value.</source>
          <target state="translated">Retorna um valor que indica se um valor <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> é maior que outro valor <ph id="ph2">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="957" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_GreaterThan(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="left" /&gt;</ph> is greater than <ph id="ph3">&lt;paramref name="right" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> caso <ph id="ph2">&lt;paramref name="left" /&gt;</ph> seja maior que <ph id="ph3">&lt;paramref name="right" /&gt;</ph>; do contrário, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="958" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_GreaterThan(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_GreaterThan%2A&gt;</ph> method defines the operation of the greater than operator for <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> values.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_GreaterThan%2A&gt;</ph> método define a operação de maior que o operador para <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> valores.</target>       </trans-unit>
        <trans-unit id="959" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_GreaterThan(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>It enables code such as the following:</source>
          <target state="translated">Ele permite que o código seja o seguinte:</target>       </trans-unit>
        <trans-unit id="960" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_GreaterThan(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>Languages that do not support custom operators can call the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Compare%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType&gt;</ph> method instead.</source>
          <target state="translated">Linguagens que não dão suporte a operadores personalizados podem chamar o método <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Compare%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType&gt;</ph> em vez disso.</target>       </trans-unit>
        <trans-unit id="961" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_GreaterThan(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>They can also call the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_GreaterThan%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29&gt;</ph> method directly, as the following example shows.</source>
          <target state="translated">Eles também podem chamar o <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_GreaterThan%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29&gt;</ph> método diretamente, como o exemplo a seguir mostra.</target>       </trans-unit>
        <trans-unit id="962" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_GreaterThan(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>The equivalent method for this operator is <ph id="ph1">&lt;xref:System.Numerics.BigInteger.CompareTo(System.Numerics.BigInteger)?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">O método equivalente para esse operador é <ph id="ph1">&lt;xref:System.Numerics.BigInteger.CompareTo(System.Numerics.BigInteger)?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="963" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_GreaterThan(System.Numerics.BigInteger,System.UInt64)">
          <source>The first value to compare.</source>
          <target state="translated">O primeiro valor a ser comparado.</target>       </trans-unit>
        <trans-unit id="964" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_GreaterThan(System.Numerics.BigInteger,System.UInt64)">
          <source>The second value to compare.</source>
          <target state="translated">O segundo valor a ser comparado.</target>       </trans-unit>
        <trans-unit id="965" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_GreaterThan(System.Numerics.BigInteger,System.UInt64)">
          <source>Returns a value that indicates whether a <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> value is greater than a 64-bit unsigned integer.</source>
          <target state="translated">Retorna um valor que indica se um valor <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> é maior que um inteiro sem sinal de 64 bits.</target>       </trans-unit>
        <trans-unit id="966" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_GreaterThan(System.Numerics.BigInteger,System.UInt64)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="left" /&gt;</ph> is greater than <ph id="ph3">&lt;paramref name="right" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> caso <ph id="ph2">&lt;paramref name="left" /&gt;</ph> seja maior que <ph id="ph3">&lt;paramref name="right" /&gt;</ph>; do contrário, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="967" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_GreaterThan(System.Numerics.BigInteger,System.UInt64)">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_GreaterThan%2A&gt;</ph> method defines the operation of the greater than operator for <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> values.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_GreaterThan%2A&gt;</ph> método define a operação de maior que o operador para <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> valores.</target>       </trans-unit>
        <trans-unit id="968" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_GreaterThan(System.Numerics.BigInteger,System.UInt64)">
          <source>It enables code such as the following:</source>
          <target state="translated">Ele permite que o código seja o seguinte:</target>       </trans-unit>
        <trans-unit id="969" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_GreaterThan(System.Numerics.BigInteger,System.UInt64)">
          <source>Languages that do not support custom operators can call the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType&gt;</ph> method instead.</source>
          <target state="translated">Linguagens que não dão suporte a operadores personalizados podem chamar o método <ph id="ph1">&lt;xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType&gt;</ph> em vez disso.</target>       </trans-unit>
        <trans-unit id="970" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_GreaterThan(System.Numerics.BigInteger,System.UInt64)">
          <source>Some languages can also call the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_GreaterThan%28System.Numerics.BigInteger%2CSystem.UInt64%29&gt;</ph> method directly, as the following example shows.</source>
          <target state="translated">Alguns idiomas também podem chamar o <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_GreaterThan%28System.Numerics.BigInteger%2CSystem.UInt64%29&gt;</ph> método diretamente, como o exemplo a seguir mostra.</target>       </trans-unit>
        <trans-unit id="971" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_GreaterThan(System.UInt64,System.Numerics.BigInteger)">
          <source>The first value to compare.</source>
          <target state="translated">O primeiro valor a ser comparado.</target>       </trans-unit>
        <trans-unit id="972" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_GreaterThan(System.UInt64,System.Numerics.BigInteger)">
          <source>The second value to compare.</source>
          <target state="translated">O segundo valor a ser comparado.</target>       </trans-unit>
        <trans-unit id="973" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_GreaterThan(System.UInt64,System.Numerics.BigInteger)">
          <source>Returns a value that indicates whether a <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> value is greater than a 64-bit unsigned integer.</source>
          <target state="translated">Retorna um valor que indica se um valor <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> é maior que um inteiro sem sinal de 64 bits.</target>       </trans-unit>
        <trans-unit id="974" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_GreaterThan(System.UInt64,System.Numerics.BigInteger)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="left" /&gt;</ph> is greater than <ph id="ph3">&lt;paramref name="right" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> caso <ph id="ph2">&lt;paramref name="left" /&gt;</ph> seja maior que <ph id="ph3">&lt;paramref name="right" /&gt;</ph>; do contrário, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="975" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_GreaterThan(System.UInt64,System.Numerics.BigInteger)">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_GreaterThan%2A&gt;</ph> method defines the operation of the greater than operator for <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> values.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_GreaterThan%2A&gt;</ph> método define a operação de maior que o operador para <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> valores.</target>       </trans-unit>
        <trans-unit id="976" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_GreaterThan(System.UInt64,System.Numerics.BigInteger)">
          <source>It enables code such as the following:</source>
          <target state="translated">Ele permite que o código seja o seguinte:</target>       </trans-unit>
        <trans-unit id="977" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_GreaterThan(System.UInt64,System.Numerics.BigInteger)">
          <source>Languages that do not support custom operators can call the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType&gt;</ph> method instead.</source>
          <target state="translated">Linguagens que não dão suporte a operadores personalizados podem chamar o método <ph id="ph1">&lt;xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType&gt;</ph> em vez disso.</target>       </trans-unit>
        <trans-unit id="978" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_GreaterThan(System.UInt64,System.Numerics.BigInteger)">
          <source>Some languages can also call the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_GreaterThan%28System.UInt64%2CSystem.Numerics.BigInteger%29&gt;</ph> method directly, as the following example shows.</source>
          <target state="translated">Alguns idiomas também podem chamar o <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_GreaterThan%28System.UInt64%2CSystem.Numerics.BigInteger%29&gt;</ph> método diretamente, como o exemplo a seguir mostra.</target>       </trans-unit>
        <trans-unit id="979" translate="yes" xml:space="preserve" uid="T:System.Numerics.BigInteger">
          <source>Returns a value that indicates whether a specified value is greater than or equal to another specified value.</source>
          <target state="translated">Retorna um valor que indica se um valor especificado é maior ou igual a outro valor especificado.</target>       </trans-unit>
        <trans-unit id="980" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.Int64,System.Numerics.BigInteger)">
          <source>The first value to compare.</source>
          <target state="translated">O primeiro valor a ser comparado.</target>       </trans-unit>
        <trans-unit id="981" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.Int64,System.Numerics.BigInteger)">
          <source>The second value to compare.</source>
          <target state="translated">O segundo valor a ser comparado.</target>       </trans-unit>
        <trans-unit id="982" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.Int64,System.Numerics.BigInteger)">
          <source>Returns a value that indicates whether a 64-bit signed integer is greater than or equal to a <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> value.</source>
          <target state="translated">Retorna um valor que indica se um inteiro com sinal de 64 bits é maior ou igual a um valor <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="983" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.Int64,System.Numerics.BigInteger)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="left" /&gt;</ph> is greater than <ph id="ph3">&lt;paramref name="right" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> caso <ph id="ph2">&lt;paramref name="left" /&gt;</ph> seja maior que <ph id="ph3">&lt;paramref name="right" /&gt;</ph>; do contrário, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="984" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.Int64,System.Numerics.BigInteger)">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%2A&gt;</ph> method defines the operation of the greater than or equal to operator for <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> values.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%2A&gt;</ph> método define a operação de maior que ou igual ao operador para <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> valores.</target>       </trans-unit>
        <trans-unit id="985" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.Int64,System.Numerics.BigInteger)">
          <source>It enables code such as the following:</source>
          <target state="translated">Ele permite que o código seja o seguinte:</target>       </trans-unit>
        <trans-unit id="986" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.Int64,System.Numerics.BigInteger)">
          <source>Languages that do not support custom operators can call the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType&gt;</ph> method instead.</source>
          <target state="translated">Linguagens que não dão suporte a operadores personalizados podem chamar o método <ph id="ph1">&lt;xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType&gt;</ph> em vez disso.</target>       </trans-unit>
        <trans-unit id="987" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.Int64,System.Numerics.BigInteger)">
          <source>Some languages can also call the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%28System.Int64%2CSystem.Numerics.BigInteger%29&gt;</ph> method directly, as the following example shows.</source>
          <target state="translated">Alguns idiomas também podem chamar o <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%28System.Int64%2CSystem.Numerics.BigInteger%29&gt;</ph> método diretamente, como o exemplo a seguir mostra.</target>       </trans-unit>
        <trans-unit id="988" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.Int64,System.Numerics.BigInteger)">
          <source>If <ph id="ph1">`left`</ph> is a <ph id="ph2">&lt;xref:System.Byte&gt;</ph>, <ph id="ph3">&lt;xref:System.Int16&gt;</ph>, <ph id="ph4">&lt;xref:System.Int32&gt;</ph>, <ph id="ph5">&lt;xref:System.SByte&gt;</ph>, <ph id="ph6">&lt;xref:System.UInt16&gt;</ph>, or <ph id="ph7">&lt;xref:System.UInt32&gt;</ph> value, it is implicitly converted to an <ph id="ph8">&lt;xref:System.Int64&gt;</ph> value when the operation is performed.</source>
          <target state="translated">Se <ph id="ph1">`left`</ph> é um <ph id="ph2">&lt;xref:System.Byte&gt;</ph>, <ph id="ph3">&lt;xref:System.Int16&gt;</ph>, <ph id="ph4">&lt;xref:System.Int32&gt;</ph>, <ph id="ph5">&lt;xref:System.SByte&gt;</ph>, <ph id="ph6">&lt;xref:System.UInt16&gt;</ph>, ou <ph id="ph7">&lt;xref:System.UInt32&gt;</ph> valor, ele é convertido implicitamente em um <ph id="ph8">&lt;xref:System.Int64&gt;</ph> valor quando a operação é executada.</target>       </trans-unit>
        <trans-unit id="989" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.Int64,System.Numerics.BigInteger)">
          <source>The equivalent method for this operator is <ph id="ph1">&lt;xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">O método equivalente para esse operador é <ph id="ph1">&lt;xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="990" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.Numerics.BigInteger,System.Int64)">
          <source>The first value to compare.</source>
          <target state="translated">O primeiro valor a ser comparado.</target>       </trans-unit>
        <trans-unit id="991" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.Numerics.BigInteger,System.Int64)">
          <source>The second value to compare.</source>
          <target state="translated">O segundo valor a ser comparado.</target>       </trans-unit>
        <trans-unit id="992" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.Numerics.BigInteger,System.Int64)">
          <source>Returns a value that indicates whether a <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> value is greater than or equal to a 64-bit signed integer value.</source>
          <target state="translated">Retorna um valor que indica se um valor de <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> é maior ou igual a um valor inteiro com sinal de 64 bits.</target>       </trans-unit>
        <trans-unit id="993" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.Numerics.BigInteger,System.Int64)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="left" /&gt;</ph> is greater than <ph id="ph3">&lt;paramref name="right" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> caso <ph id="ph2">&lt;paramref name="left" /&gt;</ph> seja maior que <ph id="ph3">&lt;paramref name="right" /&gt;</ph>; do contrário, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="994" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.Numerics.BigInteger,System.Int64)">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%2A&gt;</ph> method defines the operation of the greater than or equal to operator for <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> values.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%2A&gt;</ph> método define a operação de maior que ou igual ao operador para <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> valores.</target>       </trans-unit>
        <trans-unit id="995" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.Numerics.BigInteger,System.Int64)">
          <source>It enables code such as the following:</source>
          <target state="translated">Ele permite que o código seja o seguinte:</target>       </trans-unit>
        <trans-unit id="996" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.Numerics.BigInteger,System.Int64)">
          <source>Languages that do not support custom operators can call the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType&gt;</ph> method instead.</source>
          <target state="translated">Linguagens que não dão suporte a operadores personalizados podem chamar o método <ph id="ph1">&lt;xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType&gt;</ph> em vez disso.</target>       </trans-unit>
        <trans-unit id="997" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.Numerics.BigInteger,System.Int64)">
          <source>Some languages can also call the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%28System.Numerics.BigInteger%2CSystem.Int64%29&gt;</ph> method directly, as the following example shows.</source>
          <target state="translated">Alguns idiomas também podem chamar o <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%28System.Numerics.BigInteger%2CSystem.Int64%29&gt;</ph> método diretamente, como o exemplo a seguir mostra.</target>       </trans-unit>
        <trans-unit id="998" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.Numerics.BigInteger,System.Int64)">
          <source>If <ph id="ph1">`right`</ph> is a <ph id="ph2">&lt;xref:System.Byte&gt;</ph>, <ph id="ph3">&lt;xref:System.Int16&gt;</ph>, <ph id="ph4">&lt;xref:System.Int32&gt;</ph>, <ph id="ph5">&lt;xref:System.SByte&gt;</ph>, <ph id="ph6">&lt;xref:System.UInt16&gt;</ph>, or <ph id="ph7">&lt;xref:System.UInt32&gt;</ph> value, it is implicitly converted to an <ph id="ph8">&lt;xref:System.Int64&gt;</ph> value when the operation is performed.</source>
          <target state="translated">Se <ph id="ph1">`right`</ph> é um <ph id="ph2">&lt;xref:System.Byte&gt;</ph>, <ph id="ph3">&lt;xref:System.Int16&gt;</ph>, <ph id="ph4">&lt;xref:System.Int32&gt;</ph>, <ph id="ph5">&lt;xref:System.SByte&gt;</ph>, <ph id="ph6">&lt;xref:System.UInt16&gt;</ph>, ou <ph id="ph7">&lt;xref:System.UInt32&gt;</ph> valor, ele é convertido implicitamente em um <ph id="ph8">&lt;xref:System.Int64&gt;</ph> valor quando a operação é executada.</target>       </trans-unit>
        <trans-unit id="999" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.Numerics.BigInteger,System.Int64)">
          <source>The equivalent method for this operator is <ph id="ph1">&lt;xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">O método equivalente para esse operador é <ph id="ph1">&lt;xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1000" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>The first value to compare.</source>
          <target state="translated">O primeiro valor a ser comparado.</target>       </trans-unit>
        <trans-unit id="1001" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>The second value to compare.</source>
          <target state="translated">O segundo valor a ser comparado.</target>       </trans-unit>
        <trans-unit id="1002" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>Returns a value that indicates whether a <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> value is greater than or equal to another <ph id="ph2">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> value.</source>
          <target state="translated">Retorna um valor que indica se um valor <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> é maior ou igual a outro valor <ph id="ph2">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1003" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="left" /&gt;</ph> is greater than <ph id="ph3">&lt;paramref name="right" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> caso <ph id="ph2">&lt;paramref name="left" /&gt;</ph> seja maior que <ph id="ph3">&lt;paramref name="right" /&gt;</ph>; do contrário, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1004" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%2A&gt;</ph> method defines the operation of the greater than or equal to operator for <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> values.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%2A&gt;</ph> método define a operação de maior que ou igual ao operador para <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> valores.</target>       </trans-unit>
        <trans-unit id="1005" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>It enables code such as the following:</source>
          <target state="translated">Ele permite que o código seja o seguinte:</target>       </trans-unit>
        <trans-unit id="1006" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>Languages that do not support custom operators can call the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Compare%2A?displayProperty=nameWithType&gt;</ph> method instead.</source>
          <target state="translated">Linguagens que não dão suporte a operadores personalizados podem chamar o método <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Compare%2A?displayProperty=nameWithType&gt;</ph> em vez disso.</target>       </trans-unit>
        <trans-unit id="1007" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>Some languages can also call the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29&gt;</ph> method directly, as the following example shows.</source>
          <target state="translated">Alguns idiomas também podem chamar o <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29&gt;</ph> método diretamente, como o exemplo a seguir mostra.</target>       </trans-unit>
        <trans-unit id="1008" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>The equivalent method for this operator is <ph id="ph1">&lt;xref:System.Numerics.BigInteger.CompareTo(System.Numerics.BigInteger)?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">O método equivalente para esse operador é <ph id="ph1">&lt;xref:System.Numerics.BigInteger.CompareTo(System.Numerics.BigInteger)?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1009" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.Numerics.BigInteger,System.UInt64)">
          <source>The first value to compare.</source>
          <target state="translated">O primeiro valor a ser comparado.</target>       </trans-unit>
        <trans-unit id="1010" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.Numerics.BigInteger,System.UInt64)">
          <source>The second value to compare.</source>
          <target state="translated">O segundo valor a ser comparado.</target>       </trans-unit>
        <trans-unit id="1011" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.Numerics.BigInteger,System.UInt64)">
          <source>Returns a value that indicates whether a <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> value is greater than or equal to a 64-bit unsigned integer value.</source>
          <target state="translated">Retorna um valor que indica se um valor <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> é maior ou igual a um valor inteiro sem sinal de 64 bits.</target>       </trans-unit>
        <trans-unit id="1012" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.Numerics.BigInteger,System.UInt64)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="left" /&gt;</ph> is greater than <ph id="ph3">&lt;paramref name="right" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> caso <ph id="ph2">&lt;paramref name="left" /&gt;</ph> seja maior que <ph id="ph3">&lt;paramref name="right" /&gt;</ph>; do contrário, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1013" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.Numerics.BigInteger,System.UInt64)">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%2A&gt;</ph> method defines the operation of the greater than or equal to operator for <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> values.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%2A&gt;</ph> método define a operação de maior que ou igual ao operador para <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> valores.</target>       </trans-unit>
        <trans-unit id="1014" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.Numerics.BigInteger,System.UInt64)">
          <source>It enables code such as the following:</source>
          <target state="translated">Ele permite que o código seja o seguinte:</target>       </trans-unit>
        <trans-unit id="1015" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.Numerics.BigInteger,System.UInt64)">
          <source>Languages that do not support custom operators can call the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType&gt;</ph> method instead.</source>
          <target state="translated">Linguagens que não dão suporte a operadores personalizados podem chamar o método <ph id="ph1">&lt;xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType&gt;</ph> em vez disso.</target>       </trans-unit>
        <trans-unit id="1016" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.Numerics.BigInteger,System.UInt64)">
          <source>Some languages can also call the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%28System.Numerics.BigInteger%2CSystem.UInt64%29&gt;</ph> method directly, as the following example shows.</source>
          <target state="translated">Alguns idiomas também podem chamar o <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%28System.Numerics.BigInteger%2CSystem.UInt64%29&gt;</ph> método diretamente, como o exemplo a seguir mostra.</target>       </trans-unit>
        <trans-unit id="1017" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.Numerics.BigInteger,System.UInt64)">
          <source>The equivalent method for this operator is <ph id="ph1">&lt;xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">O método equivalente para esse operador é <ph id="ph1">&lt;xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1018" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.UInt64,System.Numerics.BigInteger)">
          <source>The first value to compare.</source>
          <target state="translated">O primeiro valor a ser comparado.</target>       </trans-unit>
        <trans-unit id="1019" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.UInt64,System.Numerics.BigInteger)">
          <source>The second value to compare.</source>
          <target state="translated">O segundo valor a ser comparado.</target>       </trans-unit>
        <trans-unit id="1020" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.UInt64,System.Numerics.BigInteger)">
          <source>Returns a value that indicates whether a 64-bit unsigned integer is greater than or equal to a <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> value.</source>
          <target state="translated">Retorna um valor que indica se um inteiro sem sinal de 64 bits é maior ou igual a um valor <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1021" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.UInt64,System.Numerics.BigInteger)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="left" /&gt;</ph> is greater than <ph id="ph3">&lt;paramref name="right" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> caso <ph id="ph2">&lt;paramref name="left" /&gt;</ph> seja maior que <ph id="ph3">&lt;paramref name="right" /&gt;</ph>; do contrário, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1022" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.UInt64,System.Numerics.BigInteger)">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%2A&gt;</ph> method defines the operation of the greater than or equal to operator for <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> values.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%2A&gt;</ph> método define a operação de maior que ou igual ao operador para <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> valores.</target>       </trans-unit>
        <trans-unit id="1023" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.UInt64,System.Numerics.BigInteger)">
          <source>It enables code such as the following:</source>
          <target state="translated">Ele permite que o código seja o seguinte:</target>       </trans-unit>
        <trans-unit id="1024" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.UInt64,System.Numerics.BigInteger)">
          <source>Languages that do not support custom operators can call the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType&gt;</ph> method instead.</source>
          <target state="translated">Linguagens que não dão suporte a operadores personalizados podem chamar o método <ph id="ph1">&lt;xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType&gt;</ph> em vez disso.</target>       </trans-unit>
        <trans-unit id="1025" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.UInt64,System.Numerics.BigInteger)">
          <source>Some languages can also call the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%28System.UInt64%2CSystem.Numerics.BigInteger%29&gt;</ph> method directly, as the following example shows.</source>
          <target state="translated">Alguns idiomas também podem chamar o <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%28System.UInt64%2CSystem.Numerics.BigInteger%29&gt;</ph> método diretamente, como o exemplo a seguir mostra.</target>       </trans-unit>
        <trans-unit id="1026" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.UInt64,System.Numerics.BigInteger)">
          <source>The equivalent method for this operator is <ph id="ph1">&lt;xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">O método equivalente para esse operador é <ph id="ph1">&lt;xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1027" translate="yes" xml:space="preserve" uid="T:System.Numerics.BigInteger">
          <source>Defines an implicit conversion between a <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> object and another type.</source>
          <target state="translated">Define uma conversão implícita entre um objeto <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> e outro tipo.</target>       </trans-unit>
        <trans-unit id="1028" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger">
          <source>The value to convert to a <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph>.</source>
          <target state="translated">O valor a ser convertido para um <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1029" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger">
          <source>Defines an implicit conversion of an unsigned byte to a <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> value.</source>
          <target state="translated">Define uma conversão implícita de um byte sem sinal em um valor <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1030" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger">
          <source>An object that contains the value of the <ph id="ph1">&lt;paramref name="value" /&gt;</ph> parameter.</source>
          <target state="translated">Um objeto que contém o valor do parâmetro <ph id="ph1">&lt;paramref name="value" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1031" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger">
          <source>Any fractional part of the <ph id="ph1">`value`</ph> parameter is truncated before conversion.</source>
          <target state="translated">Qualquer parte fracionária do <ph id="ph1">`value`</ph> parâmetro será truncado antes da conversão.</target>       </trans-unit>
        <trans-unit id="1032" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger">
          <source>For languages that do not support implicit operators, the alternative method is <ph id="ph1">&lt;xref:System.Numerics.BigInteger.%23ctor%28System.Int32%29?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Para idiomas que não dão suporte a operadores implícita, o método alternativo é <ph id="ph1">&lt;xref:System.Numerics.BigInteger.%23ctor%28System.Int32%29?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1033" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger">
          <source>The overloads of the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger&gt;</ph> method define the types to which or from which a compiler can automatically convert a <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> value without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</source>
          <target state="translated">As sobrecargas do <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger&gt;</ph> método definem os tipos de qual ou para que um compilador pode converter automaticamente um <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> valor sem um operador de conversão explícita (em c#) ou uma chamada para uma função de conversão (no Visual Basic).</target>       </trans-unit>
        <trans-unit id="1034" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger">
          <source>They are widening conversions that do not involve data loss and do not throw an <ph id="ph1">&lt;xref:System.OverflowException&gt;</ph>.</source>
          <target state="translated">Eles são widening conversões que não envolvem a perda de dados e não gerará uma <ph id="ph1">&lt;xref:System.OverflowException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1035" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger">
          <source>This overload lets the compiler handle conversions from a <ph id="ph1">&lt;xref:System.Byte&gt;</ph> value to a <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> value, as the following example shows.</source>
          <target state="translated">Essa sobrecarga permite que o compilador trate conversões de um <ph id="ph1">&lt;xref:System.Byte&gt;</ph> valor para um <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> valor, como mostra o exemplo a seguir.</target>       </trans-unit>
        <trans-unit id="1036" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Implicit(System.Int16)~System.Numerics.BigInteger">
          <source>The value to convert to a <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph>.</source>
          <target state="translated">O valor a ser convertido para um <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1037" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Implicit(System.Int16)~System.Numerics.BigInteger">
          <source>Defines an implicit conversion of a signed 16-bit integer to a <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> value.</source>
          <target state="translated">Define uma conversão implícita de um inteiro com sinal de 16 bits em um valor <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1038" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Implicit(System.Int16)~System.Numerics.BigInteger">
          <source>An object that contains the value of the <ph id="ph1">&lt;paramref name="value" /&gt;</ph> parameter.</source>
          <target state="translated">Um objeto que contém o valor do parâmetro <ph id="ph1">&lt;paramref name="value" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1039" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Implicit(System.Int16)~System.Numerics.BigInteger">
          <source>For languages that do not support implicit operators, the alternative method is <ph id="ph1">&lt;xref:System.Numerics.BigInteger.%23ctor%28System.Int32%29?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Para idiomas que não dão suporte a operadores implícita, o método alternativo é <ph id="ph1">&lt;xref:System.Numerics.BigInteger.%23ctor%28System.Int32%29?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1040" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Implicit(System.Int16)~System.Numerics.BigInteger">
          <source>The overloads of the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger&gt;</ph> method define the types to which or from which a compiler can automatically convert a <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> value without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</source>
          <target state="translated">As sobrecargas do <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger&gt;</ph> método definem os tipos de qual ou para que um compilador pode converter automaticamente um <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> valor sem um operador de conversão explícita (em c#) ou uma chamada para uma função de conversão (no Visual Basic).</target>       </trans-unit>
        <trans-unit id="1041" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Implicit(System.Int16)~System.Numerics.BigInteger">
          <source>They are widening conversions that do not involve data loss and do not throw an <ph id="ph1">&lt;xref:System.OverflowException&gt;</ph>.</source>
          <target state="translated">Eles são widening conversões que não envolvem a perda de dados e não gerará uma <ph id="ph1">&lt;xref:System.OverflowException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1042" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Implicit(System.Int16)~System.Numerics.BigInteger">
          <source>This overload lets the compiler handle conversions from a <ph id="ph1">&lt;xref:System.Int16&gt;</ph> value to a <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> value, as the following example shows.</source>
          <target state="translated">Essa sobrecarga permite que o compilador trate conversões de um <ph id="ph1">&lt;xref:System.Int16&gt;</ph> valor para um <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> valor, como mostra o exemplo a seguir.</target>       </trans-unit>
        <trans-unit id="1043" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Implicit(System.Int32)~System.Numerics.BigInteger">
          <source>The value to convert to a <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph>.</source>
          <target state="translated">O valor a ser convertido para um <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1044" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Implicit(System.Int32)~System.Numerics.BigInteger">
          <source>Defines an implicit conversion of a signed 32-bit integer to a <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> value.</source>
          <target state="translated">Define uma conversão implícita de um inteiro com sinal de 32 bits em um valor <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1045" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Implicit(System.Int32)~System.Numerics.BigInteger">
          <source>An object that contains the value of the <ph id="ph1">&lt;paramref name="value" /&gt;</ph> parameter.</source>
          <target state="translated">Um objeto que contém o valor do parâmetro <ph id="ph1">&lt;paramref name="value" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1046" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Implicit(System.Int32)~System.Numerics.BigInteger">
          <source>For languages that do not support implicit operators, the alternative method is <ph id="ph1">&lt;xref:System.Numerics.BigInteger.%23ctor%28System.Int32%29?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Para idiomas que não dão suporte a operadores implícita, o método alternativo é <ph id="ph1">&lt;xref:System.Numerics.BigInteger.%23ctor%28System.Int32%29?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1047" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Implicit(System.Int32)~System.Numerics.BigInteger">
          <source>The overloads of the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger&gt;</ph> method define the types to which or from which a compiler can automatically convert a <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> value without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</source>
          <target state="translated">As sobrecargas do <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger&gt;</ph> método definem os tipos de qual ou para que um compilador pode converter automaticamente um <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> valor sem um operador de conversão explícita (em c#) ou uma chamada para uma função de conversão (no Visual Basic).</target>       </trans-unit>
        <trans-unit id="1048" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Implicit(System.Int32)~System.Numerics.BigInteger">
          <source>They are widening conversions that do not involve data loss and do not throw an <ph id="ph1">&lt;xref:System.OverflowException&gt;</ph>.</source>
          <target state="translated">Eles são widening conversões que não envolvem a perda de dados e não gerará uma <ph id="ph1">&lt;xref:System.OverflowException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1049" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Implicit(System.Int32)~System.Numerics.BigInteger">
          <source>This overload lets the compiler handle conversions from a <ph id="ph1">&lt;xref:System.Int32&gt;</ph> value to a <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> value, as the following example shows.</source>
          <target state="translated">Essa sobrecarga permite que o compilador trate conversões de um <ph id="ph1">&lt;xref:System.Int32&gt;</ph> valor para um <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> valor, como mostra o exemplo a seguir.</target>       </trans-unit>
        <trans-unit id="1050" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Implicit(System.Int64)~System.Numerics.BigInteger">
          <source>The value to convert to a <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph>.</source>
          <target state="translated">O valor a ser convertido para um <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1051" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Implicit(System.Int64)~System.Numerics.BigInteger">
          <source>Defines an implicit conversion of a signed 64-bit integer to a <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> value.</source>
          <target state="translated">Define uma conversão implícita de um inteiro com sinal de 64 bits em um valor <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1052" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Implicit(System.Int64)~System.Numerics.BigInteger">
          <source>An object that contains the value of the <ph id="ph1">&lt;paramref name="value" /&gt;</ph> parameter.</source>
          <target state="translated">Um objeto que contém o valor do parâmetro <ph id="ph1">&lt;paramref name="value" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1053" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Implicit(System.Int64)~System.Numerics.BigInteger">
          <source>For languages that do not support implicit operators, the alternative method is <ph id="ph1">&lt;xref:System.Numerics.BigInteger.%23ctor%28System.Int64%29?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Para idiomas que não dão suporte a operadores implícita, o método alternativo é <ph id="ph1">&lt;xref:System.Numerics.BigInteger.%23ctor%28System.Int64%29?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1054" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Implicit(System.Int64)~System.Numerics.BigInteger">
          <source>The overloads of the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger&gt;</ph> method define the types to which or from which a compiler can automatically convert a <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> value without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</source>
          <target state="translated">As sobrecargas do <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger&gt;</ph> método definem os tipos de qual ou para que um compilador pode converter automaticamente um <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> valor sem um operador de conversão explícita (em c#) ou uma chamada para uma função de conversão (no Visual Basic).</target>       </trans-unit>
        <trans-unit id="1055" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Implicit(System.Int64)~System.Numerics.BigInteger">
          <source>They are widening conversions that do not involve data loss and do not throw an <ph id="ph1">&lt;xref:System.OverflowException&gt;</ph>.</source>
          <target state="translated">Eles são widening conversões que não envolvem a perda de dados e não gerará uma <ph id="ph1">&lt;xref:System.OverflowException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1056" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Implicit(System.Int64)~System.Numerics.BigInteger">
          <source>This overload lets the compiler handle conversions from a <ph id="ph1">&lt;xref:System.Int64&gt;</ph> value to a <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> value, as the following example shows.</source>
          <target state="translated">Essa sobrecarga permite que o compilador trate conversões de um <ph id="ph1">&lt;xref:System.Int64&gt;</ph> valor para um <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> valor, como mostra o exemplo a seguir.</target>       </trans-unit>
        <trans-unit id="1057" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Implicit(System.SByte)~System.Numerics.BigInteger">
          <source>The value to convert to a <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph>.</source>
          <target state="translated">O valor a ser convertido para um <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1058" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Implicit(System.SByte)~System.Numerics.BigInteger">
          <source>Defines an implicit conversion of an 8-bit signed integer to a <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> value.</source>
          <target state="translated">Define uma conversão implícita de um inteiro com sinal de 8 bits em um valor <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1059" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Implicit(System.SByte)~System.Numerics.BigInteger">
          <source>This API is not CLS-compliant.</source>
          <target state="translated">Esta API não compatível com CLS.</target>       </trans-unit>
        <trans-unit id="1060" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Implicit(System.SByte)~System.Numerics.BigInteger">
          <source>The compliant alternative is <ph id="ph1">&lt;see cref="M:System.Numerics.BigInteger.#ctor(System.Int32)" /&gt;</ph>.</source>
          <target state="translated">A alternativa em conformidade é <ph id="ph1">&lt;see cref="M:System.Numerics.BigInteger.#ctor(System.Int32)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1061" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Implicit(System.SByte)~System.Numerics.BigInteger">
          <source>An object that contains the value of the <ph id="ph1">&lt;paramref name="value" /&gt;</ph> parameter.</source>
          <target state="translated">Um objeto que contém o valor do parâmetro <ph id="ph1">&lt;paramref name="value" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1062" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Implicit(System.SByte)~System.Numerics.BigInteger">
          <source>For languages that do not support implicit operators, the alternative method is <ph id="ph1">&lt;xref:System.Numerics.BigInteger.%23ctor%28System.Int32%29?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Para idiomas que não dão suporte a operadores implícita, o método alternativo é <ph id="ph1">&lt;xref:System.Numerics.BigInteger.%23ctor%28System.Int32%29?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1063" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Implicit(System.SByte)~System.Numerics.BigInteger">
          <source>The overloads of the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger&gt;</ph> method define the types to which or from which a compiler can automatically convert a <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> value without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</source>
          <target state="translated">As sobrecargas do <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger&gt;</ph> método definem os tipos de qual ou para que um compilador pode converter automaticamente um <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> valor sem um operador de conversão explícita (em c#) ou uma chamada para uma função de conversão (no Visual Basic).</target>       </trans-unit>
        <trans-unit id="1064" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Implicit(System.SByte)~System.Numerics.BigInteger">
          <source>They are widening conversions that do not involve data loss and do not throw an <ph id="ph1">&lt;xref:System.OverflowException&gt;</ph>.</source>
          <target state="translated">Eles são widening conversões que não envolvem a perda de dados e não gerará uma <ph id="ph1">&lt;xref:System.OverflowException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1065" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Implicit(System.SByte)~System.Numerics.BigInteger">
          <source>This overload lets the compiler handle conversions from a <ph id="ph1">&lt;xref:System.SByte&gt;</ph> value to a <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> value, as the following example shows.</source>
          <target state="translated">Essa sobrecarga permite que o compilador trate conversões de um <ph id="ph1">&lt;xref:System.SByte&gt;</ph> valor para um <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> valor, como mostra o exemplo a seguir.</target>       </trans-unit>
        <trans-unit id="1066" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Implicit(System.UInt16)~System.Numerics.BigInteger">
          <source>The value to convert to a <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph>.</source>
          <target state="translated">O valor a ser convertido para um <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1067" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Implicit(System.UInt16)~System.Numerics.BigInteger">
          <source>Defines an implicit conversion of a 16-bit unsigned integer to a <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> value.</source>
          <target state="translated">Define uma conversão implícita de um inteiro sem sinal de 16 bits em um valor <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1068" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Implicit(System.UInt16)~System.Numerics.BigInteger">
          <source>This API is not CLS-compliant.</source>
          <target state="translated">Esta API não compatível com CLS.</target>       </trans-unit>
        <trans-unit id="1069" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Implicit(System.UInt16)~System.Numerics.BigInteger">
          <source>The compliant alternative is <ph id="ph1">&lt;see cref="M:System.Numerics.BigInteger.op_Implicit(System.Int32)~System.Numerics.BigInteger" /&gt;</ph>.</source>
          <target state="translated">A alternativa em conformidade é <ph id="ph1">&lt;see cref="M:System.Numerics.BigInteger.op_Implicit(System.Int32)~System.Numerics.BigInteger" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1070" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Implicit(System.UInt16)~System.Numerics.BigInteger">
          <source>An object that contains the value of the <ph id="ph1">&lt;paramref name="value" /&gt;</ph> parameter.</source>
          <target state="translated">Um objeto que contém o valor do parâmetro <ph id="ph1">&lt;paramref name="value" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1071" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Implicit(System.UInt16)~System.Numerics.BigInteger">
          <source>For languages that do not support implicit operators, the alternative method is <ph id="ph1">&lt;xref:System.Numerics.BigInteger.%23ctor%28System.UInt32%29?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Para idiomas que não dão suporte a operadores implícita, o método alternativo é <ph id="ph1">&lt;xref:System.Numerics.BigInteger.%23ctor%28System.UInt32%29?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1072" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Implicit(System.UInt16)~System.Numerics.BigInteger">
          <source>The overloads of the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger&gt;</ph> method define the types to which or from which a compiler can automatically convert a <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> value without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</source>
          <target state="translated">As sobrecargas do <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger&gt;</ph> método definem os tipos de qual ou para que um compilador pode converter automaticamente um <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> valor sem um operador de conversão explícita (em c#) ou uma chamada para uma função de conversão (no Visual Basic).</target>       </trans-unit>
        <trans-unit id="1073" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Implicit(System.UInt16)~System.Numerics.BigInteger">
          <source>They are widening conversions that do not involve data loss and do not throw an <ph id="ph1">&lt;xref:System.OverflowException&gt;</ph>.</source>
          <target state="translated">Eles são widening conversões que não envolvem a perda de dados e não gerará uma <ph id="ph1">&lt;xref:System.OverflowException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1074" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Implicit(System.UInt16)~System.Numerics.BigInteger">
          <source>This overload lets the compiler handle conversions from a <ph id="ph1">&lt;xref:System.UInt16&gt;</ph> value to a <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> value, as the following example shows.</source>
          <target state="translated">Essa sobrecarga permite que o compilador trate conversões de um <ph id="ph1">&lt;xref:System.UInt16&gt;</ph> valor para um <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> valor, como mostra o exemplo a seguir.</target>       </trans-unit>
        <trans-unit id="1075" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Implicit(System.UInt32)~System.Numerics.BigInteger">
          <source>The value to convert to a <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph>.</source>
          <target state="translated">O valor a ser convertido para um <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1076" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Implicit(System.UInt32)~System.Numerics.BigInteger">
          <source>Defines an implicit conversion of a 32-bit unsigned integer to a <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> value.</source>
          <target state="translated">Define uma conversão implícita de um inteiro sem sinal de 32 bits em um valor <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1077" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Implicit(System.UInt32)~System.Numerics.BigInteger">
          <source>This API is not CLS-compliant.</source>
          <target state="translated">Esta API não compatível com CLS.</target>       </trans-unit>
        <trans-unit id="1078" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Implicit(System.UInt32)~System.Numerics.BigInteger">
          <source>The compliant alternative is <ph id="ph1">&lt;see cref="M:System.Numerics.BigInteger.op_Implicit(System.Int64)~System.Numerics.BigInteger" /&gt;</ph>.</source>
          <target state="translated">A alternativa em conformidade é <ph id="ph1">&lt;see cref="M:System.Numerics.BigInteger.op_Implicit(System.Int64)~System.Numerics.BigInteger" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1079" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Implicit(System.UInt32)~System.Numerics.BigInteger">
          <source>An object that contains the value of the <ph id="ph1">&lt;paramref name="value" /&gt;</ph> parameter.</source>
          <target state="translated">Um objeto que contém o valor do parâmetro <ph id="ph1">&lt;paramref name="value" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1080" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Implicit(System.UInt32)~System.Numerics.BigInteger">
          <source>For languages that do not support implicit operators, the alternative method is <ph id="ph1">&lt;xref:System.Numerics.BigInteger.%23ctor%28System.UInt32%29?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Para idiomas que não dão suporte a operadores implícita, o método alternativo é <ph id="ph1">&lt;xref:System.Numerics.BigInteger.%23ctor%28System.UInt32%29?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1081" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Implicit(System.UInt32)~System.Numerics.BigInteger">
          <source>The overloads of the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger&gt;</ph> method define the types to which or from which a compiler can automatically convert a <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> value without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</source>
          <target state="translated">As sobrecargas do <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger&gt;</ph> método definem os tipos de qual ou para que um compilador pode converter automaticamente um <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> valor sem um operador de conversão explícita (em c#) ou uma chamada para uma função de conversão (no Visual Basic).</target>       </trans-unit>
        <trans-unit id="1082" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Implicit(System.UInt32)~System.Numerics.BigInteger">
          <source>They are widening conversions that do not involve data loss and do not throw an <ph id="ph1">&lt;xref:System.OverflowException&gt;</ph>.</source>
          <target state="translated">Eles são widening conversões que não envolvem a perda de dados e não gerará uma <ph id="ph1">&lt;xref:System.OverflowException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1083" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Implicit(System.UInt32)~System.Numerics.BigInteger">
          <source>This overload lets the compiler handle conversions from a <ph id="ph1">&lt;xref:System.UInt32&gt;</ph> value to a <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> value, as the following example shows.</source>
          <target state="translated">Essa sobrecarga permite que o compilador trate conversões de um <ph id="ph1">&lt;xref:System.UInt32&gt;</ph> valor para um <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> valor, como mostra o exemplo a seguir.</target>       </trans-unit>
        <trans-unit id="1084" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Implicit(System.UInt64)~System.Numerics.BigInteger">
          <source>The value to convert to a <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph>.</source>
          <target state="translated">O valor a ser convertido para um <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1085" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Implicit(System.UInt64)~System.Numerics.BigInteger">
          <source>Defines an implicit conversion of a 64-bit unsigned integer to a <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> value.</source>
          <target state="translated">Define uma conversão implícita de um inteiro sem sinal de 64 bits em um valor <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1086" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Implicit(System.UInt64)~System.Numerics.BigInteger">
          <source>This API is not CLS-compliant.</source>
          <target state="translated">Esta API não compatível com CLS.</target>       </trans-unit>
        <trans-unit id="1087" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Implicit(System.UInt64)~System.Numerics.BigInteger">
          <source>The compliant alternative is <ph id="ph1">&lt;see cref="T:System.Double" /&gt;</ph>.</source>
          <target state="translated">A alternativa em conformidade é <ph id="ph1">&lt;see cref="T:System.Double" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1088" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Implicit(System.UInt64)~System.Numerics.BigInteger">
          <source>An object that contains the value of the <ph id="ph1">&lt;paramref name="value" /&gt;</ph> parameter.</source>
          <target state="translated">Um objeto que contém o valor do parâmetro <ph id="ph1">&lt;paramref name="value" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1089" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Implicit(System.UInt64)~System.Numerics.BigInteger">
          <source>For languages that do not support implicit operators, the alternative method is <ph id="ph1">&lt;xref:System.Numerics.BigInteger.%23ctor%28System.UInt64%29?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Para idiomas que não dão suporte a operadores implícita, o método alternativo é <ph id="ph1">&lt;xref:System.Numerics.BigInteger.%23ctor%28System.UInt64%29?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1090" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Implicit(System.UInt64)~System.Numerics.BigInteger">
          <source>The overloads of the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger&gt;</ph> method define the types to which or from which a compiler can automatically convert a <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> value without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</source>
          <target state="translated">As sobrecargas do <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger&gt;</ph> método definem os tipos de qual ou para que um compilador pode converter automaticamente um <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> valor sem um operador de conversão explícita (em c#) ou uma chamada para uma função de conversão (no Visual Basic).</target>       </trans-unit>
        <trans-unit id="1091" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Implicit(System.UInt64)~System.Numerics.BigInteger">
          <source>They are widening conversions that do not involve data loss and do not throw an <ph id="ph1">&lt;xref:System.OverflowException&gt;</ph>.</source>
          <target state="translated">Eles são widening conversões que não envolvem a perda de dados e não gerará uma <ph id="ph1">&lt;xref:System.OverflowException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1092" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Implicit(System.UInt64)~System.Numerics.BigInteger">
          <source>This overload lets the compiler handle conversions from a <ph id="ph1">&lt;xref:System.UInt64&gt;</ph> value to a <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> value, as the following example shows.</source>
          <target state="translated">Essa sobrecarga permite que o compilador trate conversões de um <ph id="ph1">&lt;xref:System.UInt64&gt;</ph> valor para um <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> valor, como mostra o exemplo a seguir.</target>       </trans-unit>
        <trans-unit id="1093" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Increment(System.Numerics.BigInteger)">
          <source>The value to increment.</source>
          <target state="translated">O valor a ser incrementado.</target>       </trans-unit>
        <trans-unit id="1094" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Increment(System.Numerics.BigInteger)">
          <source>Increments a <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> value by 1.</source>
          <target state="translated">Incrementa um valor <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> em 1.</target>       </trans-unit>
        <trans-unit id="1095" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Increment(System.Numerics.BigInteger)">
          <source>The value of the <ph id="ph1">&lt;paramref name="value" /&gt;</ph> parameter incremented by 1.</source>
          <target state="translated">O valor do parâmetro <ph id="ph1">&lt;paramref name="value" /&gt;</ph> incrementado em 1.</target>       </trans-unit>
        <trans-unit id="1096" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Increment(System.Numerics.BigInteger)">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_Increment%2A&gt;</ph> method defines the increment operation for <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> values.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_Increment%2A&gt;</ph> método define a operação de incremento para <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> valores.</target>       </trans-unit>
        <trans-unit id="1097" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Increment(System.Numerics.BigInteger)">
          <source>It enables code such as the following:</source>
          <target state="translated">Ele permite que o código seja o seguinte:</target>       </trans-unit>
        <trans-unit id="1098" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Increment(System.Numerics.BigInteger)">
          <source>Some languages (such as Visual Basic) that lack an increment operator or do not support operator overloading can call the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_Increment%2A&gt;</ph> method directly, as the following example shows.</source>
          <target state="translated">Alguns idiomas (como o Visual Basic) que não têm um operador de incremento ou não oferecem suporte a sobrecarga de operador podem chamar o <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_Increment%2A&gt;</ph> método diretamente, como o exemplo a seguir mostra.</target>       </trans-unit>
        <trans-unit id="1099" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Increment(System.Numerics.BigInteger)">
          <source>Because <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> objects are immutable, the <ph id="ph2">&lt;xref:System.Numerics.BigInteger.op_Increment%2A&gt;</ph> operator creates a new <ph id="ph3">&lt;xref:System.Numerics.BigInteger&gt;</ph> object whose value is one more than the <ph id="ph4">&lt;xref:System.Numerics.BigInteger&gt;</ph> object represented by <ph id="ph5">`value`</ph>.</source>
          <target state="translated">Porque <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> objetos são imutáveis, a <ph id="ph2">&lt;xref:System.Numerics.BigInteger.op_Increment%2A&gt;</ph> operador cria um novo <ph id="ph3">&lt;xref:System.Numerics.BigInteger&gt;</ph> objeto cujo valor é um mais do que o <ph id="ph4">&lt;xref:System.Numerics.BigInteger&gt;</ph> objeto representado pelo <ph id="ph5">`value`</ph>.</target>       </trans-unit>
        <trans-unit id="1100" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Increment(System.Numerics.BigInteger)">
          <source>Therefore, repeated calls to <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_Increment%2A&gt;</ph> may be expensive.</source>
          <target state="translated">Portanto, repetidas chamadas para <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_Increment%2A&gt;</ph> pode ser cara.</target>       </trans-unit>
        <trans-unit id="1101" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Increment(System.Numerics.BigInteger)">
          <source>The equivalent method for this operator is <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Add%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">O método equivalente para esse operador é <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Add%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1102" translate="yes" xml:space="preserve" uid="T:System.Numerics.BigInteger">
          <source>Returns a value that indicates whether two numeric values are not equal.</source>
          <target state="translated">Retorna um valor que indica se dois valores numéricos não são iguais.</target>       </trans-unit>
        <trans-unit id="1103" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Inequality(System.Int64,System.Numerics.BigInteger)">
          <source>The first value to compare.</source>
          <target state="translated">O primeiro valor a ser comparado.</target>       </trans-unit>
        <trans-unit id="1104" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Inequality(System.Int64,System.Numerics.BigInteger)">
          <source>The second value to compare.</source>
          <target state="translated">O segundo valor a ser comparado.</target>       </trans-unit>
        <trans-unit id="1105" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Inequality(System.Int64,System.Numerics.BigInteger)">
          <source>Returns a value that indicates whether a 64-bit signed integer and a <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> value are not equal.</source>
          <target state="translated">Retorna um valor que indica se um inteiro com sinal de 64 bits e um valor <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> não são iguais.</target>       </trans-unit>
        <trans-unit id="1106" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Inequality(System.Int64,System.Numerics.BigInteger)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="left" /&gt;</ph> and <ph id="ph3">&lt;paramref name="right" /&gt;</ph> are not equal; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se <ph id="ph2">&lt;paramref name="left" /&gt;</ph> e <ph id="ph3">&lt;paramref name="right" /&gt;</ph> não forem iguais; caso contrário, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1107" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Inequality(System.Int64,System.Numerics.BigInteger)">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_Inequality%2A&gt;</ph> method defines the operation of the inequality operator for <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> values.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_Inequality%2A&gt;</ph> método define a operação do operador de desigualdade para <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> valores.</target>       </trans-unit>
        <trans-unit id="1108" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Inequality(System.Int64,System.Numerics.BigInteger)">
          <source>It enables code such as the following:</source>
          <target state="translated">Ele permite que o código seja o seguinte:</target>       </trans-unit>
        <trans-unit id="1109" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Inequality(System.Int64,System.Numerics.BigInteger)">
          <source>Languages that do not support custom operators can test for inequality by using one of the following techniques:</source>
          <target state="translated">Idiomas que dão suporte a operadores personalizados podem testar desigualdade usando uma das seguintes técnicas:</target>       </trans-unit>
        <trans-unit id="1110" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Inequality(System.Int64,System.Numerics.BigInteger)">
          <source>Calling the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType&gt;</ph> instance method, which indicates the relationship between a <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> and a signed long integer value.</source>
          <target state="translated">Chamando o <ph id="ph1">&lt;xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType&gt;</ph> instância de método, que indica a relação entre um <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> e um valor inteiro longo.</target>       </trans-unit>
        <trans-unit id="1111" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Inequality(System.Int64,System.Numerics.BigInteger)">
          <source>Calling the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType&gt;</ph> instance method and reversing its value.</source>
          <target state="translated">Chamando o <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType&gt;</ph> da instância de método e Revertendo seu valor.</target>       </trans-unit>
        <trans-unit id="1112" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Inequality(System.Int64,System.Numerics.BigInteger)">
          <source>If <ph id="ph1">`left`</ph> is a <ph id="ph2">&lt;xref:System.Byte&gt;</ph>, <ph id="ph3">&lt;xref:System.Int16&gt;</ph>, <ph id="ph4">&lt;xref:System.Int32&gt;</ph>, <ph id="ph5">&lt;xref:System.SByte&gt;</ph>, <ph id="ph6">&lt;xref:System.UInt16&gt;</ph>, or <ph id="ph7">&lt;xref:System.UInt32&gt;</ph> value, it is implicitly converted to an <ph id="ph8">&lt;xref:System.Int64&gt;</ph> value when the operation is performed.</source>
          <target state="translated">Se <ph id="ph1">`left`</ph> é um <ph id="ph2">&lt;xref:System.Byte&gt;</ph>, <ph id="ph3">&lt;xref:System.Int16&gt;</ph>, <ph id="ph4">&lt;xref:System.Int32&gt;</ph>, <ph id="ph5">&lt;xref:System.SByte&gt;</ph>, <ph id="ph6">&lt;xref:System.UInt16&gt;</ph>, ou <ph id="ph7">&lt;xref:System.UInt32&gt;</ph> valor, ele é convertido implicitamente em um <ph id="ph8">&lt;xref:System.Int64&gt;</ph> valor quando a operação é executada.</target>       </trans-unit>
        <trans-unit id="1113" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Inequality(System.Numerics.BigInteger,System.Int64)">
          <source>The first value to compare.</source>
          <target state="translated">O primeiro valor a ser comparado.</target>       </trans-unit>
        <trans-unit id="1114" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Inequality(System.Numerics.BigInteger,System.Int64)">
          <source>The second value to compare.</source>
          <target state="translated">O segundo valor a ser comparado.</target>       </trans-unit>
        <trans-unit id="1115" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Inequality(System.Numerics.BigInteger,System.Int64)">
          <source>Returns a value that indicates whether a <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> value and a 64-bit signed integer are not equal.</source>
          <target state="translated">Retorna um valor que indica se um valor <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> e um inteiro com sinal de 64 bits não são iguais.</target>       </trans-unit>
        <trans-unit id="1116" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Inequality(System.Numerics.BigInteger,System.Int64)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="left" /&gt;</ph> and <ph id="ph3">&lt;paramref name="right" /&gt;</ph> are not equal; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se <ph id="ph2">&lt;paramref name="left" /&gt;</ph> e <ph id="ph3">&lt;paramref name="right" /&gt;</ph> não forem iguais; caso contrário, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1117" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Inequality(System.Numerics.BigInteger,System.Int64)">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_Inequality%2A&gt;</ph> method defines the operation of the inequality operator for <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> values.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_Inequality%2A&gt;</ph> método define a operação do operador de desigualdade para <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> valores.</target>       </trans-unit>
        <trans-unit id="1118" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Inequality(System.Numerics.BigInteger,System.Int64)">
          <source>It enables code such as the following:</source>
          <target state="translated">Ele permite que o código seja o seguinte:</target>       </trans-unit>
        <trans-unit id="1119" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Inequality(System.Numerics.BigInteger,System.Int64)">
          <source>Languages that do not support custom operators can test for inequality by using one of the following techniques:</source>
          <target state="translated">Idiomas que dão suporte a operadores personalizados podem testar desigualdade usando uma das seguintes técnicas:</target>       </trans-unit>
        <trans-unit id="1120" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Inequality(System.Numerics.BigInteger,System.Int64)">
          <source>Calling the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType&gt;</ph> method, which indicates the relationship between a <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> and a signed long integer value.</source>
          <target state="translated">Chamando o <ph id="ph1">&lt;xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType&gt;</ph> método, que indica a relação entre um <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> e um valor inteiro longo.</target>       </trans-unit>
        <trans-unit id="1121" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Inequality(System.Numerics.BigInteger,System.Int64)">
          <source>Calling the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType&gt;</ph> method and reversing its value.</source>
          <target state="translated">Chamar o <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType&gt;</ph> método e a reversão de seu valor.</target>       </trans-unit>
        <trans-unit id="1122" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Inequality(System.Numerics.BigInteger,System.Int64)">
          <source>If <ph id="ph1">`right`</ph> is a <ph id="ph2">&lt;xref:System.Byte&gt;</ph>, <ph id="ph3">&lt;xref:System.Int16&gt;</ph>, <ph id="ph4">&lt;xref:System.Int32&gt;</ph>, <ph id="ph5">&lt;xref:System.SByte&gt;</ph>, <ph id="ph6">&lt;xref:System.UInt16&gt;</ph>, or <ph id="ph7">&lt;xref:System.UInt32&gt;</ph> value, it is implicitly converted to an <ph id="ph8">&lt;xref:System.Int64&gt;</ph> value when the operation is performed.</source>
          <target state="translated">Se <ph id="ph1">`right`</ph> é um <ph id="ph2">&lt;xref:System.Byte&gt;</ph>, <ph id="ph3">&lt;xref:System.Int16&gt;</ph>, <ph id="ph4">&lt;xref:System.Int32&gt;</ph>, <ph id="ph5">&lt;xref:System.SByte&gt;</ph>, <ph id="ph6">&lt;xref:System.UInt16&gt;</ph>, ou <ph id="ph7">&lt;xref:System.UInt32&gt;</ph> valor, ele é convertido implicitamente em um <ph id="ph8">&lt;xref:System.Int64&gt;</ph> valor quando a operação é executada.</target>       </trans-unit>
        <trans-unit id="1123" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Inequality(System.Numerics.BigInteger,System.Int64)">
          <source>The equivalent method for this operator is <ph id="ph1">&lt;xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">O método equivalente para esse operador é <ph id="ph1">&lt;xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1124" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Inequality(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>The first value to compare.</source>
          <target state="translated">O primeiro valor a ser comparado.</target>       </trans-unit>
        <trans-unit id="1125" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Inequality(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>The second value to compare.</source>
          <target state="translated">O segundo valor a ser comparado.</target>       </trans-unit>
        <trans-unit id="1126" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Inequality(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>Returns a value that indicates whether two <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> objects have different values.</source>
          <target state="translated">Retorna um valor que indica se dois objetos <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> têm valores diferentes.</target>       </trans-unit>
        <trans-unit id="1127" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Inequality(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="left" /&gt;</ph> and <ph id="ph3">&lt;paramref name="right" /&gt;</ph> are not equal; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se <ph id="ph2">&lt;paramref name="left" /&gt;</ph> e <ph id="ph3">&lt;paramref name="right" /&gt;</ph> não forem iguais; caso contrário, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1128" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Inequality(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_Inequality%2A&gt;</ph> method defines the operation of the inequality operator for <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> values.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_Inequality%2A&gt;</ph> método define a operação do operador de desigualdade para <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> valores.</target>       </trans-unit>
        <trans-unit id="1129" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Inequality(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>It enables code such as the following:</source>
          <target state="translated">Ele permite que o código seja o seguinte:</target>       </trans-unit>
        <trans-unit id="1130" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Inequality(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>Languages that do not support custom operators can test for inequality by using one of the following techniques:</source>
          <target state="translated">Idiomas que dão suporte a operadores personalizados podem testar desigualdade usando uma das seguintes técnicas:</target>       </trans-unit>
        <trans-unit id="1131" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Inequality(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>Calling the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Compare%2A?displayProperty=nameWithType&gt;</ph> method, which indicates the relationship between two <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> objects.</source>
          <target state="translated">Chamando o <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Compare%2A?displayProperty=nameWithType&gt;</ph> método, que indica a relação entre duas <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> objetos.</target>       </trans-unit>
        <trans-unit id="1132" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Inequality(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>Calling the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Equals%28System.Numerics.BigInteger%29?displayProperty=nameWithType&gt;</ph> method and reversing its value.</source>
          <target state="translated">Chamar o <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Equals%28System.Numerics.BigInteger%29?displayProperty=nameWithType&gt;</ph> método e a reversão de seu valor.</target>       </trans-unit>
        <trans-unit id="1133" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Inequality(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>The equivalent method for this operator is <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Compare%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">O método equivalente para esse operador é <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Compare%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1134" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Inequality(System.Numerics.BigInteger,System.UInt64)">
          <source>The first value to compare.</source>
          <target state="translated">O primeiro valor a ser comparado.</target>       </trans-unit>
        <trans-unit id="1135" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Inequality(System.Numerics.BigInteger,System.UInt64)">
          <source>The second value to compare.</source>
          <target state="translated">O segundo valor a ser comparado.</target>       </trans-unit>
        <trans-unit id="1136" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Inequality(System.Numerics.BigInteger,System.UInt64)">
          <source>Returns a value that indicates whether a <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> value and a 64-bit unsigned integer are not equal.</source>
          <target state="translated">Retorna um valor que indica se um valor <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> e um inteiro sem sinal de 64 bits não são iguais.</target>       </trans-unit>
        <trans-unit id="1137" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Inequality(System.Numerics.BigInteger,System.UInt64)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="left" /&gt;</ph> and <ph id="ph3">&lt;paramref name="right" /&gt;</ph> are not equal; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se <ph id="ph2">&lt;paramref name="left" /&gt;</ph> e <ph id="ph3">&lt;paramref name="right" /&gt;</ph> não forem iguais; caso contrário, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1138" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Inequality(System.Numerics.BigInteger,System.UInt64)">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_Inequality%2A&gt;</ph> method defines the operation of the inequality operator for <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> values.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_Inequality%2A&gt;</ph> método define a operação do operador de desigualdade para <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> valores.</target>       </trans-unit>
        <trans-unit id="1139" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Inequality(System.Numerics.BigInteger,System.UInt64)">
          <source>It enables code such as the following:</source>
          <target state="translated">Ele permite que o código seja o seguinte:</target>       </trans-unit>
        <trans-unit id="1140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Inequality(System.Numerics.BigInteger,System.UInt64)">
          <source>Languages that do not support custom operators can test for inequality by using one of the following techniques:</source>
          <target state="translated">Idiomas que dão suporte a operadores personalizados podem testar desigualdade usando uma das seguintes técnicas:</target>       </trans-unit>
        <trans-unit id="1141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Inequality(System.Numerics.BigInteger,System.UInt64)">
          <source>Calling the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType&gt;</ph> method, which indicates the relationship between a <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> and an unsigned long integer value.</source>
          <target state="translated">Chamando o <ph id="ph1">&lt;xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType&gt;</ph> método, que indica a relação entre um <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> e um valor inteiro longo não assinado.</target>       </trans-unit>
        <trans-unit id="1142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Inequality(System.Numerics.BigInteger,System.UInt64)">
          <source>Calling the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Equals%28System.UInt64%29?displayProperty=nameWithType&gt;</ph> method and reversing its value.</source>
          <target state="translated">Chamar o <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Equals%28System.UInt64%29?displayProperty=nameWithType&gt;</ph> método e a reversão de seu valor.</target>       </trans-unit>
        <trans-unit id="1143" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Inequality(System.UInt64,System.Numerics.BigInteger)">
          <source>The first value to compare.</source>
          <target state="translated">O primeiro valor a ser comparado.</target>       </trans-unit>
        <trans-unit id="1144" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Inequality(System.UInt64,System.Numerics.BigInteger)">
          <source>The second value to compare.</source>
          <target state="translated">O segundo valor a ser comparado.</target>       </trans-unit>
        <trans-unit id="1145" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Inequality(System.UInt64,System.Numerics.BigInteger)">
          <source>Returns a value that indicates whether a 64-bit unsigned integer and a <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> value are not equal.</source>
          <target state="translated">Retorna um valor que indica se um inteiro sem sinal de 64 bits e um valor <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> não são iguais.</target>       </trans-unit>
        <trans-unit id="1146" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Inequality(System.UInt64,System.Numerics.BigInteger)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="left" /&gt;</ph> and <ph id="ph3">&lt;paramref name="right" /&gt;</ph> are not equal; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se <ph id="ph2">&lt;paramref name="left" /&gt;</ph> e <ph id="ph3">&lt;paramref name="right" /&gt;</ph> não forem iguais; caso contrário, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Inequality(System.UInt64,System.Numerics.BigInteger)">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_Inequality%2A&gt;</ph> method defines the operation of the inequality operator for <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> values.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_Inequality%2A&gt;</ph> método define a operação do operador de desigualdade para <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> valores.</target>       </trans-unit>
        <trans-unit id="1148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Inequality(System.UInt64,System.Numerics.BigInteger)">
          <source>It enables code such as the following:</source>
          <target state="translated">Ele permite que o código seja o seguinte:</target>       </trans-unit>
        <trans-unit id="1149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Inequality(System.UInt64,System.Numerics.BigInteger)">
          <source>Languages that do not support custom operators can test for inequality by using one of the following techniques:</source>
          <target state="translated">Idiomas que dão suporte a operadores personalizados podem testar desigualdade usando uma das seguintes técnicas:</target>       </trans-unit>
        <trans-unit id="1150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Inequality(System.UInt64,System.Numerics.BigInteger)">
          <source>Calling the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType&gt;</ph> method, which indicates the relationship between a <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> and an unsigned long integer value.</source>
          <target state="translated">Chamando o <ph id="ph1">&lt;xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType&gt;</ph> método, que indica a relação entre um <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> e um valor inteiro longo não assinado.</target>       </trans-unit>
        <trans-unit id="1151" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Inequality(System.UInt64,System.Numerics.BigInteger)">
          <source>Calling the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Equals%28System.UInt64%29?displayProperty=nameWithType&gt;</ph> method and reversing its value.</source>
          <target state="translated">Chamar o <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Equals%28System.UInt64%29?displayProperty=nameWithType&gt;</ph> método e a reversão de seu valor.</target>       </trans-unit>
        <trans-unit id="1152" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_LeftShift(System.Numerics.BigInteger,System.Int32)">
          <source>The value whose bits are to be shifted.</source>
          <target state="translated">O valor cujos bits devem ser deslocados.</target>       </trans-unit>
        <trans-unit id="1153" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_LeftShift(System.Numerics.BigInteger,System.Int32)">
          <source>The number of bits to shift <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept> to the left.</source>
          <target state="translated">O número de bits a deslocar <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept> para a esquerda.</target>       </trans-unit>
        <trans-unit id="1154" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_LeftShift(System.Numerics.BigInteger,System.Int32)">
          <source>Shifts a <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> value a specified number of bits to the left.</source>
          <target state="translated">Desloca um valor <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> um número especificado de bits para a esquerda.</target>       </trans-unit>
        <trans-unit id="1155" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_LeftShift(System.Numerics.BigInteger,System.Int32)">
          <source>A value that has been shifted to the left by the specified number of bits.</source>
          <target state="translated">Um valor que foi sido deslocado para a esquerda pelo número especificado de bits.</target>       </trans-unit>
        <trans-unit id="1156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_LeftShift(System.Numerics.BigInteger,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_LeftShift%2A&gt;</ph> method defines the operation of the bitwise left-shift operator for <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> values.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_LeftShift%2A&gt;</ph> método define a operação do operador left shift bit a bit para <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> valores.</target>       </trans-unit>
        <trans-unit id="1157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_LeftShift(System.Numerics.BigInteger,System.Int32)">
          <source>It enables code such as the following:</source>
          <target state="translated">Ele permite que o código seja o seguinte:</target>       </trans-unit>
        <trans-unit id="1158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_LeftShift(System.Numerics.BigInteger,System.Int32)">
          <source>Unlike the bitwise left-shift operation with integer primitives, the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_LeftShift%2A&gt;</ph> method preserves the sign of the original <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> value.</source>
          <target state="translated">Ao contrário a operação left shift bit a bit com primitivos de inteiro, o <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_LeftShift%2A&gt;</ph> método preserva o sinal do original <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> valor.</target>       </trans-unit>
        <trans-unit id="1159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_LeftShift(System.Numerics.BigInteger,System.Int32)">
          <source>Languages that do not support custom operators can perform a bitwise left-shift operation by multiplying <ph id="ph1">`value`</ph> by <ph id="ph2">`BigInteger.Pow(2, shift)`</ph>.</source>
          <target state="translated">Idiomas que dão suporte a operadores personalizados podem executar uma operação bit a bit de deslocamento à esquerda multiplicando <ph id="ph1">`value`</ph> por <ph id="ph2">`BigInteger.Pow(2, shift)`</ph>.</target>       </trans-unit>
        <trans-unit id="1160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_LeftShift(System.Numerics.BigInteger,System.Int32)">
          <source>The following example shows that the results are identical to the results of using this operator.</source>
          <target state="translated">O exemplo a seguir mostra os resultados são idênticos para os resultados do uso desse operador.</target>       </trans-unit>
        <trans-unit id="1161" translate="yes" xml:space="preserve" uid="T:System.Numerics.BigInteger">
          <source>Returns a value that indicates whether a specified value is less than a second specified value.</source>
          <target state="translated">Retorna um valor que indica se um valor especificado é menor que um segundo valor especificado.</target>       </trans-unit>
        <trans-unit id="1162" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_LessThan(System.Int64,System.Numerics.BigInteger)">
          <source>The first value to compare.</source>
          <target state="translated">O primeiro valor a ser comparado.</target>       </trans-unit>
        <trans-unit id="1163" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_LessThan(System.Int64,System.Numerics.BigInteger)">
          <source>The second value to compare.</source>
          <target state="translated">O segundo valor a ser comparado.</target>       </trans-unit>
        <trans-unit id="1164" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_LessThan(System.Int64,System.Numerics.BigInteger)">
          <source>Returns a value that indicates whether a 64-bit signed integer is less than a <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> value.</source>
          <target state="translated">Retorna um valor que indica se um inteiro com sinal de 64 bits é menor que um valor <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1165" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_LessThan(System.Int64,System.Numerics.BigInteger)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="left" /&gt;</ph> is less than <ph id="ph3">&lt;paramref name="right" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> caso <ph id="ph2">&lt;paramref name="left" /&gt;</ph> seja menor que <ph id="ph3">&lt;paramref name="right" /&gt;</ph>; do contrário, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_LessThan(System.Int64,System.Numerics.BigInteger)">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_LessThan%2A&gt;</ph> method defines the operation of the less than operator for <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> values.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_LessThan%2A&gt;</ph> método define a operação pelo menor que o operador para <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> valores.</target>       </trans-unit>
        <trans-unit id="1167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_LessThan(System.Int64,System.Numerics.BigInteger)">
          <source>It enables code such as the following:</source>
          <target state="translated">Ele permite que o código seja o seguinte:</target>       </trans-unit>
        <trans-unit id="1168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_LessThan(System.Int64,System.Numerics.BigInteger)">
          <source>Languages that do not support custom operators can call the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType&gt;</ph> method instead.</source>
          <target state="translated">Linguagens que não dão suporte a operadores personalizados podem chamar o método <ph id="ph1">&lt;xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType&gt;</ph> em vez disso.</target>       </trans-unit>
        <trans-unit id="1169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_LessThan(System.Int64,System.Numerics.BigInteger)">
          <source>Some languages can also call the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_LessThan%28System.Int64%2CSystem.Numerics.BigInteger%29&gt;</ph> method directly, as the following example shows.</source>
          <target state="translated">Alguns idiomas também podem chamar o <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_LessThan%28System.Int64%2CSystem.Numerics.BigInteger%29&gt;</ph> método diretamente, como o exemplo a seguir mostra.</target>       </trans-unit>
        <trans-unit id="1170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_LessThan(System.Int64,System.Numerics.BigInteger)">
          <source>If <ph id="ph1">`left`</ph> is a <ph id="ph2">&lt;xref:System.Byte&gt;</ph>, <ph id="ph3">&lt;xref:System.Int16&gt;</ph>, <ph id="ph4">&lt;xref:System.Int32&gt;</ph>, <ph id="ph5">&lt;xref:System.SByte&gt;</ph>, <ph id="ph6">&lt;xref:System.UInt16&gt;</ph>, or <ph id="ph7">&lt;xref:System.UInt32&gt;</ph> value, it is implicitly converted to an <ph id="ph8">&lt;xref:System.Int64&gt;</ph> value when the operation is performed.</source>
          <target state="translated">Se <ph id="ph1">`left`</ph> é um <ph id="ph2">&lt;xref:System.Byte&gt;</ph>, <ph id="ph3">&lt;xref:System.Int16&gt;</ph>, <ph id="ph4">&lt;xref:System.Int32&gt;</ph>, <ph id="ph5">&lt;xref:System.SByte&gt;</ph>, <ph id="ph6">&lt;xref:System.UInt16&gt;</ph>, ou <ph id="ph7">&lt;xref:System.UInt32&gt;</ph> valor, ele é convertido implicitamente em um <ph id="ph8">&lt;xref:System.Int64&gt;</ph> valor quando a operação é executada.</target>       </trans-unit>
        <trans-unit id="1171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_LessThan(System.Int64,System.Numerics.BigInteger)">
          <source>The equivalent method for this operator is <ph id="ph1">&lt;xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">O método equivalente para esse operador é <ph id="ph1">&lt;xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1172" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_LessThan(System.Numerics.BigInteger,System.Int64)">
          <source>The first value to compare.</source>
          <target state="translated">O primeiro valor a ser comparado.</target>       </trans-unit>
        <trans-unit id="1173" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_LessThan(System.Numerics.BigInteger,System.Int64)">
          <source>The second value to compare.</source>
          <target state="translated">O segundo valor a ser comparado.</target>       </trans-unit>
        <trans-unit id="1174" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_LessThan(System.Numerics.BigInteger,System.Int64)">
          <source>Returns a value that indicates whether a <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> value is less than a 64-bit signed integer.</source>
          <target state="translated">Retorna um valor que indica se um valor <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> é menor que um inteiro com sinal de 64 bits.</target>       </trans-unit>
        <trans-unit id="1175" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_LessThan(System.Numerics.BigInteger,System.Int64)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="left" /&gt;</ph> is less than <ph id="ph3">&lt;paramref name="right" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> caso <ph id="ph2">&lt;paramref name="left" /&gt;</ph> seja menor que <ph id="ph3">&lt;paramref name="right" /&gt;</ph>; do contrário, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_LessThan(System.Numerics.BigInteger,System.Int64)">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_LessThan%2A&gt;</ph> method defines the operation of the less than operator for <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> values.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_LessThan%2A&gt;</ph> método define a operação pelo menor que o operador para <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> valores.</target>       </trans-unit>
        <trans-unit id="1177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_LessThan(System.Numerics.BigInteger,System.Int64)">
          <source>It enables code such as the following:</source>
          <target state="translated">Ele permite que o código seja o seguinte:</target>       </trans-unit>
        <trans-unit id="1178" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_LessThan(System.Numerics.BigInteger,System.Int64)">
          <source>Languages that do not support custom operators can call the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType&gt;</ph> method instead.</source>
          <target state="translated">Linguagens que não dão suporte a operadores personalizados podem chamar o método <ph id="ph1">&lt;xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType&gt;</ph> em vez disso.</target>       </trans-unit>
        <trans-unit id="1179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_LessThan(System.Numerics.BigInteger,System.Int64)">
          <source>Some languages can also call the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_LessThan%28System.Numerics.BigInteger%2CSystem.Int64%29&gt;</ph> method directly, as the following example shows.</source>
          <target state="translated">Alguns idiomas também podem chamar o <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_LessThan%28System.Numerics.BigInteger%2CSystem.Int64%29&gt;</ph> método diretamente, como o exemplo a seguir mostra.</target>       </trans-unit>
        <trans-unit id="1180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_LessThan(System.Numerics.BigInteger,System.Int64)">
          <source>If <ph id="ph1">`right`</ph> is a <ph id="ph2">&lt;xref:System.Byte&gt;</ph>, <ph id="ph3">&lt;xref:System.Int16&gt;</ph>, <ph id="ph4">&lt;xref:System.Int32&gt;</ph>, <ph id="ph5">&lt;xref:System.SByte&gt;</ph>, <ph id="ph6">&lt;xref:System.UInt16&gt;</ph>, or <ph id="ph7">&lt;xref:System.UInt32&gt;</ph> value, it is implicitly converted to an <ph id="ph8">&lt;xref:System.Int64&gt;</ph> value when the operation is performed.</source>
          <target state="translated">Se <ph id="ph1">`right`</ph> é um <ph id="ph2">&lt;xref:System.Byte&gt;</ph>, <ph id="ph3">&lt;xref:System.Int16&gt;</ph>, <ph id="ph4">&lt;xref:System.Int32&gt;</ph>, <ph id="ph5">&lt;xref:System.SByte&gt;</ph>, <ph id="ph6">&lt;xref:System.UInt16&gt;</ph>, ou <ph id="ph7">&lt;xref:System.UInt32&gt;</ph> valor, ele é convertido implicitamente em um <ph id="ph8">&lt;xref:System.Int64&gt;</ph> valor quando a operação é executada.</target>       </trans-unit>
        <trans-unit id="1181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_LessThan(System.Numerics.BigInteger,System.Int64)">
          <source>The equivalent method for this operator is <ph id="ph1">&lt;xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">O método equivalente para esse operador é <ph id="ph1">&lt;xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1182" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_LessThan(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>The first value to compare.</source>
          <target state="translated">O primeiro valor a ser comparado.</target>       </trans-unit>
        <trans-unit id="1183" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_LessThan(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>The second value to compare.</source>
          <target state="translated">O segundo valor a ser comparado.</target>       </trans-unit>
        <trans-unit id="1184" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_LessThan(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>Returns a value that indicates whether a <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> value is less than another <ph id="ph2">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> value.</source>
          <target state="translated">Retorna um valor que indica se um valor <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> é menor que outro valor <ph id="ph2">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1185" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_LessThan(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="left" /&gt;</ph> is less than <ph id="ph3">&lt;paramref name="right" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> caso <ph id="ph2">&lt;paramref name="left" /&gt;</ph> seja menor que <ph id="ph3">&lt;paramref name="right" /&gt;</ph>; do contrário, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_LessThan(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_LessThan%2A&gt;</ph> method defines the operation of the less than operator for <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> values.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_LessThan%2A&gt;</ph> método define a operação pelo menor que o operador para <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> valores.</target>       </trans-unit>
        <trans-unit id="1187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_LessThan(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>It enables code such as the following:</source>
          <target state="translated">Ele permite que o código seja o seguinte:</target>       </trans-unit>
        <trans-unit id="1188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_LessThan(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>Languages that do not support custom operators can call the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Compare%2A?displayProperty=nameWithType&gt;</ph> method instead.</source>
          <target state="translated">Linguagens que não dão suporte a operadores personalizados podem chamar o método <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Compare%2A?displayProperty=nameWithType&gt;</ph> em vez disso.</target>       </trans-unit>
        <trans-unit id="1189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_LessThan(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>Some languages can also call the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_LessThan%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29&gt;</ph> method directly, as the following example shows.</source>
          <target state="translated">Alguns idiomas também podem chamar o <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_LessThan%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29&gt;</ph> método diretamente, como o exemplo a seguir mostra.</target>       </trans-unit>
        <trans-unit id="1190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_LessThan(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>The equivalent method for this operator is <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Compare%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">O método equivalente para esse operador é <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Compare%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1191" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_LessThan(System.Numerics.BigInteger,System.UInt64)">
          <source>The first value to compare.</source>
          <target state="translated">O primeiro valor a ser comparado.</target>       </trans-unit>
        <trans-unit id="1192" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_LessThan(System.Numerics.BigInteger,System.UInt64)">
          <source>The second value to compare.</source>
          <target state="translated">O segundo valor a ser comparado.</target>       </trans-unit>
        <trans-unit id="1193" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_LessThan(System.Numerics.BigInteger,System.UInt64)">
          <source>Returns a value that indicates whether a <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> value is less than a 64-bit unsigned integer.</source>
          <target state="translated">Retorna um valor que indica se um valor <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> é menor que um inteiro sem sinal de 64 bits.</target>       </trans-unit>
        <trans-unit id="1194" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_LessThan(System.Numerics.BigInteger,System.UInt64)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="left" /&gt;</ph> is less than <ph id="ph3">&lt;paramref name="right" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> caso <ph id="ph2">&lt;paramref name="left" /&gt;</ph> seja menor que <ph id="ph3">&lt;paramref name="right" /&gt;</ph>; do contrário, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_LessThan(System.Numerics.BigInteger,System.UInt64)">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_LessThan%2A&gt;</ph> method defines the operation of the less than operator for <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> values.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_LessThan%2A&gt;</ph> método define a operação pelo menor que o operador para <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> valores.</target>       </trans-unit>
        <trans-unit id="1196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_LessThan(System.Numerics.BigInteger,System.UInt64)">
          <source>It enables code such as the following:</source>
          <target state="translated">Ele permite que o código seja o seguinte:</target>       </trans-unit>
        <trans-unit id="1197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_LessThan(System.Numerics.BigInteger,System.UInt64)">
          <source>Languages that do not support custom operators can call the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType&gt;</ph> method instead.</source>
          <target state="translated">Linguagens que não dão suporte a operadores personalizados podem chamar o método <ph id="ph1">&lt;xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType&gt;</ph> em vez disso.</target>       </trans-unit>
        <trans-unit id="1198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_LessThan(System.Numerics.BigInteger,System.UInt64)">
          <source>They can also call the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_LessThan%28System.Numerics.BigInteger%2CSystem.UInt64%29&gt;</ph> method directly, as the following example shows.</source>
          <target state="translated">Eles também podem chamar o <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_LessThan%28System.Numerics.BigInteger%2CSystem.UInt64%29&gt;</ph> método diretamente, como o exemplo a seguir mostra.</target>       </trans-unit>
        <trans-unit id="1199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_LessThan(System.Numerics.BigInteger,System.UInt64)">
          <source>The equivalent method for this operator is <ph id="ph1">&lt;xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">O método equivalente para esse operador é <ph id="ph1">&lt;xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1200" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_LessThan(System.UInt64,System.Numerics.BigInteger)">
          <source>The first value to compare.</source>
          <target state="translated">O primeiro valor a ser comparado.</target>       </trans-unit>
        <trans-unit id="1201" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_LessThan(System.UInt64,System.Numerics.BigInteger)">
          <source>The second value to compare.</source>
          <target state="translated">O segundo valor a ser comparado.</target>       </trans-unit>
        <trans-unit id="1202" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_LessThan(System.UInt64,System.Numerics.BigInteger)">
          <source>Returns a value that indicates whether a 64-bit unsigned integer is less than a <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> value.</source>
          <target state="translated">Retorna um valor que indica se um inteiro sem sinal de 64 bits é menor que um valor <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1203" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_LessThan(System.UInt64,System.Numerics.BigInteger)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="left" /&gt;</ph> is less than <ph id="ph3">&lt;paramref name="right" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> caso <ph id="ph2">&lt;paramref name="left" /&gt;</ph> seja menor que <ph id="ph3">&lt;paramref name="right" /&gt;</ph>; do contrário, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_LessThan(System.UInt64,System.Numerics.BigInteger)">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_LessThan%2A&gt;</ph> method defines the operation of the less than operator for <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> values.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_LessThan%2A&gt;</ph> método define a operação pelo menor que o operador para <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> valores.</target>       </trans-unit>
        <trans-unit id="1205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_LessThan(System.UInt64,System.Numerics.BigInteger)">
          <source>It enables code such as the following:</source>
          <target state="translated">Ele permite que o código seja o seguinte:</target>       </trans-unit>
        <trans-unit id="1206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_LessThan(System.UInt64,System.Numerics.BigInteger)">
          <source>Languages that do not support custom operators can call the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType&gt;</ph> method instead.</source>
          <target state="translated">Linguagens que não dão suporte a operadores personalizados podem chamar o método <ph id="ph1">&lt;xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType&gt;</ph> em vez disso.</target>       </trans-unit>
        <trans-unit id="1207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_LessThan(System.UInt64,System.Numerics.BigInteger)">
          <source>They can also call the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_LessThan%28System.UInt64%2CSystem.Numerics.BigInteger%29&gt;</ph> method directly, as the following example shows.</source>
          <target state="translated">Eles também podem chamar o <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_LessThan%28System.UInt64%2CSystem.Numerics.BigInteger%29&gt;</ph> método diretamente, como o exemplo a seguir mostra.</target>       </trans-unit>
        <trans-unit id="1208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_LessThan(System.UInt64,System.Numerics.BigInteger)">
          <source>The equivalent method for this operator is <ph id="ph1">&lt;xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">O método equivalente para esse operador é <ph id="ph1">&lt;xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1209" translate="yes" xml:space="preserve" uid="T:System.Numerics.BigInteger">
          <source>Returns a value that indicates whether a specified value is less than or equal to another specified value.</source>
          <target state="translated">Retorna um valor que indica se um valor especificado é menor ou igual a outro valor especificado.</target>       </trans-unit>
        <trans-unit id="1210" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.Int64,System.Numerics.BigInteger)">
          <source>The first value to compare.</source>
          <target state="translated">O primeiro valor a ser comparado.</target>       </trans-unit>
        <trans-unit id="1211" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.Int64,System.Numerics.BigInteger)">
          <source>The second value to compare.</source>
          <target state="translated">O segundo valor a ser comparado.</target>       </trans-unit>
        <trans-unit id="1212" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.Int64,System.Numerics.BigInteger)">
          <source>Returns a value that indicates whether a 64-bit signed integer is less than or equal to a <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> value.</source>
          <target state="translated">Retorna um valor que indica se um inteiro com sinal de 64 bits é menor ou igual a um valor <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1213" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.Int64,System.Numerics.BigInteger)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="left" /&gt;</ph> is less than or equal to <ph id="ph3">&lt;paramref name="right" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se <ph id="ph2">&lt;paramref name="left" /&gt;</ph> for menor ou igual a <ph id="ph3">&lt;paramref name="right" /&gt;</ph>; caso contrário, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1214" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.Int64,System.Numerics.BigInteger)">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_LessThanOrEqual%2A&gt;</ph> method defines the operation of the less than or equal to operator for <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> values.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_LessThanOrEqual%2A&gt;</ph> método define a operação de menor que ou igual ao operador para <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> valores.</target>       </trans-unit>
        <trans-unit id="1215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.Int64,System.Numerics.BigInteger)">
          <source>It enables code such as the following:</source>
          <target state="translated">Ele permite que o código seja o seguinte:</target>       </trans-unit>
        <trans-unit id="1216" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.Int64,System.Numerics.BigInteger)">
          <source>Languages that do not support custom operators can call the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType&gt;</ph> method instead.</source>
          <target state="translated">Linguagens que não dão suporte a operadores personalizados podem chamar o método <ph id="ph1">&lt;xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType&gt;</ph> em vez disso.</target>       </trans-unit>
        <trans-unit id="1217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.Int64,System.Numerics.BigInteger)">
          <source>They can also call the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_LessThanOrEqual%28System.Int64%2CSystem.Numerics.BigInteger%29&gt;</ph> method directly, as the following example shows.</source>
          <target state="translated">Eles também podem chamar o <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_LessThanOrEqual%28System.Int64%2CSystem.Numerics.BigInteger%29&gt;</ph> método diretamente, como o exemplo a seguir mostra.</target>       </trans-unit>
        <trans-unit id="1218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.Int64,System.Numerics.BigInteger)">
          <source>If <ph id="ph1">`left`</ph> is a <ph id="ph2">&lt;xref:System.Byte&gt;</ph>, <ph id="ph3">&lt;xref:System.Int16&gt;</ph>, <ph id="ph4">&lt;xref:System.Int32&gt;</ph>, <ph id="ph5">&lt;xref:System.SByte&gt;</ph>, <ph id="ph6">&lt;xref:System.UInt16&gt;</ph>, or <ph id="ph7">&lt;xref:System.UInt32&gt;</ph> value, it is implicitly converted to an <ph id="ph8">&lt;xref:System.Int64&gt;</ph> value when the operation is performed.</source>
          <target state="translated">Se <ph id="ph1">`left`</ph> é um <ph id="ph2">&lt;xref:System.Byte&gt;</ph>, <ph id="ph3">&lt;xref:System.Int16&gt;</ph>, <ph id="ph4">&lt;xref:System.Int32&gt;</ph>, <ph id="ph5">&lt;xref:System.SByte&gt;</ph>, <ph id="ph6">&lt;xref:System.UInt16&gt;</ph>, ou <ph id="ph7">&lt;xref:System.UInt32&gt;</ph> valor, ele é convertido implicitamente em um <ph id="ph8">&lt;xref:System.Int64&gt;</ph> valor quando a operação é executada.</target>       </trans-unit>
        <trans-unit id="1219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.Int64,System.Numerics.BigInteger)">
          <source>The equivalent method for this operator is <ph id="ph1">&lt;xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">O método equivalente para esse operador é <ph id="ph1">&lt;xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1220" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.Numerics.BigInteger,System.Int64)">
          <source>The first value to compare.</source>
          <target state="translated">O primeiro valor a ser comparado.</target>       </trans-unit>
        <trans-unit id="1221" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.Numerics.BigInteger,System.Int64)">
          <source>The second value to compare.</source>
          <target state="translated">O segundo valor a ser comparado.</target>       </trans-unit>
        <trans-unit id="1222" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.Numerics.BigInteger,System.Int64)">
          <source>Returns a value that indicates whether a <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> value is less than or equal to a 64-bit signed integer.</source>
          <target state="translated">Retorna um valor que indica se um valor <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> é menor ou igual a um inteiro com sinal de 64 bits.</target>       </trans-unit>
        <trans-unit id="1223" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.Numerics.BigInteger,System.Int64)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="left" /&gt;</ph> is less than or equal to <ph id="ph3">&lt;paramref name="right" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se <ph id="ph2">&lt;paramref name="left" /&gt;</ph> for menor ou igual a <ph id="ph3">&lt;paramref name="right" /&gt;</ph>; caso contrário, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.Numerics.BigInteger,System.Int64)">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_LessThanOrEqual%2A&gt;</ph> method defines the operation of the less than or equal to operator for <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> values.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_LessThanOrEqual%2A&gt;</ph> método define a operação de menor que ou igual ao operador para <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> valores.</target>       </trans-unit>
        <trans-unit id="1225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.Numerics.BigInteger,System.Int64)">
          <source>It enables code such as the following:</source>
          <target state="translated">Ele permite que o código seja o seguinte:</target>       </trans-unit>
        <trans-unit id="1226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.Numerics.BigInteger,System.Int64)">
          <source>Languages that do not support custom operators can call the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType&gt;</ph> method instead.</source>
          <target state="translated">Linguagens que não dão suporte a operadores personalizados podem chamar o método <ph id="ph1">&lt;xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType&gt;</ph> em vez disso.</target>       </trans-unit>
        <trans-unit id="1227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.Numerics.BigInteger,System.Int64)">
          <source>They can also call the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_LessThanOrEqual%28System.Numerics.BigInteger%2CSystem.Int64%29&gt;</ph> method directly, as the following example shows.</source>
          <target state="translated">Eles também podem chamar o <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_LessThanOrEqual%28System.Numerics.BigInteger%2CSystem.Int64%29&gt;</ph> método diretamente, como o exemplo a seguir mostra.</target>       </trans-unit>
        <trans-unit id="1228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.Numerics.BigInteger,System.Int64)">
          <source>If <ph id="ph1">`right`</ph> is a <ph id="ph2">&lt;xref:System.Byte&gt;</ph>, <ph id="ph3">&lt;xref:System.Int16&gt;</ph>, <ph id="ph4">&lt;xref:System.Int32&gt;</ph>, <ph id="ph5">&lt;xref:System.SByte&gt;</ph>, <ph id="ph6">&lt;xref:System.UInt16&gt;</ph>, or <ph id="ph7">&lt;xref:System.UInt32&gt;</ph> value, it is implicitly converted to an <ph id="ph8">&lt;xref:System.Int64&gt;</ph> value when the operation is performed.</source>
          <target state="translated">Se <ph id="ph1">`right`</ph> é um <ph id="ph2">&lt;xref:System.Byte&gt;</ph>, <ph id="ph3">&lt;xref:System.Int16&gt;</ph>, <ph id="ph4">&lt;xref:System.Int32&gt;</ph>, <ph id="ph5">&lt;xref:System.SByte&gt;</ph>, <ph id="ph6">&lt;xref:System.UInt16&gt;</ph>, ou <ph id="ph7">&lt;xref:System.UInt32&gt;</ph> valor, ele é convertido implicitamente em um <ph id="ph8">&lt;xref:System.Int64&gt;</ph> valor quando a operação é executada.</target>       </trans-unit>
        <trans-unit id="1229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.Numerics.BigInteger,System.Int64)">
          <source>The equivalent method for this operator is <ph id="ph1">&lt;xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">O método equivalente para esse operador é <ph id="ph1">&lt;xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1230" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>The first value to compare.</source>
          <target state="translated">O primeiro valor a ser comparado.</target>       </trans-unit>
        <trans-unit id="1231" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>The second value to compare.</source>
          <target state="translated">O segundo valor a ser comparado.</target>       </trans-unit>
        <trans-unit id="1232" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>Returns a value that indicates whether a <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> value is less than or equal to another <ph id="ph2">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> value.</source>
          <target state="translated">Retorna um valor que indica se um valor <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> é menor ou igual a outro valor <ph id="ph2">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1233" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="left" /&gt;</ph> is less than or equal to <ph id="ph3">&lt;paramref name="right" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se <ph id="ph2">&lt;paramref name="left" /&gt;</ph> for menor ou igual a <ph id="ph3">&lt;paramref name="right" /&gt;</ph>; caso contrário, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_LessThanOrEqual%2A&gt;</ph> method defines the operation of the less than or equal to operator for <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> values.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_LessThanOrEqual%2A&gt;</ph> método define a operação de menor que ou igual ao operador para <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> valores.</target>       </trans-unit>
        <trans-unit id="1235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>It enables code such as the following:</source>
          <target state="translated">Ele permite que o código seja o seguinte:</target>       </trans-unit>
        <trans-unit id="1236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>Languages that do not support custom operators can call the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Compare%2A&gt;</ph> method instead.</source>
          <target state="translated">Linguagens que não dão suporte a operadores personalizados podem chamar o método <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Compare%2A&gt;</ph> em vez disso.</target>       </trans-unit>
        <trans-unit id="1237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>They can also call the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_LessThanOrEqual%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29&gt;</ph> method directly, as the following example shows.</source>
          <target state="translated">Eles também podem chamar o <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_LessThanOrEqual%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29&gt;</ph> método diretamente, como o exemplo a seguir mostra.</target>       </trans-unit>
        <trans-unit id="1238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>The equivalent method for this operator is <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Compare%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">O método equivalente para esse operador é <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Compare%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1239" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.Numerics.BigInteger,System.UInt64)">
          <source>The first value to compare.</source>
          <target state="translated">O primeiro valor a ser comparado.</target>       </trans-unit>
        <trans-unit id="1240" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.Numerics.BigInteger,System.UInt64)">
          <source>The second value to compare.</source>
          <target state="translated">O segundo valor a ser comparado.</target>       </trans-unit>
        <trans-unit id="1241" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.Numerics.BigInteger,System.UInt64)">
          <source>Returns a value that indicates whether a <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> value is less than or equal to a 64-bit unsigned integer.</source>
          <target state="translated">Retorna um valor que indica se um valor <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> é menor ou igual a um inteiro sem sinal de 64 bits.</target>       </trans-unit>
        <trans-unit id="1242" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.Numerics.BigInteger,System.UInt64)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="left" /&gt;</ph> is less than or equal to <ph id="ph3">&lt;paramref name="right" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se <ph id="ph2">&lt;paramref name="left" /&gt;</ph> for menor ou igual a <ph id="ph3">&lt;paramref name="right" /&gt;</ph>; caso contrário, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1243" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.Numerics.BigInteger,System.UInt64)">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_LessThanOrEqual%2A&gt;</ph> method defines the operation of the less than or equal to operator for <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> values.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_LessThanOrEqual%2A&gt;</ph> método define a operação de menor que ou igual ao operador para <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> valores.</target>       </trans-unit>
        <trans-unit id="1244" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.Numerics.BigInteger,System.UInt64)">
          <source>It enables code such as the following:</source>
          <target state="translated">Ele permite que o código seja o seguinte:</target>       </trans-unit>
        <trans-unit id="1245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.Numerics.BigInteger,System.UInt64)">
          <source>Languages that do not support custom operators can call the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType&gt;</ph> method instead.</source>
          <target state="translated">Linguagens que não dão suporte a operadores personalizados podem chamar o método <ph id="ph1">&lt;xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType&gt;</ph> em vez disso.</target>       </trans-unit>
        <trans-unit id="1246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.Numerics.BigInteger,System.UInt64)">
          <source>They can also call the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_LessThanOrEqual%28System.Numerics.BigInteger%2CSystem.UInt64%29&gt;</ph> method directly, as the following example shows.</source>
          <target state="translated">Eles também podem chamar o <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_LessThanOrEqual%28System.Numerics.BigInteger%2CSystem.UInt64%29&gt;</ph> método diretamente, como o exemplo a seguir mostra.</target>       </trans-unit>
        <trans-unit id="1247" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.Numerics.BigInteger,System.UInt64)">
          <source>The equivalent method for this operator is <ph id="ph1">&lt;xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">O método equivalente para esse operador é <ph id="ph1">&lt;xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1248" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.UInt64,System.Numerics.BigInteger)">
          <source>The first value to compare.</source>
          <target state="translated">O primeiro valor a ser comparado.</target>       </trans-unit>
        <trans-unit id="1249" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.UInt64,System.Numerics.BigInteger)">
          <source>The second value to compare.</source>
          <target state="translated">O segundo valor a ser comparado.</target>       </trans-unit>
        <trans-unit id="1250" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.UInt64,System.Numerics.BigInteger)">
          <source>Returns a value that indicates whether a 64-bit unsigned integer is less than or equal to a <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> value.</source>
          <target state="translated">Retorna um valor que indica se um inteiro sem sinal de 64 bits é menor ou igual a um valor <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1251" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.UInt64,System.Numerics.BigInteger)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="left" /&gt;</ph> is less than or equal to <ph id="ph3">&lt;paramref name="right" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se <ph id="ph2">&lt;paramref name="left" /&gt;</ph> for menor ou igual a <ph id="ph3">&lt;paramref name="right" /&gt;</ph>; caso contrário, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1252" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.UInt64,System.Numerics.BigInteger)">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_LessThanOrEqual%2A&gt;</ph> method defines the operation of the less than or equal to operator for <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> values.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_LessThanOrEqual%2A&gt;</ph> método define a operação de menor que ou igual ao operador para <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> valores.</target>       </trans-unit>
        <trans-unit id="1253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.UInt64,System.Numerics.BigInteger)">
          <source>It enables code such as the following:</source>
          <target state="translated">Ele permite que o código seja o seguinte:</target>       </trans-unit>
        <trans-unit id="1254" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.UInt64,System.Numerics.BigInteger)">
          <source>Languages that do not support custom operators can call the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType&gt;</ph> method instead.</source>
          <target state="translated">Linguagens que não dão suporte a operadores personalizados podem chamar o método <ph id="ph1">&lt;xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType&gt;</ph> em vez disso.</target>       </trans-unit>
        <trans-unit id="1255" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.UInt64,System.Numerics.BigInteger)">
          <source>They can also call the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_LessThanOrEqual%28System.UInt64%2CSystem.Numerics.BigInteger%29&gt;</ph> method directly, as the following example shows.</source>
          <target state="translated">Eles também podem chamar o <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_LessThanOrEqual%28System.UInt64%2CSystem.Numerics.BigInteger%29&gt;</ph> método diretamente, como o exemplo a seguir mostra.</target>       </trans-unit>
        <trans-unit id="1256" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.UInt64,System.Numerics.BigInteger)">
          <source>The equivalent method for this operator is <ph id="ph1">&lt;xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">O método equivalente para esse operador é <ph id="ph1">&lt;xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1257" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Modulus(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>The value to be divided.</source>
          <target state="translated">O valor a ser dividido.</target>       </trans-unit>
        <trans-unit id="1258" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Modulus(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>The value to divide by.</source>
          <target state="translated">O valor pelo qual dividir.</target>       </trans-unit>
        <trans-unit id="1259" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Modulus(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>Returns the remainder that results from division with two specified <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> values.</source>
          <target state="translated">Retorna o resto que resulta da divisão com dois valores especificados <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1260" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Modulus(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>The remainder that results from the division.</source>
          <target state="translated">O resto que resulta da divisão.</target>       </trans-unit>
        <trans-unit id="1261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Modulus(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_Modulus%2A&gt;</ph> method defines the operation of the modulus operator for <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> values.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_Modulus%2A&gt;</ph> método define a operação do operador de módulo para <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> valores.</target>       </trans-unit>
        <trans-unit id="1262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Modulus(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>It enables code such as the following:</source>
          <target state="translated">Ele permite que o código seja o seguinte:</target>       </trans-unit>
        <trans-unit id="1263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Modulus(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>Languages that do not support custom operators can call the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Remainder%2A?displayProperty=nameWithType&gt;</ph> method instead.</source>
          <target state="translated">Linguagens que não dão suporte a operadores personalizados podem chamar o método <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Remainder%2A?displayProperty=nameWithType&gt;</ph> em vez disso.</target>       </trans-unit>
        <trans-unit id="1264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Modulus(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>The sign of the value returned by the modulus operation depends on the sign of <ph id="ph1">`dividend`</ph>: If <ph id="ph2">`dividend`</ph> is positive, the modulus operation returns a positive result; if it is negative, the modulus operation returns a negative result.</source>
          <target state="translated">O sinal do valor retornado pela operação de módulo depende do sinal de <ph id="ph1">`dividend`</ph>: se <ph id="ph2">`dividend`</ph> for positivo, a operação de módulo retorna um resultado positivo; se for negativo, a operação de módulo retornará um resultado negativo.</target>       </trans-unit>
        <trans-unit id="1265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Modulus(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>The behavior of the modulus operation with <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> values is identical to the modulus operation with other integral types.</source>
          <target state="translated">O comportamento da operação de módulo com <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> valores é idêntica à operação de módulo com outros tipos integrais.</target>       </trans-unit>
        <trans-unit id="1266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Modulus(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>The equivalent method for this operator is <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Remainder%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">O método equivalente para esse operador é <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Remainder%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1267" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Modulus(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source><ph id="ph1">&lt;paramref name="divisor" /&gt;</ph> is 0 (zero).</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="divisor" /&gt;</ph> é 0 (zero).</target>       </trans-unit>
        <trans-unit id="1268" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Multiply(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>The first value to multiply.</source>
          <target state="translated">O primeiro valor a ser multiplicado.</target>       </trans-unit>
        <trans-unit id="1269" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Multiply(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>The second value to multiply.</source>
          <target state="translated">O segundo valor a ser multiplicado.</target>       </trans-unit>
        <trans-unit id="1270" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Multiply(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>Multiplies two specified <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> values.</source>
          <target state="translated">Multiplica dois valores <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> especificados.</target>       </trans-unit>
        <trans-unit id="1271" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Multiply(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>The product of <ph id="ph1">&lt;paramref name="left" /&gt;</ph> and <ph id="ph2">&lt;paramref name="right" /&gt;</ph>.</source>
          <target state="translated">O produto de <ph id="ph1">&lt;paramref name="left" /&gt;</ph> e <ph id="ph2">&lt;paramref name="right" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1272" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Multiply(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_Multiply%2A&gt;</ph> method defines the operation of the multiplication operator for <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> values.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_Multiply%2A&gt;</ph> método define a operação do operador de multiplicação para <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> valores.</target>       </trans-unit>
        <trans-unit id="1273" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Multiply(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>It enables code such as the following:</source>
          <target state="translated">Ele permite que o código seja o seguinte:</target>       </trans-unit>
        <trans-unit id="1274" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Multiply(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>The equivalent method for this operator is <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Multiply(System.Numerics.BigInteger,System.Numerics.BigInteger)?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">O método equivalente para esse operador é <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Multiply(System.Numerics.BigInteger,System.Numerics.BigInteger)?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1275" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_OnesComplement(System.Numerics.BigInteger)">
          <source>An integer value.</source>
          <target state="translated">Um valor inteiro.</target>       </trans-unit>
        <trans-unit id="1276" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_OnesComplement(System.Numerics.BigInteger)">
          <source>Returns the bitwise one's complement of a <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> value.</source>
          <target state="translated">Retorna o complemento bit a bit de um valor <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1277" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_OnesComplement(System.Numerics.BigInteger)">
          <source>The bitwise one's complement of <ph id="ph1">&lt;paramref name="value" /&gt;</ph>.</source>
          <target state="translated">O complemento bit a bit de <ph id="ph1">&lt;paramref name="value" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1278" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_OnesComplement(System.Numerics.BigInteger)">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_OnesComplement%2A&gt;</ph> method defines the operation of the bitwise one's complement operator for <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> values.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_OnesComplement%2A&gt;</ph> método define a operação de bit a bit de um operador de complemento para <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> valores.</target>       </trans-unit>
        <trans-unit id="1279" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_OnesComplement(System.Numerics.BigInteger)">
          <source>The bitwise one's complement operator reverses each bit in a numeric value.</source>
          <target state="translated">Bit a bit de um operador de complemento inverte cada bit em um valor numérico.</target>       </trans-unit>
        <trans-unit id="1280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_OnesComplement(System.Numerics.BigInteger)">
          <source>That is, bits in <ph id="ph1">`value`</ph> that are 0 are set to 1 in the result, and bits that are 1 are set to 0 in the result.</source>
          <target state="translated">Ou seja, o bits no <ph id="ph1">`value`</ph> que são 0 são definidos como 1 no resultado e os bits forem 1 são definidos como 0 no resultado.</target>       </trans-unit>
        <trans-unit id="1281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_OnesComplement(System.Numerics.BigInteger)">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_OnesComplement%2A&gt;</ph> method enables code such as the following:</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_OnesComplement%2A&gt;</ph> método permite que o código como o seguinte:</target>       </trans-unit>
        <trans-unit id="1282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_OnesComplement(System.Numerics.BigInteger)">
          <source>Languages that do not support custom operators may be able to call the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_OnesComplement%2A&gt;</ph> method directly to perform a bitwise one's complement operation.</source>
          <target state="translated">Idiomas que dão suporte a operadores personalizados podem ser capazes de chamar o <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_OnesComplement%2A&gt;</ph> método diretamente para executar um bit a bit de um complemento de operação.</target>       </trans-unit>
        <trans-unit id="1283" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_OnesComplement(System.Numerics.BigInteger)">
          <source>For example:</source>
          <target state="translated">Por exemplo:</target>       </trans-unit>
        <trans-unit id="1284" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_RightShift(System.Numerics.BigInteger,System.Int32)">
          <source>The value whose bits are to be shifted.</source>
          <target state="translated">O valor cujos bits devem ser deslocados.</target>       </trans-unit>
        <trans-unit id="1285" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_RightShift(System.Numerics.BigInteger,System.Int32)">
          <source>The number of bits to shift <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept> to the right.</source>
          <target state="translated">O número de bits a deslocar <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept> para a direita.</target>       </trans-unit>
        <trans-unit id="1286" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_RightShift(System.Numerics.BigInteger,System.Int32)">
          <source>Shifts a <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> value a specified number of bits to the right.</source>
          <target state="translated">Desloca um valor <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> um número especificado de bits para a direita.</target>       </trans-unit>
        <trans-unit id="1287" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_RightShift(System.Numerics.BigInteger,System.Int32)">
          <source>A value that has been shifted to the right by the specified number of bits.</source>
          <target state="translated">Um valor que foi sido deslocado para a direita pelo número especificado de bits.</target>       </trans-unit>
        <trans-unit id="1288" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_RightShift(System.Numerics.BigInteger,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_RightShift%2A&gt;</ph> method defines the operation of the bitwise right-shift operator for <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> values.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_RightShift%2A&gt;</ph> método define a operação do operador right shift bit a bit para <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> valores.</target>       </trans-unit>
        <trans-unit id="1289" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_RightShift(System.Numerics.BigInteger,System.Int32)">
          <source>It enables code such as the following:</source>
          <target state="translated">Ele permite que o código seja o seguinte:</target>       </trans-unit>
        <trans-unit id="1290" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_RightShift(System.Numerics.BigInteger,System.Int32)">
          <source>Languages that do not support custom operators can perform a bitwise right-shift operation by dividing <ph id="ph1">`value`</ph> by <ph id="ph2">`BigInteger.Pow(2, shift)`</ph> and subtracting 1 times <ph id="ph3">`shift`</ph> for negative values.</source>
          <target state="translated">Idiomas que não dão suporte a operadores personalizados podem executar uma operação bit a bit de deslocamento à direita, dividindo <ph id="ph1">`value`</ph> por <ph id="ph2">`BigInteger.Pow(2, shift)`</ph> e subtraindo 1 vezes <ph id="ph3">`shift`</ph> para valores negativos.</target>       </trans-unit>
        <trans-unit id="1291" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_RightShift(System.Numerics.BigInteger,System.Int32)">
          <source>The following example shows that the results are identical to the results of using this operator.</source>
          <target state="translated">O exemplo a seguir mostra os resultados são idênticos para os resultados do uso desse operador.</target>       </trans-unit>
        <trans-unit id="1292" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_RightShift(System.Numerics.BigInteger,System.Int32)">
          <source>If <ph id="ph1">`shift`</ph> is greater than or equal to the number of bits in a positive <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> value, the result of the right-shift operation is <ph id="ph3">&lt;xref:System.Numerics.BigInteger.Zero%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Se <ph id="ph1">`shift`</ph> é maior que ou igual ao número de bits em um positivo <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> valor, o resultado da operação right shift é <ph id="ph3">&lt;xref:System.Numerics.BigInteger.Zero%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1293" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_RightShift(System.Numerics.BigInteger,System.Int32)">
          <source>If <ph id="ph1">`shift`</ph> is greater than the number of bits in a negative <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> value, the result of the right-shift operation is <ph id="ph3">&lt;xref:System.Numerics.BigInteger.MinusOne%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Se <ph id="ph1">`shift`</ph> é maior que o número de bits em um negativo <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> valor, o resultado da operação right shift é <ph id="ph3">&lt;xref:System.Numerics.BigInteger.MinusOne%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1294" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Subtraction(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>The value to subtract from (the minuend).</source>
          <target state="translated">O valor do qual um valor será subtraído (o minuendo).</target>       </trans-unit>
        <trans-unit id="1295" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Subtraction(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>The value to subtract (the subtrahend).</source>
          <target state="translated">O valor a ser subtraído (o subtraendo).</target>       </trans-unit>
        <trans-unit id="1296" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Subtraction(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>Subtracts a <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> value from another <ph id="ph2">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> value.</source>
          <target state="translated">Subtrai um valor <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> de outro valor <ph id="ph2">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1297" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_Subtraction(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>The result of subtracting <ph id="ph1">&lt;paramref name="right" /&gt;</ph> from <ph id="ph2">&lt;paramref name="left" /&gt;</ph>.</source>
          <target state="translated">O resultado da subtração de <ph id="ph1">&lt;paramref name="right" /&gt;</ph> de <ph id="ph2">&lt;paramref name="left" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Subtraction(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_Subtraction%2A&gt;</ph> method defines the operation of the subtraction operator for <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> values.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_Subtraction%2A&gt;</ph> método define a operação do operador de subtração para <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> valores.</target>       </trans-unit>
        <trans-unit id="1299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Subtraction(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>It enables code such as the following:</source>
          <target state="translated">Ele permite que o código seja o seguinte:</target>       </trans-unit>
        <trans-unit id="1300" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Subtraction(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>Languages that do not support custom operators can call the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Subtract%2A?displayProperty=nameWithType&gt;</ph> method instead.</source>
          <target state="translated">Linguagens que não dão suporte a operadores personalizados podem chamar o método <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Subtract%2A?displayProperty=nameWithType&gt;</ph> em vez disso.</target>       </trans-unit>
        <trans-unit id="1301" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_Subtraction(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>The equivalent method for this operator is <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Subtract%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">O método equivalente para esse operador é <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Subtract%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1302" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_UnaryNegation(System.Numerics.BigInteger)">
          <source>The value to negate.</source>
          <target state="translated">O valor a ser negado.</target>       </trans-unit>
        <trans-unit id="1303" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_UnaryNegation(System.Numerics.BigInteger)">
          <source>Negates a specified BigInteger value.</source>
          <target state="translated">Nega um valor BigInteger especificado.</target>       </trans-unit>
        <trans-unit id="1304" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_UnaryNegation(System.Numerics.BigInteger)">
          <source>The result of the <ph id="ph1">&lt;paramref name="value" /&gt;</ph> parameter multiplied by negative one (-1).</source>
          <target state="translated">O resultado do parâmetro <ph id="ph1">&lt;paramref name="value" /&gt;</ph> multiplicado por um negativo (-1).</target>       </trans-unit>
        <trans-unit id="1305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_UnaryNegation(System.Numerics.BigInteger)">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_UnaryNegation%2A&gt;</ph> method defines the operation of the unary negation operator (or the additive inverse operator) for <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> values.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_UnaryNegation%2A&gt;</ph> método define a operação de operador unário de negação (ou o operador aditivo inverso) para <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> valores.</target>       </trans-unit>
        <trans-unit id="1306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_UnaryNegation(System.Numerics.BigInteger)">
          <source>The operation produces a value that results in 0 (zero) when it is added to the original number.</source>
          <target state="translated">A operação produz um valor que resulta em 0 (zero) quando ele é adicionado ao número original.</target>       </trans-unit>
        <trans-unit id="1307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_UnaryNegation(System.Numerics.BigInteger)">
          <source>Languages that do not support custom operators can call the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Negate%2A&gt;</ph> method instead.</source>
          <target state="translated">Linguagens que não dão suporte a operadores personalizados podem chamar o método <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Negate%2A&gt;</ph> em vez disso.</target>       </trans-unit>
        <trans-unit id="1308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_UnaryNegation(System.Numerics.BigInteger)">
          <source>The equivalent method for this operator is <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Negate%28System.Numerics.BigInteger%29?displayProperty=nameWithType&gt;</ph></source>
          <target state="translated">O método equivalente para esse operador é <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Negate%28System.Numerics.BigInteger%29?displayProperty=nameWithType&gt;</ph></target>       </trans-unit>
        <trans-unit id="1309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_UnaryNegation(System.Numerics.BigInteger)">
          <source>The following example illustrates three different ways to negate the value of a <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> object.</source>
          <target state="translated">O exemplo a seguir ilustra três maneiras diferentes para negar o valor de uma <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="1310" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_UnaryPlus(System.Numerics.BigInteger)">
          <source>An integer value.</source>
          <target state="translated">Um valor inteiro.</target>       </trans-unit>
        <trans-unit id="1311" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_UnaryPlus(System.Numerics.BigInteger)">
          <source>Returns the value of the <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> operand.</source>
          <target state="translated">Retorna o valor do operando <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1312" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_UnaryPlus(System.Numerics.BigInteger)">
          <source>(The sign of the operand is unchanged.)</source>
          <target state="translated">(O sinal do operando permanece inalterado).</target>       </trans-unit>
        <trans-unit id="1313" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.op_UnaryPlus(System.Numerics.BigInteger)">
          <source>The value of the <ph id="ph1">&lt;paramref name="value" /&gt;</ph> operand.</source>
          <target state="translated">O valor do operando <ph id="ph1">&lt;paramref name="value" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1314" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.op_UnaryPlus(System.Numerics.BigInteger)">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_UnaryPlus%2A&gt;</ph> method defines the operation of the unary positive operator for <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> values.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_UnaryPlus%2A&gt;</ph> método define a operação do operador unário positivo para <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> valores.</target>       </trans-unit>
        <trans-unit id="1315" translate="yes" xml:space="preserve" uid="T:System.Numerics.BigInteger">
          <source>Converts the string representation of a number to its <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> equivalent.</source>
          <target state="translated">Converte a representação da cadeia de caracteres de um número no <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> equivalente.</target>       </trans-unit>
        <trans-unit id="1316" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.Parse(System.String)">
          <source>A string that contains the number to convert.</source>
          <target state="translated">Uma cadeia de caracteres que contém o número a ser convertido.</target>       </trans-unit>
        <trans-unit id="1317" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.Parse(System.String)">
          <source>Converts the string representation of a number to its <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> equivalent.</source>
          <target state="translated">Converte a representação da cadeia de caracteres de um número no <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> equivalente.</target>       </trans-unit>
        <trans-unit id="1318" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.Parse(System.String)">
          <source>A value that is equivalent to the number specified in the <ph id="ph1">&lt;paramref name="value" /&gt;</ph> parameter.</source>
          <target state="translated">Um valor equivalente ao número especificado no parâmetro <ph id="ph1">&lt;paramref name="value" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1319" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String)">
          <source>The <ph id="ph1">`value`</ph> parameter should be the string representation of a number in the following form.</source>
          <target state="translated">O <ph id="ph1">`value`</ph> parâmetro deve ser a representação de cadeia de caracteres de um número no formato a seguir.</target>       </trans-unit>
        <trans-unit id="1320" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String)">
          <source>[<bpt id="p1">*</bpt>ws<ept id="p1">*</ept>][<bpt id="p2">*</bpt>sign<ept id="p2">*</ept>]<bpt id="p3">*</bpt>digits<ept id="p3">*</ept>[<bpt id="p4">*</bpt>ws<ept id="p4">*</ept>]</source>
          <target state="translated">[<bpt id="p1">*</bpt>ws<ept id="p1">*</ept>][<bpt id="p2">*</bpt>sign<ept id="p2">*</ept>]<bpt id="p3">*</bpt>digits<ept id="p3">*</ept>[<bpt id="p4">*</bpt>ws<ept id="p4">*</ept>]</target>       </trans-unit>
        <trans-unit id="1321" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String)">
          <source>Elements in square brackets ([ and ]) are optional.</source>
          <target state="translated">Os elementos entre colchetes ([ e ]) são opcionais.</target>       </trans-unit>
        <trans-unit id="1322" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String)">
          <source>The following table describes each element.</source>
          <target state="translated">A tabela a seguir descreve cada elemento.</target>       </trans-unit>
        <trans-unit id="1323" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String)">
          <source>Element</source>
          <target state="translated">Elemento</target>       </trans-unit>
        <trans-unit id="1324" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String)">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="1325" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String)">
          <source><bpt id="p1">*</bpt>ws<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>ws<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="1326" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String)">
          <source>Optional white space.</source>
          <target state="translated">Espaço em branco opcional.</target>       </trans-unit>
        <trans-unit id="1327" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String)">
          <source><bpt id="p1">*</bpt>sign<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>sign<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="1328" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String)">
          <source>An optional sign.</source>
          <target state="translated">Um sinal opcional.</target>       </trans-unit>
        <trans-unit id="1329" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String)">
          <source>Valid sign characters are determined by the <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo.PositiveSign%2A?displayProperty=nameWithType&gt;</ph> properties of the current culture.</source>
          <target state="translated">Os caracteres de sinal válido são determinados pelas propriedades <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType&gt;</ph> e <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo.PositiveSign%2A?displayProperty=nameWithType&gt;</ph> da cultura atual.</target>       </trans-unit>
        <trans-unit id="1330" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String)">
          <source><bpt id="p1">*</bpt>digits<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>digits<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="1331" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String)">
          <source>A sequence of digits ranging from 0 to 9.</source>
          <target state="translated">Uma sequência de dígitos que varia de 0 a 9.</target>       </trans-unit>
        <trans-unit id="1332" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String)">
          <source>Any leading zeros are ignored.</source>
          <target state="translated">Todos os zeros à esquerda são ignorados.</target>       </trans-unit>
        <trans-unit id="1333" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String)">
          <source>The string specified by the <ph id="ph1">`value`</ph> parameter is interpreted by using the <ph id="ph2">&lt;xref:System.Globalization.NumberStyles.Integer?displayProperty=nameWithType&gt;</ph> style.</source>
          <target state="translated">A cadeia de caracteres especificada pelo <ph id="ph1">`value`</ph> parâmetro é interpretado usando o <ph id="ph2">&lt;xref:System.Globalization.NumberStyles.Integer?displayProperty=nameWithType&gt;</ph> estilo.</target>       </trans-unit>
        <trans-unit id="1334" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String)">
          <source>It cannot contain any group separators or decimal separator, and it cannot have a decimal portion.</source>
          <target state="translated">Ele não pode conter nenhum separador de grupo ou decimal, e não pode ter uma parte decimal.</target>       </trans-unit>
        <trans-unit id="1335" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String)">
          <source>The <ph id="ph1">`value`</ph> parameter is parsed by using the formatting information in a <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo?displayProperty=nameWithType&gt;</ph> object that is initialized for the current system culture.</source>
          <target state="translated">O parâmetro <ph id="ph1">`value`</ph> é analisado usando-se as informações de formatação em um objeto <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo?displayProperty=nameWithType&gt;</ph> que é inicializado para a cultura do sistema atual.</target>       </trans-unit>
        <trans-unit id="1336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String)">
          <source>For more information, see <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Para obter mais informações, consulte <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1337" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String)">
          <source>To parse a string by using the formatting information of a specific culture, use the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.IFormatProvider%29&gt;</ph> method.</source>
          <target state="translated">Para analisar uma cadeia de caracteres usando as informações de formatação de uma cultura específica, use o <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.IFormatProvider%29&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="1338" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String)">
          <source>If you use the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Parse%2A&gt;</ph> method to round-trip the string representation of a <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> value that was output by the <ph id="ph3">&lt;xref:System.Numerics.BigInteger.ToString%2A&gt;</ph> method, you should use the <ph id="ph4">&lt;xref:System.Numerics.BigInteger.ToString%28System.String%29?displayProperty=nameWithType&gt;</ph> method with the "R" format specifier to generate the string representation of the <ph id="ph5">&lt;xref:System.Numerics.BigInteger&gt;</ph> value.</source>
          <target state="translated">Se você usar o <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Parse%2A&gt;</ph> método viagem a representação de cadeia de caracteres de um <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> valor foi saída o <ph id="ph3">&lt;xref:System.Numerics.BigInteger.ToString%2A&gt;</ph> método, você deve usar o <ph id="ph4">&lt;xref:System.Numerics.BigInteger.ToString%28System.String%29?displayProperty=nameWithType&gt;</ph> método com o especificador de formato "R" para gerar a representação de cadeia de caracteres da <ph id="ph5">&lt;xref:System.Numerics.BigInteger&gt;</ph> valor.</target>       </trans-unit>
        <trans-unit id="1339" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String)">
          <source>Otherwise, the string representation of the <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> preserves only the 50 most significant digits of the original value, and data may be lost when you use the <ph id="ph2">&lt;xref:System.Numerics.BigInteger.Parse%2A&gt;</ph> method to restore the <ph id="ph3">&lt;xref:System.Numerics.BigInteger&gt;</ph> value.</source>
          <target state="translated">Caso contrário, a representação de cadeia de caracteres da <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> preserva apenas os 50 dígitos significativos do valor original e dados podem ser perdidos quando você usa o <ph id="ph2">&lt;xref:System.Numerics.BigInteger.Parse%2A&gt;</ph> método para restaurar o <ph id="ph3">&lt;xref:System.Numerics.BigInteger&gt;</ph> valor.</target>       </trans-unit>
        <trans-unit id="1340" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Parse%28System.String%29&gt;</ph> method to instantiate two <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> objects.</source>
          <target state="translated">O exemplo a seguir usa o <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Parse%28System.String%29&gt;</ph> método para instanciar dois <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> objetos.</target>       </trans-unit>
        <trans-unit id="1341" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String)">
          <source>It multiplies each object by another number and then calls the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Compare%2A&gt;</ph> method to determine the relationship between the two values.</source>
          <target state="translated">Ele multiplica cada objeto por outro número e, em seguida, chama o <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Compare%2A&gt;</ph> método para determinar a relação entre os dois valores.</target>       </trans-unit>
        <trans-unit id="1342" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.Parse(System.String)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1343" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.Parse(System.String)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is not in the correct format.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> não está no formato correto.</target>       </trans-unit>
        <trans-unit id="1344" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles)">
          <source>A string that contains a number to convert.</source>
          <target state="translated">Uma cadeia de caracteres que contém um número a ser convertido.</target>       </trans-unit>
        <trans-unit id="1345" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles)">
          <source>A bitwise combination of the enumeration values that specify the permitted format of <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Um combinação bit a bit de valores de enumeração que especificam o formato permitido de <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="1346" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles)">
          <source>Converts the string representation of a number in a specified style to its <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> equivalent.</source>
          <target state="translated">Converte a representação de cadeia de caracteres de um número em um estilo especificado em seu <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> equivalente.</target>       </trans-unit>
        <trans-unit id="1347" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles)">
          <source>A value that is equivalent to the number specified in the <ph id="ph1">&lt;paramref name="value" /&gt;</ph> parameter.</source>
          <target state="translated">Um valor equivalente ao número especificado no parâmetro <ph id="ph1">&lt;paramref name="value" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles)">
          <source>The <ph id="ph1">`style`</ph> parameter defines the style elements (such as white space, the positive or negative sign symbol, the group separator symbol, or the decimal point symbol) that are allowed in the <ph id="ph2">`value`</ph> parameter for the parse operation to succeed.</source>
          <target state="translated">O <ph id="ph1">`style`</ph> parâmetro define os elementos de estilo (como o espaço em branco, o símbolo de sinal positivo ou negativo, o símbolo de separador de grupo ou o símbolo de ponto decimal) que são permitidos no <ph id="ph2">`value`</ph> parâmetro para o êxito da operação de análise.</target>       </trans-unit>
        <trans-unit id="1349" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles)">
          <source><ph id="ph1">`styles`</ph> must be a combination of bit flags from the <ph id="ph2">&lt;xref:System.Globalization.NumberStyles&gt;</ph> enumeration.</source>
          <target state="translated"><ph id="ph1">`styles`</ph> deve ser uma combinação de sinalizadores de bit do <ph id="ph2">&lt;xref:System.Globalization.NumberStyles&gt;</ph> enumeração.</target>       </trans-unit>
        <trans-unit id="1350" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles)">
          <source>The <ph id="ph1">`style`</ph> parameter makes this method overload useful when <ph id="ph2">`value`</ph> contains the string representation of a hexadecimal value, when the number system (decimal or hexadecimal) represented by <ph id="ph3">`value`</ph> is known only at run time, or when you want to disallow white space or a sign symbol in <ph id="ph4">`value`</ph>.</source>
          <target state="translated">O <ph id="ph1">`style`</ph> parâmetro faz com que esse método de sobrecarga útil quando <ph id="ph2">`value`</ph> contém a representação de cadeia de caracteres de um valor hexadecimal, quando o sistema de número (decimal ou hexadecimal) representado por <ph id="ph3">`value`</ph> é conhecido apenas em tempo de execução, ou quando você deseja impedir que o espaço em branco ou um sinal de símbolo em <ph id="ph4">`value`</ph>.</target>       </trans-unit>
        <trans-unit id="1351" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles)">
          <source>Depending on the value of <ph id="ph1">`style`</ph>, the <ph id="ph2">`value`</ph> parameter may include the following elements:</source>
          <target state="translated">Dependendo do valor de <ph id="ph1">`style`</ph>, o parâmetro <ph id="ph2">`value`</ph> pode incluir os seguintes elementos:</target>       </trans-unit>
        <trans-unit id="1352" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles)">
          <source>[<bpt id="p1">*</bpt>ws<ept id="p1">*</ept>][<bpt id="p2">*</bpt><ph id="ph1">$</ph><ept id="p2">*</ept>][<bpt id="p3">*</bpt>sign<ept id="p3">*</ept>][<bpt id="p4">*</bpt>digits<ept id="p4">*</ept>,]<bpt id="p5">*</bpt>digits<ept id="p5">*</ept>[.<bpt id="p6">*</bpt>fractional_digits<ept id="p6">*</ept>][E[<bpt id="p7">*</bpt>sign<ept id="p7">*</ept>]<bpt id="p8">*</bpt>exponential_digits<ept id="p8">*</ept>][<bpt id="p9">*</bpt>ws<ept id="p9">*</ept>]</source>
          <target state="translated">[<bpt id="p1">*</bpt>ws<ept id="p1">*</ept>][<bpt id="p2">*</bpt><ph id="ph1">$</ph><ept id="p2">*</ept>][<bpt id="p3">*</bpt>sign<ept id="p3">*</ept>][<bpt id="p4">*</bpt>digits<ept id="p4">*</ept>,]<bpt id="p5">*</bpt>digits<ept id="p5">*</ept>[.<bpt id="p6">*</bpt>fractional_digits<ept id="p6">*</ept>][E[<bpt id="p7">*</bpt>sign<ept id="p7">*</ept>]<bpt id="p8">*</bpt>exponential_digits<ept id="p8">*</ept>][<bpt id="p9">*</bpt>ws<ept id="p9">*</ept>]</target>       </trans-unit>
        <trans-unit id="1353" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles)">
          <source>If <ph id="ph1">`style`</ph> includes <ph id="ph2">&lt;xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType&gt;</ph>, the <ph id="ph3">`value`</ph> parameter may contain the following elements:</source>
          <target state="translated">Caso <ph id="ph1">`style`</ph> inclua <ph id="ph2">&lt;xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType&gt;</ph>, o parâmetro <ph id="ph3">`value`</ph> pode conter os seguintes elementos:</target>       </trans-unit>
        <trans-unit id="1354" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles)">
          <source>[<bpt id="p1">*</bpt>ws<ept id="p1">*</ept>]<bpt id="p2">*</bpt>hexdigits<ept id="p2">*</ept>[<bpt id="p3">*</bpt>ws<ept id="p3">*</ept>]</source>
          <target state="translated">[<bpt id="p1">*</bpt>ws<ept id="p1">*</ept>]<bpt id="p2">*</bpt>hexdigits<ept id="p2">*</ept>[<bpt id="p3">*</bpt>ws<ept id="p3">*</ept>]</target>       </trans-unit>
        <trans-unit id="1355" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles)">
          <source>Elements in square brackets ([ and ]) are optional.</source>
          <target state="translated">Os elementos entre colchetes ([ e ]) são opcionais.</target>       </trans-unit>
        <trans-unit id="1356" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles)">
          <source>The following table describes each element.</source>
          <target state="translated">A tabela a seguir descreve cada elemento.</target>       </trans-unit>
        <trans-unit id="1357" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles)">
          <source>Element</source>
          <target state="translated">Elemento</target>       </trans-unit>
        <trans-unit id="1358" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles)">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="1359" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles)">
          <source><bpt id="p1">*</bpt>ws<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>ws<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="1360" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles)">
          <source>Optional white space.</source>
          <target state="translated">Espaço em branco opcional.</target>       </trans-unit>
        <trans-unit id="1361" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles)">
          <source>White space can appear at the start of <ph id="ph1">`value`</ph> if <ph id="ph2">`style`</ph> includes the <ph id="ph3">&lt;xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType&gt;</ph> flag, and it can appear at the end of <ph id="ph4">`value`</ph> if <ph id="ph5">`style`</ph> includes the <ph id="ph6">&lt;xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Espaço em branco pode aparecer no início de <ph id="ph1">`value`</ph> se <ph id="ph2">`style`</ph> inclui o <ph id="ph3">&lt;xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType&gt;</ph> sinalizador e podem aparecer no final da <ph id="ph4">`value`</ph> se <ph id="ph5">`style`</ph> inclui o <ph id="ph6">&lt;xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType&gt;</ph> sinalizador.</target>       </trans-unit>
        <trans-unit id="1362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles)">
          <source>A culture-specific currency symbol.</source>
          <target state="translated">Um símbolo de moeda específico de cultura.</target>       </trans-unit>
        <trans-unit id="1363" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles)">
          <source>Its position in the string is defined by the <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType&gt;</ph> properties of the current culture.</source>
          <target state="translated">A posição na cadeia de caracteres é definida pelas propriedades <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType&gt;</ph> e <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType&gt;</ph> da cultura atual.</target>       </trans-unit>
        <trans-unit id="1364" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles)">
          <source>The current culture's currency symbol can appear in <ph id="ph1">`value`</ph> if <ph id="ph2">`style`</ph> includes the <ph id="ph3">&lt;xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">O símbolo de moeda da cultura atual pode ser exibido em <ph id="ph1">`value`</ph> caso <ph id="ph2">`style`</ph> inclua o sinalizador <ph id="ph3">&lt;xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1365" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles)">
          <source><bpt id="p1">*</bpt>sign<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>sign<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="1366" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles)">
          <source>An optional sign.</source>
          <target state="translated">Um sinal opcional.</target>       </trans-unit>
        <trans-unit id="1367" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles)">
          <source>The sign can appear at the start of <ph id="ph1">`value`</ph> if <ph id="ph2">`style`</ph> includes the <ph id="ph3">&lt;xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType&gt;</ph> flag, and it can appear at the end of <ph id="ph4">`value`</ph> if <ph id="ph5">`style`</ph> includes the <ph id="ph6">&lt;xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">O sinal pode ser exibido no início de <ph id="ph1">`value`</ph> caso <ph id="ph2">`style`</ph> inclua o sinalizador <ph id="ph3">&lt;xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType&gt;</ph> e ele pode ser exibido no final de <ph id="ph4">`value`</ph> caso <ph id="ph5">`style`</ph> inclua o sinalizador <ph id="ph6">&lt;xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1368" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles)">
          <source>Parentheses can be used in <ph id="ph1">`value`</ph> to indicate a negative value if <ph id="ph2">`style`</ph> includes the <ph id="ph3">&lt;xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Os parênteses podem ser usados em <ph id="ph1">`value`</ph> para indicar um valor negativo caso <ph id="ph2">`style`</ph> inclua o sinalizador <ph id="ph3">&lt;xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1369" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles)">
          <source><bpt id="p1">*</bpt>digits<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>digits<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="1370" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles)">
          <source><bpt id="p1">*</bpt>fractional_digits<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>fractional_digits<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="1371" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles)">
          <source><bpt id="p1">*</bpt>exponential_digits<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>exponential_digits<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="1372" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles)">
          <source>A sequence of digits from 0 through 9.</source>
          <target state="translated">Uma sequência de dígitos de 0 a 9.</target>       </trans-unit>
        <trans-unit id="1373" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles)">
          <source>For <bpt id="p1">*</bpt>fractional_digits<ept id="p1">*</ept>, only the digit 0 is valid.</source>
          <target state="translated">Para <bpt id="p1">*</bpt>fractional_digits<ept id="p1">*</ept>, somente os dígitos 0 é válido.</target>       </trans-unit>
        <trans-unit id="1374" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles)">
          <source><bpt id="p1">*</bpt>,<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>,<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="1375" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles)">
          <source>A culture-specific group separator symbol.</source>
          <target state="translated">Um símbolo de separador do grupo específico da cultura.</target>       </trans-unit>
        <trans-unit id="1376" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles)">
          <source>The current culture's group separator can appear in <ph id="ph1">`value`</ph> if <ph id="ph2">`style`</ph> includes the <ph id="ph3">&lt;xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Separador de grupo da cultura atual pode aparecer em <ph id="ph1">`value`</ph> se <ph id="ph2">`style`</ph> inclui o <ph id="ph3">&lt;xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType&gt;</ph> sinalizador.</target>       </trans-unit>
        <trans-unit id="1377" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles)">
          <source><bpt id="p1">*</bpt>.<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>.<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="1378" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles)">
          <source>A culture-specific decimal point symbol.</source>
          <target state="translated">Um símbolo de vírgula decimal específico de cultura.</target>       </trans-unit>
        <trans-unit id="1379" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles)">
          <source>The current culture's decimal point symbol can appear in <ph id="ph1">`value`</ph> if <ph id="ph2">`style`</ph> includes the <ph id="ph3">&lt;xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">O símbolo da vírgula decimal da cultura atual pode ser exibido em <ph id="ph1">`value`</ph> caso <ph id="ph2">`style`</ph> inclua o sinalizador <ph id="ph3">&lt;xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1380" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles)">
          <source>Only the digit 0 can appear as a fractional digit for the parse operation to succeed; if <bpt id="p1">*</bpt>fractional_digits<ept id="p1">*</ept> includes any other digit, a <ph id="ph1">&lt;xref:System.FormatException&gt;</ph> is thrown.</source>
          <target state="translated">Somente os dígitos 0 podem ser exibido como um dígito de fração para a operação de análise ter êxito; Se <bpt id="p1">*</bpt>fractional_digits<ept id="p1">*</ept> inclui qualquer dígito, um <ph id="ph1">&lt;xref:System.FormatException&gt;</ph> é gerada.</target>       </trans-unit>
        <trans-unit id="1381" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles)">
          <source>E</source>
          <target state="translated">E</target>       </trans-unit>
        <trans-unit id="1382" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles)">
          <source>The "e" or "E" character, which indicates that the value is represented in exponential (scientific) notation.</source>
          <target state="translated">O caractere "e" ou "E", que indica que o valor é representado em notação exponencial (científica).</target>       </trans-unit>
        <trans-unit id="1383" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles)">
          <source>The <ph id="ph1">`value`</ph> parameter can represent a number in exponential notation if <ph id="ph2">`style`</ph> includes the <ph id="ph3">&lt;xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">O parâmetro <ph id="ph1">`value`</ph> pode representar um número em notação exponencial caso <ph id="ph2">`style`</ph> inclua o sinalizador <ph id="ph3">&lt;xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1384" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles)">
          <source><bpt id="p1">*</bpt>hexdigits<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>hexdigits<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="1385" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles)">
          <source>A sequence of hexadecimal digits from 0 through f, or 0 through F.</source>
          <target state="translated">Uma sequência de dígitos hexadecimais de 0 a f ou de 0 a F.</target>       </trans-unit>
        <trans-unit id="1386" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles)">
          <source>A string with digits only (which corresponds to the <ph id="ph1">&lt;xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType&gt;</ph> style) always parses successfully.</source>
          <target state="translated">Uma cadeia de caracteres apenas com dígitos (que corresponde ao estilo <ph id="ph1">&lt;xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType&gt;</ph> ) sempre é analisada com êxito.</target>       </trans-unit>
        <trans-unit id="1387" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles)">
          <source>Most of the remaining <ph id="ph1">&lt;xref:System.Globalization.NumberStyles&gt;</ph> members control elements that may be present, but are not required to be present, in the input string.</source>
          <target state="translated">A maioria dos elementos de controle de membros <ph id="ph1">&lt;xref:System.Globalization.NumberStyles&gt;</ph> restantes que podem estar presentes, mas que não precisam estar presentes, na cadeia de caracteres de entrada.</target>       </trans-unit>
        <trans-unit id="1388" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles)">
          <source>The following table indicates how individual <ph id="ph1">&lt;xref:System.Globalization.NumberStyles&gt;</ph> members affect the elements that may be present in <ph id="ph2">`value`</ph>.</source>
          <target state="translated">A tabela a seguir indica como os membros <ph id="ph1">&lt;xref:System.Globalization.NumberStyles&gt;</ph> individuais afetam os elementos que podem estar presentes em <ph id="ph2">`value`</ph>.</target>       </trans-unit>
        <trans-unit id="1389" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles)">
          <source><ph id="ph1">`NumberStyles`</ph> value</source>
          <target state="translated">Valor <ph id="ph1">`NumberStyles`</ph></target>       </trans-unit>
        <trans-unit id="1390" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles)">
          <source>Elements permitted in <ph id="ph1">`value`</ph> in addition to digits</source>
          <target state="translated">Elementos permitidos em <ph id="ph1">`value`</ph> além de dígitos</target>       </trans-unit>
        <trans-unit id="1391" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles)">
          <source>The <bpt id="p1">*</bpt>digits<ept id="p1">*</ept> element only.</source>
          <target state="translated">O <bpt id="p1">*</bpt>dígitos<ept id="p1">*</ept> apenas do elemento.</target>       </trans-unit>
        <trans-unit id="1392" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles)">
          <source>The decimal point (.) and <bpt id="p1">*</bpt>fractional-digits<ept id="p1">*</ept> elements.</source>
          <target state="translated">Decimal de ponto (.) e <bpt id="p1">*</bpt>dígitos fracionários<ept id="p1">*</ept> elementos.</target>       </trans-unit>
        <trans-unit id="1393" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles)">
          <source>The "e" or "E" character, which indicates exponential notation, along with <bpt id="p1">*</bpt>exponential_digits<ept id="p1">*</ept>.</source>
          <target state="translated">O "e" ou o caractere "E", que indica a notação exponencial, juntamente com <bpt id="p1">*</bpt>exponential_digits<ept id="p1">*</ept>.</target>       </trans-unit>
        <trans-unit id="1394" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles)">
          <source>The <bpt id="p1">*</bpt>ws<ept id="p1">*</ept> element at the start of <ph id="ph1">`value`</ph>.</source>
          <target state="translated">O <bpt id="p1">*</bpt>ws<ept id="p1">*</ept> elemento no início de <ph id="ph1">`value`</ph>.</target>       </trans-unit>
        <trans-unit id="1395" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles)">
          <source>The <bpt id="p1">*</bpt>ws<ept id="p1">*</ept> element at the end of <ph id="ph1">`value`</ph>.</source>
          <target state="translated">O elemento <bpt id="p1">*</bpt>ws<ept id="p1">*</ept> no final de <ph id="ph1">`value`</ph>.</target>       </trans-unit>
        <trans-unit id="1396" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles)">
          <source>The <bpt id="p1">*</bpt>sign<ept id="p1">*</ept> element at the start of <ph id="ph1">`value`</ph>.</source>
          <target state="translated">O <bpt id="p1">*</bpt>sinal<ept id="p1">*</ept> elemento no início de <ph id="ph1">`value`</ph>.</target>       </trans-unit>
        <trans-unit id="1397" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles)">
          <source>The <bpt id="p1">*</bpt>sign<ept id="p1">*</ept> element at the end of <ph id="ph1">`value`</ph>.</source>
          <target state="translated">O elemento <bpt id="p1">*</bpt>sinal<ept id="p1">*</ept> no final de <ph id="ph1">`value`</ph>.</target>       </trans-unit>
        <trans-unit id="1398" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles)">
          <source>The <bpt id="p1">*</bpt>sign<ept id="p1">*</ept> element in the form of parentheses enclosing the numeric value.</source>
          <target state="translated">O elemento <bpt id="p1">*</bpt>sinal<ept id="p1">*</ept> na forma de parênteses que incluem o valor numérico.</target>       </trans-unit>
        <trans-unit id="1399" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles)">
          <source>The group separator (,) element.</source>
          <target state="translated">O elemento separador do grupo (,).</target>       </trans-unit>
        <trans-unit id="1400" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles)">
          <source>The currency ($) element.</source>
          <target state="translated">O elemento de moeda ($).</target>       </trans-unit>
        <trans-unit id="1401" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles)">
          <source>All elements.</source>
          <target state="translated">Todos os elementos.</target>       </trans-unit>
        <trans-unit id="1402" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles)">
          <source>However, <ph id="ph1">`value`</ph> cannot represent a hexadecimal number or a number in exponential notation.</source>
          <target state="translated">No entanto, <ph id="ph1">`value`</ph> não pode representar um número hexadecimal ou um número em notação exponencial.</target>       </trans-unit>
        <trans-unit id="1403" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles)">
          <source>The <bpt id="p1">*</bpt>ws<ept id="p1">*</ept> element at the start or end of <ph id="ph1">`value`</ph>, <bpt id="p2">*</bpt>sign<ept id="p2">*</ept> at the start of <ph id="ph2">`value`</ph>, and the decimal point (<bpt id="p3">*</bpt>.<ept id="p3">*</ept>) symbol.</source>
          <target state="translated">O <bpt id="p1">*</bpt>ws<ept id="p1">*</ept> elemento no início ou no final de <ph id="ph1">`value`</ph>, <bpt id="p2">*</bpt>sinal<ept id="p2">*</ept> no início de <ph id="ph2">`value`</ph>e o ponto decimal (<bpt id="p3">*</bpt>.<ept id="p3">*</ept>) símbolo.</target>       </trans-unit>
        <trans-unit id="1404" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles)">
          <source>The <ph id="ph1">`value`</ph> parameter can also use exponential notation.</source>
          <target state="translated">O parâmetro <ph id="ph1">`value`</ph> também pode usar notação exponencial.</target>       </trans-unit>
        <trans-unit id="1405" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles)">
          <source>The <ph id="ph1">`ws`</ph>, <ph id="ph2">`sign`</ph>, group separator (<bpt id="p1">*</bpt>,<ept id="p1">*</ept>), and decimal point (<bpt id="p2">*</bpt>.<ept id="p2">*</ept>) elements.</source>
          <target state="translated">O <ph id="ph1">`ws`</ph>, <ph id="ph2">`sign`</ph>, separador de grupo (<bpt id="p1">*</bpt>,<ept id="p1">*</ept>) e o ponto decimal (<bpt id="p2">*</bpt>.<ept id="p2">*</ept>) elementos.</target>       </trans-unit>
        <trans-unit id="1406" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles)">
          <source>All elements.</source>
          <target state="translated">Todos os elementos.</target>       </trans-unit>
        <trans-unit id="1407" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles)">
          <source>However, <ph id="ph1">`value`</ph> cannot represent a hexadecimal number.</source>
          <target state="translated">No entanto, <ph id="ph1">`value`</ph> não pode representar um número hexadecimal.</target>       </trans-unit>
        <trans-unit id="1408" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles)">
          <source>If you use the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Parse%2A&gt;</ph> method to round-trip the string representation of a <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> value that was output by the <ph id="ph3">&lt;xref:System.Numerics.BigInteger.ToString%2A&gt;</ph> method, you should use the <ph id="ph4">&lt;xref:System.Numerics.BigInteger.ToString%28System.String%29?displayProperty=nameWithType&gt;</ph> method with the "R" format specifier to generate the string representation of the <ph id="ph5">&lt;xref:System.Numerics.BigInteger&gt;</ph> value.</source>
          <target state="translated">Se você usar o <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Parse%2A&gt;</ph> método viagem a representação de cadeia de caracteres de um <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> valor foi saída o <ph id="ph3">&lt;xref:System.Numerics.BigInteger.ToString%2A&gt;</ph> método, você deve usar o <ph id="ph4">&lt;xref:System.Numerics.BigInteger.ToString%28System.String%29?displayProperty=nameWithType&gt;</ph> método com o especificador de formato "R" para gerar a representação de cadeia de caracteres da <ph id="ph5">&lt;xref:System.Numerics.BigInteger&gt;</ph> valor.</target>       </trans-unit>
        <trans-unit id="1409" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles)">
          <source>Otherwise, the string representation of the <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> preserves only the 50 most significant digits of the original value, and data may be lost when you use the <ph id="ph2">&lt;xref:System.Numerics.BigInteger.Parse%2A&gt;</ph> method to restore the <ph id="ph3">&lt;xref:System.Numerics.BigInteger&gt;</ph> value.</source>
          <target state="translated">Caso contrário, a representação de cadeia de caracteres da <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> preserva apenas os 50 dígitos significativos do valor original e dados podem ser perdidos quando você usa o <ph id="ph2">&lt;xref:System.Numerics.BigInteger.Parse%2A&gt;</ph> método para restaurar o <ph id="ph3">&lt;xref:System.Numerics.BigInteger&gt;</ph> valor.</target>       </trans-unit>
        <trans-unit id="1410" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles)">
          <source>Unlike the other <ph id="ph1">&lt;xref:System.Globalization.NumberStyles&gt;</ph> values, which allow for, but do not require, the presence of particular style elements in <ph id="ph2">`value`</ph>, the <ph id="ph3">&lt;xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType&gt;</ph> style value means that the individual numeric characters in <ph id="ph4">`value`</ph> are always interpreted as hexadecimal characters.</source>
          <target state="translated">Ao contrário de outros <ph id="ph1">&lt;xref:System.Globalization.NumberStyles&gt;</ph> valores, que permitem, mas não exigem a presença de elementos de estilo específico <ph id="ph2">`value`</ph>, o <ph id="ph3">&lt;xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType&gt;</ph> valor de estilo significa que os caracteres individuais nos <ph id="ph4">`value`</ph> sempre são interpretados como caracteres hexadecimais.</target>       </trans-unit>
        <trans-unit id="1411" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles)">
          <source>Valid hexadecimal characters are 0-9, A-F, and a-f.</source>
          <target state="translated">Os caracteres hexadecimais válidos são 0-9, A-F e a-f.</target>       </trans-unit>
        <trans-unit id="1412" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles)">
          <source>The only other flags that can be combined with the <ph id="ph1">`style`</ph> parameter are <ph id="ph2">&lt;xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType&gt;</ph> and <ph id="ph3">&lt;xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Os únicos outros sinalizadores que podem ser combinados com o parâmetro <ph id="ph1">`style`</ph> são <ph id="ph2">&lt;xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType&gt;</ph> e <ph id="ph3">&lt;xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1413" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles)">
          <source>(The <ph id="ph1">&lt;xref:System.Globalization.NumberStyles&gt;</ph> enumeration includes a composite number style, <ph id="ph2">&lt;xref:System.Globalization.NumberStyles.HexNumber&gt;</ph>, that includes both white-space flags.)</source>
          <target state="translated">(A enumeração de <ph id="ph1">&lt;xref:System.Globalization.NumberStyles&gt;</ph> inclui um estilo de número composto, <ph id="ph2">&lt;xref:System.Globalization.NumberStyles.HexNumber&gt;</ph>, que inclui ambos os sinalizadores de espaço em branco.)</target>       </trans-unit>
        <trans-unit id="1414" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles)">
          <source>If <ph id="ph1">`value`</ph> is the string representation of a hexadecimal number, it cannot be preceded by any decoration (such as <ph id="ph2">`0x`</ph> or <ph id="ph3">`&amp;h`</ph>) that differentiates it as a hexadecimal number.</source>
          <target state="translated">Caso <ph id="ph1">`value`</ph> seja a representação da cadeia de caracteres de um número hexadecimal, ele não pode ser precedido por qualquer decoração (como <ph id="ph2">`0x`</ph> ou <ph id="ph3">`&amp;h`</ph>) que o diferencia como um número hexadecimal.</target>       </trans-unit>
        <trans-unit id="1415" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles)">
          <source>This causes the conversion to fail.</source>
          <target state="translated">Isso faz a conversão falhar.</target>       </trans-unit>
        <trans-unit id="1416" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles)">
          <source>If <ph id="ph1">`value`</ph> is a hexadecimal string, the <ph id="ph2">&lt;xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%29&gt;</ph> method interprets <ph id="ph3">`value`</ph> as a negative number stored by using two's complement representation if its first two hexadecimal digits are greater than or equal to <ph id="ph4">`0x80`</ph>.</source>
          <target state="translated">Se <ph id="ph1">`value`</ph> é uma cadeia de caracteres hexadecimal de <ph id="ph2">&lt;xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%29&gt;</ph> método interpreta <ph id="ph3">`value`</ph> como um número negativo armazenado usando representação de complemento de dois, se seu primeiro de dois dígitos hexadecimais forem maior que ou igual a <ph id="ph4">`0x80`</ph>.</target>       </trans-unit>
        <trans-unit id="1417" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles)">
          <source>In other words, the method interprets the highest-order bit of the first byte in <ph id="ph1">`value`</ph> as the sign bit.</source>
          <target state="translated">Em outras palavras, o método interpreta o bit de ordem mais alta do primeiro byte no <ph id="ph1">`value`</ph> como o bit de sinal.</target>       </trans-unit>
        <trans-unit id="1418" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles)">
          <source>To make sure that a hexadecimal string is correctly interpreted as a positive number, the first digit in <ph id="ph1">`value`</ph> must have a value of zero.</source>
          <target state="translated">Para certificar-se de que uma cadeia de caracteres hexadecimal é interpretada corretamente como um número positivo, o primeiro dígito em <ph id="ph1">`value`</ph> deve ter um valor de zero.</target>       </trans-unit>
        <trans-unit id="1419" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles)">
          <source>For example, the method interprets <ph id="ph1">`0x80`</ph> as a negative value, but it interprets either <ph id="ph2">`0x080`</ph> or <ph id="ph3">`0x0080`</ph> as a positive value.</source>
          <target state="translated">Por exemplo, o método interpreta <ph id="ph1">`0x80`</ph> como um valor negativo, mas ele interpreta o <ph id="ph2">`0x080`</ph> ou <ph id="ph3">`0x0080`</ph> como um valor positivo.</target>       </trans-unit>
        <trans-unit id="1420" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles)">
          <source>The following example illustrates the difference between hexadecimal strings that represent negative and positive values.</source>
          <target state="translated">O exemplo a seguir ilustra a diferença entre cadeias de caracteres hexadecimais que representam valores negativos e positivos.</target>       </trans-unit>
        <trans-unit id="1421" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles)">
          <source>The <ph id="ph1">`value`</ph> parameter is parsed by using the formatting information in a <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object that is initialized for the current system culture.</source>
          <target state="translated">O parâmetro <ph id="ph1">`value`</ph> é analisado usando-se as informações de formatação em um objeto <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> que é inicializado para a cultura do sistema atual.</target>       </trans-unit>
        <trans-unit id="1422" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles)">
          <source>To specify the culture whose formatting information is used for the parse operation, call the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29&gt;</ph> overload.</source>
          <target state="translated">Para especificar a cultura cujas informações de formatação são usadas para a operação de análise, chame o <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29&gt;</ph> sobrecarga.</target>       </trans-unit>
        <trans-unit id="1423" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles)">
          <source>The following example illustrates calls to the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%29&gt;</ph> method with several possible values for the <ph id="ph2">`style`</ph> parameter.</source>
          <target state="translated">O exemplo a seguir ilustra chamadas para o <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%29&gt;</ph> método com vários valores possíveis para a <ph id="ph2">`style`</ph> parâmetro.</target>       </trans-unit>
        <trans-unit id="1424" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles)">
          <source>It illustrates how to interpret a string as a hexadecimal value, and how to disallow spaces and sign symbols.</source>
          <target state="translated">Ele ilustra como uma cadeia de caracteres como um valor hexadecimal de interpretar e como não permitir espaços e assinar os símbolos.</target>       </trans-unit>
        <trans-unit id="1425" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles)">
          <source><ph id="ph1">&lt;paramref name="style" /&gt;</ph> is not a <ph id="ph2">&lt;see cref="T:System.Globalization.NumberStyles" /&gt;</ph> value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="style" /&gt;</ph> não é um valor <ph id="ph2">&lt;see cref="T:System.Globalization.NumberStyles" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1426" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1427" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles)">
          <source><ph id="ph1">&lt;paramref name="style" /&gt;</ph> includes the <ph id="ph2">&lt;see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" /&gt;</ph> or <ph id="ph3">&lt;see cref="F:System.Globalization.NumberStyles.HexNumber" /&gt;</ph> flag along with another value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="style" /&gt;</ph> inclui o sinalizador <ph id="ph2">&lt;see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" /&gt;</ph> ou <ph id="ph3">&lt;see cref="F:System.Globalization.NumberStyles.HexNumber" /&gt;</ph> em conjunto com outro valor.</target>       </trans-unit>
        <trans-unit id="1428" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1429" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> does not comply with the input pattern specified by <ph id="ph2">&lt;see cref="T:System.Globalization.NumberStyles" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> não é compatível com o padrão de entrada especificado por <ph id="ph2">&lt;see cref="T:System.Globalization.NumberStyles" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1430" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.Parse(System.String,System.IFormatProvider)">
          <source>A string that contains a number to convert.</source>
          <target state="translated">Uma cadeia de caracteres que contém um número a ser convertido.</target>       </trans-unit>
        <trans-unit id="1431" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.Parse(System.String,System.IFormatProvider)">
          <source>An object that provides culture-specific formatting information about <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Um objeto que fornece informações de formatação específicas de cultura sobre <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="1432" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.Parse(System.String,System.IFormatProvider)">
          <source>Converts the string representation of a number in a specified culture-specific format to its <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> equivalent.</source>
          <target state="translated">Converte a representação de cadeia de caracteres de um número em um formato específico da cultura especificado em seu equivalente de <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1433" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.Parse(System.String,System.IFormatProvider)">
          <source>A value that is equivalent to the number specified in the <ph id="ph1">&lt;paramref name="value" /&gt;</ph> parameter.</source>
          <target state="translated">Um valor equivalente ao número especificado no parâmetro <ph id="ph1">&lt;paramref name="value" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1434" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.IFormatProvider)">
          <source>The <ph id="ph1">`value`</ph> parameter should be the string representation of a number in the following form:</source>
          <target state="translated">O <ph id="ph1">`value`</ph> parâmetro deve ser a representação de cadeia de caracteres de um número no seguinte formato:</target>       </trans-unit>
        <trans-unit id="1435" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.IFormatProvider)">
          <source>[<bpt id="p1">*</bpt>ws<ept id="p1">*</ept>][<bpt id="p2">*</bpt>sign<ept id="p2">*</ept>]<bpt id="p3">*</bpt>digits<ept id="p3">*</ept>[<bpt id="p4">*</bpt>ws<ept id="p4">*</ept>]</source>
          <target state="translated">[<bpt id="p1">*</bpt>ws<ept id="p1">*</ept>][<bpt id="p2">*</bpt>sign<ept id="p2">*</ept>]<bpt id="p3">*</bpt>digits<ept id="p3">*</ept>[<bpt id="p4">*</bpt>ws<ept id="p4">*</ept>]</target>       </trans-unit>
        <trans-unit id="1436" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.IFormatProvider)">
          <source>Elements in square brackets ([ and ]) are optional.</source>
          <target state="translated">Os elementos entre colchetes ([ e ]) são opcionais.</target>       </trans-unit>
        <trans-unit id="1437" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.IFormatProvider)">
          <source>The following table describes each element.</source>
          <target state="translated">A tabela a seguir descreve cada elemento.</target>       </trans-unit>
        <trans-unit id="1438" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.IFormatProvider)">
          <source>Element</source>
          <target state="translated">Elemento</target>       </trans-unit>
        <trans-unit id="1439" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.IFormatProvider)">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="1440" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.IFormatProvider)">
          <source><bpt id="p1">*</bpt>ws<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>ws<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="1441" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.IFormatProvider)">
          <source>Optional white space.</source>
          <target state="translated">Espaço em branco opcional.</target>       </trans-unit>
        <trans-unit id="1442" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.IFormatProvider)">
          <source><bpt id="p1">*</bpt>sign<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>sign<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="1443" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.IFormatProvider)">
          <source>An optional sign.</source>
          <target state="translated">Um sinal opcional.</target>       </trans-unit>
        <trans-unit id="1444" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.IFormatProvider)">
          <source>Valid sign characters are determined by the <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo.PositiveSign%2A?displayProperty=nameWithType&gt;</ph> properties of the <ph id="ph3">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object that is returned by the <ph id="ph4">`provider`</ph> object's <ph id="ph5">&lt;xref:System.IFormatProvider.GetFormat%2A&gt;</ph> method.</source>
          <target state="translated">Caracteres de entrada válida são determinados pelo <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType&gt;</ph> e <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo.PositiveSign%2A?displayProperty=nameWithType&gt;</ph> propriedades do <ph id="ph3">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> objeto que é retornado pelo <ph id="ph4">`provider`</ph> do objeto <ph id="ph5">&lt;xref:System.IFormatProvider.GetFormat%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="1445" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.IFormatProvider)">
          <source><bpt id="p1">*</bpt>digits<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>digits<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="1446" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.IFormatProvider)">
          <source>A sequence of digits ranging from 0 to 9.</source>
          <target state="translated">Uma sequência de dígitos que varia de 0 a 9.</target>       </trans-unit>
        <trans-unit id="1447" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.IFormatProvider)">
          <source>Any leading zeros are ignored.</source>
          <target state="translated">Todos os zeros à esquerda são ignorados.</target>       </trans-unit>
        <trans-unit id="1448" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.IFormatProvider)">
          <source>The string specified by the <ph id="ph1">`value`</ph> parameter is interpreted using the <ph id="ph2">&lt;xref:System.Globalization.NumberStyles.Integer?displayProperty=nameWithType&gt;</ph> style.</source>
          <target state="translated">A cadeia de caracteres especificada pelo <ph id="ph1">`value`</ph> parâmetro é interpretado usando o <ph id="ph2">&lt;xref:System.Globalization.NumberStyles.Integer?displayProperty=nameWithType&gt;</ph> estilo.</target>       </trans-unit>
        <trans-unit id="1449" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.IFormatProvider)">
          <source>It cannot contain any group separators or decimal separator, and it cannot have a decimal portion.</source>
          <target state="translated">Ele não pode conter nenhum separador de grupo ou decimal, e não pode ter uma parte decimal.</target>       </trans-unit>
        <trans-unit id="1450" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.IFormatProvider)">
          <source>If you use the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Parse%2A&gt;</ph> method to round-trip the string representation of a <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> value that was output by the <ph id="ph3">&lt;xref:System.Numerics.BigInteger.ToString%2A&gt;</ph> method, you should use the <ph id="ph4">&lt;xref:System.Numerics.BigInteger.ToString%28System.String%29?displayProperty=nameWithType&gt;</ph> method with the "R" format specifier to generate the string representation of the <ph id="ph5">&lt;xref:System.Numerics.BigInteger&gt;</ph> value.</source>
          <target state="translated">Se você usar o <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Parse%2A&gt;</ph> método viagem a representação de cadeia de caracteres de um <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> valor foi saída o <ph id="ph3">&lt;xref:System.Numerics.BigInteger.ToString%2A&gt;</ph> método, você deve usar o <ph id="ph4">&lt;xref:System.Numerics.BigInteger.ToString%28System.String%29?displayProperty=nameWithType&gt;</ph> método com o especificador de formato "R" para gerar a representação de cadeia de caracteres da <ph id="ph5">&lt;xref:System.Numerics.BigInteger&gt;</ph> valor.</target>       </trans-unit>
        <trans-unit id="1451" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.IFormatProvider)">
          <source>Otherwise, the string representation of the <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> preserves only the 50 most significant digits of the original value, and data may be lost when you use the <ph id="ph2">&lt;xref:System.Numerics.BigInteger.Parse%2A&gt;</ph> method to restore the <ph id="ph3">&lt;xref:System.Numerics.BigInteger&gt;</ph> value.</source>
          <target state="translated">Caso contrário, a representação de cadeia de caracteres da <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> preserva apenas os 50 dígitos significativos do valor original e dados podem ser perdidos quando você usa o <ph id="ph2">&lt;xref:System.Numerics.BigInteger.Parse%2A&gt;</ph> método para restaurar o <ph id="ph3">&lt;xref:System.Numerics.BigInteger&gt;</ph> valor.</target>       </trans-unit>
        <trans-unit id="1452" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.IFormatProvider)">
          <source>The <ph id="ph1">`provider`</ph> parameter is an <ph id="ph2">&lt;xref:System.IFormatProvider&gt;</ph> implementation whose <ph id="ph3">&lt;xref:System.IFormatProvider.GetFormat%2A&gt;</ph> method returns a <ph id="ph4">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object that provides culture-specific formatting information.</source>
          <target state="translated">O <ph id="ph1">`provider`</ph> parâmetro é um <ph id="ph2">&lt;xref:System.IFormatProvider&gt;</ph> implementação cujo <ph id="ph3">&lt;xref:System.IFormatProvider.GetFormat%2A&gt;</ph> método retorna um <ph id="ph4">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> objeto que fornece informações de formatação específica da cultura.</target>       </trans-unit>
        <trans-unit id="1453" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.IFormatProvider)">
          <source>When the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.IFormatProvider%29&gt;</ph> method is invoked, it calls the <ph id="ph2">`provider`</ph> parameter's <ph id="ph3">&lt;xref:System.IFormatProvider.GetFormat%2A&gt;</ph> method and passes it a <ph id="ph4">&lt;xref:System.Type&gt;</ph> object that represents the <ph id="ph5">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> type.</source>
          <target state="translated">Quando o <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.IFormatProvider%29&gt;</ph> método é invocado, ele chama o <ph id="ph2">`provider`</ph> do parâmetro <ph id="ph3">&lt;xref:System.IFormatProvider.GetFormat%2A&gt;</ph> método e o transmite um <ph id="ph4">&lt;xref:System.Type&gt;</ph> objeto que representa o <ph id="ph5">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> tipo.</target>       </trans-unit>
        <trans-unit id="1454" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.IFormatProvider)">
          <source>The <ph id="ph1">&lt;xref:System.IFormatProvider.GetFormat%2A&gt;</ph> method then returns the <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object that provides information about the format of the <ph id="ph3">`value`</ph> parameter.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.IFormatProvider.GetFormat%2A&gt;</ph> , em seguida, o método retorna o <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> objeto que fornece informações sobre o formato da <ph id="ph3">`value`</ph> parâmetro.</target>       </trans-unit>
        <trans-unit id="1455" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.IFormatProvider)">
          <source>There are three ways to use the <ph id="ph1">`provider`</ph> parameter to supply custom formatting information to the parse operation:</source>
          <target state="translated">Existem três maneiras de usar o parâmetro <ph id="ph1">`provider`</ph> para fornecer informações de formatação personalizadas para a operação de análise:</target>       </trans-unit>
        <trans-unit id="1456" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.IFormatProvider)">
          <source>You can pass a <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> object that represents the culture that supplies formatting information.</source>
          <target state="translated">É possível passar um objeto <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> que representa a cultura que fornece informações de formatação.</target>       </trans-unit>
        <trans-unit id="1457" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.IFormatProvider)">
          <source>Its <ph id="ph1">&lt;xref:System.Globalization.CultureInfo.GetFormat%2A&gt;</ph> method returns the <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object that provides numeric formatting information for that culture.</source>
          <target state="translated">O método <ph id="ph1">&lt;xref:System.Globalization.CultureInfo.GetFormat%2A&gt;</ph> retorna o objeto <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> que fornece informações de formatação numérica para essa cultura.</target>       </trans-unit>
        <trans-unit id="1458" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.IFormatProvider)">
          <source>You can pass the actual <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object that provides numeric formatting information.</source>
          <target state="translated">É possível passar o objeto real <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> que fornece informações de formatação numérica.</target>       </trans-unit>
        <trans-unit id="1459" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.IFormatProvider)">
          <source>(Its implementation of <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo.GetFormat%2A&gt;</ph> just returns itself.)</source>
          <target state="translated">(Sua implementação de <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo.GetFormat%2A&gt;</ph> retorna apenas ele próprio.)</target>       </trans-unit>
        <trans-unit id="1460" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.IFormatProvider)">
          <source>You can pass a custom object that implements <ph id="ph1">&lt;xref:System.IFormatProvider&gt;</ph>.</source>
          <target state="translated">É possível passar um objeto personalizado que implementa <ph id="ph1">&lt;xref:System.IFormatProvider&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1461" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.IFormatProvider)">
          <source>Its <ph id="ph1">&lt;xref:System.IFormatProvider.GetFormat%2A&gt;</ph> method instantiates and returns the <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object that provides formatting information.</source>
          <target state="translated">O método <ph id="ph1">&lt;xref:System.IFormatProvider.GetFormat%2A&gt;</ph> cria uma instância e retorna o objeto <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> que fornece informações de formatação.</target>       </trans-unit>
        <trans-unit id="1462" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.IFormatProvider)">
          <source>If <ph id="ph1">`provider`</ph> is <ph id="ph2">`null`</ph>, the formatting of <ph id="ph3">`value`</ph> is interpreted based on the <ph id="ph4">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object of the current culture.</source>
          <target state="translated">Se <ph id="ph1">`provider`</ph> é <ph id="ph2">`null`</ph>, a formatação de <ph id="ph3">`value`</ph> é interpretado com base no <ph id="ph4">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> objeto da cultura atual.</target>       </trans-unit>
        <trans-unit id="1463" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.IFormatProvider)">
          <source>The following examples show two ways to define the tilde (~) as a negative sign for formatting <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> values.</source>
          <target state="translated">Os exemplos a seguir mostram dois modos para definir o til (~) como um sinal negativo para formatação <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> valores.</target>       </trans-unit>
        <trans-unit id="1464" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.IFormatProvider)">
          <source>Note that to display the <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> values in the same format as the original strings, your code must call the <ph id="ph2">&lt;xref:System.Numerics.BigInteger.ToString%28System.IFormatProvider%29?displayProperty=nameWithType&gt;</ph> method and pass it the <ph id="ph3">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object that provides formatting information.</source>
          <target state="translated">Observe que para exibir o <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> valores no mesmo formato que as cadeias de caracteres originais, seu código deve chamar o <ph id="ph2">&lt;xref:System.Numerics.BigInteger.ToString%28System.IFormatProvider%29?displayProperty=nameWithType&gt;</ph> método e passá-lo a <ph id="ph3">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> objeto que fornece informações de formatação.</target>       </trans-unit>
        <trans-unit id="1465" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.IFormatProvider)">
          <source>The first example defines a class that implements <ph id="ph1">&lt;xref:System.IFormatProvider&gt;</ph> and uses the <ph id="ph2">&lt;xref:System.IFormatProvider.GetFormat%2A&gt;</ph> method to return the <ph id="ph3">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object that provides formatting information.</source>
          <target state="translated">O primeiro exemplo define uma classe que implementa <ph id="ph1">&lt;xref:System.IFormatProvider&gt;</ph> e usa o <ph id="ph2">&lt;xref:System.IFormatProvider.GetFormat%2A&gt;</ph> método para retornar o <ph id="ph3">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> objeto que fornece informações de formatação.</target>       </trans-unit>
        <trans-unit id="1466" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.IFormatProvider)">
          <source>A <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> object can then be instantiated with the following code:</source>
          <target state="translated">Um <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> objeto pode ser instanciado com o código a seguir:</target>       </trans-unit>
        <trans-unit id="1467" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.IFormatProvider)">
          <source>The second example is more straightforward.</source>
          <target state="translated">O segundo exemplo é mais simples.</target>       </trans-unit>
        <trans-unit id="1468" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.IFormatProvider)">
          <source>It passes the <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object that provides formatting information to the <ph id="ph2">`provider`</ph> parameter.</source>
          <target state="translated">Ele passa a <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> objeto que fornece informações de formatação para o <ph id="ph2">`provider`</ph> parâmetro.</target>       </trans-unit>
        <trans-unit id="1469" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.Parse(System.String,System.IFormatProvider)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1470" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.Parse(System.String,System.IFormatProvider)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is not in the correct format.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> não está no formato correto.</target>       </trans-unit>
        <trans-unit id="1471" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>A string that contains a number to convert.</source>
          <target state="translated">Uma cadeia de caracteres que contém um número a ser convertido.</target>       </trans-unit>
        <trans-unit id="1472" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>A bitwise combination of the enumeration values that specify the permitted format of <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Um combinação bit a bit de valores de enumeração que especificam o formato permitido de <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="1473" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>An object that provides culture-specific formatting information about <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Um objeto que fornece informações de formatação específicas de cultura sobre <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="1474" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>Converts the string representation of a number in a specified style and culture-specific format to its <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> equivalent.</source>
          <target state="translated">Converte a representação de cadeia de caracteres de um número com um estilo especificado e um formato específico à cultura para seu <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> equivalente.</target>       </trans-unit>
        <trans-unit id="1475" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>A value that is equivalent to the number specified in the <ph id="ph1">&lt;paramref name="value" /&gt;</ph> parameter.</source>
          <target state="translated">Um valor equivalente ao número especificado no parâmetro <ph id="ph1">&lt;paramref name="value" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1476" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>The <ph id="ph1">`style`</ph> parameter defines the style elements (such as white space, the positive or negative sign symbol, the group separator symbol, or the decimal point symbol) that are allowed in the <ph id="ph2">`value`</ph> parameter for the parse operation to succeed.</source>
          <target state="translated">O <ph id="ph1">`style`</ph> parâmetro define os elementos de estilo (como o espaço em branco, o símbolo de sinal positivo ou negativo, o símbolo de separador de grupo ou o símbolo de ponto decimal) que são permitidos no <ph id="ph2">`value`</ph> parâmetro para o êxito da operação de análise.</target>       </trans-unit>
        <trans-unit id="1477" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source><ph id="ph1">`styles`</ph> must be a combination of bit flags from the <ph id="ph2">&lt;xref:System.Globalization.NumberStyles&gt;</ph> enumeration.</source>
          <target state="translated"><ph id="ph1">`styles`</ph> deve ser uma combinação de sinalizadores de bit do <ph id="ph2">&lt;xref:System.Globalization.NumberStyles&gt;</ph> enumeração.</target>       </trans-unit>
        <trans-unit id="1478" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>The <ph id="ph1">`style`</ph> parameter makes this method overload useful when <ph id="ph2">`value`</ph> contains the string representation of a hexadecimal value, when the number system (decimal or hexadecimal) represented by <ph id="ph3">`value`</ph> is known only at run time, or when you want to disallow white space or a sign symbol in <ph id="ph4">`value`</ph>.</source>
          <target state="translated">O <ph id="ph1">`style`</ph> parâmetro faz com que esse método de sobrecarga útil quando <ph id="ph2">`value`</ph> contém a representação de cadeia de caracteres de um valor hexadecimal, quando o sistema de número (decimal ou hexadecimal) representado por <ph id="ph3">`value`</ph> é conhecido apenas em tempo de execução, ou quando você deseja impedir que o espaço em branco ou um sinal de símbolo em <ph id="ph4">`value`</ph>.</target>       </trans-unit>
        <trans-unit id="1479" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>Depending on the value of <ph id="ph1">`style`</ph>, the <ph id="ph2">`value`</ph> parameter may include the following elements:</source>
          <target state="translated">Dependendo do valor de <ph id="ph1">`style`</ph>, o parâmetro <ph id="ph2">`value`</ph> pode incluir os seguintes elementos:</target>       </trans-unit>
        <trans-unit id="1480" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>[<bpt id="p1">*</bpt>ws<ept id="p1">*</ept>][<bpt id="p2">*</bpt><ph id="ph1">$</ph><ept id="p2">*</ept>][<bpt id="p3">*</bpt>sign<ept id="p3">*</ept>][<bpt id="p4">*</bpt>digits<ept id="p4">*</ept>,]<bpt id="p5">*</bpt>digits<ept id="p5">*</ept>[<bpt id="p6">*</bpt>.fractional_digits<ept id="p6">*</ept>][E[<bpt id="p7">*</bpt>sign<ept id="p7">*</ept>]<bpt id="p8">*</bpt>exponential_digits<ept id="p8">*</ept>][<bpt id="p9">*</bpt>ws<ept id="p9">*</ept>]</source>
          <target state="translated">[<bpt id="p1">*</bpt>ws<ept id="p1">*</ept>][<bpt id="p2">*</bpt><ph id="ph1">$</ph><ept id="p2">*</ept>][<bpt id="p3">*</bpt>sign<ept id="p3">*</ept>][<bpt id="p4">*</bpt>digits<ept id="p4">*</ept>,]<bpt id="p5">*</bpt>digits<ept id="p5">*</ept>[<bpt id="p6">*</bpt>.fractional_digits<ept id="p6">*</ept>][E[<bpt id="p7">*</bpt>sign<ept id="p7">*</ept>]<bpt id="p8">*</bpt>exponential_digits<ept id="p8">*</ept>][<bpt id="p9">*</bpt>ws<ept id="p9">*</ept>]</target>       </trans-unit>
        <trans-unit id="1481" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>If <ph id="ph1">`style`</ph> includes <ph id="ph2">&lt;xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType&gt;</ph>, the <ph id="ph3">`value`</ph> parameter may include the following elements:</source>
          <target state="translated">Se <ph id="ph1">`style`</ph> inclui <ph id="ph2">&lt;xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType&gt;</ph>, o <ph id="ph3">`value`</ph> parâmetro pode incluir os seguintes elementos:</target>       </trans-unit>
        <trans-unit id="1482" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>[<bpt id="p1">*</bpt>ws<ept id="p1">*</ept>]<bpt id="p2">*</bpt>hexdigits<ept id="p2">*</ept>[<bpt id="p3">*</bpt>ws<ept id="p3">*</ept>]</source>
          <target state="translated">[<bpt id="p1">*</bpt>ws<ept id="p1">*</ept>]<bpt id="p2">*</bpt>hexdigits<ept id="p2">*</ept>[<bpt id="p3">*</bpt>ws<ept id="p3">*</ept>]</target>       </trans-unit>
        <trans-unit id="1483" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>Elements in square brackets ([ and ]) are optional.</source>
          <target state="translated">Os elementos entre colchetes ([ e ]) são opcionais.</target>       </trans-unit>
        <trans-unit id="1484" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>The following table describes each element.</source>
          <target state="translated">A tabela a seguir descreve cada elemento.</target>       </trans-unit>
        <trans-unit id="1485" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>Element</source>
          <target state="translated">Elemento</target>       </trans-unit>
        <trans-unit id="1486" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="1487" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source><bpt id="p1">*</bpt>ws<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>ws<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="1488" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>Optional white space.</source>
          <target state="translated">Espaço em branco opcional.</target>       </trans-unit>
        <trans-unit id="1489" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>White space can appear at the start of <ph id="ph1">`value`</ph> if <ph id="ph2">`style`</ph> includes the <ph id="ph3">&lt;xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType&gt;</ph> flag, and it can appear at the end of <ph id="ph4">`value`</ph> if <ph id="ph5">`style`</ph> includes the <ph id="ph6">&lt;xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Espaço em branco pode aparecer no início de <ph id="ph1">`value`</ph> se <ph id="ph2">`style`</ph> inclui o <ph id="ph3">&lt;xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType&gt;</ph> sinalizador e podem aparecer no final da <ph id="ph4">`value`</ph> se <ph id="ph5">`style`</ph> inclui o <ph id="ph6">&lt;xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType&gt;</ph> sinalizador.</target>       </trans-unit>
        <trans-unit id="1490" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>A culture-specific currency symbol.</source>
          <target state="translated">Um símbolo de moeda específico de cultura.</target>       </trans-unit>
        <trans-unit id="1491" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>Its position in the string is defined by the <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType&gt;</ph> properties of the culture indicated by the <ph id="ph3">`provider`</ph> parameter.</source>
          <target state="translated">Sua posição na cadeia de caracteres é definida pelo <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType&gt;</ph> e <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType&gt;</ph> propriedades de cultura indicado pelo <ph id="ph3">`provider`</ph> parâmetro.</target>       </trans-unit>
        <trans-unit id="1492" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>The current culture's currency symbol can appear in <ph id="ph1">`value`</ph> if <ph id="ph2">`style`</ph> includes the <ph id="ph3">&lt;xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">O símbolo de moeda da cultura atual pode ser exibido em <ph id="ph1">`value`</ph> caso <ph id="ph2">`style`</ph> inclua o sinalizador <ph id="ph3">&lt;xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1493" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source><bpt id="p1">*</bpt>sign<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>sign<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="1494" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>An optional sign.</source>
          <target state="translated">Um sinal opcional.</target>       </trans-unit>
        <trans-unit id="1495" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>The sign can appear at the start of <ph id="ph1">`value`</ph> if <ph id="ph2">`style`</ph> includes the <ph id="ph3">&lt;xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType&gt;</ph> flag, and it can appear at the end of <ph id="ph4">`value`</ph> if <ph id="ph5">`style`</ph> includes the <ph id="ph6">&lt;xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">O sinal pode ser exibido no início de <ph id="ph1">`value`</ph> caso <ph id="ph2">`style`</ph> inclua o sinalizador <ph id="ph3">&lt;xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType&gt;</ph> e ele pode ser exibido no final de <ph id="ph4">`value`</ph> caso <ph id="ph5">`style`</ph> inclua o sinalizador <ph id="ph6">&lt;xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1496" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>Parentheses can be used in <ph id="ph1">`value`</ph> to indicate a negative value if <ph id="ph2">`style`</ph> includes the <ph id="ph3">&lt;xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Os parênteses podem ser usados em <ph id="ph1">`value`</ph> para indicar um valor negativo caso <ph id="ph2">`style`</ph> inclua o sinalizador <ph id="ph3">&lt;xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1497" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source><bpt id="p1">*</bpt>digits<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>digits<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="1498" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source><bpt id="p1">*</bpt>fractional_digits<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>fractional_digits<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="1499" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source><bpt id="p1">*</bpt>exponential_digits<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>exponential_digits<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="1500" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>A sequence of digits from 0 through 9.</source>
          <target state="translated">Uma sequência de dígitos de 0 a 9.</target>       </trans-unit>
        <trans-unit id="1501" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>For <bpt id="p1">*</bpt>fractional_digits<ept id="p1">*</ept>, only the digit 0 is valid.</source>
          <target state="translated">Para <bpt id="p1">*</bpt>fractional_digits<ept id="p1">*</ept>, somente os dígitos 0 é válido.</target>       </trans-unit>
        <trans-unit id="1502" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source><bpt id="p1">*</bpt>,<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>,<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="1503" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>A culture-specific group separator symbol.</source>
          <target state="translated">Um símbolo de separador do grupo específico da cultura.</target>       </trans-unit>
        <trans-unit id="1504" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>The group separator symbol of the culture specified by <ph id="ph1">`provider`</ph> can appear in <ph id="ph2">`value`</ph> if <ph id="ph3">`style`</ph> includes the <ph id="ph4">&lt;xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">O símbolo de separador de grupo da cultura especificada por <ph id="ph1">`provider`</ph> pode aparecer em <ph id="ph2">`value`</ph> se <ph id="ph3">`style`</ph> inclui o <ph id="ph4">&lt;xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType&gt;</ph> sinalizador.</target>       </trans-unit>
        <trans-unit id="1505" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source><bpt id="p1">*</bpt>.<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>.<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="1506" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>A culture-specific decimal point symbol.</source>
          <target state="translated">Um símbolo de vírgula decimal específico de cultura.</target>       </trans-unit>
        <trans-unit id="1507" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>The decimal point symbol of the culture designated by <ph id="ph1">`provider`</ph> can appear in <ph id="ph2">`value`</ph> if <ph id="ph3">`style`</ph> includes the <ph id="ph4">&lt;xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">O símbolo de ponto decimal da cultura designado pelo <ph id="ph1">`provider`</ph> pode aparecer em <ph id="ph2">`value`</ph> se <ph id="ph3">`style`</ph> inclui o <ph id="ph4">&lt;xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType&gt;</ph> sinalizador.</target>       </trans-unit>
        <trans-unit id="1508" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>Only the digit 0 can appear as a fractional digit for the parse operation to succeed; if <bpt id="p1">*</bpt>fractional_digits<ept id="p1">*</ept> includes any other digit, a <ph id="ph1">&lt;xref:System.FormatException&gt;</ph> is thrown.</source>
          <target state="translated">Somente os dígitos 0 podem ser exibido como um dígito de fração para a operação de análise ter êxito; Se <bpt id="p1">*</bpt>fractional_digits<ept id="p1">*</ept> inclui qualquer dígito, um <ph id="ph1">&lt;xref:System.FormatException&gt;</ph> é gerada.</target>       </trans-unit>
        <trans-unit id="1509" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>E</source>
          <target state="translated">E</target>       </trans-unit>
        <trans-unit id="1510" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>The "e" or "E" character, which indicates that the value is represented in exponential (scientific) notation.</source>
          <target state="translated">O caractere "e" ou "E", que indica que o valor é representado em notação exponencial (científica).</target>       </trans-unit>
        <trans-unit id="1511" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>The <ph id="ph1">`value`</ph> parameter can represent a number in exponential notation if <ph id="ph2">`style`</ph> includes the <ph id="ph3">&lt;xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">O parâmetro <ph id="ph1">`value`</ph> pode representar um número em notação exponencial caso <ph id="ph2">`style`</ph> inclua o sinalizador <ph id="ph3">&lt;xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1512" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source><bpt id="p1">*</bpt>hexdigits<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>hexdigits<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="1513" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>A sequence of hexadecimal digits from 0 through f, or 0 through F.</source>
          <target state="translated">Uma sequência de dígitos hexadecimais de 0 a f ou de 0 a F.</target>       </trans-unit>
        <trans-unit id="1514" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>A string with digits only (which corresponds to the <ph id="ph1">&lt;xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType&gt;</ph> style) always parses successfully.</source>
          <target state="translated">Uma cadeia de caracteres apenas com dígitos (que corresponde ao estilo <ph id="ph1">&lt;xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType&gt;</ph> ) sempre é analisada com êxito.</target>       </trans-unit>
        <trans-unit id="1515" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>Most of the remaining <ph id="ph1">&lt;xref:System.Globalization.NumberStyles&gt;</ph> members control elements that may be present, but are not required to be present, in the input string.</source>
          <target state="translated">A maioria dos elementos de controle de membros <ph id="ph1">&lt;xref:System.Globalization.NumberStyles&gt;</ph> restantes que podem estar presentes, mas que não precisam estar presentes, na cadeia de caracteres de entrada.</target>       </trans-unit>
        <trans-unit id="1516" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>The following table indicates how individual <ph id="ph1">&lt;xref:System.Globalization.NumberStyles&gt;</ph> members affect the elements that may be present in <ph id="ph2">`value`</ph>.</source>
          <target state="translated">A tabela a seguir indica como os membros <ph id="ph1">&lt;xref:System.Globalization.NumberStyles&gt;</ph> individuais afetam os elementos que podem estar presentes em <ph id="ph2">`value`</ph>.</target>       </trans-unit>
        <trans-unit id="1517" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>NumberStyles value</source>
          <target state="translated">Valor NumberStyles</target>       </trans-unit>
        <trans-unit id="1518" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>Elements permitted in value in addition to digits</source>
          <target state="translated">Elementos permitidos no valor além de dígitos</target>       </trans-unit>
        <trans-unit id="1519" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>The <bpt id="p1">*</bpt>digits<ept id="p1">*</ept> element only.</source>
          <target state="translated">O <bpt id="p1">*</bpt>dígitos<ept id="p1">*</ept> apenas do elemento.</target>       </trans-unit>
        <trans-unit id="1520" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>The decimal point (.) and <bpt id="p1">*</bpt>fractional-digits<ept id="p1">*</ept> elements.</source>
          <target state="translated">Decimal de ponto (.) e <bpt id="p1">*</bpt>dígitos fracionários<ept id="p1">*</ept> elementos.</target>       </trans-unit>
        <trans-unit id="1521" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>The "e" or "E" character, which indicates exponential notation.</source>
          <target state="translated">O caractere "e" ou "E", que indica a notação exponencial.</target>       </trans-unit>
        <trans-unit id="1522" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>along with <bpt id="p1">*</bpt>exponential_digits<ept id="p1">*</ept>.</source>
          <target state="translated">juntamente com <bpt id="p1">*</bpt>exponential_digits<ept id="p1">*</ept>.</target>       </trans-unit>
        <trans-unit id="1523" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>The <bpt id="p1">*</bpt>ws<ept id="p1">*</ept> element at the start of <ph id="ph1">`value`</ph>.</source>
          <target state="translated">O <bpt id="p1">*</bpt>ws<ept id="p1">*</ept> elemento no início de <ph id="ph1">`value`</ph>.</target>       </trans-unit>
        <trans-unit id="1524" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>The <bpt id="p1">*</bpt>ws<ept id="p1">*</ept> element at the end of <ph id="ph1">`value`</ph>.</source>
          <target state="translated">O elemento <bpt id="p1">*</bpt>ws<ept id="p1">*</ept> no final de <ph id="ph1">`value`</ph>.</target>       </trans-unit>
        <trans-unit id="1525" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>The <bpt id="p1">*</bpt>sign<ept id="p1">*</ept> element at the start of <ph id="ph1">`value`</ph>.</source>
          <target state="translated">O <bpt id="p1">*</bpt>sinal<ept id="p1">*</ept> elemento no início de <ph id="ph1">`value`</ph>.</target>       </trans-unit>
        <trans-unit id="1526" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>The <bpt id="p1">*</bpt>sign<ept id="p1">*</ept> element at the end of <ph id="ph1">`value`</ph>.</source>
          <target state="translated">O elemento <bpt id="p1">*</bpt>sinal<ept id="p1">*</ept> no final de <ph id="ph1">`value`</ph>.</target>       </trans-unit>
        <trans-unit id="1527" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>The <bpt id="p1">*</bpt>sign<ept id="p1">*</ept> element in the form of parentheses enclosing the numeric value.</source>
          <target state="translated">O elemento <bpt id="p1">*</bpt>sinal<ept id="p1">*</ept> na forma de parênteses que incluem o valor numérico.</target>       </trans-unit>
        <trans-unit id="1528" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>The group separator (,) element.</source>
          <target state="translated">O elemento separador do grupo (,).</target>       </trans-unit>
        <trans-unit id="1529" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>The currency ($) element.</source>
          <target state="translated">O elemento de moeda ($).</target>       </trans-unit>
        <trans-unit id="1530" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>All elements.</source>
          <target state="translated">Todos os elementos.</target>       </trans-unit>
        <trans-unit id="1531" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>However, <ph id="ph1">`value`</ph> cannot represent a hexadecimal number or a number in exponential notation.</source>
          <target state="translated">No entanto, <ph id="ph1">`value`</ph> não pode representar um número hexadecimal ou um número em notação exponencial.</target>       </trans-unit>
        <trans-unit id="1532" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>The <bpt id="p1">*</bpt>ws<ept id="p1">*</ept> element at the start or end of <ph id="ph1">`value`</ph>, <bpt id="p2">*</bpt>sign<ept id="p2">*</ept> at the start of <ph id="ph2">`value`</ph>, and the decimal point (.) symbol.</source>
          <target state="translated">O <bpt id="p1">*</bpt>ws<ept id="p1">*</ept> elemento no início ou no final de <ph id="ph1">`value`</ph>, <bpt id="p2">*</bpt>sinal<ept id="p2">*</ept> no início de <ph id="ph2">`value`</ph>e o símbolo de ponto decimal (.).</target>       </trans-unit>
        <trans-unit id="1533" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>The <ph id="ph1">`value`</ph> parameter can also use exponential notation.</source>
          <target state="translated">O parâmetro <ph id="ph1">`value`</ph> também pode usar notação exponencial.</target>       </trans-unit>
        <trans-unit id="1534" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>The <ph id="ph1">`ws`</ph>, <ph id="ph2">`sign`</ph>, group separator (,), and decimal point (.) elements.</source>
          <target state="translated">O <ph id="ph1">`ws`</ph>, <ph id="ph2">`sign`</ph>, elementos de ponto decimal (.) e o separador de grupo (,).</target>       </trans-unit>
        <trans-unit id="1535" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>All elements.</source>
          <target state="translated">Todos os elementos.</target>       </trans-unit>
        <trans-unit id="1536" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>However, <ph id="ph1">`value`</ph> cannot represent a hexadecimal number.</source>
          <target state="translated">No entanto, <ph id="ph1">`value`</ph> não pode representar um número hexadecimal.</target>       </trans-unit>
        <trans-unit id="1537" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>If you use the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Parse%2A&gt;</ph> method to round-trip the string representation of a <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> value that was output by the <ph id="ph3">&lt;xref:System.Numerics.BigInteger.ToString%2A&gt;</ph> method, you should use the <ph id="ph4">&lt;xref:System.Numerics.BigInteger.ToString%28System.String%29?displayProperty=nameWithType&gt;</ph> method with the "R" format specifier to generate the string representation of the <ph id="ph5">&lt;xref:System.Numerics.BigInteger&gt;</ph> value.</source>
          <target state="translated">Se você usar o <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Parse%2A&gt;</ph> método viagem a representação de cadeia de caracteres de um <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> valor foi saída o <ph id="ph3">&lt;xref:System.Numerics.BigInteger.ToString%2A&gt;</ph> método, você deve usar o <ph id="ph4">&lt;xref:System.Numerics.BigInteger.ToString%28System.String%29?displayProperty=nameWithType&gt;</ph> método com o especificador de formato "R" para gerar a representação de cadeia de caracteres da <ph id="ph5">&lt;xref:System.Numerics.BigInteger&gt;</ph> valor.</target>       </trans-unit>
        <trans-unit id="1538" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>Otherwise, the string representation of the <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> preserves only the 50 most significant digits of the original value, and data may be lost when you use the <ph id="ph2">&lt;xref:System.Numerics.BigInteger.Parse%2A&gt;</ph> method to restore the <ph id="ph3">&lt;xref:System.Numerics.BigInteger&gt;</ph> value.</source>
          <target state="translated">Caso contrário, a representação de cadeia de caracteres da <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> preserva apenas os 50 dígitos significativos do valor original e dados podem ser perdidos quando você usa o <ph id="ph2">&lt;xref:System.Numerics.BigInteger.Parse%2A&gt;</ph> método para restaurar o <ph id="ph3">&lt;xref:System.Numerics.BigInteger&gt;</ph> valor.</target>       </trans-unit>
        <trans-unit id="1539" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>Unlike the other <ph id="ph1">&lt;xref:System.Globalization.NumberStyles&gt;</ph> values, which allow for but do not require the presence of particular style elements in <ph id="ph2">`value`</ph>, the <ph id="ph3">&lt;xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType&gt;</ph> style value means that the individual numeric characters in <ph id="ph4">`value`</ph> are always interpreted as hexadecimal characters.</source>
          <target state="translated">Ao contrário de outros <ph id="ph1">&lt;xref:System.Globalization.NumberStyles&gt;</ph> valores, que permitem, mas não exigem a presença de elementos de estilo específico <ph id="ph2">`value`</ph>, o <ph id="ph3">&lt;xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType&gt;</ph> valor de estilo significa que os caracteres individuais nos <ph id="ph4">`value`</ph> sempre são interpretados como caracteres hexadecimais.</target>       </trans-unit>
        <trans-unit id="1540" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>Valid hexadecimal characters are 0-9, A-F, and a-f.</source>
          <target state="translated">Os caracteres hexadecimais válidos são 0-9, A-F e a-f.</target>       </trans-unit>
        <trans-unit id="1541" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>The only other flags that can be combined with the <ph id="ph1">`style`</ph> parameter are <ph id="ph2">&lt;xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType&gt;</ph> and <ph id="ph3">&lt;xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Os únicos outros sinalizadores que podem ser combinados com o parâmetro <ph id="ph1">`style`</ph> são <ph id="ph2">&lt;xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType&gt;</ph> e <ph id="ph3">&lt;xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1542" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>(The <ph id="ph1">&lt;xref:System.Globalization.NumberStyles&gt;</ph> enumeration includes a composite number style, <ph id="ph2">&lt;xref:System.Globalization.NumberStyles.HexNumber&gt;</ph>, that includes both white-space flags.)</source>
          <target state="translated">(A enumeração de <ph id="ph1">&lt;xref:System.Globalization.NumberStyles&gt;</ph> inclui um estilo de número composto, <ph id="ph2">&lt;xref:System.Globalization.NumberStyles.HexNumber&gt;</ph>, que inclui ambos os sinalizadores de espaço em branco.)</target>       </trans-unit>
        <trans-unit id="1543" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>If <ph id="ph1">`value`</ph> is the string representation of a hexadecimal number, it cannot be preceded by any decoration (such as <ph id="ph2">`0x`</ph> or <ph id="ph3">`&amp;h`</ph>) that differentiates it as a hexadecimal number.</source>
          <target state="translated">Caso <ph id="ph1">`value`</ph> seja a representação da cadeia de caracteres de um número hexadecimal, ele não pode ser precedido por qualquer decoração (como <ph id="ph2">`0x`</ph> ou <ph id="ph3">`&amp;h`</ph>) que o diferencia como um número hexadecimal.</target>       </trans-unit>
        <trans-unit id="1544" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>This causes the conversion to fail.</source>
          <target state="translated">Isso faz a conversão falhar.</target>       </trans-unit>
        <trans-unit id="1545" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>If <ph id="ph1">`value`</ph> is a hexadecimal string, the <ph id="ph2">&lt;xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%29&gt;</ph> method interprets <ph id="ph3">`value`</ph> as a negative number stored by using two's complement representation if its first two hexadecimal digits are greater than or equal to <ph id="ph4">`0x80`</ph>.</source>
          <target state="translated">Se <ph id="ph1">`value`</ph> é uma cadeia de caracteres hexadecimal de <ph id="ph2">&lt;xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%29&gt;</ph> método interpreta <ph id="ph3">`value`</ph> como um número negativo armazenado usando representação de complemento de dois, se seu primeiro de dois dígitos hexadecimais forem maior que ou igual a <ph id="ph4">`0x80`</ph>.</target>       </trans-unit>
        <trans-unit id="1546" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>In other words, the method interprets the highest-order bit of the first byte in <ph id="ph1">`value`</ph> as the sign bit.</source>
          <target state="translated">Em outras palavras, o método interpreta o bit de ordem mais alta do primeiro byte no <ph id="ph1">`value`</ph> como o bit de sinal.</target>       </trans-unit>
        <trans-unit id="1547" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>To make sure that a hexadecimal string is correctly interpreted as a positive number, the first digit in <ph id="ph1">`value`</ph> must have a value of zero.</source>
          <target state="translated">Para certificar-se de que uma cadeia de caracteres hexadecimal é interpretada corretamente como um número positivo, o primeiro dígito em <ph id="ph1">`value`</ph> deve ter um valor de zero.</target>       </trans-unit>
        <trans-unit id="1548" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>For example, the method interprets <ph id="ph1">`0x80`</ph> as a negative value, but it interprets either <ph id="ph2">`0x080`</ph> or <ph id="ph3">`0x0080`</ph> as a positive value.</source>
          <target state="translated">Por exemplo, o método interpreta <ph id="ph1">`0x80`</ph> como um valor negativo, mas ele interpreta o <ph id="ph2">`0x080`</ph> ou <ph id="ph3">`0x0080`</ph> como um valor positivo.</target>       </trans-unit>
        <trans-unit id="1549" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>The following example illustrates the difference between hexadecimal strings that represent negative and positive values.</source>
          <target state="translated">O exemplo a seguir ilustra a diferença entre cadeias de caracteres hexadecimais que representam valores negativos e positivos.</target>       </trans-unit>
        <trans-unit id="1550" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>The <ph id="ph1">`provider`</ph> parameter is an <ph id="ph2">&lt;xref:System.IFormatProvider&gt;</ph> implementation.</source>
          <target state="translated">O parâmetro <ph id="ph1">`provider`</ph> é uma implementação de <ph id="ph2">&lt;xref:System.IFormatProvider&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1551" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>Its <ph id="ph1">&lt;xref:System.IFormatProvider.GetFormat%2A&gt;</ph> method returns a <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object that provides culture-specific information about the format of <ph id="ph3">`value`</ph>.</source>
          <target state="translated">O método <ph id="ph1">&lt;xref:System.IFormatProvider.GetFormat%2A&gt;</ph> retorna um objeto <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> que fornece informações específicas de cultura sobre o formato de <ph id="ph3">`value`</ph>.</target>       </trans-unit>
        <trans-unit id="1552" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>Typically, <ph id="ph1">`provider`</ph> can be any one of the following:</source>
          <target state="translated">Normalmente, <ph id="ph1">`provider`</ph> pode ser qualquer um dos seguintes:</target>       </trans-unit>
        <trans-unit id="1553" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>A <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> object that represents the culture that provides numeric formatting information.</source>
          <target state="translated">Um <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> objeto que representa a cultura que fornece informações de formatação numéricas.</target>       </trans-unit>
        <trans-unit id="1554" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>Its <ph id="ph1">&lt;xref:System.Globalization.CultureInfo.GetFormat%2A&gt;</ph> method returns the <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object that provides numeric formatting information.</source>
          <target state="translated">Seu <ph id="ph1">&lt;xref:System.Globalization.CultureInfo.GetFormat%2A&gt;</ph> método retorna o <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> objeto que fornece informações de formatação numéricas.</target>       </trans-unit>
        <trans-unit id="1555" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>A <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object that provides formatting information.</source>
          <target state="translated">Um <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> objeto que fornece informações de formatação.</target>       </trans-unit>
        <trans-unit id="1556" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>(Its implementation of <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo.GetFormat%2A&gt;</ph> just returns itself.)</source>
          <target state="translated">(Sua implementação de <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo.GetFormat%2A&gt;</ph> retorna apenas ele próprio.)</target>       </trans-unit>
        <trans-unit id="1557" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>A custom object that implements <ph id="ph1">&lt;xref:System.IFormatProvider&gt;</ph> and uses the <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo.GetFormat%2A&gt;</ph> method to instantiate and return the <ph id="ph3">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object that provides formatting information.</source>
          <target state="translated">Um objeto personalizado que implementa <ph id="ph1">&lt;xref:System.IFormatProvider&gt;</ph> e usa o <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo.GetFormat%2A&gt;</ph> método para instanciar e retornar o <ph id="ph3">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> objeto que fornece informações de formatação.</target>       </trans-unit>
        <trans-unit id="1558" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>If <ph id="ph1">`provider`</ph> is <ph id="ph2">`null`</ph>, the <ph id="ph3">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object for the current culture is used.</source>
          <target state="translated">Caso <ph id="ph1">`provider`</ph> seja <ph id="ph2">`null`</ph>, o objeto <ph id="ph3">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> da cultura atual é usado.</target>       </trans-unit>
        <trans-unit id="1559" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>The following example makes several calls to the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29&gt;</ph> method using various combinations of values for the <ph id="ph2">`style`</ph> and <ph id="ph3">`provider`</ph> parameters.</source>
          <target state="translated">O exemplo a seguir faz várias chamadas para o <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29&gt;</ph> método usando várias combinações de valores para o <ph id="ph2">`style`</ph> e <ph id="ph3">`provider`</ph> parâmetros.</target>       </trans-unit>
        <trans-unit id="1560" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>A number of the individual calls to the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29&gt;</ph> method pass an instance of the following <ph id="ph2">`BigIntegerFormatProvider`</ph> class, which defines a tilde (~) as the negative sign.</source>
          <target state="translated">Um número de chamadas individuais para o <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29&gt;</ph> método passar uma instância das seguintes <ph id="ph2">`BigIntegerFormatProvider`</ph> classe, que define um til (~) como o sinal negativo.</target>       </trans-unit>
        <trans-unit id="1561" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source><ph id="ph1">&lt;paramref name="style" /&gt;</ph> is not a <ph id="ph2">&lt;see cref="T:System.Globalization.NumberStyles" /&gt;</ph> value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="style" /&gt;</ph> não é um valor <ph id="ph2">&lt;see cref="T:System.Globalization.NumberStyles" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1562" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1563" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source><ph id="ph1">&lt;paramref name="style" /&gt;</ph> includes the <ph id="ph2">&lt;see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" /&gt;</ph> or <ph id="ph3">&lt;see cref="F:System.Globalization.NumberStyles.HexNumber" /&gt;</ph> flag along with another value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="style" /&gt;</ph> inclui o sinalizador <ph id="ph2">&lt;see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" /&gt;</ph> ou <ph id="ph3">&lt;see cref="F:System.Globalization.NumberStyles.HexNumber" /&gt;</ph> em conjunto com outro valor.</target>       </trans-unit>
        <trans-unit id="1564" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1565" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> does not comply with the input pattern specified by <ph id="ph2">&lt;paramref name="style" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> não é compatível com o padrão de entrada especificado por <ph id="ph2">&lt;paramref name="style" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1566" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.Pow(System.Numerics.BigInteger,System.Int32)">
          <source>The number to raise to the <bpt id="p1">&lt;c&gt;</bpt>exponent<ept id="p1">&lt;/c&gt;</ept> power.</source>
          <target state="translated">O número a elevar à potência <bpt id="p1">&lt;c&gt;</bpt>expoente<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="1567" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.Pow(System.Numerics.BigInteger,System.Int32)">
          <source>The exponent to raise <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept> by.</source>
          <target state="translated">O expoente pelo qual <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept> será elevado.</target>       </trans-unit>
        <trans-unit id="1568" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.Pow(System.Numerics.BigInteger,System.Int32)">
          <source>Raises a <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> value to the power of a specified value.</source>
          <target state="translated">Gera um valor <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> à potência de um valor especificado.</target>       </trans-unit>
        <trans-unit id="1569" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.Pow(System.Numerics.BigInteger,System.Int32)">
          <source>The result of raising <ph id="ph1">&lt;paramref name="value" /&gt;</ph> to the <ph id="ph2">&lt;paramref name="exponent" /&gt;</ph> power.</source>
          <target state="translated">O resultado da elevação <ph id="ph1">&lt;paramref name="value" /&gt;</ph> para a potência <ph id="ph2">&lt;paramref name="exponent" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1570" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Pow(System.Numerics.BigInteger,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Pow%2A&gt;</ph> method returns 1 if the value of the exponent parameter is 0, or if the values of both the <ph id="ph2">`value`</ph> and <ph id="ph3">`exponent`</ph> parameters are 0.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Pow%2A&gt;</ph> método retornará 1 se o valor do parâmetro expoente é 0, ou se os valores de ambos os <ph id="ph2">`value`</ph> e <ph id="ph3">`exponent`</ph> parâmetros são 0.</target>       </trans-unit>
        <trans-unit id="1571" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Pow(System.Numerics.BigInteger,System.Int32)">
          <source>If <ph id="ph1">`exponent`</ph> is 1, the <ph id="ph2">&lt;xref:System.Numerics.BigInteger.Pow%2A&gt;</ph> method returns <ph id="ph3">`value`</ph>.</source>
          <target state="translated">Se <ph id="ph1">`exponent`</ph> é 1, o <ph id="ph2">&lt;xref:System.Numerics.BigInteger.Pow%2A&gt;</ph> método retornará <ph id="ph3">`value`</ph>.</target>       </trans-unit>
        <trans-unit id="1572" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Pow(System.Numerics.BigInteger,System.Int32)">
          <source>If <ph id="ph1">`value`</ph> is negative, the method returns a negative result.</source>
          <target state="translated">Se <ph id="ph1">`value`</ph> for negativo, o método retornará um resultado negativo.</target>       </trans-unit>
        <trans-unit id="1573" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Pow(System.Numerics.BigInteger,System.Int32)">
          <source>This method corresponds to the <ph id="ph1">&lt;xref:System.Math.Pow%2A?displayProperty=nameWithType&gt;</ph> method for primitive numeric types.</source>
          <target state="translated">Esse método corresponde do <ph id="ph1">&lt;xref:System.Math.Pow%2A?displayProperty=nameWithType&gt;</ph> método para tipos numéricos primitivos.</target>       </trans-unit>
        <trans-unit id="1574" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Pow(System.Numerics.BigInteger,System.Int32)">
          <source>The following example illustrates exponentiation using a <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> value and an exponent whose value ranges from 0 to 10.</source>
          <target state="translated">O exemplo a seguir ilustra o uso de exponenciação um <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> valor e um expoente cujo valor varia de 0 a 10.</target>       </trans-unit>
        <trans-unit id="1575" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.Pow(System.Numerics.BigInteger,System.Int32)">
          <source>The value of the <ph id="ph1">&lt;paramref name="exponent" /&gt;</ph> parameter is negative.</source>
          <target state="translated">O valor do parâmetro <ph id="ph1">&lt;paramref name="exponent" /&gt;</ph> é negativo.</target>       </trans-unit>
        <trans-unit id="1576" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.Remainder(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>The value to be divided.</source>
          <target state="translated">O valor a ser dividido.</target>       </trans-unit>
        <trans-unit id="1577" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.Remainder(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>The value to divide by.</source>
          <target state="translated">O valor pelo qual dividir.</target>       </trans-unit>
        <trans-unit id="1578" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.Remainder(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>Performs integer division on two <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> values and returns the remainder.</source>
          <target state="translated">Executa a divisão do inteiro em dois valores <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> e retorna o restante.</target>       </trans-unit>
        <trans-unit id="1579" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.Remainder(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>The remainder after dividing <ph id="ph1">&lt;paramref name="dividend" /&gt;</ph> by <ph id="ph2">&lt;paramref name="divisor" /&gt;</ph>.</source>
          <target state="translated">O resto após dividir <ph id="ph1">&lt;paramref name="dividend" /&gt;</ph> por <ph id="ph2">&lt;paramref name="divisor" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1580" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Remainder(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>The sign of the remainder is the sign of the <ph id="ph1">`dividend`</ph> parameter.</source>
          <target state="translated">O sinal do resto é o sinal do <ph id="ph1">`dividend`</ph> parâmetro.</target>       </trans-unit>
        <trans-unit id="1581" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Remainder(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Remainder%2A&gt;</ph> method is implemented for languages that do not support custom operators.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Remainder%2A&gt;</ph> método é implementado para os idiomas que não dão suporte a operadores personalizados.</target>       </trans-unit>
        <trans-unit id="1582" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Remainder(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>Its behavior is identical to division using the modulus operator.</source>
          <target state="translated">Seu comportamento é idêntico a divisão usando o operador de módulo.</target>       </trans-unit>
        <trans-unit id="1583" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Remainder(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>If necessary, the method automatically performs implicit conversion of other integral types to <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> objects before it performs the modulus operation.</source>
          <target state="translated">Se necessário, o método executa automaticamente a conversão implícita de outros tipos integrais <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> objetos antes de executar a operação de módulo.</target>       </trans-unit>
        <trans-unit id="1584" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Remainder(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>The following example compares the remainder from the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.DivRem%2A&gt;</ph> method with the remainder returned by the <ph id="ph2">&lt;xref:System.Numerics.BigInteger.Remainder%2A&gt;</ph> method to establish that the two methods calculate identical remainders.</source>
          <target state="translated">O exemplo a seguir compara o restante do <ph id="ph1">&lt;xref:System.Numerics.BigInteger.DivRem%2A&gt;</ph> método com o restante retornado pelo <ph id="ph2">&lt;xref:System.Numerics.BigInteger.Remainder%2A&gt;</ph> método para estabelecer os dois métodos calculam restante idêntico.</target>       </trans-unit>
        <trans-unit id="1585" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.Remainder(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source><ph id="ph1">&lt;paramref name="divisor" /&gt;</ph> is 0 (zero).</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="divisor" /&gt;</ph> é 0 (zero).</target>       </trans-unit>
        <trans-unit id="1586" translate="yes" xml:space="preserve" uid="P:System.Numerics.BigInteger.Sign">
          <source>Gets a number that indicates the sign (negative, positive, or zero) of the current <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> object.</source>
          <target state="translated">Obtém um número que indica o sinal (negativo, positivo ou zero) do objeto <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> atual.</target>       </trans-unit>
        <trans-unit id="1587" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Numerics.BigInteger.Sign">
          <source>A number that indicates the sign of the <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> object, as shown in the following table.</source>
          <target state="translated">Um número que indica o sinal do objeto <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph>, conforme mostrado na tabela a seguir.</target>       </trans-unit>
        <trans-unit id="1588" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Numerics.BigInteger.Sign">
          <source><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Number</source>
          <target state="translated"><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Número</target>       </trans-unit>
        <trans-unit id="1589" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Numerics.BigInteger.Sign">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Description</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Descrição</target>       </trans-unit>
        <trans-unit id="1590" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Numerics.BigInteger.Sign">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> -1</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> -1</target>       </trans-unit>
        <trans-unit id="1591" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Numerics.BigInteger.Sign">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> The value of this object is negative.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> O valor do objeto é negativo.</target>       </trans-unit>
        <trans-unit id="1592" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Numerics.BigInteger.Sign">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> 0</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> 0</target>       </trans-unit>
        <trans-unit id="1593" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Numerics.BigInteger.Sign">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> The value of this object is 0 (zero).</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> O valor do objeto é 0 (zero).</target>       </trans-unit>
        <trans-unit id="1594" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Numerics.BigInteger.Sign">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> 1</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> 1</target>       </trans-unit>
        <trans-unit id="1595" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Numerics.BigInteger.Sign">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> The value of this object is positive.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> O valor do objeto é positivo.</target>       </trans-unit>
        <trans-unit id="1596" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Numerics.BigInteger.Sign">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Sign%2A&gt;</ph> property is equivalent to the <ph id="ph2">&lt;xref:System.Math.Sign%2A?displayProperty=nameWithType&gt;</ph> method for the primitive numeric types.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Sign%2A&gt;</ph> propriedade é equivalente a <ph id="ph2">&lt;xref:System.Math.Sign%2A?displayProperty=nameWithType&gt;</ph> método para os tipos numéricos primitivo.</target>       </trans-unit>
        <trans-unit id="1597" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.Subtract(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>The value to subtract from (the minuend).</source>
          <target state="translated">O valor do qual um valor será subtraído (o minuendo).</target>       </trans-unit>
        <trans-unit id="1598" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.Subtract(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>The value to subtract (the subtrahend).</source>
          <target state="translated">O valor a ser subtraído (o subtraendo).</target>       </trans-unit>
        <trans-unit id="1599" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.Subtract(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>Subtracts one <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> value from another and returns the result.</source>
          <target state="translated">Subtrai um valor <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> de outro e retorna o resultado.</target>       </trans-unit>
        <trans-unit id="1600" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.Subtract(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>The result of subtracting <ph id="ph1">&lt;paramref name="right" /&gt;</ph> from <ph id="ph2">&lt;paramref name="left" /&gt;</ph>.</source>
          <target state="translated">O resultado da subtração de <ph id="ph1">&lt;paramref name="right" /&gt;</ph> de <ph id="ph2">&lt;paramref name="left" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1601" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Subtract(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>Languages that do not support custom operators can use the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Subtract%2A&gt;</ph> method to perform subtraction using <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> values.</source>
          <target state="translated">Idiomas que dão suporte a operadores personalizados podem usar o <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Subtract%2A&gt;</ph> método para executar usando subtração <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> valores.</target>       </trans-unit>
        <trans-unit id="1602" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.Subtract(System.Numerics.BigInteger,System.Numerics.BigInteger)">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Subtract%2A&gt;</ph> method is a useful substitute for the subtraction operator when instantiating a <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> variable by assigning it the difference that results from subtraction, as shown in the following example.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Subtract%2A&gt;</ph> método é um substituto úteis para o operador de subtração ao instanciar um <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> variável, atribuindo a diferença que resulta da subtração, conforme mostrado no exemplo a seguir.</target>       </trans-unit>
        <trans-unit id="1603" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.ToByteArray">
          <source>Converts a <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> value to a byte array.</source>
          <target state="translated">Converte um valor de <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> em uma matriz de bytes.</target>       </trans-unit>
        <trans-unit id="1604" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.ToByteArray">
          <source>The value of the current <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> object converted to an array of bytes.</source>
          <target state="translated">O valor do objeto <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> atual convertido em uma matriz de bytes.</target>       </trans-unit>
        <trans-unit id="1605" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.ToByteArray">
          <source>The individual bytes in the array returned by this method appear in little-endian order.</source>
          <target state="translated">Os bytes individuais na matriz retornada por este método aparecem na ordem little endian.</target>       </trans-unit>
        <trans-unit id="1606" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.ToByteArray">
          <source>That is, the lower-order bytes of the value precede the higher-order bytes.</source>
          <target state="translated">Ou seja, os bytes de ordem inferior do valor precedem os bytes de ordem superior.</target>       </trans-unit>
        <trans-unit id="1607" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.ToByteArray">
          <source>The first byte of the array reflects the first eight bits of the <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> value, the second byte reflects the next eight bits, and so on.</source>
          <target state="translated">O primeiro byte da matriz reflete os primeiros oito bits do <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> valor, o segundo byte reflete o próximos oito bits e assim por diante.</target>       </trans-unit>
        <trans-unit id="1608" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.ToByteArray">
          <source>For example, the value 1024, or 0x0400, is stored as the following array of two bytes:</source>
          <target state="translated">Por exemplo, o valor de 1024 ou 0x0400, são armazenados como a seguinte matriz de dois bytes:</target>       </trans-unit>
        <trans-unit id="1609" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.ToByteArray">
          <source>Element</source>
          <target state="translated">Elemento</target>       </trans-unit>
        <trans-unit id="1610" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.ToByteArray">
          <source>Byte value</source>
          <target state="translated">Valor de byte</target>       </trans-unit>
        <trans-unit id="1611" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.ToByteArray">
          <source>0</source>
          <target state="translated">0</target>       </trans-unit>
        <trans-unit id="1612" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.ToByteArray">
          <source>0x00</source>
          <target state="translated">0x00</target>       </trans-unit>
        <trans-unit id="1613" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.ToByteArray">
          <source>1</source>
          <target state="translated">1</target>       </trans-unit>
        <trans-unit id="1614" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.ToByteArray">
          <source>0x04</source>
          <target state="translated">0x04</target>       </trans-unit>
        <trans-unit id="1615" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.ToByteArray">
          <source>Negative values are written to the array using two's complement representation in the most compact form possible.</source>
          <target state="translated">Valores negativos são gravados para a matriz usando a representação de complemento de dois nos possíveis de forma mais compacto.</target>       </trans-unit>
        <trans-unit id="1616" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.ToByteArray">
          <source>For example, -1 is represented as a single byte whose value is <ph id="ph1">`0xFF`</ph> instead of as an array with multiple elements, such as <ph id="ph2">`0xFF`</ph>, <ph id="ph3">`0xFF`</ph> or <ph id="ph4">`0xFF`</ph>, <ph id="ph5">`0xFF`</ph>, <ph id="ph6">`0xFF`</ph>, <ph id="ph7">`0xFF`</ph>.</source>
          <target state="translated">Por exemplo, -1 é representado como um único byte cujo valor é <ph id="ph1">`0xFF`</ph> em vez de como uma matriz com vários elementos, como <ph id="ph2">`0xFF`</ph>, <ph id="ph3">`0xFF`</ph> ou <ph id="ph4">`0xFF`</ph>, <ph id="ph5">`0xFF`</ph>, <ph id="ph6">`0xFF`</ph>, <ph id="ph7">`0xFF`</ph>.</target>       </trans-unit>
        <trans-unit id="1617" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.ToByteArray">
          <source>Because two's complement representation always interprets the highest-order bit of the last byte in the array (the byte at position <ph id="ph1">&lt;xref:System.Array.Length%2A?displayProperty=nameWithType&gt;</ph><ph id="ph2">`- 1`</ph>) as the sign bit, the method returns a byte array with an extra element whose value is zero to disambiguate positive values that could otherwise be interpreted as having their sign bits set.</source>
          <target state="translated">Porque do complemento de dois representação sempre interpreta o bit de ordem mais alta do que o último byte na matriz (bytes na posição <ph id="ph1">&lt;xref:System.Array.Length%2A?displayProperty=nameWithType&gt;</ph> <ph id="ph2">`- 1`</ph>) como o bit de sinal, o método retorna uma matriz de bytes com um elemento adicional cujo valor é zero para resolver a ambiguidade valores positivos caso contrário, podem ser interpretados como tendo seus bits de entrada definido.</target>       </trans-unit>
        <trans-unit id="1618" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.ToByteArray">
          <source>For example, the value 120 or <ph id="ph1">`0x78`</ph> is represented as a single-byte array: <ph id="ph2">`0x78`</ph>.</source>
          <target state="translated">Por exemplo, o valor 120 ou <ph id="ph1">`0x78`</ph> é representado como uma matriz de byte único: <ph id="ph2">`0x78`</ph>.</target>       </trans-unit>
        <trans-unit id="1619" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.ToByteArray">
          <source>However, 128, or <ph id="ph1">`0x80`</ph>, is represented as a two-byte array: <ph id="ph2">`0x80`</ph>, <ph id="ph3">`0x00`</ph>.</source>
          <target state="translated">No entanto, 128, ou <ph id="ph1">`0x80`</ph>, é representado como uma matriz de dois bytes: <ph id="ph2">`0x80`</ph>, <ph id="ph3">`0x00`</ph>.</target>       </trans-unit>
        <trans-unit id="1620" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.ToByteArray">
          <source>You can round-trip a <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> value by storing it to a byte array and then restoring it using the <ph id="ph2">&lt;xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29&gt;</ph> constructor.</source>
          <target state="translated">Você pode viagem um <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> valor armazenando-o em uma matriz de bytes e, em seguida, restaurá-la usando o <ph id="ph2">&lt;xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29&gt;</ph> construtor.</target>       </trans-unit>
        <trans-unit id="1621" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.ToByteArray">
          <source>If your code modifies the value of individual bytes in the array returned by this method before it restores the value, you must make sure that you do not unintentionally change the sign bit.</source>
          <target state="translated">Se seu código modifica o valor de bytes individuais na matriz retornada por este método antes de ele restaura o valor, você deve garantir que você não altere acidentalmente o bit de sinal.</target>       </trans-unit>
        <trans-unit id="1622" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.ToByteArray">
          <source>For example, if your modifications increase a positive value so that the highest-order bit in the last element of the byte array becomes set, you can add a new byte whose value is zero to the end of the array.</source>
          <target state="translated">Por exemplo, se suas modificações aumentam um valor positivo para que os bits de ordem mais alta no último elemento da matriz de bytes torna-se definido, que você pode adicionar um novo cujo valor é zero para o final da matriz de byte.</target>       </trans-unit>
        <trans-unit id="1623" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.ToByteArray">
          <source>The following example illustrates how some <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> values are represented in byte arrays.</source>
          <target state="translated">O exemplo a seguir ilustra como alguns <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> os valores são representados em matrizes de bytes.</target>       </trans-unit>
        <trans-unit id="1624" translate="yes" xml:space="preserve" uid="T:System.Numerics.BigInteger">
          <source>Converts the numeric value of the current <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> object to its equivalent string representation.</source>
          <target state="translated">Converte o valor numérico do objeto <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> atual na representação da cadeia de caracteres equivalente.</target>       </trans-unit>
        <trans-unit id="1625" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.ToString">
          <source>Converts the numeric value of the current <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> object to its equivalent string representation.</source>
          <target state="translated">Converte o valor numérico do objeto <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> atual na representação da cadeia de caracteres equivalente.</target>       </trans-unit>
        <trans-unit id="1626" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.ToString">
          <source>The string representation of the current <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> value.</source>
          <target state="translated">Uma representação de cadeia de caracteres do valor <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> atual.</target>       </trans-unit>
        <trans-unit id="1627" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.ToString">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.ToString&gt;</ph> method formats a <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> value in the "R", or round-trip, format of the current culture.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Numerics.BigInteger.ToString&gt;</ph> formatos do método um <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> valor no "R" ou viagem, formato da cultura atual.</target>       </trans-unit>
        <trans-unit id="1628" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.ToString">
          <source>If you want to specify a different format or culture, use the other overloads of the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.ToString%2A&gt;</ph> method, as follows:</source>
          <target state="translated">Se você quiser especificar um formato diferente ou a cultura, use as outras sobrecargas do <ph id="ph1">&lt;xref:System.Numerics.BigInteger.ToString%2A&gt;</ph> método, da seguinte maneira:</target>       </trans-unit>
        <trans-unit id="1629" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.ToString">
          <source>To use format</source>
          <target state="translated">Para usar o formato</target>       </trans-unit>
        <trans-unit id="1630" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.ToString">
          <source>For culture</source>
          <target state="translated">Para a cultura</target>       </trans-unit>
        <trans-unit id="1631" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.ToString">
          <source>Use the overload</source>
          <target state="translated">Use a sobrecarga</target>       </trans-unit>
        <trans-unit id="1632" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.ToString">
          <source>Round-trip ("R") format</source>
          <target state="translated">Formato de round-trip ("R")</target>       </trans-unit>
        <trans-unit id="1633" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.ToString">
          <source>A specific culture</source>
          <target state="translated">Uma cultura específica</target>       </trans-unit>
        <trans-unit id="1634" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.ToString">
          <source>A specific format</source>
          <target state="translated">Um formato específico</target>       </trans-unit>
        <trans-unit id="1635" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.ToString">
          <source>Default (current) culture</source>
          <target state="translated">Cultura do padrão (atual)</target>       </trans-unit>
        <trans-unit id="1636" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.ToString">
          <source>A specific format</source>
          <target state="translated">Um formato específico</target>       </trans-unit>
        <trans-unit id="1637" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.ToString">
          <source>A specific culture</source>
          <target state="translated">Uma cultura específica</target>       </trans-unit>
        <trans-unit id="1638" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.ToString">
          <source>The string representation of the <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> value includes a negative sign if its value is negative, and a sequence of digits ranging from 0 to 9 without leading zeros.</source>
          <target state="translated">A representação de cadeia de caracteres da <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> valor inclui um sinal negativo se o valor for negativo e uma sequência de dígitos, variando de 0 a 9 sem zeros à esquerda.</target>       </trans-unit>
        <trans-unit id="1639" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.ToString">
          <source>The negative sign is defined by the <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object for the current culture.</source>
          <target state="translated">O sinal negativo é definido pelo <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> objeto para a cultura atual.</target>       </trans-unit>
        <trans-unit id="1640" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.ToString">
          <source>The following example displays a <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> value by using the default <ph id="ph2">&lt;xref:System.Numerics.BigInteger.ToString&gt;</ph> method.</source>
          <target state="translated">O exemplo a seguir exibe um <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> valor usando o padrão <ph id="ph2">&lt;xref:System.Numerics.BigInteger.ToString&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="1641" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.ToString">
          <source>It also displays the string representations of the <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> value that results from using some standard format specifiers.</source>
          <target state="translated">Ele também exibe as representações de cadeia de caracteres da <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> valor resultante do uso de alguns especificadores de formato padrão.</target>       </trans-unit>
        <trans-unit id="1642" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.ToString">
          <source>The examples are displayed using the formatting conventions of the en-US culture.</source>
          <target state="translated">Os exemplos são exibidos usando-se as convenções de formatação da cultura en-US.</target>       </trans-unit>
        <trans-unit id="1643" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.ToString(System.IFormatProvider)">
          <source>An object that supplies culture-specific formatting information.</source>
          <target state="translated">Um objeto que fornece informações de formatação específicas de cultura.</target>       </trans-unit>
        <trans-unit id="1644" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.ToString(System.IFormatProvider)">
          <source>Converts the numeric value of the current <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> object to its equivalent string representation by using the specified culture-specific formatting information.</source>
          <target state="translated">Converte o valor numérico do objeto <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> atual em sua representação de cadeia de caracteres equivalente usando as informações especificadas de formatação específicas de cultura.</target>       </trans-unit>
        <trans-unit id="1645" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.ToString(System.IFormatProvider)">
          <source>The string representation of the current <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> value in the format specified by the <ph id="ph2">&lt;paramref name="provider" /&gt;</ph> parameter.</source>
          <target state="translated">A representação de cadeia de caracteres do valor <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> atual no formato especificado pelo parâmetro <ph id="ph2">&lt;paramref name="provider" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1646" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.ToString(System.IFormatProvider)">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.ToString%28System.IFormatProvider%29&gt;</ph> method formats a <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> value in the "R", or round-trip, format by using the <ph id="ph3">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object of a specified culture.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Numerics.BigInteger.ToString%28System.IFormatProvider%29&gt;</ph> formatos do método um <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> valor em "R", ou viagem, formatar usando o <ph id="ph3">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> objeto de uma cultura específica.</target>       </trans-unit>
        <trans-unit id="1647" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.ToString(System.IFormatProvider)">
          <source>If you want to specify a different format or the current culture, use the other overloads of the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.ToString%2A&gt;</ph> method, as follows:</source>
          <target state="translated">Se você quiser especificar um formato diferente ou a cultura atual, use as outras sobrecargas do <ph id="ph1">&lt;xref:System.Numerics.BigInteger.ToString%2A&gt;</ph> método, da seguinte maneira:</target>       </trans-unit>
        <trans-unit id="1648" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.ToString(System.IFormatProvider)">
          <source>To use format</source>
          <target state="translated">Para usar o formato</target>       </trans-unit>
        <trans-unit id="1649" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.ToString(System.IFormatProvider)">
          <source>For culture</source>
          <target state="translated">Para a cultura</target>       </trans-unit>
        <trans-unit id="1650" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.ToString(System.IFormatProvider)">
          <source>Use the overload</source>
          <target state="translated">Use a sobrecarga</target>       </trans-unit>
        <trans-unit id="1651" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.ToString(System.IFormatProvider)">
          <source>Round-trip ("R") format</source>
          <target state="translated">Formato de round-trip ("R")</target>       </trans-unit>
        <trans-unit id="1652" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.ToString(System.IFormatProvider)">
          <source>Default (current) culture</source>
          <target state="translated">Cultura do padrão (atual)</target>       </trans-unit>
        <trans-unit id="1653" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.ToString(System.IFormatProvider)">
          <source>A specific format</source>
          <target state="translated">Um formato específico</target>       </trans-unit>
        <trans-unit id="1654" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.ToString(System.IFormatProvider)">
          <source>Default (current) culture</source>
          <target state="translated">Cultura do padrão (atual)</target>       </trans-unit>
        <trans-unit id="1655" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.ToString(System.IFormatProvider)">
          <source>A specific format</source>
          <target state="translated">Um formato específico</target>       </trans-unit>
        <trans-unit id="1656" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.ToString(System.IFormatProvider)">
          <source>A specific culture</source>
          <target state="translated">Uma cultura específica</target>       </trans-unit>
        <trans-unit id="1657" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.ToString(System.IFormatProvider)">
          <source>The <ph id="ph1">`provider`</ph> parameter is an <ph id="ph2">&lt;xref:System.IFormatProvider&gt;</ph> implementation.</source>
          <target state="translated">O parâmetro <ph id="ph1">`provider`</ph> é uma implementação de <ph id="ph2">&lt;xref:System.IFormatProvider&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1658" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.ToString(System.IFormatProvider)">
          <source>Its <ph id="ph1">&lt;xref:System.IFormatProvider.GetFormat%2A&gt;</ph> method returns a <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object that provides culture-specific information about the format of the string returned by this method.</source>
          <target state="translated">O método <ph id="ph1">&lt;xref:System.IFormatProvider.GetFormat%2A&gt;</ph> retorna um objeto <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> que fornece informações específicas de cultura sobre o formato da cadeia de caracteres retornada por esse método.</target>       </trans-unit>
        <trans-unit id="1659" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.ToString(System.IFormatProvider)">
          <source>If <ph id="ph1">`provider`</ph> is <ph id="ph2">`null`</ph>, the <ph id="ph3">&lt;xref:System.Numerics.BigInteger&gt;</ph> value is formatted using the <ph id="ph4">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object of the current culture.</source>
          <target state="translated">Se <ph id="ph1">`provider`</ph> é <ph id="ph2">`null`</ph>, o <ph id="ph3">&lt;xref:System.Numerics.BigInteger&gt;</ph> valor é formatado usando o <ph id="ph4">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> objeto da cultura atual.</target>       </trans-unit>
        <trans-unit id="1660" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.ToString(System.IFormatProvider)">
          <source>The only property of the <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object that controls the string representation of the <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> value using the general format specifier is <ph id="ph3">&lt;xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType&gt;</ph>, which defines the character that represents the negative sign.</source>
          <target state="translated">A única propriedade do <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> que controla a representação de cadeia de caracteres do objeto de <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> valor usando o especificador de formato geral é <ph id="ph3">&lt;xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType&gt;</ph>, que define o caractere que representa o sinal negativo.</target>       </trans-unit>
        <trans-unit id="1661" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.ToString(System.IFormatProvider)">
          <source>The <ph id="ph1">`provider`</ph> parameter can be one of the following:</source>
          <target state="translated">O parâmetro <ph id="ph1">`provider`</ph> pode ser um dos seguintes:</target>       </trans-unit>
        <trans-unit id="1662" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.ToString(System.IFormatProvider)">
          <source>A <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> object that represents the culture that supplies formatting information.</source>
          <target state="translated">Um objeto <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> que representa a cultura que fornece informações de formatação.</target>       </trans-unit>
        <trans-unit id="1663" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.ToString(System.IFormatProvider)">
          <source>The <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object that supplies formatting information.</source>
          <target state="translated">O objeto <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> que fornece informações de formatação.</target>       </trans-unit>
        <trans-unit id="1664" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.ToString(System.IFormatProvider)">
          <source>A custom object that implements <ph id="ph1">&lt;xref:System.IFormatProvider&gt;</ph>.</source>
          <target state="translated">Um objeto personalizado que implementa <ph id="ph1">&lt;xref:System.IFormatProvider&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1665" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.ToString(System.IFormatProvider)">
          <source>Its <ph id="ph1">&lt;xref:System.IFormatProvider.GetFormat%2A&gt;</ph> method returns the <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object that supplies formatting information.</source>
          <target state="translated">O método <ph id="ph1">&lt;xref:System.IFormatProvider.GetFormat%2A&gt;</ph> retorna o objeto <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> que fornece informações de formatação.</target>       </trans-unit>
        <trans-unit id="1666" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.ToString(System.IFormatProvider)">
          <source>The following example instantiates a custom <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object that defines the tilde (~) as a negative sign.</source>
          <target state="translated">O exemplo a seguir cria um personalizado <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> objeto que define o til (~) como um sinal negativo.</target>       </trans-unit>
        <trans-unit id="1667" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.ToString(System.IFormatProvider)">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.ToString%28System.IFormatProvider%29&gt;</ph> method then uses the custom <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object to display a negative <ph id="ph3">&lt;xref:System.Numerics.BigInteger&gt;</ph> value.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Numerics.BigInteger.ToString%28System.IFormatProvider%29&gt;</ph> método usa personalizado <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> objeto para exibir um negativo <ph id="ph3">&lt;xref:System.Numerics.BigInteger&gt;</ph> valor.</target>       </trans-unit>
        <trans-unit id="1668" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.ToString(System.String)">
          <source>A standard or custom numeric format string.</source>
          <target state="translated">Uma cadeia de caracteres padrão ou de formato numérico personalizado.</target>       </trans-unit>
        <trans-unit id="1669" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.ToString(System.String)">
          <source>Converts the numeric value of the current <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> object to its equivalent string representation by using the specified format.</source>
          <target state="translated">Converte o valor numérico do objeto <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> atual para sua representação de cadeia de caracteres equivalente usando o formato especificado.</target>       </trans-unit>
        <trans-unit id="1670" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.ToString(System.String)">
          <source>The string representation of the current <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> value in the format specified by the <ph id="ph2">&lt;paramref name="format" /&gt;</ph> parameter.</source>
          <target state="translated">A representação de cadeia de caracteres do valor <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> atual no formato especificado pelo parâmetro <ph id="ph2">&lt;paramref name="format" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1671" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.ToString(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.ToString%28System.String%29&gt;</ph> method formats a <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> value in a specified format by using a <ph id="ph3">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object that represents the conventions of the current culture.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Numerics.BigInteger.ToString%28System.String%29&gt;</ph> formatos do método um <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> valor em um formato especificado usando um <ph id="ph3">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> objeto que representa as convenções da cultura atual.</target>       </trans-unit>
        <trans-unit id="1672" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.ToString(System.String)">
          <source>If you want to use the "R", or round-trip, format or specify a different culture, use the other overloads of the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.ToString%2A&gt;</ph> method, as follows:</source>
          <target state="translated">Se você quiser usar o "R", ou uma viagem, formatar ou especificar uma cultura diferente, use as outras sobrecargas do <ph id="ph1">&lt;xref:System.Numerics.BigInteger.ToString%2A&gt;</ph> método, da seguinte maneira:</target>       </trans-unit>
        <trans-unit id="1673" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.ToString(System.String)">
          <source>To use format</source>
          <target state="translated">Para usar o formato</target>       </trans-unit>
        <trans-unit id="1674" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.ToString(System.String)">
          <source>For culture</source>
          <target state="translated">Para a cultura</target>       </trans-unit>
        <trans-unit id="1675" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.ToString(System.String)">
          <source>Use the overload</source>
          <target state="translated">Use a sobrecarga</target>       </trans-unit>
        <trans-unit id="1676" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.ToString(System.String)">
          <source>Round-trip ("R") format</source>
          <target state="translated">Formato de round-trip ("R")</target>       </trans-unit>
        <trans-unit id="1677" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.ToString(System.String)">
          <source>Default (current) culture</source>
          <target state="translated">Cultura do padrão (atual)</target>       </trans-unit>
        <trans-unit id="1678" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.ToString(System.String)">
          <source>Round-trip ("R") format</source>
          <target state="translated">Formato de round-trip ("R")</target>       </trans-unit>
        <trans-unit id="1679" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.ToString(System.String)">
          <source>A specific culture</source>
          <target state="translated">Uma cultura específica</target>       </trans-unit>
        <trans-unit id="1680" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.ToString(System.String)">
          <source>A specific format</source>
          <target state="translated">Um formato específico</target>       </trans-unit>
        <trans-unit id="1681" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.ToString(System.String)">
          <source>A specific culture</source>
          <target state="translated">Uma cultura específica</target>       </trans-unit>
        <trans-unit id="1682" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.ToString(System.String)">
          <source>The <ph id="ph1">`format`</ph> parameter can be any valid <bpt id="p1">[</bpt>standard numeric string<ept id="p1">](~/docs/standard/base-types/standard-numeric-format-strings.md)</ept>, or any combination of <bpt id="p2">[</bpt>custom numeric format strings<ept id="p2">](~/docs/standard/base-types/custom-numeric-format-strings.md)</ept>.</source>
          <target state="translated">O <ph id="ph1">`format`</ph> parâmetro pode ser qualquer <bpt id="p1">[</bpt>cadeia de caracteres numérica padrão<ept id="p1">](~/docs/standard/base-types/standard-numeric-format-strings.md)</ept>, ou qualquer combinação de <bpt id="p2">[</bpt>cadeias de caracteres de formato numérico personalizado<ept id="p2">](~/docs/standard/base-types/custom-numeric-format-strings.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1683" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.ToString(System.String)">
          <source>If <ph id="ph1">`format`</ph> is equal to <ph id="ph2">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph> or is <ph id="ph3">`null`</ph>, the return value of the current <ph id="ph4">&lt;xref:System.Numerics.BigInteger&gt;</ph> object is formatted with the round-trip format specifier ("R").</source>
          <target state="translated">Se <ph id="ph1">`format`</ph> é igual a <ph id="ph2">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph> ou <ph id="ph3">`null`</ph>, o valor de retorno do atual <ph id="ph4">&lt;xref:System.Numerics.BigInteger&gt;</ph> objeto é formatado com o especificador de formato de ida e volta ("R").</target>       </trans-unit>
        <trans-unit id="1684" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.ToString(System.String)">
          <source>If <ph id="ph1">`format`</ph> is any other value, the method throws a <ph id="ph2">&lt;xref:System.FormatException&gt;</ph>.</source>
          <target state="translated">Caso <ph id="ph1">`format`</ph> tenha qualquer outro valor, o método lança um <ph id="ph2">&lt;xref:System.FormatException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1685" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.ToString(System.String)">
          <source>The .NET Framework provides extensive formatting support, which is described in greater detail in the following formatting topics:</source>
          <target state="translated">O .NET Framework fornece extenso suporte à formatação, que é descrito com mais detalhes nos seguintes tópicos de formatação:</target>       </trans-unit>
        <trans-unit id="1686" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.ToString(System.String)">
          <source>For more information about numeric format specifiers, see <bpt id="p1">[</bpt>Standard Numeric Format Strings<ept id="p1">](~/docs/standard/base-types/standard-numeric-format-strings.md)</ept> and <bpt id="p2">[</bpt>Custom Numeric Format Strings<ept id="p2">](~/docs/standard/base-types/custom-numeric-format-strings.md)</ept>.</source>
          <target state="translated">Para obter mais informações sobre especificadores de formato numérico, consulte <bpt id="p1">[</bpt>cadeias de caracteres de formato numérico padrão<ept id="p1">](~/docs/standard/base-types/standard-numeric-format-strings.md)</ept> e <bpt id="p2">[</bpt>cadeias de caracteres de formato numérico personalizado<ept id="p2">](~/docs/standard/base-types/custom-numeric-format-strings.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1687" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.ToString(System.String)">
          <source>For more information about support for formatting in the .NET Framework, see <bpt id="p1">[</bpt>Formatting Types<ept id="p1">](~/docs/standard/base-types/formatting-types.md)</ept>.</source>
          <target state="translated">Para obter mais informações sobre o suporte para a formatação do .NET Framework, consulte <bpt id="p1">[</bpt>tipos de formatação<ept id="p1">](~/docs/standard/base-types/formatting-types.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1688" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.ToString(System.String)">
          <source>The format of the returned string is determined by the <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object for the current culture.</source>
          <target state="translated">O formato da cadeia de caracteres retornada é determinado pelo objeto <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> para a cultura atual.</target>       </trans-unit>
        <trans-unit id="1689" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.ToString(System.String)">
          <source>Depending on the <ph id="ph1">`format`</ph> parameter, this object controls symbols such as the negative sign, the group separator, and the decimal point symbol in the output string.</source>
          <target state="translated">Dependendo do parâmetro <ph id="ph1">`format`</ph>, esse objeto controla símbolos como o sinal negativo, o separador do grupo e o símbolo da vírgula decimal na cadeia de caracteres de saída.</target>       </trans-unit>
        <trans-unit id="1690" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.ToString(System.String)">
          <source>To provide formatting information for cultures other than the current culture, call the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29&gt;</ph> overload.</source>
          <target state="translated">Para fornecer informações de formatação para culturas diferentes a cultura atual, chame o <ph id="ph1">&lt;xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29&gt;</ph> sobrecarga.</target>       </trans-unit>
        <trans-unit id="1691" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.ToString(System.String)">
          <source>The following example initializes a <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> value and displays it by using each standard format string and some custom format strings.</source>
          <target state="translated">O exemplo a seguir inicializa um <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> valor e o exibe por meio de cada cadeia de caracteres de formato padrão e algumas cadeias de caracteres de formato personalizado.</target>       </trans-unit>
        <trans-unit id="1692" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.ToString(System.String)">
          <source><ph id="ph1">&lt;paramref name="format" /&gt;</ph> is not a valid format string.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="format" /&gt;</ph> não é uma cadeia de caracteres de formato válida.</target>       </trans-unit>
        <trans-unit id="1693" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.ToString(System.String,System.IFormatProvider)">
          <source>A standard or custom numeric format string.</source>
          <target state="translated">Uma cadeia de caracteres padrão ou de formato numérico personalizado.</target>       </trans-unit>
        <trans-unit id="1694" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.ToString(System.String,System.IFormatProvider)">
          <source>An object that supplies culture-specific formatting information.</source>
          <target state="translated">Um objeto que fornece informações de formatação específicas de cultura.</target>       </trans-unit>
        <trans-unit id="1695" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.ToString(System.String,System.IFormatProvider)">
          <source>Converts the numeric value of the current <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> object to its equivalent string representation by using the specified format and culture-specific format information.</source>
          <target state="translated">Converte o valor numérico do objeto <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> atual em sua representação de cadeia de caracteres equivalente usando o formato especificado e as informações de formato específicas de cultura.</target>       </trans-unit>
        <trans-unit id="1696" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.ToString(System.String,System.IFormatProvider)">
          <source>The string representation of the current <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> value as specified by the <ph id="ph2">&lt;paramref name="format" /&gt;</ph> and <ph id="ph3">&lt;paramref name="provider" /&gt;</ph> parameters.</source>
          <target state="translated">A representação de cadeia de caracteres do valor <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> atual, conforme especificado pelos parâmetros <ph id="ph2">&lt;paramref name="format" /&gt;</ph> e <ph id="ph3">&lt;paramref name="provider" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1697" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.ToString(System.String,System.IFormatProvider)">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29&gt;</ph> method formats a <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> value in a specified format by using the <ph id="ph3">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object of a specified culture.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29&gt;</ph> formatos do método um <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> valor em um formato especificado usando o <ph id="ph3">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> objeto de uma cultura específica.</target>       </trans-unit>
        <trans-unit id="1698" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.ToString(System.String,System.IFormatProvider)">
          <source>If you want to use the round-trip format or default culture settings, use the other overloads of the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.ToString%2A&gt;</ph> method, as follows:</source>
          <target state="translated">Se você quiser usar o formato de ida e volta ou configurações de cultura padrão, use as outras sobrecargas do <ph id="ph1">&lt;xref:System.Numerics.BigInteger.ToString%2A&gt;</ph> método, da seguinte maneira:</target>       </trans-unit>
        <trans-unit id="1699" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.ToString(System.String,System.IFormatProvider)">
          <source>To use format</source>
          <target state="translated">Para usar o formato</target>       </trans-unit>
        <trans-unit id="1700" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.ToString(System.String,System.IFormatProvider)">
          <source>For culture</source>
          <target state="translated">Para a cultura</target>       </trans-unit>
        <trans-unit id="1701" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.ToString(System.String,System.IFormatProvider)">
          <source>Use the overload</source>
          <target state="translated">Use a sobrecarga</target>       </trans-unit>
        <trans-unit id="1702" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.ToString(System.String,System.IFormatProvider)">
          <source>Round-trip ("R") format</source>
          <target state="translated">Formato de round-trip ("R")</target>       </trans-unit>
        <trans-unit id="1703" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.ToString(System.String,System.IFormatProvider)">
          <source>Default (current) culture</source>
          <target state="translated">Cultura do padrão (atual)</target>       </trans-unit>
        <trans-unit id="1704" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.ToString(System.String,System.IFormatProvider)">
          <source>Round-trip ("R") format</source>
          <target state="translated">Formato de round-trip ("R")</target>       </trans-unit>
        <trans-unit id="1705" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.ToString(System.String,System.IFormatProvider)">
          <source>A specific culture</source>
          <target state="translated">Uma cultura específica</target>       </trans-unit>
        <trans-unit id="1706" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.ToString(System.String,System.IFormatProvider)">
          <source>A specific format</source>
          <target state="translated">Um formato específico</target>       </trans-unit>
        <trans-unit id="1707" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.ToString(System.String,System.IFormatProvider)">
          <source>Default (current) culture</source>
          <target state="translated">Cultura do padrão (atual)</target>       </trans-unit>
        <trans-unit id="1708" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.ToString(System.String,System.IFormatProvider)">
          <source>The <ph id="ph1">`format`</ph> parameter can be any valid  <bpt id="p1">[</bpt>standard numeric string<ept id="p1">](~/docs/standard/base-types/standard-numeric-format-strings.md)</ept>, or any combination of <bpt id="p2">[</bpt>custom numeric format strings<ept id="p2">](~/docs/standard/base-types/custom-numeric-format-strings.md)</ept>.</source>
          <target state="translated">O <ph id="ph1">`format`</ph> parâmetro pode ser qualquer <bpt id="p1">[</bpt>cadeia de caracteres numérica padrão<ept id="p1">](~/docs/standard/base-types/standard-numeric-format-strings.md)</ept>, ou qualquer combinação de <bpt id="p2">[</bpt>cadeias de caracteres de formato numérico personalizado<ept id="p2">](~/docs/standard/base-types/custom-numeric-format-strings.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1709" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.ToString(System.String,System.IFormatProvider)">
          <source>If <ph id="ph1">`format`</ph> is equal to <ph id="ph2">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph> or is <ph id="ph3">`null`</ph>, the return value of the current <ph id="ph4">&lt;xref:System.Numerics.BigInteger&gt;</ph> object is formatted with the round-trip format specifier ("R").</source>
          <target state="translated">Se <ph id="ph1">`format`</ph> é igual a <ph id="ph2">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph> ou <ph id="ph3">`null`</ph>, o valor de retorno do atual <ph id="ph4">&lt;xref:System.Numerics.BigInteger&gt;</ph> objeto é formatado com o especificador de formato de ida e volta ("R").</target>       </trans-unit>
        <trans-unit id="1710" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.ToString(System.String,System.IFormatProvider)">
          <source>If <ph id="ph1">`format`</ph> is any other value, the method throws a <ph id="ph2">&lt;xref:System.FormatException&gt;</ph>.</source>
          <target state="translated">Caso <ph id="ph1">`format`</ph> tenha qualquer outro valor, o método lança um <ph id="ph2">&lt;xref:System.FormatException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1711" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.ToString(System.String,System.IFormatProvider)">
          <source>The .NET Framework provides extensive formatting support, which is described in greater detail in the following formatting topics:</source>
          <target state="translated">O .NET Framework fornece extenso suporte à formatação, que é descrito com mais detalhes nos seguintes tópicos de formatação:</target>       </trans-unit>
        <trans-unit id="1712" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.ToString(System.String,System.IFormatProvider)">
          <source>For more information about numeric format specifiers, see <bpt id="p1">[</bpt>Standard Numeric Format Strings<ept id="p1">](~/docs/standard/base-types/standard-numeric-format-strings.md)</ept> and <bpt id="p2">[</bpt>Custom Numeric Format Strings<ept id="p2">](~/docs/standard/base-types/custom-numeric-format-strings.md)</ept>.</source>
          <target state="translated">Para obter mais informações sobre especificadores de formato numérico, consulte <bpt id="p1">[</bpt>cadeias de caracteres de formato numérico padrão<ept id="p1">](~/docs/standard/base-types/standard-numeric-format-strings.md)</ept> e <bpt id="p2">[</bpt>cadeias de caracteres de formato numérico personalizado<ept id="p2">](~/docs/standard/base-types/custom-numeric-format-strings.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1713" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.ToString(System.String,System.IFormatProvider)">
          <source>For more information about support for formatting in the .NET Framework, see <bpt id="p1">[</bpt>Formatting Types<ept id="p1">](~/docs/standard/base-types/formatting-types.md)</ept>.</source>
          <target state="translated">Para obter mais informações sobre o suporte para a formatação do .NET Framework, consulte <bpt id="p1">[</bpt>tipos de formatação<ept id="p1">](~/docs/standard/base-types/formatting-types.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1714" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.ToString(System.String,System.IFormatProvider)">
          <source>The <ph id="ph1">`provider`</ph> parameter is an <ph id="ph2">&lt;xref:System.IFormatProvider&gt;</ph> implementation.</source>
          <target state="translated">O parâmetro <ph id="ph1">`provider`</ph> é uma implementação de <ph id="ph2">&lt;xref:System.IFormatProvider&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1715" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.ToString(System.String,System.IFormatProvider)">
          <source>Its <ph id="ph1">&lt;xref:System.IFormatProvider.GetFormat%2A&gt;</ph> method returns a <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object that provides culture-specific information about the format of the string returned by this method.</source>
          <target state="translated">O método <ph id="ph1">&lt;xref:System.IFormatProvider.GetFormat%2A&gt;</ph> retorna um objeto <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> que fornece informações específicas de cultura sobre o formato da cadeia de caracteres retornada por esse método.</target>       </trans-unit>
        <trans-unit id="1716" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.ToString(System.String,System.IFormatProvider)">
          <source>When the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29&gt;</ph> method is invoked, it calls the <ph id="ph2">`provider`</ph> parameter's <ph id="ph3">&lt;xref:System.IFormatProvider.GetFormat%2A&gt;</ph> method and passes it a <ph id="ph4">&lt;xref:System.Type&gt;</ph> object that represents the <ph id="ph5">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> type.</source>
          <target state="translated">Quando o <ph id="ph1">&lt;xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29&gt;</ph> método é invocado, ele chama o <ph id="ph2">`provider`</ph> do parâmetro <ph id="ph3">&lt;xref:System.IFormatProvider.GetFormat%2A&gt;</ph> método e o transmite um <ph id="ph4">&lt;xref:System.Type&gt;</ph> objeto que representa o <ph id="ph5">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> tipo.</target>       </trans-unit>
        <trans-unit id="1717" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.ToString(System.String,System.IFormatProvider)">
          <source>The <ph id="ph1">&lt;xref:System.IFormatProvider.GetFormat%2A&gt;</ph> method then returns the <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object that provides information for formatting the <ph id="ph3">`value`</ph> parameter, such as the negative sign symbol, the group separator symbol, or the decimal point symbol.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.IFormatProvider.GetFormat%2A&gt;</ph> , em seguida, o método retorna o <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> objeto que fornece informações de formatação de <ph id="ph3">`value`</ph> parâmetro, como o símbolo de sinal negativo, o símbolo de separador de grupo ou o símbolo de ponto decimal.</target>       </trans-unit>
        <trans-unit id="1718" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.ToString(System.String,System.IFormatProvider)">
          <source>There are three ways to use the <ph id="ph1">`provider`</ph> parameter to supply formatting information to the <ph id="ph2">&lt;xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29&gt;</ph> method:</source>
          <target state="translated">Há três maneiras de usar o <ph id="ph1">`provider`</ph> parâmetro para fornecer informações de formatação para o <ph id="ph2">&lt;xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29&gt;</ph> método:</target>       </trans-unit>
        <trans-unit id="1719" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.ToString(System.String,System.IFormatProvider)">
          <source>You can pass a <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> object that represents the culture that supplies formatting information.</source>
          <target state="translated">É possível passar um objeto <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> que representa a cultura que fornece informações de formatação.</target>       </trans-unit>
        <trans-unit id="1720" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.ToString(System.String,System.IFormatProvider)">
          <source>Its <ph id="ph1">&lt;xref:System.Globalization.CultureInfo.GetFormat%2A&gt;</ph> method returns the <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object that provides numeric formatting information for that culture.</source>
          <target state="translated">O método <ph id="ph1">&lt;xref:System.Globalization.CultureInfo.GetFormat%2A&gt;</ph> retorna o objeto <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> que fornece informações de formatação numérica para essa cultura.</target>       </trans-unit>
        <trans-unit id="1721" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.ToString(System.String,System.IFormatProvider)">
          <source>You can pass the actual <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object that provides numeric formatting information.</source>
          <target state="translated">É possível passar o objeto real <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> que fornece informações de formatação numérica.</target>       </trans-unit>
        <trans-unit id="1722" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.ToString(System.String,System.IFormatProvider)">
          <source>(Its implementation of <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo.GetFormat%2A&gt;</ph> just returns itself.)</source>
          <target state="translated">(Sua implementação de <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo.GetFormat%2A&gt;</ph> retorna apenas ele próprio.)</target>       </trans-unit>
        <trans-unit id="1723" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.ToString(System.String,System.IFormatProvider)">
          <source>You can pass a custom object that implements <ph id="ph1">&lt;xref:System.IFormatProvider&gt;</ph>.</source>
          <target state="translated">É possível passar um objeto personalizado que implementa <ph id="ph1">&lt;xref:System.IFormatProvider&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1724" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.ToString(System.String,System.IFormatProvider)">
          <source>Its <ph id="ph1">&lt;xref:System.IFormatProvider.GetFormat%2A&gt;</ph> method instantiates and returns the <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object that provides formatting information.</source>
          <target state="translated">O método <ph id="ph1">&lt;xref:System.IFormatProvider.GetFormat%2A&gt;</ph> cria uma instância e retorna o objeto <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> que fornece informações de formatação.</target>       </trans-unit>
        <trans-unit id="1725" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.ToString(System.String,System.IFormatProvider)">
          <source>If <ph id="ph1">`provider`</ph> is <ph id="ph2">`null`</ph>, the formatting of the returned string is based on the <ph id="ph3">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object of the current culture.</source>
          <target state="translated">Caso <ph id="ph1">`provider`</ph> seja <ph id="ph2">`null`</ph>, a formatação da cadeia de caracteres retornada baseia-se no objeto <ph id="ph3">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> da cultura atual.</target>       </trans-unit>
        <trans-unit id="1726" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.ToString(System.String,System.IFormatProvider)">
          <source>The following example initializes a <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> value, and displays it to the console using a standard format string and a <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object that defines the tilde (~) as a negative sign.</source>
          <target state="translated">O exemplo a seguir inicializa um <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> valor e o exibe no console usando uma cadeia de caracteres de formato padrão e uma <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> objeto que define o til (~) como um sinal negativo.</target>       </trans-unit>
        <trans-unit id="1727" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.ToString(System.String,System.IFormatProvider)">
          <source><ph id="ph1">&lt;paramref name="format" /&gt;</ph> is not a valid format string.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="format" /&gt;</ph> não é uma cadeia de caracteres de formato válida.</target>       </trans-unit>
        <trans-unit id="1728" translate="yes" xml:space="preserve" uid="T:System.Numerics.BigInteger">
          <source>Tries to convert the string representation of a number to its <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> equivalent, and returns a value that indicates whether the conversion succeeded.</source>
          <target state="translated">Tenta converter a representação de cadeia de caracteres de seu equivalente de <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> e retorna um valor que indica se a conversão foi bem-sucedida.</target>       </trans-unit>
        <trans-unit id="1729" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.TryParse(System.String,System.Numerics.BigInteger@)">
          <source>The string representation of a number.</source>
          <target state="translated">A representação de cadeia de caracteres de um número.</target>       </trans-unit>
        <trans-unit id="1730" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.TryParse(System.String,System.Numerics.BigInteger@)">
          <source>When this method returns, contains the <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> equivalent to the number that is contained in <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept>, or zero (0) if the conversion fails.</source>
          <target state="translated">Quando este método retorna, ele contém o <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> equivalente ao número contido em <bpt id="p1">&lt;c&gt;</bpt>valor<ept id="p1">&lt;/c&gt;</ept> ou zero (0) quando a conversão falha.</target>       </trans-unit>
        <trans-unit id="1731" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.TryParse(System.String,System.Numerics.BigInteger@)">
          <source>The conversion fails if the <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept> parameter is <ph id="ph1">&lt;see langword="null" /&gt;</ph> or is not of the correct format.</source>
          <target state="translated">A conversão falhará se o parâmetro de <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept> for <ph id="ph1">&lt;see langword="null" /&gt;</ph> ou não estiver no formato correto.</target>       </trans-unit>
        <trans-unit id="1732" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.TryParse(System.String,System.Numerics.BigInteger@)">
          <source>This parameter is passed uninitialized.</source>
          <target state="translated">Este parâmetro é passado não inicializado.</target>       </trans-unit>
        <trans-unit id="1733" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.TryParse(System.String,System.Numerics.BigInteger@)">
          <source>Tries to convert the string representation of a number to its <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> equivalent, and returns a value that indicates whether the conversion succeeded.</source>
          <target state="translated">Tenta converter a representação de cadeia de caracteres de seu equivalente de <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> e retorna um valor que indica se a conversão foi bem-sucedida.</target>       </trans-unit>
        <trans-unit id="1734" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.TryParse(System.String,System.Numerics.BigInteger@)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="value" /&gt;</ph> was converted successfully; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> caso <ph id="ph2">&lt;paramref name="value" /&gt;</ph> tenha sido convertido com êxito; do contrário, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1735" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.TryParse(System.String,System.Numerics.BigInteger@)">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Numerics.BigInteger%40%29&gt;</ph> method is like the <ph id="ph2">&lt;xref:System.Numerics.BigInteger.Parse%28System.String%29&gt;</ph> method, except that it does not throw an exception if the conversion fails.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Numerics.BigInteger%40%29&gt;</ph> método é como o <ph id="ph2">&lt;xref:System.Numerics.BigInteger.Parse%28System.String%29&gt;</ph> método, exceto que ele não gerará uma exceção se a conversão falhar.</target>       </trans-unit>
        <trans-unit id="1736" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.TryParse(System.String,System.Numerics.BigInteger@)">
          <source>This method eliminates the need to use exception handling to test for a <ph id="ph1">&lt;xref:System.FormatException&gt;</ph> if <ph id="ph2">`value`</ph> is invalid and cannot be successfully parsed.</source>
          <target state="translated">Esse método elimina a necessidade de usar a manipulação de exceção para testar um <ph id="ph1">&lt;xref:System.FormatException&gt;</ph> se <ph id="ph2">`value`</ph> é inválido e não pode ser analisado com êxito.</target>       </trans-unit>
        <trans-unit id="1737" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.TryParse(System.String,System.Numerics.BigInteger@)">
          <source>The <ph id="ph1">`value`</ph> parameter should be the string representation of a decimal number in the following form:</source>
          <target state="translated">O parâmetro <ph id="ph1">`value`</ph> deve ser a representação da cadeia de caracteres de um número decimal na seguinte forma:</target>       </trans-unit>
        <trans-unit id="1738" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.TryParse(System.String,System.Numerics.BigInteger@)">
          <source>[<bpt id="p1">*</bpt>ws<ept id="p1">*</ept>][<bpt id="p2">*</bpt>sign<ept id="p2">*</ept>]<bpt id="p3">*</bpt>digits<ept id="p3">*</ept>[<bpt id="p4">*</bpt>ws<ept id="p4">*</ept>]</source>
          <target state="translated">[<bpt id="p1">*</bpt>ws<ept id="p1">*</ept>][<bpt id="p2">*</bpt>sign<ept id="p2">*</ept>]<bpt id="p3">*</bpt>digits<ept id="p3">*</ept>[<bpt id="p4">*</bpt>ws<ept id="p4">*</ept>]</target>       </trans-unit>
        <trans-unit id="1739" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.TryParse(System.String,System.Numerics.BigInteger@)">
          <source>Elements in square brackets ([ and ]) are optional.</source>
          <target state="translated">Os elementos entre colchetes ([ e ]) são opcionais.</target>       </trans-unit>
        <trans-unit id="1740" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.TryParse(System.String,System.Numerics.BigInteger@)">
          <source>The following table describes each element.</source>
          <target state="translated">A tabela a seguir descreve cada elemento.</target>       </trans-unit>
        <trans-unit id="1741" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.TryParse(System.String,System.Numerics.BigInteger@)">
          <source>Element</source>
          <target state="translated">Elemento</target>       </trans-unit>
        <trans-unit id="1742" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.TryParse(System.String,System.Numerics.BigInteger@)">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="1743" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.TryParse(System.String,System.Numerics.BigInteger@)">
          <source><bpt id="p1">*</bpt>ws<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>ws<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="1744" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.TryParse(System.String,System.Numerics.BigInteger@)">
          <source>Optional white space.</source>
          <target state="translated">Espaço em branco opcional.</target>       </trans-unit>
        <trans-unit id="1745" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.TryParse(System.String,System.Numerics.BigInteger@)">
          <source><bpt id="p1">*</bpt>sign<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>sign<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="1746" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.TryParse(System.String,System.Numerics.BigInteger@)">
          <source>An optional sign.</source>
          <target state="translated">Um sinal opcional.</target>       </trans-unit>
        <trans-unit id="1747" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.TryParse(System.String,System.Numerics.BigInteger@)">
          <source>Valid sign characters are determined by the <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo.PositiveSign%2A?displayProperty=nameWithType&gt;</ph> properties of the current culture.</source>
          <target state="translated">Os caracteres de sinal válido são determinados pelas propriedades <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType&gt;</ph> e <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo.PositiveSign%2A?displayProperty=nameWithType&gt;</ph> da cultura atual.</target>       </trans-unit>
        <trans-unit id="1748" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.TryParse(System.String,System.Numerics.BigInteger@)">
          <source><bpt id="p1">*</bpt>digits<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>digits<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="1749" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.TryParse(System.String,System.Numerics.BigInteger@)">
          <source>A sequence of decimal digits ranging from 0 to 9.</source>
          <target state="translated">Uma sequência de dígitos decimais que varia de 0 a 9.</target>       </trans-unit>
        <trans-unit id="1750" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.TryParse(System.String,System.Numerics.BigInteger@)">
          <source>The string specified by the <ph id="ph1">`value`</ph> parameter cannot contain any group separators or decimal separator, and it cannot have a decimal portion.</source>
          <target state="translated">A cadeia de caracteres especificada o <ph id="ph1">`value`</ph> parâmetro não pode conter qualquer separadores de grupo ou o separador decimal e não pode ter uma parte decimal.</target>       </trans-unit>
        <trans-unit id="1751" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.TryParse(System.String,System.Numerics.BigInteger@)">
          <source>The <ph id="ph1">`value`</ph> parameter is interpreted by using the <ph id="ph2">&lt;xref:System.Globalization.NumberStyles.Integer?displayProperty=nameWithType&gt;</ph> style.</source>
          <target state="translated">O parâmetro <ph id="ph1">`value`</ph> é interpretado usando-se o estilo <ph id="ph2">&lt;xref:System.Globalization.NumberStyles.Integer?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1752" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.TryParse(System.String,System.Numerics.BigInteger@)">
          <source>In addition to the decimal digits, only leading and trailing spaces with a leading sign are allowed.</source>
          <target state="translated">Além dos dígitos decimais, apenas os espaço à esquerda e à direita com um sinal à esquerda são permitidos.</target>       </trans-unit>
        <trans-unit id="1753" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.TryParse(System.String,System.Numerics.BigInteger@)">
          <source>To explicitly define the style elements with the culture-specific formatting information that can be present in <ph id="ph1">`value`</ph>, call the <ph id="ph2">&lt;xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29&gt;</ph> method.</source>
          <target state="translated">Para definir explicitamente os elementos de estilo com as informações de formatação específica da cultura que podem estar presentes em <ph id="ph1">`value`</ph>, chame o <ph id="ph2">&lt;xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="1754" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.TryParse(System.String,System.Numerics.BigInteger@)">
          <source>The <ph id="ph1">`value`</ph> parameter is parsed by using the formatting information in a <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object for the current culture.</source>
          <target state="translated">O <ph id="ph1">`value`</ph> parâmetro é analisado usando as informações de formatação em um <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> objeto para a cultura atual.</target>       </trans-unit>
        <trans-unit id="1755" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.TryParse(System.String,System.Numerics.BigInteger@)">
          <source>For more information, see <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Para obter mais informações, consulte <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1756" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.TryParse(System.String,System.Numerics.BigInteger@)">
          <source>This overload interprets all digits in the <ph id="ph1">`value`</ph> parameter as decimal digits.</source>
          <target state="translated">Essa sobrecarga interpreta todos os dígitos de <ph id="ph1">`value`</ph> parâmetro como dígitos decimais.</target>       </trans-unit>
        <trans-unit id="1757" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.TryParse(System.String,System.Numerics.BigInteger@)">
          <source>To parse the string representation of a hexadecimal number, call the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29&gt;</ph> overload instead.</source>
          <target state="translated">Para analisar a representação de cadeia de caracteres de um número hexadecimal, chame o <ph id="ph1">&lt;xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29&gt;</ph> sobrecarga.</target>       </trans-unit>
        <trans-unit id="1758" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.TryParse(System.String,System.Numerics.BigInteger@)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Numerics.BigInteger%40%29&gt;</ph> method to instantiate two <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> objects.</source>
          <target state="translated">O exemplo a seguir usa o <ph id="ph1">&lt;xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Numerics.BigInteger%40%29&gt;</ph> método para instanciar dois <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> objetos.</target>       </trans-unit>
        <trans-unit id="1759" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.TryParse(System.String,System.Numerics.BigInteger@)">
          <source>If the conversions succeed, it multiplies each object by another number and then calls the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Compare%2A&gt;</ph> method to determine the relationship between the two objects.</source>
          <target state="translated">Se as conversões tiver êxito, ele multiplica cada objeto por outro número e, em seguida, chama o <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Compare%2A&gt;</ph> método para determinar a relação entre os dois objetos.</target>       </trans-unit>
        <trans-unit id="1760" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.TryParse(System.String,System.Numerics.BigInteger@)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1761" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)">
          <source>The string representation of a number.</source>
          <target state="translated">A representação de cadeia de caracteres de um número.</target>       </trans-unit>
        <trans-unit id="1762" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)">
          <source>The string is interpreted using the style specified by <bpt id="p1">&lt;c&gt;</bpt>style<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">A cadeia de caracteres é interpretada usando-se o estilo especificado por <bpt id="p1">&lt;c&gt;</bpt>style<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="1763" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)">
          <source>A bitwise combination of enumeration values that indicates the style elements that can be present in <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Um combinação bit a bit de valores de enumeração que indica os elementos de estilo que podem estar presentes em <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="1764" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)">
          <source>A typical value to specify is <ph id="ph1">&lt;see cref="F:System.Globalization.NumberStyles.Integer" /&gt;</ph>.</source>
          <target state="translated">Um valor típico a ser especificado é <ph id="ph1">&lt;see cref="F:System.Globalization.NumberStyles.Integer" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1765" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)">
          <source>An object that supplies culture-specific formatting information about <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Um objeto que fornece informações de formatação específicas de cultura sobre <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="1766" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)">
          <source>When this method returns, contains the <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> equivalent to the number that is contained in <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept>, or <ph id="ph2">&lt;see cref="P:System.Numerics.BigInteger.Zero" /&gt;</ph> if the conversion failed.</source>
          <target state="translated">Quando esse método é retornado, contém o equivalente <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> do número contido em <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept> ou <ph id="ph2">&lt;see cref="P:System.Numerics.BigInteger.Zero" /&gt;</ph> se a conversão falhou.</target>       </trans-unit>
        <trans-unit id="1767" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)">
          <source>The conversion fails if the <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept> parameter is <ph id="ph1">&lt;see langword="null" /&gt;</ph> or is not in a format that is compliant with <bpt id="p2">&lt;c&gt;</bpt>style<ept id="p2">&lt;/c&gt;</ept>.</source>
          <target state="translated">A conversão falhará se o parâmetro <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept> for <ph id="ph1">&lt;see langword="null" /&gt;</ph> ou não estiver em um formato em conformidade com <bpt id="p2">&lt;c&gt;</bpt>style<ept id="p2">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="1768" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)">
          <source>This parameter is passed uninitialized.</source>
          <target state="translated">Este parâmetro é passado não inicializado.</target>       </trans-unit>
        <trans-unit id="1769" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)">
          <source>Tries to convert the string representation of a number in a specified style and culture-specific format to its <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> equivalent, and returns a value that indicates whether the conversion succeeded.</source>
          <target state="translated">Tenta converter a representação de cadeia de caracteres de um número em um estilo e formato específico à cultura especificados no equivalente <ph id="ph1">&lt;see cref="T:System.Numerics.BigInteger" /&gt;</ph> e retorna um valor que indica se a conversão foi bem-sucedida.</target>       </trans-unit>
        <trans-unit id="1770" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;paramref name="value" /&gt;</ph> parameter was converted successfully; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> caso o parâmetro <ph id="ph2">&lt;paramref name="value" /&gt;</ph> tenha sido convertido com êxito; do contrário, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1771" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29&gt;</ph> method is like the <ph id="ph2">&lt;xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29&gt;</ph> method, except that it does not throw an exception if the conversion fails.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29&gt;</ph> método é como o <ph id="ph2">&lt;xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29&gt;</ph> método, exceto que ele não gerará uma exceção se a conversão falhar.</target>       </trans-unit>
        <trans-unit id="1772" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)">
          <source>This method eliminates the need to use exception handling to test for a <ph id="ph1">&lt;xref:System.FormatException&gt;</ph> if <ph id="ph2">`value`</ph> is invalid and cannot be parsed successfully.</source>
          <target state="translated">Esse método elimina a necessidade de usar a manipulação de exceção para testar um <ph id="ph1">&lt;xref:System.FormatException&gt;</ph> se <ph id="ph2">`value`</ph> é inválido e não pode ser analisado com êxito.</target>       </trans-unit>
        <trans-unit id="1773" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)">
          <source>The <ph id="ph1">`style`</ph> parameter defines the style elements (such as white space or a positive or negative sign) that are allowed in the <ph id="ph2">`value`</ph> parameter for the parse operation to succeed.</source>
          <target state="translated">O parâmetro <ph id="ph1">`style`</ph> define os elementos de estilo (como o espaço em branco ou um sinal positivo ou negativo) que são permitidos no parâmetro <ph id="ph2">`value`</ph> para que a operação de análise seja bem-sucedida.</target>       </trans-unit>
        <trans-unit id="1774" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)">
          <source>It must be a combination of bit flags from the <ph id="ph1">&lt;xref:System.Globalization.NumberStyles&gt;</ph> enumeration.</source>
          <target state="translated">Ele deve ser uma combinação de sinalizadores de bits da enumeração <ph id="ph1">&lt;xref:System.Globalization.NumberStyles&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1775" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)">
          <source>Depending on the value of <ph id="ph1">`style`</ph>, the <ph id="ph2">`value`</ph> parameter may include the following elements:</source>
          <target state="translated">Dependendo do valor de <ph id="ph1">`style`</ph>, o parâmetro <ph id="ph2">`value`</ph> pode incluir os seguintes elementos:</target>       </trans-unit>
        <trans-unit id="1776" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)">
          <source>[<bpt id="p1">*</bpt>ws<ept id="p1">*</ept>][<bpt id="p2">*</bpt><ph id="ph1">$</ph><ept id="p2">*</ept>][<bpt id="p3">*</bpt>sign<ept id="p3">*</ept>][<bpt id="p4">*</bpt>digits<ept id="p4">*</ept>,]<bpt id="p5">*</bpt>digits<ept id="p5">*</ept>[.<bpt id="p6">*</bpt>fractional_digits<ept id="p6">*</ept>][E[<bpt id="p7">*</bpt>sign<ept id="p7">*</ept>]<bpt id="p8">*</bpt>exponential_digits<ept id="p8">*</ept>][<bpt id="p9">*</bpt>ws<ept id="p9">*</ept>]</source>
          <target state="translated">[<bpt id="p1">*</bpt>ws<ept id="p1">*</ept>][<bpt id="p2">*</bpt><ph id="ph1">$</ph><ept id="p2">*</ept>][<bpt id="p3">*</bpt>sign<ept id="p3">*</ept>][<bpt id="p4">*</bpt>digits<ept id="p4">*</ept>,]<bpt id="p5">*</bpt>digits<ept id="p5">*</ept>[.<bpt id="p6">*</bpt>fractional_digits<ept id="p6">*</ept>][E[<bpt id="p7">*</bpt>sign<ept id="p7">*</ept>]<bpt id="p8">*</bpt>exponential_digits<ept id="p8">*</ept>][<bpt id="p9">*</bpt>ws<ept id="p9">*</ept>]</target>       </trans-unit>
        <trans-unit id="1777" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)">
          <source>If the <ph id="ph1">`style`</ph> parameter includes <ph id="ph2">&lt;xref:System.Globalization.NumberStyles.AllowHexSpecifier&gt;</ph>, the <ph id="ph3">`value`</ph> parameter may include the following elements:</source>
          <target state="translated">Se o <ph id="ph1">`style`</ph> inclui o parâmetro <ph id="ph2">&lt;xref:System.Globalization.NumberStyles.AllowHexSpecifier&gt;</ph>, o <ph id="ph3">`value`</ph> parâmetro pode incluir os seguintes elementos:</target>       </trans-unit>
        <trans-unit id="1778" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)">
          <source>[<bpt id="p1">*</bpt>ws<ept id="p1">*</ept>]<bpt id="p2">*</bpt>hexdigits<ept id="p2">*</ept>[<bpt id="p3">*</bpt>ws<ept id="p3">*</ept>]</source>
          <target state="translated">[<bpt id="p1">*</bpt>ws<ept id="p1">*</ept>]<bpt id="p2">*</bpt>hexdigits<ept id="p2">*</ept>[<bpt id="p3">*</bpt>ws<ept id="p3">*</ept>]</target>       </trans-unit>
        <trans-unit id="1779" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)">
          <source>Elements in square brackets ([ and ]) are optional.</source>
          <target state="translated">Os elementos entre colchetes ([ e ]) são opcionais.</target>       </trans-unit>
        <trans-unit id="1780" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)">
          <source>The following table describes each element.</source>
          <target state="translated">A tabela a seguir descreve cada elemento.</target>       </trans-unit>
        <trans-unit id="1781" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)">
          <source>Element</source>
          <target state="translated">Elemento</target>       </trans-unit>
        <trans-unit id="1782" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)">
          <source>Description</source>
          <target state="translated">Descrição</target>       </trans-unit>
        <trans-unit id="1783" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)">
          <source><bpt id="p1">*</bpt>ws<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>ws<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="1784" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)">
          <source>Optional white space.</source>
          <target state="translated">Espaço em branco opcional.</target>       </trans-unit>
        <trans-unit id="1785" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)">
          <source>White space can appear at the start of <ph id="ph1">`value`</ph> if <ph id="ph2">`style`</ph> includes the <ph id="ph3">&lt;xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType&gt;</ph> flag, or at the end of <ph id="ph4">`value`</ph> if <ph id="ph5">`style`</ph> includes the <ph id="ph6">&lt;xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Espaço em branco pode aparecer no início de <ph id="ph1">`value`</ph> se <ph id="ph2">`style`</ph> inclui o <ph id="ph3">&lt;xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType&gt;</ph> sinalizador, ou no final da <ph id="ph4">`value`</ph> se <ph id="ph5">`style`</ph> inclui o <ph id="ph6">&lt;xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType&gt;</ph> sinalizador.</target>       </trans-unit>
        <trans-unit id="1786" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)">
          <source>A culture-specific currency symbol.</source>
          <target state="translated">Um símbolo de moeda específico de cultura.</target>       </trans-unit>
        <trans-unit id="1787" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)">
          <source>Its position in the string is defined by the <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A&gt;</ph> property of the <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object returned by the <ph id="ph3">&lt;xref:System.IFormatProvider.GetFormat%2A&gt;</ph> method of the <ph id="ph4">`provider`</ph> parameter.</source>
          <target state="translated">A posição na cadeia de caracteres é definida pela propriedade <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A&gt;</ph> do objeto <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> retornado pelo método <ph id="ph3">&lt;xref:System.IFormatProvider.GetFormat%2A&gt;</ph> do parâmetro <ph id="ph4">`provider`</ph>.</target>       </trans-unit>
        <trans-unit id="1788" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)">
          <source>The currency symbol can appear in <ph id="ph1">`value`</ph> if <ph id="ph2">`style`</ph> includes the <ph id="ph3">&lt;xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">O símbolo de moeda pode ser exibido em <ph id="ph1">`value`</ph> caso <ph id="ph2">`style`</ph> inclua o sinalizador <ph id="ph3">&lt;xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1789" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)">
          <source><bpt id="p1">*</bpt>sign<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>sign<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="1790" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)">
          <source>An optional sign.</source>
          <target state="translated">Um sinal opcional.</target>       </trans-unit>
        <trans-unit id="1791" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)">
          <source>The sign can appear at the start of <ph id="ph1">`value`</ph> if <ph id="ph2">`style`</ph> includes the <ph id="ph3">&lt;xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType&gt;</ph> flag, and it can appear at the end of <ph id="ph4">`value`</ph> if <ph id="ph5">`style`</ph> includes the <ph id="ph6">&lt;xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">O sinal pode ser exibido no início de <ph id="ph1">`value`</ph> caso <ph id="ph2">`style`</ph> inclua o sinalizador <ph id="ph3">&lt;xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType&gt;</ph> e ele pode ser exibido no final de <ph id="ph4">`value`</ph> caso <ph id="ph5">`style`</ph> inclua o sinalizador <ph id="ph6">&lt;xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1792" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)">
          <source>Parentheses can be used in <ph id="ph1">`value`</ph> to indicate a negative value if <ph id="ph2">`style`</ph> includes the <ph id="ph3">&lt;xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Os parênteses podem ser usados em <ph id="ph1">`value`</ph> para indicar um valor negativo caso <ph id="ph2">`style`</ph> inclua o sinalizador <ph id="ph3">&lt;xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1793" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)">
          <source><bpt id="p1">*</bpt>digits<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>digits<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="1794" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)">
          <source>A sequence of digits from 0 through 9.</source>
          <target state="translated">Uma sequência de dígitos de 0 a 9.</target>       </trans-unit>
        <trans-unit id="1795" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)">
          <source><bpt id="p1">*</bpt>,<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>,<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="1796" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)">
          <source>A culture-specific group separator.</source>
          <target state="translated">Um separador de grupo específico de cultura.</target>       </trans-unit>
        <trans-unit id="1797" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)">
          <source>The group separator of the culture specified by <ph id="ph1">`provider`</ph> can appear in <ph id="ph2">`value`</ph> if <ph id="ph3">`style`</ph> includes the <ph id="ph4">&lt;xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">O separador de grupo da cultura especificada por <ph id="ph1">`provider`</ph> pode aparecer em <ph id="ph2">`value`</ph> se <ph id="ph3">`style`</ph> inclui o <ph id="ph4">&lt;xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType&gt;</ph> sinalizador.</target>       </trans-unit>
        <trans-unit id="1798" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)">
          <source><bpt id="p1">*</bpt>.<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>.<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="1799" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)">
          <source>A culture-specific decimal point symbol.</source>
          <target state="translated">Um símbolo de vírgula decimal específico de cultura.</target>       </trans-unit>
        <trans-unit id="1800" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)">
          <source>The decimal point symbol of the culture specified by <ph id="ph1">`provider`</ph> can appear in <ph id="ph2">`value`</ph> if <ph id="ph3">`style`</ph> includes the <ph id="ph4">&lt;xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">O símbolo da vírgula decimal da cultura especificada por <ph id="ph1">`provider`</ph> pode ser exibido em <ph id="ph2">`value`</ph> caso <ph id="ph3">`style`</ph> inclua o sinalizador <ph id="ph4">&lt;xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1801" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)">
          <source><bpt id="p1">*</bpt>fractional_digits<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>fractional_digits<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="1802" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)">
          <source>One or more occurrences of the digit 0.</source>
          <target state="translated">Uma ou mais ocorrências de dígito 0.</target>       </trans-unit>
        <trans-unit id="1803" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)">
          <source>Fractional digits can appear in <ph id="ph1">`value`</ph> only if <ph id="ph2">`style`</ph> includes the <ph id="ph3">&lt;xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Os dígitos fracionários só podem ser exibidos em <ph id="ph1">`value`</ph> caso <ph id="ph2">`style`</ph> inclua o sinalizador <ph id="ph3">&lt;xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1804" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)">
          <source>E</source>
          <target state="translated">E</target>       </trans-unit>
        <trans-unit id="1805" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)">
          <source>The "e" or "E" character, which indicates that the value is represented in exponential (scientific) notation.</source>
          <target state="translated">O caractere "e" ou "E", que indica que o valor é representado em notação exponencial (científica).</target>       </trans-unit>
        <trans-unit id="1806" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)">
          <source>The <ph id="ph1">`value`</ph> parameter can represent a number in exponential notation if <ph id="ph2">`style`</ph> includes the <ph id="ph3">&lt;xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">O parâmetro <ph id="ph1">`value`</ph> pode representar um número em notação exponencial caso <ph id="ph2">`style`</ph> inclua o sinalizador <ph id="ph3">&lt;xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1807" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)">
          <source><bpt id="p1">*</bpt>exponential_digits<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>exponential_digits<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="1808" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)">
          <source>A sequence of digits from 0 through 9.</source>
          <target state="translated">Uma sequência de dígitos de 0 a 9.</target>       </trans-unit>
        <trans-unit id="1809" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)">
          <source>The <ph id="ph1">`value`</ph> parameter can represent a number in exponential notation if <ph id="ph2">`style`</ph> includes the <ph id="ph3">&lt;xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">O parâmetro <ph id="ph1">`value`</ph> pode representar um número em notação exponencial caso <ph id="ph2">`style`</ph> inclua o sinalizador <ph id="ph3">&lt;xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1810" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)">
          <source><bpt id="p1">*</bpt>hexdigits<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>hexdigits<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="1811" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)">
          <source>A sequence of hexadecimal digits from 0 through f, or 0 through F.</source>
          <target state="translated">Uma sequência de dígitos hexadecimais de 0 a f ou de 0 a F.</target>       </trans-unit>
        <trans-unit id="1812" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)">
          <source>A string with decimal digits only (which corresponds to the <ph id="ph1">&lt;xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType&gt;</ph> flag) always parses successfully.</source>
          <target state="translated">Uma cadeia de caracteres apenas com dígitos decimais (que corresponde ao sinalizador <ph id="ph1">&lt;xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType&gt;</ph> ) sempre é analisada com êxito.</target>       </trans-unit>
        <trans-unit id="1813" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)">
          <source>Most of the remaining <ph id="ph1">&lt;xref:System.Globalization.NumberStyles&gt;</ph> members control elements that may be present, but are not required to be present, in this input string.</source>
          <target state="translated">A maioria dos elementos de controle de membros <ph id="ph1">&lt;xref:System.Globalization.NumberStyles&gt;</ph> restantes que podem estar presentes, mas que não precisam estar presentes, na cadeia de caracteres de entrada.</target>       </trans-unit>
        <trans-unit id="1814" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)">
          <source>The following table indicates how individual <ph id="ph1">&lt;xref:System.Globalization.NumberStyles&gt;</ph> members affect the elements that may be present in <ph id="ph2">`value`</ph>.</source>
          <target state="translated">A tabela a seguir indica como os membros <ph id="ph1">&lt;xref:System.Globalization.NumberStyles&gt;</ph> individuais afetam os elementos que podem estar presentes em <ph id="ph2">`value`</ph>.</target>       </trans-unit>
        <trans-unit id="1815" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)">
          <source>Non-composite <ph id="ph1">`NumberStyles`</ph> values</source>
          <target state="translated">Valores <ph id="ph1">`NumberStyles`</ph> não compostos</target>       </trans-unit>
        <trans-unit id="1816" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)">
          <source>Elements permitted in value in addition to digits</source>
          <target state="translated">Elementos permitidos no valor além de dígitos</target>       </trans-unit>
        <trans-unit id="1817" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)">
          <source>Decimal digits only.</source>
          <target state="translated">Somente dígitos decimais.</target>       </trans-unit>
        <trans-unit id="1818" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)">
          <source>The decimal point (<bpt id="p1">*</bpt>.<ept id="p1">*</ept>) and <bpt id="p2">*</bpt>fractional_digits<ept id="p2">*</ept> elements.</source>
          <target state="translated">O ponto decimal (<bpt id="p1">*</bpt>.<ept id="p1">*</ept>) e <bpt id="p2">*</bpt>fractional_digits<ept id="p2">*</ept> elementos.</target>       </trans-unit>
        <trans-unit id="1819" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)">
          <source>However, <bpt id="p1">*</bpt>fractional_digits<ept id="p1">*</ept> must consist of only one or more 0 digits, or the method returns <ph id="ph1">`false`</ph>.</source>
          <target state="translated">No entanto, <bpt id="p1">*</bpt>fractional_digits<ept id="p1">*</ept> deve consistir de apenas um ou mais dígitos 0 ou o método retorna <ph id="ph1">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="1820" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)">
          <source>The "e" or "E" character, which indicates exponential notation, along with <bpt id="p1">*</bpt>exponential_digits<ept id="p1">*</ept>.</source>
          <target state="translated">O "e" ou o caractere "E", que indica a notação exponencial, juntamente com <bpt id="p1">*</bpt>exponential_digits<ept id="p1">*</ept>.</target>       </trans-unit>
        <trans-unit id="1821" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)">
          <source>If <ph id="ph1">`value`</ph> represents a number in exponential notation, it cannot have a non-zero, fractional component.</source>
          <target state="translated">Se <ph id="ph1">`value`</ph> representa um número em notação exponencial, ele não pode ter um componente diferente de zero, frações.</target>       </trans-unit>
        <trans-unit id="1822" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)">
          <source>The <bpt id="p1">*</bpt>ws<ept id="p1">*</ept> element at the start of <ph id="ph1">`value`</ph>.</source>
          <target state="translated">O <bpt id="p1">*</bpt>ws<ept id="p1">*</ept> elemento no início de <ph id="ph1">`value`</ph>.</target>       </trans-unit>
        <trans-unit id="1823" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)">
          <source>The <bpt id="p1">*</bpt>ws<ept id="p1">*</ept> element at the end of <ph id="ph1">`value`</ph>.</source>
          <target state="translated">O elemento <bpt id="p1">*</bpt>ws<ept id="p1">*</ept> no final de <ph id="ph1">`value`</ph>.</target>       </trans-unit>
        <trans-unit id="1824" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)">
          <source>The <bpt id="p1">*</bpt>sign<ept id="p1">*</ept> element before <bpt id="p2">*</bpt>digits<ept id="p2">*</ept>.</source>
          <target state="translated">O <bpt id="p1">*</bpt>sinal<ept id="p1">*</ept> elemento antes <bpt id="p2">*</bpt>dígitos<ept id="p2">*</ept>.</target>       </trans-unit>
        <trans-unit id="1825" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)">
          <source>The <bpt id="p1">*</bpt>sign<ept id="p1">*</ept> element after <bpt id="p2">*</bpt>digits<ept id="p2">*</ept>.</source>
          <target state="translated">O <bpt id="p1">*</bpt>sinal<ept id="p1">*</ept> elemento após <bpt id="p2">*</bpt>dígitos<ept id="p2">*</ept>.</target>       </trans-unit>
        <trans-unit id="1826" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)">
          <source>The <bpt id="p1">*</bpt>sign<ept id="p1">*</ept> element in the form of parentheses enclosing the numeric value.</source>
          <target state="translated">O elemento <bpt id="p1">*</bpt>sinal<ept id="p1">*</ept> na forma de parênteses que incluem o valor numérico.</target>       </trans-unit>
        <trans-unit id="1827" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)">
          <source>The group separator (<bpt id="p1">*</bpt>,<ept id="p1">*</ept>) element.</source>
          <target state="translated">O separador de grupo (<bpt id="p1">*</bpt>,<ept id="p1">*</ept>) elemento.</target>       </trans-unit>
        <trans-unit id="1828" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)">
          <source>The currency (<bpt id="p1">*</bpt><ph id="ph1">$</ph><ept id="p1">*</ept>) element.</source>
          <target state="translated">A moeda (<bpt id="p1">*</bpt><ph id="ph1">$</ph><ept id="p1">*</ept>) elemento.</target>       </trans-unit>
        <trans-unit id="1829" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)">
          <source>All elements.</source>
          <target state="translated">Todos os elementos.</target>       </trans-unit>
        <trans-unit id="1830" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)">
          <source>However, <ph id="ph1">`value`</ph> cannot represent a hexadecimal number or a number in exponential notation.</source>
          <target state="translated">No entanto, <ph id="ph1">`value`</ph> não pode representar um número hexadecimal ou um número em notação exponencial.</target>       </trans-unit>
        <trans-unit id="1831" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)">
          <source>The <bpt id="p1">*</bpt>ws<ept id="p1">*</ept> element at the start or end of <ph id="ph1">`value`</ph>, <bpt id="p2">*</bpt>sign<ept id="p2">*</ept> at the start of <ph id="ph2">`value`</ph>, and the decimal point (<bpt id="p3">*</bpt>.<ept id="p3">*</ept>) symbol.</source>
          <target state="translated">O <bpt id="p1">*</bpt>ws<ept id="p1">*</ept> elemento no início ou no final de <ph id="ph1">`value`</ph>, <bpt id="p2">*</bpt>sinal<ept id="p2">*</ept> no início de <ph id="ph2">`value`</ph>e o ponto decimal (<bpt id="p3">*</bpt>.<ept id="p3">*</ept>) símbolo.</target>       </trans-unit>
        <trans-unit id="1832" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)">
          <source>The <ph id="ph1">`value`</ph> parameter can also use exponential notation.</source>
          <target state="translated">O parâmetro <ph id="ph1">`value`</ph> também pode usar notação exponencial.</target>       </trans-unit>
        <trans-unit id="1833" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)">
          <source>The <bpt id="p1">*</bpt>ws<ept id="p1">*</ept>, <bpt id="p2">*</bpt>sign<ept id="p2">*</ept>, group separator (<bpt id="p3">*</bpt>,<ept id="p3">*</ept>), and decimal point (<bpt id="p4">*</bpt>.<ept id="p4">*</ept>) elements.</source>
          <target state="translated">O <bpt id="p1">*</bpt>ws<ept id="p1">*</ept>, <bpt id="p2">*</bpt>sinal<ept id="p2">*</ept>, separador de grupo (<bpt id="p3">*</bpt>,<ept id="p3">*</ept>) e o ponto decimal (<bpt id="p4">*</bpt>.<ept id="p4">*</ept>) elementos.</target>       </trans-unit>
        <trans-unit id="1834" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)">
          <source>All elements.</source>
          <target state="translated">Todos os elementos.</target>       </trans-unit>
        <trans-unit id="1835" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)">
          <source>However, <ph id="ph1">`value`</ph> cannot represent a hexadecimal number.</source>
          <target state="translated">No entanto, <ph id="ph1">`value`</ph> não pode representar um número hexadecimal.</target>       </trans-unit>
        <trans-unit id="1836" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)">
          <source>If you use the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.TryParse%2A&gt;</ph> method to round-trip the string representation of a <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> value that was output by the <ph id="ph3">&lt;xref:System.Numerics.BigInteger.ToString%2A&gt;</ph> method, you should use the <ph id="ph4">&lt;xref:System.Numerics.BigInteger.ToString%28System.String%29?displayProperty=nameWithType&gt;</ph> method with the "R" format specifier to generate the string representation of the <ph id="ph5">&lt;xref:System.Numerics.BigInteger&gt;</ph> value.</source>
          <target state="translated">Se você usar o <ph id="ph1">&lt;xref:System.Numerics.BigInteger.TryParse%2A&gt;</ph> método viagem a representação de cadeia de caracteres de um <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> valor foi saída o <ph id="ph3">&lt;xref:System.Numerics.BigInteger.ToString%2A&gt;</ph> método, você deve usar o <ph id="ph4">&lt;xref:System.Numerics.BigInteger.ToString%28System.String%29?displayProperty=nameWithType&gt;</ph> método com o especificador de formato "R" para gerar a representação de cadeia de caracteres da <ph id="ph5">&lt;xref:System.Numerics.BigInteger&gt;</ph> valor.</target>       </trans-unit>
        <trans-unit id="1837" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)">
          <source>Otherwise, the string representation of the <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> preserves only the 50 most significant digits of the original value, and data may be lost when you use the <ph id="ph2">&lt;xref:System.Numerics.BigInteger.TryParse%2A&gt;</ph> method to restore the <ph id="ph3">&lt;xref:System.Numerics.BigInteger&gt;</ph> value.</source>
          <target state="translated">Caso contrário, a representação de cadeia de caracteres da <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> preserva apenas os 50 dígitos significativos do valor original e dados podem ser perdidos quando você usa o <ph id="ph2">&lt;xref:System.Numerics.BigInteger.TryParse%2A&gt;</ph> método para restaurar o <ph id="ph3">&lt;xref:System.Numerics.BigInteger&gt;</ph> valor.</target>       </trans-unit>
        <trans-unit id="1838" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)">
          <source>If the <ph id="ph1">&lt;xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType&gt;</ph> flag is used, <ph id="ph2">`value`</ph> must be a hexadecimal value.</source>
          <target state="translated">Caso o sinalizador <ph id="ph1">&lt;xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType&gt;</ph> seja usado, <ph id="ph2">`value`</ph> deve ser um valor hexadecimal.</target>       </trans-unit>
        <trans-unit id="1839" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)">
          <source>The only other flags that can be present in <ph id="ph1">`style`</ph> are <ph id="ph2">&lt;xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType&gt;</ph> and <ph id="ph3">&lt;xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Os únicos outros sinalizadores que podem estar presentes em <ph id="ph1">`style`</ph> são <ph id="ph2">&lt;xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType&gt;</ph> e <ph id="ph3">&lt;xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1840" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)">
          <source>(The <ph id="ph1">&lt;xref:System.Globalization.NumberStyles&gt;</ph> enumeration has a composite style, <ph id="ph2">&lt;xref:System.Globalization.NumberStyles.HexNumber&gt;</ph>, that includes both white-space flags.)</source>
          <target state="translated">(A enumeração <ph id="ph1">&lt;xref:System.Globalization.NumberStyles&gt;</ph> tem um estilo composto, <ph id="ph2">&lt;xref:System.Globalization.NumberStyles.HexNumber&gt;</ph>, que inclui ambos os sinalizadores de espaço em branco.)</target>       </trans-unit>
        <trans-unit id="1841" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)">
          <source>If <ph id="ph1">`value`</ph> is the string representation of a hexadecimal number, it cannot be preceded by any decoration (such as <ph id="ph2">`0x`</ph> or <ph id="ph3">`&amp;h`</ph>) that differentiates it as a hexadecimal number.</source>
          <target state="translated">Caso <ph id="ph1">`value`</ph> seja a representação da cadeia de caracteres de um número hexadecimal, ele não pode ser precedido por qualquer decoração (como <ph id="ph2">`0x`</ph> ou <ph id="ph3">`&amp;h`</ph>) que o diferencia como um número hexadecimal.</target>       </trans-unit>
        <trans-unit id="1842" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)">
          <source>This causes the conversion to fail.</source>
          <target state="translated">Isso faz a conversão falhar.</target>       </trans-unit>
        <trans-unit id="1843" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)">
          <source>If <ph id="ph1">`value`</ph> is a hexadecimal string, the <ph id="ph2">&lt;xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29&gt;</ph> method interprets <ph id="ph3">`value`</ph> as a negative number stored by using two's complement representation if its first two hexadecimal digits are greater than or equal to <ph id="ph4">`0x80`</ph>.</source>
          <target state="translated">Se <ph id="ph1">`value`</ph> é uma cadeia de caracteres hexadecimal de <ph id="ph2">&lt;xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29&gt;</ph> método interpreta <ph id="ph3">`value`</ph> como um número negativo armazenado usando representação de complemento de dois, se seu primeiro de dois dígitos hexadecimais forem maior que ou igual a <ph id="ph4">`0x80`</ph>.</target>       </trans-unit>
        <trans-unit id="1844" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)">
          <source>In other words, the method interprets the highest-order bit of the first byte in <ph id="ph1">`value`</ph> as the sign bit.</source>
          <target state="translated">Em outras palavras, o método interpreta o bit de ordem mais alta do primeiro byte no <ph id="ph1">`value`</ph> como o bit de sinal.</target>       </trans-unit>
        <trans-unit id="1845" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)">
          <source>To make sure that a hexadecimal string is correctly interpreted as a positive number, the first digit in <ph id="ph1">`value`</ph> must have a value of zero.</source>
          <target state="translated">Para certificar-se de que uma cadeia de caracteres hexadecimal é interpretada corretamente como um número positivo, o primeiro dígito em <ph id="ph1">`value`</ph> deve ter um valor de zero.</target>       </trans-unit>
        <trans-unit id="1846" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)">
          <source>For example, the method interprets <ph id="ph1">`0x80`</ph> as a negative value, but it interprets either <ph id="ph2">`0x080`</ph> or <ph id="ph3">`0x0080`</ph> as a positive value.</source>
          <target state="translated">Por exemplo, o método interpreta <ph id="ph1">`0x80`</ph> como um valor negativo, mas ele interpreta o <ph id="ph2">`0x080`</ph> ou <ph id="ph3">`0x0080`</ph> como um valor positivo.</target>       </trans-unit>
        <trans-unit id="1847" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)">
          <source>The following example illustrates the difference between hexadecimal strings that represent negative and positive values.</source>
          <target state="translated">O exemplo a seguir ilustra a diferença entre cadeias de caracteres hexadecimais que representam valores negativos e positivos.</target>       </trans-unit>
        <trans-unit id="1848" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)">
          <source>The <ph id="ph1">`provider`</ph> parameter is an <ph id="ph2">&lt;xref:System.IFormatProvider&gt;</ph> implementation.</source>
          <target state="translated">O parâmetro <ph id="ph1">`provider`</ph> é uma implementação de <ph id="ph2">&lt;xref:System.IFormatProvider&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1849" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)">
          <source>Its <ph id="ph1">&lt;xref:System.IFormatProvider.GetFormat%2A&gt;</ph> method returns a <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object that provides culture-specific information about the format of <ph id="ph3">`value`</ph>.</source>
          <target state="translated">O método <ph id="ph1">&lt;xref:System.IFormatProvider.GetFormat%2A&gt;</ph> retorna um objeto <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> que fornece informações específicas de cultura sobre o formato de <ph id="ph3">`value`</ph>.</target>       </trans-unit>
        <trans-unit id="1850" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)">
          <source>The <ph id="ph1">`provider`</ph> parameter can be any one of the following:</source>
          <target state="translated">O parâmetro <ph id="ph1">`provider`</ph> pode ser qualquer um dos seguintes:</target>       </trans-unit>
        <trans-unit id="1851" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)">
          <source>A <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> object that represents the culture that supplies formatting information.</source>
          <target state="translated">Um objeto <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> que representa a cultura que fornece informações de formatação.</target>       </trans-unit>
        <trans-unit id="1852" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)">
          <source>Its <ph id="ph1">&lt;xref:System.Globalization.CultureInfo.GetFormat%2A&gt;</ph> method returns the <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object that provides numeric formatting information for that culture.</source>
          <target state="translated">O método <ph id="ph1">&lt;xref:System.Globalization.CultureInfo.GetFormat%2A&gt;</ph> retorna o objeto <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> que fornece informações de formatação numérica para essa cultura.</target>       </trans-unit>
        <trans-unit id="1853" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)">
          <source>A <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object that provides numeric formatting information.</source>
          <target state="translated">Um objeto <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> que fornece informações de formatação numérica.</target>       </trans-unit>
        <trans-unit id="1854" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)">
          <source>(Its implementation of <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo.GetFormat%2A&gt;</ph> just returns itself.)</source>
          <target state="translated">(Sua implementação de <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo.GetFormat%2A&gt;</ph> retorna apenas ele próprio.)</target>       </trans-unit>
        <trans-unit id="1855" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)">
          <source>A custom object that implements <ph id="ph1">&lt;xref:System.IFormatProvider&gt;</ph>.</source>
          <target state="translated">Um objeto personalizado que implementa <ph id="ph1">&lt;xref:System.IFormatProvider&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1856" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)">
          <source>Its <ph id="ph1">&lt;xref:System.IFormatProvider.GetFormat%2A&gt;</ph> method instantiates and returns the <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object that provides formatting information.</source>
          <target state="translated">O método <ph id="ph1">&lt;xref:System.IFormatProvider.GetFormat%2A&gt;</ph> cria uma instância e retorna o objeto <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> que fornece informações de formatação.</target>       </trans-unit>
        <trans-unit id="1857" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)">
          <source>If <ph id="ph1">`provider`</ph> is <ph id="ph2">`null`</ph>, the <ph id="ph3">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object for the current culture is used.</source>
          <target state="translated">Caso <ph id="ph1">`provider`</ph> seja <ph id="ph2">`null`</ph>, o objeto <ph id="ph3">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> da cultura atual é usado.</target>       </trans-unit>
        <trans-unit id="1858" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)">
          <source>The following example makes some calls to the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29&gt;</ph> method using various combinations of values for the <ph id="ph2">`style`</ph> and <ph id="ph3">`provider`</ph> parameters.</source>
          <target state="translated">O exemplo a seguir faz algumas chamadas para o <ph id="ph1">&lt;xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29&gt;</ph> método usando várias combinações de valores para o <ph id="ph2">`style`</ph> e <ph id="ph3">`provider`</ph> parâmetros.</target>       </trans-unit>
        <trans-unit id="1859" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Numerics.BigInteger.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)">
          <source>A number of the individual calls to the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29&gt;</ph> method pass an instance of the following <ph id="ph2">`BigIntegerFormatProvider`</ph> class, which defines a tilde (~) as the negative sign.</source>
          <target state="translated">Um número de chamadas individuais para o <ph id="ph1">&lt;xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29&gt;</ph> método passar uma instância das seguintes <ph id="ph2">`BigIntegerFormatProvider`</ph> classe, que define um til (~) como o sinal negativo.</target>       </trans-unit>
        <trans-unit id="1860" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)">
          <source><ph id="ph1">&lt;paramref name="style" /&gt;</ph> is not a <ph id="ph2">&lt;see cref="T:System.Globalization.NumberStyles" /&gt;</ph> value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="style" /&gt;</ph> não é um valor <ph id="ph2">&lt;see cref="T:System.Globalization.NumberStyles" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1861" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1862" translate="yes" xml:space="preserve" uid="M:System.Numerics.BigInteger.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)">
          <source><ph id="ph1">&lt;paramref name="style" /&gt;</ph> includes the <ph id="ph2">&lt;see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" /&gt;</ph> or <ph id="ph3">&lt;see cref="F:System.Globalization.NumberStyles.HexNumber" /&gt;</ph> flag along with another value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="style" /&gt;</ph> inclui o sinalizador <ph id="ph2">&lt;see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" /&gt;</ph> ou <ph id="ph3">&lt;see cref="F:System.Globalization.NumberStyles.HexNumber" /&gt;</ph> em conjunto com outro valor.</target>       </trans-unit>
        <trans-unit id="1863" translate="yes" xml:space="preserve" uid="P:System.Numerics.BigInteger.Zero">
          <source>Gets a value that represents the number 0 (zero).</source>
          <target state="translated">Obtém um valor que representa o número 0 (zero).</target>       </trans-unit>
        <trans-unit id="1864" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Numerics.BigInteger.Zero">
          <source>An integer whose value is 0 (zero).</source>
          <target state="translated">Um inteiro cujo valor é 0 (zero).</target>       </trans-unit>
        <trans-unit id="1865" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Numerics.BigInteger.Zero">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> object returned by this property provides a convenient source of a zero value for use in assignments and comparisons.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> objeto retornado por esta propriedade fornece uma fonte conveniente de um valor de zero para uso em comparações e atribuições.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>