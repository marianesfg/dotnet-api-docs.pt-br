<Type Name="BigInteger" FullName="System.Numerics.BigInteger">
  <Metadata><Meta Name="ms.openlocfilehash" Value="2c47bbf74c7f856bea7b4b54550203dc60592929" /><Meta Name="ms.sourcegitcommit" Value="42a3c35677e9d87eeb503607ae50c9d39827d414" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pt-BR" /><Meta Name="ms.lasthandoff" Value="12/17/2018" /><Meta Name="ms.locfileid" Value="53465136" /></Metadata><TypeSignature Language="C#" Value="public struct BigInteger : IComparable, IComparable&lt;System.Numerics.BigInteger&gt;, IEquatable&lt;System.Numerics.BigInteger&gt;, IFormattable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit BigInteger extends System.ValueType implements class System.IComparable, class System.IComparable`1&lt;valuetype System.Numerics.BigInteger&gt;, class System.IEquatable`1&lt;valuetype System.Numerics.BigInteger&gt;, class System.IFormattable" />
  <TypeSignature Language="DocId" Value="T:System.Numerics.BigInteger" />
  <TypeSignature Language="VB.NET" Value="Public Structure BigInteger&#xA;Implements IComparable, IComparable(Of BigInteger), IEquatable(Of BigInteger), IFormattable" />
  <TypeSignature Language="C++ CLI" Value="public value class BigInteger : IComparable, IComparable&lt;System::Numerics::BigInteger&gt;, IEquatable&lt;System::Numerics::BigInteger&gt;, IFormattable" />
  <TypeSignature Language="F#" Value="type BigInteger = struct&#xA;    interface IFormattable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Numerics</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Numerics</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable&lt;System.Numerics.BigInteger&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.Numerics.BigInteger&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IFormattable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netcore-2.1;netcore-2.2">
      <AttributeName>System.Runtime.CompilerServices.IsReadOnly</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Representa um inteiro com sinal arbitrariamente grande.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Numerics.BigInteger> tipo é um tipo imutável que representa um inteiro arbitrariamente grande cujo valor, em teoria tem sem limites superiores ou inferiores. Os membros de <xref:System.Numerics.BigInteger> tipo muito semelhantes dos outros tipos integrais (o <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.Int64>, <xref:System.SByte>, <xref:System.UInt16>, <xref:System.UInt32>, e <xref:System.UInt64> tipos). Esse tipo é diferente de outros tipos integrais na [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)], que tem um intervalo indicado por seus `MinValue` e `MaxValue` propriedades.  
  
> [!NOTE]
>  Porque o <xref:System.Numerics.BigInteger> tipo é imutável (consulte [Mutabilidade e a estrutura de BigInteger](#mutability)) e porque não há limites superiores ou inferiores, tem um <xref:System.OutOfMemoryException> pode ser gerada para qualquer operação que faz com que um <xref:System.Numerics.BigInteger> valor cresça demais grande.  
  
## <a name="instantiating-a-biginteger-object"></a>Criando uma instância de um objeto BigInteger  
 Você pode instanciar um <xref:System.Numerics.BigInteger> objeto de várias maneiras:  
  
-   Você pode usar o `new` palavra-chave e forneça qualquer valor integral ou de ponto flutuante como um parâmetro para o <xref:System.Numerics.BigInteger> construtor. (Valores de ponto flutuante são truncadas antes que eles forem atribuídos a <xref:System.Numerics.BigInteger>.) O exemplo a seguir ilustra como usar o `new` palavra-chave para criar uma instância <xref:System.Numerics.BigInteger> valores.  
  
     [!code-csharp[System.Numerics.BigInteger.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/cs/BigInteger_Examples.cs#1)]
     [!code-vb[System.Numerics.BigInteger.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/vb/BigInteger_Examples.vb#1)]  
  
-   Você pode declarar um <xref:System.Numerics.BigInteger> variável e atribuir um valor, assim como você faria com qualquer tipo numérico, desde que esse valor é um tipo integral. O exemplo a seguir usa a atribuição para criar uma <xref:System.Numerics.BigInteger> valor de um <xref:System.Int64>.  
  
     [!code-csharp[System.Numerics.BigInteger.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/cs/BigInteger_Examples.cs#2)]
     [!code-vb[System.Numerics.BigInteger.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/vb/BigInteger_Examples.vb#2)]  
  
-   Você pode atribuir um valor decimal ou de ponto flutuante para um <xref:System.Numerics.BigInteger> objeto se você converter o valor ou convertê-lo pela primeira vez. O exemplo a seguir converte a (em c#) ou converte (no Visual Basic) explicitamente uma <xref:System.Double> e uma <xref:System.Decimal> valor para um <xref:System.Numerics.BigInteger>.  
  
     [!code-csharp[System.Numerics.BigInteger.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/cs/BigInteger_Examples.cs#3)]
     [!code-vb[System.Numerics.BigInteger.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/vb/BigInteger_Examples.vb#3)]  
  
 Esses métodos permitem que você criar uma instância de um <xref:System.Numerics.BigInteger> somente tipos de objeto cujo valor está no intervalo de um dos numérico existente. Você pode instanciar um <xref:System.Numerics.BigInteger> objeto cujo valor pode exceder o intervalo dos tipos numéricos existentes em uma das três maneiras:  
  
-   Você pode usar o `new` palavra-chave e forneça uma matriz de bytes de qualquer tamanho para o <xref:System.Numerics.BigInteger.%23ctor%2A?displayProperty=nameWithType> construtor. Por exemplo:  
  
     [!code-csharp[System.Numerics.BigInteger.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/cs/BigInteger_Examples.cs#4)]
     [!code-vb[System.Numerics.BigInteger.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/vb/BigInteger_Examples.vb#4)]  
  
-   Você pode chamar o <xref:System.Numerics.BigInteger.Parse%2A> ou <xref:System.Numerics.BigInteger.TryParse%2A> métodos para converter a representação de cadeia de caracteres de um número para um <xref:System.Numerics.BigInteger>. Por exemplo:  
  
     [!code-csharp[System.Numerics.BigInteger.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/cs/BigInteger_Examples.cs#5)]
     [!code-vb[System.Numerics.BigInteger.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/vb/BigInteger_Examples.vb#5)]  
  
-   Você pode chamar um `static` (`Shared` no Visual Basic) <xref:System.Numerics.BigInteger> método que executa alguma operação em uma expressão numérica e retorna um calculado <xref:System.Numerics.BigInteger> resultado. O exemplo a seguir faz isso por cubing <xref:System.UInt64.MaxValue?displayProperty=nameWithType> e atribuir o resultado para um <xref:System.Numerics.BigInteger>.  
  
     [!code-csharp[System.Numerics.BigInteger.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/cs/BigInteger_Examples.cs#6)]
     [!code-vb[System.Numerics.BigInteger.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/vb/BigInteger_Examples.vb#6)]  
  
 O valor não inicializado de um <xref:System.Numerics.BigInteger> é <xref:System.Numerics.BigInteger.Zero%2A>.  
  
## <a name="performing-operations-on-biginteger-values"></a>Realizando operações em valores BigInteger  
 Você pode usar um <xref:System.Numerics.BigInteger> como você usaria qualquer outro tipo integral da instância. <xref:System.Numerics.BigInteger> sobrecarrega os operadores numéricos padrão para que você possa executar operações matemáticas básicas, como adição, subtração, divisão, multiplicação, subtração, negação e negação unária. Você também pode usar os operadores numéricos padrão para comparar dois <xref:System.Numerics.BigInteger> valores entre si. Como os outros tipos integrais <xref:System.Numerics.BigInteger> também dá suporte à operação bit a bit `And`, `Or`, `XOr`, esquerda shift e operadores de deslocamento para a direita. Para idiomas que não dão suporte a operadores personalizados, o <xref:System.Numerics.BigInteger> estrutura também fornece métodos equivalentes para executar operações matemáticas. Eles incluem <xref:System.Numerics.BigInteger.Add%2A>, <xref:System.Numerics.BigInteger.Divide%2A>, <xref:System.Numerics.BigInteger.Multiply%2A>, <xref:System.Numerics.BigInteger.Negate%2A>, <xref:System.Numerics.BigInteger.Subtract%2A>e muitas outras.  
  
 Número de membros do <xref:System.Numerics.BigInteger> estrutura correspondem diretamente aos membros de outros tipos integrais. Além disso, <xref:System.Numerics.BigInteger> adiciona membros, como o seguinte:  
  
-   <xref:System.Numerics.BigInteger.Sign%2A>, que retorna um valor que indica o sinal de um <xref:System.Numerics.BigInteger> valor.  
  
-   <xref:System.Numerics.BigInteger.Abs%2A>, que retorna o valor absoluto de um <xref:System.Numerics.BigInteger> valor.  
  
-   <xref:System.Numerics.BigInteger.DivRem%2A>, que retorna o quociente e o restante de uma operação de divisão.  
  
-   <xref:System.Numerics.BigInteger.GreatestCommonDivisor%2A>, que retorna o máximo divisor comum de dois <xref:System.Numerics.BigInteger> valores.  
  
 Muitos desses membros adicionais correspondem aos membros do <xref:System.Math> classe, que fornece a funcionalidade para trabalhar com os tipos numéricos primitivos.  
  
<a name="mutability"></a>   
## <a name="mutability-and-the-biginteger-structure"></a>Mutabilidade e a estrutura de BigInteger  
 O exemplo a seguir instancia um <xref:System.Numerics.BigInteger> de objeto e, em seguida, incrementa o valor em um.  
  
 [!code-csharp[System.Numerics.BigInteger.Class.Mutability#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.Mutability/cs/Mutability_Examples.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Class.Mutability#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.Mutability/vb/Mutability_Examples.vb#1)]  
  
 Embora esse exemplo é exibido modificar o valor do objeto existente, isso não é o caso. <xref:System.Numerics.BigInteger> objetos são imutáveis, o que significa que, internamente, o common language runtime, na verdade, cria um novo <xref:System.Numerics.BigInteger> de objeto e atribui um valor maior do que seu valor anterior. Esse novo objeto é retornado ao chamador.  
  
> [!NOTE]
>  Os tipos numéricos no .NET Framework também são imutáveis. No entanto, porque o <xref:System.Numerics.BigInteger> tipo tem sem limites superiores ou inferiores, seus valores podem ficar muito grandes e ter um impacto mensurável no desempenho.  
  
 Embora esse processo é transparente para o chamador, incorre em uma penalidade de desempenho. Em alguns casos, especialmente quando repetidas operações são executadas em um loop em grandes <xref:System.Numerics.BigInteger> valores, essa penalidade de desempenho pode ser significativa. Por exemplo, no exemplo a seguir, uma operação é executada repetidamente até um milhão de vezes e um <xref:System.Numerics.BigInteger> valor é incrementado em um sempre que a operação seja bem-sucedida.  
  
 [!code-csharp[System.Numerics.BigInteger.Class.Mutability#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.Mutability/cs/Mutability_Examples.cs#12)]
 [!code-vb[System.Numerics.BigInteger.Class.Mutability#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.Mutability/vb/Mutability_Examples.vb#12)]  
  
 Nesse caso, você pode melhorar o desempenho executando todas as atribuições de intermediárias para um <xref:System.Int32> variável. O valor final da variável, em seguida, pode ser atribuído para o <xref:System.Numerics.BigInteger> objeto quando o loop é encerrado. O exemplo a seguir fornece uma ilustração.  
  
 [!code-csharp[System.Numerics.BigInteger.Class.Mutability#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.Mutability/cs/Mutability_Examples.cs#3)]
 [!code-vb[System.Numerics.BigInteger.Class.Mutability#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.Mutability/vb/Mutability_Examples.vb#3)]  
  
## <a name="working-with-byte-arrays-and-hexadecimal-strings"></a>Trabalhando com matrizes de bytes e cadeias de caracteres hexadecimais  
 Se você converter <xref:System.Numerics.BigInteger> valores a matrizes de bytes, ou se você converter matrizes de bytes para <xref:System.Numerics.BigInteger> valores, você deve considerar a ordem de bytes. O <xref:System.Numerics.BigInteger> estrutura espera que os bytes individuais em uma matriz de bytes para aparecer em ordem little endian (ou seja, os bytes de ordem inferior do valor precedem os bytes de ordem mais alta). Você pode ir e voltar uma <xref:System.Numerics.BigInteger> valor chamando o <xref:System.Numerics.BigInteger.ToByteArray%2A> método e, em seguida, passando o byte resultante de matriz para o <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> construtor, como mostra o exemplo a seguir.  
  
 [!code-csharp[System.Numerics.BigInteger.Class.ByteAndHex#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/cs/ByteAndHex_Examples.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Class.ByteAndHex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/vb/ByteAndHex_Examples.vb#1)]  
  
 Para criar uma instância de um <xref:System.Numerics.BigInteger> valor de uma matriz de bytes que representa um valor de outro tipo integral, você pode passar o valor integral para o <xref:System.BitConverter.GetBytes%2A?displayProperty=nameWithType> método e, em seguida, passe o byte resultante de matriz para o <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> construtor. O exemplo a seguir instancia um <xref:System.Numerics.BigInteger> valor de uma matriz de bytes que representa um <xref:System.Int16> valor.  
  
 [!code-csharp[System.Numerics.BigInteger.Class.ByteAndHex#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/cs/ByteAndHex_Examples.cs#2)]
 [!code-vb[System.Numerics.BigInteger.Class.ByteAndHex#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/vb/ByteAndHex_Examples.vb#2)]  
  
 O <xref:System.Numerics.BigInteger> estrutura pressupõe que os valores negativos são armazenados usando a representação de complemento de dois. Porque o <xref:System.Numerics.BigInteger> estrutura representa um valor numérico com nenhum comprimento fixo, o <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> construtor sempre interpreta o bit mais significativo do último byte na matriz como um bit de sinal. Para impedir que o <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> construtor de confuso de dois complemento representação de um valor negativo com a representação de sinal e magnitude de um valor positivo, positivo valores em que a maioria dos bits significativa do último byte na matriz de bytes seria normalmente conjunto deve incluir um byte adicional, cujo valor é 0. Por exemplo, 0xC0 0xBD 0xF0 0xFF é a representação hexadecimal de little endian de-1,000,000 ou 4,293,967,296. Como o bit mais significativo do último byte nessa matriz está em, o valor da matriz de bytes poderia ser interpretado pelo <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> construtor como-1,000,000. Para instanciar um <xref:System.Numerics.BigInteger> cujo valor é positivo, uma matriz de bytes cujos elementos são 0xC0 0xBD 0xF0 0xFF 0x00 deve ser passado para o construtor. O exemplo a seguir ilustra essa situação.  
  
 [!code-csharp[System.Numerics.BigInteger.Class.ByteAndHex#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/cs/ByteAndHex_Examples.cs#3)]
 [!code-vb[System.Numerics.BigInteger.Class.ByteAndHex#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/vb/ByteAndHex_Examples.vb#3)]  
  
 Matrizes de bytes criados pelo <xref:System.Numerics.BigInteger.ToByteArray%2A> método dos valores positivos de incluir esse valor extra zero byte. Portanto, o <xref:System.Numerics.BigInteger> estrutura pode valores de ida e volta com êxito, atribuí-los para e, em seguida, restaurá-los de matrizes de bytes, como mostra o exemplo a seguir.  
  
 [!code-csharp[System.Numerics.BigInteger.Class.ByteAndHex#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/cs/ByteAndHex_Examples.cs#4)]
 [!code-vb[System.Numerics.BigInteger.Class.ByteAndHex#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/vb/ByteAndHex_Examples.vb#4)]  
  
 No entanto, talvez seja necessário adicionar esse byte adicional do valor de zero para matrizes de bytes que são criados dinamicamente pelo desenvolvedor ou que são retornados por métodos que convertem inteiros sem sinal em matrizes de bytes (como <xref:System.BitConverter.GetBytes%28System.UInt16%29?displayProperty=nameWithType>, <xref:System.BitConverter.GetBytes%28System.UInt32%29?displayProperty=nameWithType>, e <xref:System.BitConverter.GetBytes%28System.UInt64%29?displayProperty=nameWithType>).  
  
 Ao analisar uma cadeia de caracteres hexadecimal, o <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%29?displayProperty=nameWithType> e <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29?displayProperty=nameWithType> métodos supõem que, se o bit mais significativo do primeiro byte na cadeia de caracteres é definido, ou se o primeiro dígito hexadecimal da cadeia de caracteres representa os quatro bits inferiores de um valor de byte, o valor é representado usando a representação de complemento de dois. Por exemplo, "FF01" e "F01" representam o valor decimal-255. Para diferenciar positivo de valores negativos, a valores positivos devem incluir um zero à esquerda. As sobrecargas relevantes a <xref:System.Numerics.BigInteger.ToString%2A> método, quando eles são passados a cadeia de caracteres de formato "X", adicione um zero à esquerda para a cadeia de caracteres hexadecimal retornado para valores positivos. Isso torna possível a ida e volta <xref:System.Numerics.BigInteger> valores usando o <xref:System.Numerics.BigInteger.ToString%2A> e <xref:System.Numerics.BigInteger.Parse%2A> métodos, como mostra o exemplo a seguir.  
  
 [!code-csharp[System.Numerics.BigInteger.Class.ByteAndHex#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/cs/ByteAndHex_Examples.cs#5)]
 [!code-vb[System.Numerics.BigInteger.Class.ByteAndHex#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/vb/ByteAndHex_Examples.vb#5)]  
  
 No entanto, as cadeias de caracteres hexadecimais é criado chamando o `ToString` métodos de outros tipos integrais ou as sobrecargas do <xref:System.Convert.ToString%2A> método que incluem um `toBase` parâmetro não indicam o sinal do valor ou o tipo de dados de origem do qual a cadeia de caracteres hexadecimal foi derivada. Criando uma instância com êxito um <xref:System.Numerics.BigInteger> valor de uma cadeia de caracteres requer alguma lógica adicional. O exemplo a seguir fornece uma implementação possível.  
  
 [!code-csharp[System.Numerics.BigInteger.Class.ByteAndHex#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/cs/ByteAndHex_Examples2.cs#6)]
 [!code-vb[System.Numerics.BigInteger.Class.ByteAndHex#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/vb/ByteAndHex_Examples2.vb#6)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa uma nova instância da estrutura <see cref="T:System.Numerics.BigInteger" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (byte[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(cli::array &lt;System::Byte&gt; ^ value);" />
      <MemberSignature Language="F#" Value="new System.Numerics.BigInteger : byte[] -&gt; System.Numerics.BigInteger" Usage="new System.Numerics.BigInteger value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="value">Uma matriz de valores de bytes em ordem little endian.</param>
        <summary>Inicializa uma nova instância da estrutura <see cref="T:System.Numerics.BigInteger" /> usando os valores de uma matriz de bytes.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Os bytes individuais no `value` matriz deve estar em ordem little endian, de byte de ordem mais baixa para o byte de ordem mais alta. Por exemplo, o valor numérico 1.000.000.000.000 é representado como mostrado na tabela a seguir:  
  
|||  
|-|-|  
|Cadeia de caracteres hexadecimal|E8D4A51000|  
|Matriz de bytes (menor índice pela primeira vez)|00 10 A5 D4 E8 00|  
  
 A maioria dos métodos que convertem valores numéricos em matrizes de bytes, como <xref:System.Numerics.BigInteger.ToByteArray%2A?displayProperty=nameWithType> e <xref:System.BitConverter.GetBytes%2A?displayProperty=nameWithType>, retornar matrizes de bytes em ordem little endian.  
  
 O construtor espera valores positivos na matriz de bytes para usar a representação de sinal e magnitude e valores negativos para usar a representação de complemento de dois. Em outras palavras, se a ordem mais alta de bits do byte de ordem mais alta na `value` for definido, resultante <xref:System.Numerics.BigInteger> valor é negativo. Dependendo da fonte da matriz de bytes, isso pode causar um valor positivo ser interpretado incorretamente como um valor negativo. Normalmente, as matrizes de bytes são gerados das seguintes maneiras:  
  
-   Chamando o <xref:System.Numerics.BigInteger.ToByteArray%2A?displayProperty=nameWithType> método. Como esse método retorna uma matriz de bytes com o bit de ordem mais alta do byte de ordem mais alta no conjunto de matriz como zero para valores positivos, não há nenhuma chance de interpretação incorreta de um valor positivo como negativo. Sem modificações matrizes de bytes criados pelo <xref:System.Numerics.BigInteger.ToByteArray%2A> método sempre com êxito de ida e volta quando eles são passados para o <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> construtor.  
  
-   Chamando o <xref:System.BitConverter.GetBytes%2A?displayProperty=nameWithType> método e passá-lo em um inteiro com sinal como um parâmetro. Como inteiros com sinal de manipular a representação de sinal e magnitude e a representação de complemento de dois, não há nenhuma chance de interpretação incorreta de um valor positivo como negativo.  
  
-   Chamando o <xref:System.BitConverter.GetBytes%2A?displayProperty=nameWithType> método e passá-lo em um inteiro sem sinal como um parâmetro. Como números inteiros sem sinal são representados por seu magnitude apenas, valores positivos podem ser interpretados incorretamente como valores negativos. Para evitar essa má interpretação, você pode adicionar um valor de zero byte ao final da matriz. O exemplo na próxima seção fornece uma ilustração.  
  
-   Criando uma matriz de bytes ou estática ou dinamicamente sem necessariamente chamar qualquer um dos métodos anteriores ou modificando uma matriz de bytes existente. Para impedir que valores positivos serem mal interpretados como valores negativos, você pode adicionar um valor de zero byte ao final da matriz.  
  
 Se `value` está vazio <xref:System.Byte> array, a nova <xref:System.Numerics.BigInteger> objeto é inicializado como um valor de <xref:System.Numerics.BigInteger.Zero%2A?displayProperty=nameWithType>. Se `value` está `null`, o construtor gerará um <xref:System.ArgumentNullException>.  
  
   
  
## Examples  
 O exemplo a seguir instancia um <xref:System.Numerics.BigInteger> objeto a partir de uma matriz de bytes de elemento de 5 cujo valor é {5, 4, 3, 2, 1}. Em seguida, ele exibe o <xref:System.Numerics.BigInteger> valor, representado como números decimais e hexadecimais, no console. Uma comparação de matriz de entrada com a saída de texto deixa claro por que essa sobrecarga da <xref:System.Numerics.BigInteger> construtor de classe cria um <xref:System.Numerics.BigInteger> objeto cujo valor é 4328719365 (ou 0x102030405). O primeiro elemento da matriz de bytes, cujo valor é 5, define o valor do byte de ordem mais baixa a <xref:System.Numerics.BigInteger> objeto, que é 0x05. O segundo elemento da matriz de bytes, cujo valor é 4, define o valor do segundo byte do <xref:System.Numerics.BigInteger> objeto, que é 0x04 e assim por diante.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.ctors#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example1.vb#1)]  
  
 O exemplo a seguir instancia um positivo e negativo <xref:System.Numerics.BigInteger> o valor, passa para o <xref:System.Numerics.BigInteger.ToByteArray%2A> método e, em seguida, restaura o original <xref:System.Numerics.BigInteger> valores da matriz de bytes resultante. Observe que os dois valores são representados pelo matrizes de byte idênticos. A única diferença entre eles é no bit mais significativo do último elemento na matriz de bytes. Esse bit estiver definido (o valor do byte é 0xFF), se a matriz é criada a partir de um negativo <xref:System.Numerics.BigInteger> valor. O bits não estiver definido (o valor do byte é zero), se a matriz é criada a partir de um positivo <xref:System.Numerics.BigInteger> valor.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.ctors#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example1.vb#2)]  
  
 O exemplo a seguir ilustra como certificar-se de que um valor positivo não é incorretamente instanciado como um valor negativo com a adição de um byte cujo valor é zero para o final da matriz.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.ctors#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> é <see langword="null" />.</exception>
        <altmember cref="M:System.Numerics.BigInteger.ToByteArray" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(System::Decimal value);" />
      <MemberSignature Language="F#" Value="new System.Numerics.BigInteger : decimal -&gt; System.Numerics.BigInteger" Usage="new System.Numerics.BigInteger value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">Um número decimal.</param>
        <summary>Inicializa uma nova instância da estrutura <see cref="T:System.Numerics.BigInteger" /> usando um valor <see cref="T:System.Decimal" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O resultado de chamar este construtor é idêntico ao atribuir explicitamente um <xref:System.Decimal> de valor para um <xref:System.Numerics.BigInteger> variável.  
  
 Chamar esse construtor pode causar perda de dados; qualquer parte fracionária `value` é truncado ao instanciar um <xref:System.Numerics.BigInteger> objeto.  
  
   
  
## Examples  
 O exemplo a seguir ilustra o uso do <xref:System.Numerics.BigInteger.%23ctor%28System.Decimal%29> construtor para instanciar um <xref:System.Numerics.BigInteger> objeto. Ele define uma matriz de <xref:System.Decimal> valores e, em seguida, passa cada valor com o <xref:System.Numerics.BigInteger.%23ctor%28System.Decimal%29> construtor. Observe que o <xref:System.Decimal> valor é truncado em vez de arredondados quando ele é atribuído a <xref:System.Numerics.BigInteger> objeto.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#4)]
 [!code-vb[System.Numerics.BigInteger.ctors#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(double value);" />
      <MemberSignature Language="F#" Value="new System.Numerics.BigInteger : double -&gt; System.Numerics.BigInteger" Usage="new System.Numerics.BigInteger value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">Um valor de ponto flutuante de precisão dupla.</param>
        <summary>Inicializa uma nova instância de estrutura <see cref="T:System.Numerics.BigInteger" /> usando um valor de ponto flutuante de precisão dupla.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Qualquer parte fracionária de `value` parâmetro é truncado ao instanciar um <xref:System.Numerics.BigInteger> objeto.  
  
 Devido à falta de precisão do <xref:System.Double> tipo de dados, chamar este construtor pode causar perda de dados.  
  
 O <xref:System.Numerics.BigInteger> valor que resulta de chamar este construtor é idêntico ao valor que resulta da atribuir explicitamente um <xref:System.Double> valor para um <xref:System.Numerics.BigInteger>.  
  
   
  
## Examples  
 O exemplo a seguir ilustra o uso do <xref:System.Numerics.BigInteger.%23ctor%28System.Double%29> construtor para instanciar um <xref:System.Numerics.BigInteger> objeto. Ele também ilustra que a perda de precisão que pode ocorrer quando você usa o <xref:System.Double> tipo de dados. Um <xref:System.Double> é atribuído um valor grande, o que é então atribuído a um <xref:System.Numerics.BigInteger> objeto. Como mostra a saída, essa atribuição envolve uma perda de precisão. Os dois valores, em seguida, são incrementados em um. A saída mostra que o <xref:System.Numerics.BigInteger> objeto reflete o valor alterado, enquanto o <xref:System.Double> do objeto não.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#5)]
 [!code-vb[System.Numerics.BigInteger.ctors#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><paramref name="value" /> é <see cref="F:System.Double.NaN" />, <see cref="F:System.Double.NegativeInfinity" /> ou <see cref="F:System.Double.PositiveInfinity" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(int value);" />
      <MemberSignature Language="F#" Value="new System.Numerics.BigInteger : int -&gt; System.Numerics.BigInteger" Usage="new System.Numerics.BigInteger value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Um inteiro com sinal de 32 bits.</param>
        <summary>Inicializa uma nova instância da estrutura <see cref="T:System.Numerics.BigInteger" /> usando um valor inteiro com sinal de 32 bits.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Não há nenhuma perda de precisão ao instanciar um <xref:System.Numerics.BigInteger> objeto usando este construtor.  
  
 O <xref:System.Numerics.BigInteger> valor que resulta de chamar este construtor é idêntico ao valor resultante da atribuição de um <xref:System.Int32> valor para um <xref:System.Numerics.BigInteger>.  
  
 O <xref:System.Numerics.BigInteger> estrutura não tem construtores com um parâmetro do tipo <xref:System.Byte>, <xref:System.Int16>, <xref:System.SByte>, ou <xref:System.UInt16>. No entanto, o <xref:System.Int32> tipo dá suporte à conversão implícita de inteiros assinados e não assinados de 8 bits e 16 bits inteiros com sinal de 32 bits. Como resultado, esse construtor é chamado se `value` é qualquer um desses quatro tipos integrais.  
  
   
  
## Examples  
 A exemplo a seguir chama o <xref:System.Numerics.BigInteger.%23ctor%28System.Int32%29> construtor para instanciar <xref:System.Numerics.BigInteger> valores de uma matriz de inteiros de 32 bits. Ele também usa a conversão implícita para atribuir cada valor de inteiro de 32 bits para um <xref:System.Numerics.BigInteger> variável. Ele então compara os dois valores para estabelecer que resultante <xref:System.Numerics.BigInteger> valores são iguais.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#6)]
 [!code-vb[System.Numerics.BigInteger.ctors#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(long value);" />
      <MemberSignature Language="F#" Value="new System.Numerics.BigInteger : int64 -&gt; System.Numerics.BigInteger" Usage="new System.Numerics.BigInteger value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">Um inteiro com sinal de 64 bits.</param>
        <summary>Inicializa uma nova instância da estrutura <see cref="T:System.Numerics.BigInteger" /> usando um valor inteiro com sinal de 64 bits.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Não há nenhuma perda de precisão ao instanciar um <xref:System.Numerics.BigInteger> objeto usando este construtor.  
  
 O <xref:System.Numerics.BigInteger> valor que resulta de chamar este construtor é idêntico ao valor resultante da atribuição de um <xref:System.Int64> valor para um <xref:System.Numerics.BigInteger>.  
  
   
  
## Examples  
 A exemplo a seguir chama o <xref:System.Numerics.BigInteger.%23ctor%28System.Int64%29> construtor para instanciar <xref:System.Numerics.BigInteger> valores de uma matriz de inteiros de 64 bits. Ele também usa a conversão implícita para atribuir cada valor de inteiro de 64 bits com um <xref:System.Numerics.BigInteger> variável. Ele então compara os dois valores para estabelecer que resultante <xref:System.Numerics.BigInteger> valores são iguais.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#7)]
 [!code-vb[System.Numerics.BigInteger.ctors#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(float value);" />
      <MemberSignature Language="F#" Value="new System.Numerics.BigInteger : single -&gt; System.Numerics.BigInteger" Usage="new System.Numerics.BigInteger value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">Um valor de ponto flutuante de precisão simples.</param>
        <summary>Inicializa uma nova instância da estrutura <see cref="T:System.Numerics.BigInteger" /> usando um valor de ponto flutuante de precisão simples.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Qualquer parte fracionária de `value` parâmetro é truncado ao instanciar um <xref:System.Numerics.BigInteger> objeto.  
  
 Devido à falta de precisão do <xref:System.Single> tipo de dados, chamar este construtor pode resultar em perda de dados.  
  
 O <xref:System.Numerics.BigInteger> valor que resulta de chamar este construtor é idêntico ao valor que resulta da atribuir explicitamente um <xref:System.Single> valor para um <xref:System.Numerics.BigInteger>.  
  
   
  
## Examples  
 O exemplo a seguir ilustra o uso do <xref:System.Numerics.BigInteger.%23ctor%28System.Single%29> construtor para instanciar um <xref:System.Numerics.BigInteger> objeto. Ele também ilustra que a perda de precisão que pode ocorrer quando você usa o <xref:System.Single> tipo de dados. Um <xref:System.Single> é atribuído um valor negativo grande, que é então atribuído a um <xref:System.Numerics.BigInteger> objeto. Como mostra a saída, essa atribuição envolve uma perda de precisão. Os dois valores, em seguida, são incrementados em um. A saída mostra que o <xref:System.Numerics.BigInteger> objeto reflete o valor alterado, enquanto o <xref:System.Single> do objeto não.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#8)]
 [!code-vb[System.Numerics.BigInteger.ctors#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><paramref name="value" /> é <see cref="F:System.Single.NaN" />, <see cref="F:System.Single.NegativeInfinity" /> ou <see cref="F:System.Single.PositiveInfinity" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As UInteger)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(System::UInt32 value);" />
      <MemberSignature Language="F#" Value="new System.Numerics.BigInteger : uint32 -&gt; System.Numerics.BigInteger" Usage="new System.Numerics.BigInteger value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value">Um valor inteiro de 32 bits sem sinal.</param>
        <summary>Inicializa uma nova instância da estrutura <see cref="T:System.Numerics.BigInteger" /> usando um valor inteiro de 32 bits sem sinal.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Não há nenhuma perda de precisão ao instanciar um <xref:System.Numerics.BigInteger> usando este construtor.  
  
 O <xref:System.Numerics.BigInteger> valor que resulta de chamar este construtor é idêntico ao valor resultante da atribuição de um <xref:System.UInt32> valor para um <xref:System.Numerics.BigInteger>.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.Numerics.BigInteger.%23ctor%28System.UInt32%29> construtor e uma instrução de atribuição para inicializar <xref:System.Numerics.BigInteger> valores de uma matriz de inteiros sem sinal de 32 bits. Em seguida, compara os dois valores para demonstrar que os dois métodos de inicializar um <xref:System.Numerics.BigInteger> valor produz resultados idênticos.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#9)]
 [!code-vb[System.Numerics.BigInteger.ctors#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#9)]  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Numerics.BigInteger.#ctor(System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As ULong)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(System::UInt64 value);" />
      <MemberSignature Language="F#" Value="new System.Numerics.BigInteger : uint64 -&gt; System.Numerics.BigInteger" Usage="new System.Numerics.BigInteger value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value">Um inteiro de 64 bits sem sinal.</param>
        <summary>Inicializa uma nova instância da estrutura <see cref="T:System.Numerics.BigInteger" /> com um valor inteiro de 64 bits sem sinal.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Não há nenhuma perda de precisão ao instanciar um <xref:System.Numerics.BigInteger> usando este construtor.  
  
 O <xref:System.Numerics.BigInteger> valor que resulta de chamar este construtor é idêntico ao valor resultante da atribuição de um <xref:System.UInt64> valor para um <xref:System.Numerics.BigInteger>.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.Numerics.BigInteger.%23ctor%28System.UInt64%29> construtor para instanciar uma <xref:System.Numerics.BigInteger> objeto cujo valor é igual a <xref:System.UInt64.MaxValue>.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#10)]
 [!code-vb[System.Numerics.BigInteger.ctors#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#10)]  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Numerics.BigInteger.#ctor(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (ReadOnlySpan&lt;byte&gt; value, bool isUnsigned = false, bool isBigEndian = false);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; value, bool isUnsigned, bool isBigEndian) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.ReadOnlySpan{System.Byte},System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As ReadOnlySpan(Of Byte), Optional isUnsigned As Boolean = false, Optional isBigEndian As Boolean = false)" />
      <MemberSignature Language="F#" Value="new System.Numerics.BigInteger : ReadOnlySpan&lt;byte&gt; * bool * bool -&gt; System.Numerics.BigInteger" Usage="new System.Numerics.BigInteger (value, isUnsigned, isBigEndian)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="isUnsigned" Type="System.Boolean" />
        <Parameter Name="isBigEndian" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="isUnsigned">To be added.</param>
        <param name="isBigEndian">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Abs">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Abs (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Abs(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Abs(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Abs (value As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Abs(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member Abs : System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Abs value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Um número.</param>
        <summary>Obtém o valor absoluto de um objeto <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>O valor absoluto de <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor absoluto de um número é esse número sem sinal, conforme mostrado na tabela a seguir.  
  
|Parâmetro `value`|Valor retornado|  
|-----------------------|------------------|  
|`value` >= 0|`value`|  
|`value` < 0|`value` * -1|  
  
 O <xref:System.Numerics.BigInteger.Abs%2A> método é equivalente de <xref:System.Math.Abs%2A?displayProperty=nameWithType> método para os tipos numéricos primitivos.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.Numerics.BigInteger.Abs%2A> método para converter um <xref:System.Numerics.BigInteger> valor de representação de complemento de dois a representação de sinal e magnitude antes serializando-o para um arquivo. Os dados no arquivo, em seguida, são desserializados e atribuídos a um novo <xref:System.Numerics.BigInteger> objeto.  
  
 [!code-csharp[System.Numerics.BigInteger.Abs#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Abs/cs/Abs1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Abs#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Abs/vb/Abs1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Abs(System.SByte)" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Add (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Add(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Add(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Add(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member Add : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Add (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">O primeiro valor a ser adicionado.</param>
        <param name="right">O segundo valor a ser adicionado.</param>
        <summary>Adiciona dois valores de <see cref="T:System.Numerics.BigInteger" /> e retorna o resultado.</summary>
        <returns>A soma de <paramref name="left" /> e <paramref name="right" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Idiomas que não dão suporte a sobrecarga de operador ou operadores personalizados podem usar o <xref:System.Numerics.BigInteger.Add%2A> método para executar a adição usando <xref:System.Numerics.BigInteger> valores.  
  
 O <xref:System.Numerics.BigInteger.Add%2A> método é um substituto úteis para o operador de adição ao instanciar um <xref:System.Numerics.BigInteger> variável atribuindo a ela uma soma que resulta da adição, conforme mostrado no exemplo a seguir.  
  
 [!code-csharp[System.Numerics.BigInteger.OperationMethods#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/cs/Multiply1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.OperationMethods#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/vb/Multiply1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_Addition(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Compare(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (left As BigInteger, right As BigInteger) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member Compare : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; int" Usage="System.Numerics.BigInteger.Compare (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">O primeiro valor a ser comparado.</param>
        <param name="right">O segundo valor a ser comparado.</param>
        <summary>Compara dois valores <see cref="T:System.Numerics.BigInteger" /> e retorna um inteiro que indica se o primeiro valor é menor que, igual a ou maior que o segundo valor.</summary>
        <returns>Um inteiro assinado que indica os valores relativos de <paramref name="left" /> e <paramref name="right" />, conforme mostrado na tabela a seguir.  
  
 <list type="table"><listheader><term> Valor 
 </term><description> Condição 
 </description></listheader><item><term> Menor que zero 
 </term><description><paramref name="left" /> é menor que <paramref name="right" />.  
  
 </description></item><item><term> Zero 
 </term><description><paramref name="left" /> é igual a <paramref name="right" />.  
  
 </description></item><item><term> Maior que zero 
 </term><description><paramref name="left" /> é maior que <paramref name="right" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Embora o <xref:System.Numerics.BigInteger> tipo não tem nenhum intervalo fixo, as comparações de <xref:System.Numerics.BigInteger> valores não são caracterizados por falta de precisão que caracteriza a comparação dos números de ponto flutuante. O exemplo a seguir compara duas <xref:System.Numerics.BigInteger> valores que diferem por um e que cada têm 1,896 dígitos. O <xref:System.Numerics.BigInteger.Compare%2A> método relata corretamente se os dois valores não são iguais.  
  
 [!code-csharp[System.Numerics.BigInteger.Compare#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Compare/cs/Compare1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Compare#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Compare/vb/Compare1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.CompareTo" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CompareTo">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Compara o valor desta instância com outro valor e retorna um inteiro que indica se o valor desta instância é menor, igual ou maior que o outro valor.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (long other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 CompareTo(int64 other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.CompareTo(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (other As Long) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int CompareTo(long other);" />
      <MemberSignature Language="F#" Value="member this.CompareTo : int64 -&gt; int" Usage="bigInteger.CompareTo other" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="other">O inteiro com sinal de 64 bits para comparar.</param>
        <summary>Compara essa instância a um inteiro com sinal de 64 bits e retorna um inteiro que indica se o valor dessa instância é menor, igual ou maior que o valor do inteiro com sinal de 64 bits.</summary>
        <returns>Um valor de inteiro com sinal que indica a relação desta instância com <paramref name="other" />, conforme mostrado na tabela a seguir.  
  
 <list type="table"><listheader><term> Valor retornado 
 </term><description> Descrição 
 </description></listheader><item><term> Menor que zero 
 </term><description> A instância atual é menor que <paramref name="other" />.  
  
 </description></item><item><term> Zero 
 </term><description> A instância atual é igual a <paramref name="other" />.  
  
 </description></item><item><term> Maior que zero 
 </term><description> A instância atual é maior que <paramref name="other" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `other` é um <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, ou <xref:System.UInt32> valor, ele é convertido implicitamente em um <xref:System.Int64> valor quando o <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29> método é chamado.  
  
   
  
## Examples  
 O exemplo a seguir ilustra o resultado de chamar o <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29> método com valores inteiros.  
  
 [!code-csharp[System.Numerics.BigInteger.CompareTo#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/cs/Example2.cs#3)]
 [!code-vb[System.Numerics.BigInteger.CompareTo#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/vb/Example2.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (System.Numerics.BigInteger other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(valuetype System.Numerics.BigInteger other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.CompareTo(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (other As BigInteger) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::Numerics::BigInteger other);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : System.Numerics.BigInteger -&gt; int&#xA;override this.CompareTo : System.Numerics.BigInteger -&gt; int" Usage="bigInteger.CompareTo other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable`1.CompareTo(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="other">O objeto a ser comparado.</param>
        <summary>Compara esta instância a um segundo <see cref="T:System.Numerics.BigInteger" /> e retorna um inteiro que indica se o valor desta instância é menor, igual ou maior que o valor do objeto especificado.</summary>
        <returns>Um valor de inteiro com sinal que indica a relação desta instância com <paramref name="other" />, conforme mostrado na tabela a seguir.  
  
 <list type="table"><listheader><term> Valor retornado 
 </term><description> Descrição 
 </description></listheader><item><term> Menor que zero 
 </term><description> A instância atual é menor que <paramref name="other" />.  
  
 </description></item><item><term> Zero 
 </term><description> A instância atual é igual a <paramref name="other" />.  
  
 </description></item><item><term> Maior que zero 
 </term><description> A instância atual é maior que <paramref name="other" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa sobrecarga da <xref:System.Numerics.BigInteger.CompareTo%2A> método implementa o <xref:System.IComparable%601.CompareTo%2A?displayProperty=nameWithType> método. Ele é usado por objetos de coleção genérica para ordenar os itens na coleção.  
  
   
  
## Examples  
 O exemplo a seguir ilustra o uso do <xref:System.Numerics.BigInteger.CompareTo%28System.Numerics.BigInteger%29> método para solicitar uma lista de `StarInfo` objetos. Cada `StarInfo` objeto fornece informações sobre o nome de uma estrela e sua distância da Terra em milhas. `StarInfo` implementa o <xref:System.IComparable%601> da interface, que permite que `StarInfo` objetos a serem classificados pelas classes de coleção genérica. Sua <xref:System.IComparable%601.CompareTo%2A?displayProperty=nameWithType> implementação simplesmente encapsula uma chamada para <xref:System.Numerics.BigInteger.CompareTo%28System.Numerics.BigInteger%29>.  
  
 [!code-csharp[System.Numerics.BigInteger.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/cs/Example1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/vb/Example1.vb#1)]  
  
 O código a seguir, em seguida, cria uma instância de quatro `StarInfo` objetos e os armazena em um genérico <xref:System.Collections.Generic.List%601> objeto. Após o <xref:System.Collections.Generic.List%601.Sort%2A?displayProperty=nameWithType> método é chamado, `StarInfo` objetos são exibidos em ordem de sua distância da Terra.  
  
 [!code-csharp[System.Numerics.BigInteger.CompareTo#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/cs/Example1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.CompareTo#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/vb/Example1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.Compare(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="M:System.Numerics.BigInteger.Equals(System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (obj As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : obj -&gt; int&#xA;override this.CompareTo : obj -&gt; int" Usage="bigInteger.CompareTo obj" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">O objeto a ser comparado.</param>
        <summary>Compara esta instância a um objeto especificado e retorna um inteiro que indica se o valor desta instância é menor, igual ou maior que o valor do objeto especificado.</summary>
        <returns>Um inteiro com sinal que indica a relação da instância atual com o parâmetro <paramref name="obj" />, conforme mostrado na tabela a seguir.  
  
 <list type="table"><listheader><term> Valor retornado 
 </term><description> Descrição 
 </description></listheader><item><term> Menor que zero 
 </term><description> A instância atual é menor que <paramref name="obj" />.  
  
 </description></item><item><term> Zero 
 </term><description> A instância atual é igual a <paramref name="obj" />.  
  
 </description></item><item><term> Maior que zero 
 </term><description> A instância atual é maior do que <paramref name="obj" /> ou o parâmetro <paramref name="obj" /> é <see langword="null" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa sobrecarga da <xref:System.Numerics.BigInteger.CompareTo%2A> método implementa o <xref:System.IComparable.CompareTo%2A?displayProperty=nameWithType> método. Ele é usado por objetos de coleção não genéricas para ordenar os itens na coleção.  
  
 O `obj` parâmetro deve ser um dos seguintes:  
  
-   Um objeto cujo tipo de tempo de execução é <xref:System.Numerics.BigInteger>.  
  
-   Uma <xref:System.Object> variável cujo valor é `null`. Se o valor da `obj` parâmetro é `null`, o método retorna 1, que indica que a instância atual é maior que `obj`.  
  
   
  
## Examples  
 A exemplo a seguir chama o <xref:System.Numerics.BigInteger.CompareTo%28System.Object%29> método para comparar um <xref:System.Numerics.BigInteger> valor com cada elemento em uma matriz de objetos  
  
 [!code-csharp[System.Numerics.BigInteger.CompareTo#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/cs/Example2.cs#4)]
 [!code-vb[System.Numerics.BigInteger.CompareTo#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/vb/Example2.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="obj" /> não é um <see cref="T:System.Numerics.BigInteger" />.</exception>
        <altmember cref="T:System.IComparable" />
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (ulong other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 CompareTo(unsigned int64 other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.CompareTo(System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (other As ULong) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int CompareTo(System::UInt64 other);" />
      <MemberSignature Language="F#" Value="member this.CompareTo : uint64 -&gt; int" Usage="bigInteger.CompareTo other" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="other">O inteiro sem sinal de 64 bits para comparar.</param>
        <summary>Compara essa instância a um inteiro sem sinal de 64 bits e retorna um inteiro que indica se o valor dessa instância é menor, igual ou maior que o valor do inteiro sem sinal de 64 bits.</summary>
        <returns>Um inteiro com sinal que indica o valor relativo dessa instância e <paramref name="other" />, conforme mostrado na tabela a seguir.  
  
 <list type="table"><listheader><term> Valor retornado 
 </term><description> Descrição 
 </description></listheader><item><term> Menor que zero 
 </term><description> A instância atual é menor que <paramref name="other" />.  
  
 </description></item><item><term> Zero 
 </term><description> A instância atual é igual a <paramref name="other" />.  
  
 </description></item><item><term> Maior que zero 
 </term><description> A instância atual é maior que <paramref name="other" />.  
  
 </description></item></list></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Divide">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Divide (System.Numerics.BigInteger dividend, System.Numerics.BigInteger divisor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Divide(valuetype System.Numerics.BigInteger dividend, valuetype System.Numerics.BigInteger divisor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Divide(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Divide (dividend As BigInteger, divisor As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Divide(System::Numerics::BigInteger dividend, System::Numerics::BigInteger divisor);" />
      <MemberSignature Language="F#" Value="static member Divide : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Divide (dividend, divisor)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dividend" Type="System.Numerics.BigInteger" />
        <Parameter Name="divisor" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="dividend">O valor a ser dividido.</param>
        <param name="divisor">O valor pelo qual dividir.</param>
        <summary>Divide um valor <see cref="T:System.Numerics.BigInteger" /> em outro e retorna o resultado.</summary>
        <returns>O quociente da divisão.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Numerics.BigInteger.Divide%2A> método executa a divisão de inteiro; qualquer resto que resulta da divisão é descartado. Para executar a divisão de inteiros, preservando o resto, chamar o <xref:System.Numerics.BigInteger.DivRem%2A> método. Para recuperar apenas o resto, chame o <xref:System.Numerics.BigInteger.Remainder%2A> método.  
  
 O <xref:System.Numerics.BigInteger.Divide%2A> método pode ser usado por idiomas que não dão suporte a sobrecarga de operador. Seu comportamento é idêntico à divisão usando o operador de divisão.  
  
   
  
## Examples  
 O exemplo a seguir cria uma matriz de <xref:System.Numerics.BigInteger> valores. Ele usa, em seguida, cada elemento como o quociente em uma operação de divisão que usa o <xref:System.Numerics.BigInteger.Divide%2A> método, o operador de divisão (/) e o <xref:System.Numerics.BigInteger.DivRem%2A> método.  
  
 [!code-csharp[System.Numerics.BigInteger.Divide#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Divide/cs/Divide1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Divide#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Divide/vb/Divide1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException"><paramref name="divisor" /> é 0 (zero).</exception>
        <altmember cref="M:System.Numerics.BigInteger.op_Division(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
        <altmember cref="M:System.Numerics.BigInteger.DivRem(System.Numerics.BigInteger,System.Numerics.BigInteger,System.Numerics.BigInteger@)" />
        <altmember cref="M:System.Numerics.BigInteger.Remainder(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="DivRem">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger DivRem (System.Numerics.BigInteger dividend, System.Numerics.BigInteger divisor, out System.Numerics.BigInteger remainder);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger DivRem(valuetype System.Numerics.BigInteger dividend, valuetype System.Numerics.BigInteger divisor, [out] valuetype System.Numerics.BigInteger&amp; remainder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.DivRem(System.Numerics.BigInteger,System.Numerics.BigInteger,System.Numerics.BigInteger@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DivRem (dividend As BigInteger, divisor As BigInteger, ByRef remainder As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger DivRem(System::Numerics::BigInteger dividend, System::Numerics::BigInteger divisor, [Runtime::InteropServices::Out] System::Numerics::BigInteger % remainder);" />
      <MemberSignature Language="F#" Value="static member DivRem : System.Numerics.BigInteger * System.Numerics.BigInteger *  -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.DivRem (dividend, divisor, remainder)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dividend" Type="System.Numerics.BigInteger" />
        <Parameter Name="divisor" Type="System.Numerics.BigInteger" />
        <Parameter Name="remainder" Type="System.Numerics.BigInteger" RefType="out" />
      </Parameters>
      <Docs>
        <param name="dividend">O valor a ser dividido.</param>
        <param name="divisor">O valor pelo qual dividir.</param>
        <param name="remainder">Quando este método retorna, contém um valor <see cref="T:System.Numerics.BigInteger" /> que representa o restante da divisão. Este parâmetro é passado não inicializado.</param>
        <summary>Divide um valor <see cref="T:System.Numerics.BigInteger" /> por outro, retorna o resultado e retorna o restante em um parâmetro de saída.</summary>
        <returns>O quociente da divisão.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método preserva o quociente e o resto que resulta da divisão de inteiros. Se você não estiver interessado no restante, use o <xref:System.Numerics.BigInteger.Divide%2A> método ou o operador de divisão; se você estiver apenas interessado no restante, use o <xref:System.Numerics.BigInteger.Remainder%2A> método.  
  
 O sinal do retornado `remainder` valor é o mesmo que o sinal do `dividend` parâmetro.  
  
 O comportamento do <xref:System.Numerics.BigInteger.DivRem%2A> método é idêntico do <xref:System.Math.DivRem%2A?displayProperty=nameWithType> método.  
  
   
  
## Examples  
 O exemplo a seguir cria uma matriz de <xref:System.Numerics.BigInteger> valores. Ele usa, em seguida, cada elemento como o quociente em uma operação de divisão que usa o <xref:System.Numerics.BigInteger.Divide%2A> método, o operador de divisão (/) e o <xref:System.Numerics.BigInteger.DivRem%2A> método.  
  
 [!code-csharp[System.Numerics.BigInteger.Divide#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Divide/cs/Divide1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Divide#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Divide/vb/Divide1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException"><paramref name="divisor" /> é 0 (zero).</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retorna um valor que indica se dois valores numéricos são iguais.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (long other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(int64 other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Equals(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (other As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Equals(long other);" />
      <MemberSignature Language="F#" Value="override this.Equals : int64 -&gt; bool" Usage="bigInteger.Equals other" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="other">O valor inteiro com sinal de 64 bits para comparar.</param>
        <summary>Retorna um valor que indica se a instância atual e um inteiro com sinal de 64 bits têm o mesmo valor.</summary>
        <returns><see langword="true" /> se o inteiro com sinal de 64 bits e a instância atual tiverem o mesmo valor; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `other` é um <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, ou <xref:System.UInt32> valor, ele é convertido implicitamente em um <xref:System.Int64> valor quando o método é chamado.  
  
 Para determinar a relação entre os dois objetos em vez de apenas Testando a igualdade, chame o <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> método.  
  
   
  
## Examples  
 O exemplo a seguir instancia um <xref:System.Numerics.BigInteger> objeto de cada tipo integral exceto <xref:System.UInt64>. Em seguida, ele chama o <xref:System.Numerics.BigInteger.Equals%28System.Int64%29> método a ser comparado a <xref:System.Numerics.BigInteger> valor com o valor de inteiro original que foi passado para o <xref:System.Numerics.BigInteger> construtor. Como mostra a saída, os valores são iguais em cada caso.  
  
 [!code-cpp[System.Numerics.BigInteger.Equals#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cpp/equals.cpp#1)]
 [!code-csharp[System.Numerics.BigInteger.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cs/EqualsExample1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/vb/EqualsExample1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (System.Numerics.BigInteger other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(valuetype System.Numerics.BigInteger other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Equals(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (other As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::Numerics::BigInteger other);" />
      <MemberSignature Language="F#" Value="override this.Equals : System.Numerics.BigInteger -&gt; bool" Usage="bigInteger.Equals other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="other">O objeto a ser comparado.</param>
        <summary>Retorna um valor que indica se a instância atual e um objeto <see cref="T:System.Numerics.BigInteger" /> especificado têm o mesmo valor.</summary>
        <returns><see langword="true" /> se este objeto <see cref="T:System.Numerics.BigInteger" /> e <paramref name="other" /> tiverem o mesmo valor; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método implementa o <xref:System.IEquatable%601> da interface e executa um pouco melhor do que <xref:System.Numerics.BigInteger.Equals%28System.Object%29> porque ele não tem que converter a `other` parâmetro para um <xref:System.Numerics.BigInteger> objeto.  
  
 Para determinar a relação entre os dois <xref:System.Numerics.BigInteger> objetos, em vez de apenas Testando a igualdade, chamar o <xref:System.Numerics.BigInteger.CompareTo%28System.Numerics.BigInteger%29?displayProperty=nameWithType> método.  
  
   
  
## Examples  
 O exemplo a seguir compara a distância aproximada de várias estrelas de Terra com a distância do Épsilon indicada de terra para determinar se eles são iguais. O exemplo usa cada sobrecarga da <xref:System.Numerics.BigInteger.Equals%2A> método para testar a igualdade.  
  
 [!code-cpp[System.Numerics.BigInteger.Equals#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cpp/equals2.cpp#2)]
 [!code-csharp[System.Numerics.BigInteger.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cs/EqualsExample1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/vb/EqualsExample1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="bigInteger.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">O objeto a ser comparado.</param>
        <summary>Retorna um valor que indica se a instância atual e um objeto especificado têm o mesmo valor.</summary>
        <returns><see langword="true" /> se o <paramref name="obj" /> argumento for um objeto <see cref="T:System.Numerics.BigInteger" /> e seu valor for igual ao valor da instância <see cref="T:System.Numerics.BigInteger" /> atual; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se o `obj` argumento não é um <xref:System.Numerics.BigInteger> de valor, o método retorna `false`. O método retornará `true` somente se `obj` é um <xref:System.Numerics.BigInteger> instância cujo valor é igual à instância atual.  
  
 Para determinar a relação entre os dois objetos em vez de apenas Testando a igualdade, chame o <xref:System.Numerics.BigInteger.CompareTo%28System.Object%29> método.  
  
   
  
## Examples  
 O exemplo a seguir define paralelo <xref:System.Object> e <xref:System.Numerics.BigInteger> matrizes. Cada elemento de uma matriz tem o mesmo valor que o elemento correspondente da segunda matriz. Como a saída do exemplo mostra, a instância no <xref:System.Numerics.BigInteger> matriz é considerada igual à instância das <xref:System.Object> matriz somente se o último é um <xref:System.Numerics.BigInteger> e seus valores são iguais.  
  
 [!code-csharp[System.Numerics.BigInteger.Equals#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cs/Equals_Obj1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.Equals#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/vb/Equals_Obj1.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (ulong other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(unsigned int64 other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Equals(System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (other As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Equals(System::UInt64 other);" />
      <MemberSignature Language="F#" Value="override this.Equals : uint64 -&gt; bool" Usage="bigInteger.Equals other" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="other">O inteiro sem sinal de 64 bits para comparar.</param>
        <summary>Retorna um valor que indica se a instância atual e um inteiro sem sinal de 64 bits têm o mesmo valor.</summary>
        <returns><see langword="true" /> se a instância atual e o inteiro sem sinal de 64 bits tiverem o mesmo valor; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para determinar a relação entre os dois objetos em vez de apenas Testando a igualdade, chame o <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> método.  
  
   
  
## Examples  
 O exemplo a seguir compara a distância aproximada de várias estrelas de Terra com a distância do Épsilon indicada de terra para determinar se eles são iguais. O exemplo usa cada sobrecarga da <xref:System.Numerics.BigInteger.Equals%2A> método para testar a igualdade.  
  
 [!code-cpp[System.Numerics.BigInteger.Equals#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cpp/equals2.cpp#2)]
 [!code-csharp[System.Numerics.BigInteger.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cs/EqualsExample1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/vb/EqualsExample1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public int GetByteCount (bool isUnsigned = false);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetByteCount(bool isUnsigned) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.GetByteCount(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetByteCount (Optional isUnsigned As Boolean = false) As Integer" />
      <MemberSignature Language="F#" Value="member this.GetByteCount : bool -&gt; int" Usage="bigInteger.GetByteCount isUnsigned" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="isUnsigned" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="isUnsigned">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="bigInteger.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna o código hash para o objeto <see cref="T:System.Numerics.BigInteger" /> atual.</summary>
        <returns>Um código de hash do inteiro assinado de 32 bits.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GreatestCommonDivisor">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger GreatestCommonDivisor (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger GreatestCommonDivisor(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.GreatestCommonDivisor(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GreatestCommonDivisor (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger GreatestCommonDivisor(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member GreatestCommonDivisor : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.GreatestCommonDivisor (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">O primeiro valor.</param>
        <param name="right">O segundo valor.</param>
        <summary>Localiza o maior divisor comum de dois valores <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>O maior divisor comum de <paramref name="left" /> e <paramref name="right" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O maior divisor comum é o maior número na qual os dois <xref:System.Numerics.BigInteger> valores podem ser divididos sem retornar um resto.  
  
 Se o `left` e `right` parâmetros são números diferentes de zero, o método sempre retorna pelo menos um valor de 1, porque todos os números podem ser divididos em 1. Se o parâmetro é zero, o método retorna o valor absoluto do parâmetro diferente de zero. Se os dois valores forem zero, o método retorna zero.  
  
> [!NOTE]
>  O máximo divisor comum de valores muito grandes de computação `left` e `right` pode ser uma operação muito demorada.  
  
 O valor retornado pela <xref:System.Numerics.BigInteger.GreatestCommonDivisor%2A> método sempre é positivo, independentemente do sinal do `left` e `right` parâmetros.  
  
   
  
## Examples  
 O exemplo a seguir ilustra uma chamada para o <xref:System.Numerics.BigInteger.GreatestCommonDivisor%2A> método de manipulação e exceções necessárias para fornecer informações úteis sobre um <xref:System.ArgumentOutOfRangeException>. O resultado indica que o máximo divisor comum desses dois números é 1.  
  
 [!code-csharp[System.Numeric.BigInteger.Class#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#10)]
 [!code-vb[System.Numeric.BigInteger.Class#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#10)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEven">
      <MemberSignature Language="C#" Value="public bool IsEven { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEven" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.IsEven" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsEven As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsEven { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsEven : bool" Usage="System.Numerics.BigInteger.IsEven" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indica se o valor do objeto <see cref="T:System.Numerics.BigInteger" /> atual é um número par.</summary>
        <value><see langword="true" /> se o valor do objeto <see cref="T:System.Numerics.BigInteger" /> é um número par; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propriedade é um recurso conveniente que indica se um <xref:System.Numerics.BigInteger> valor é igualmente divisível por dois. É equivalente à expressão a seguir:  
  
```csharp   
value % 2 == 0;  
```  
  
```vb  
value Mod 2 = 0  
```  
  
 Se o valor do atual <xref:System.Numerics.BigInteger> objeto está <xref:System.Numerics.BigInteger.Zero%2A?displayProperty=nameWithType>, a propriedade retorna `true`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsOne">
      <MemberSignature Language="C#" Value="public bool IsOne { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsOne" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.IsOne" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsOne As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsOne { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsOne : bool" Usage="System.Numerics.BigInteger.IsOne" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indica se o valor do objeto <see cref="T:System.Numerics.BigInteger" /> atual é <see cref="P:System.Numerics.BigInteger.One" />.</summary>
        <value><see langword="true" /> Se o valor de <see cref="T:System.Numerics.BigInteger" /> objeto está <see cref="P:System.Numerics.BigInteger.One" />; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa propriedade oferece um desempenho significativamente melhor que outros comparações com um, tais como `thisBigInteger.Equals(BigInteger.One)`.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.BigInteger.One" />
      </Docs>
    </Member>
    <Member MemberName="IsPowerOfTwo">
      <MemberSignature Language="C#" Value="public bool IsPowerOfTwo { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPowerOfTwo" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.IsPowerOfTwo" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPowerOfTwo As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPowerOfTwo { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPowerOfTwo : bool" Usage="System.Numerics.BigInteger.IsPowerOfTwo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indica se o valor do objeto <see cref="T:System.Numerics.BigInteger" /> atual é uma potência de dois.</summary>
        <value><see langword="true" /> Se o valor de <see cref="T:System.Numerics.BigInteger" /> objeto é uma potência de dois; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa propriedade determina se um <xref:System.Numerics.BigInteger> valor tem um único bit diferente de zero definido. Isso significa que ele retorna `true` se o valor do atual <xref:System.Numerics.BigInteger> objeto é 1 (ou seja, 2<sup>0</sup>) ou qualquer maior potência de dois. Ele retorna `false` se o valor do atual <xref:System.Numerics.BigInteger> objeto é 0.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsZero">
      <MemberSignature Language="C#" Value="public bool IsZero { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsZero" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.IsZero" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsZero As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsZero { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsZero : bool" Usage="System.Numerics.BigInteger.IsZero" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indica se o valor do objeto <see cref="T:System.Numerics.BigInteger" /> atual é <see cref="P:System.Numerics.BigInteger.Zero" />.</summary>
        <value><see langword="true" /> Se o valor de <see cref="T:System.Numerics.BigInteger" /> objeto está <see cref="P:System.Numerics.BigInteger.Zero" />; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa propriedade oferece um desempenho significativamente melhor que `BigInteger.Equals(BigInteger.Zero)`.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.BigInteger.Zero" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Log">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retorna o logaritmo de um número especificado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public static double Log (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Log(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Log(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log (value As BigInteger) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Log(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member Log : System.Numerics.BigInteger -&gt; double" Usage="System.Numerics.BigInteger.Log value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">O número cujo logaritmo deve ser encontrado.</param>
        <summary>Retorna o logaritmo natural (de base <see langword="e" />) de um número especificado.</summary>
        <returns>O logaritmo natural (base <see langword="e" />) de <paramref name="value" />, conforme mostrado na tabela na seção Comentários.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `value` parâmetro é especificado como um número de base 10.  
  
 Retorna o exato depende do valor desse método o sinal do `value`, como mostra a tabela a seguir.  
  
|Inscreva-se de `value` parâmetro|Valor retornado|  
|-------------------------------|------------------|  
|Positivo|O logaritmo natural de `value`; ou seja, ln `value`, ou log e`value`.|  
|Zero|<xref:System.Double.NegativeInfinity>.|  
|Negativo|<xref:System.Double.NaN>.|  
  
 Para calcular o logaritmo de base 10 de um <xref:System.Numerics.BigInteger> de valor, chame o <xref:System.Numerics.BigInteger.Log10%2A> método. Para calcular o logaritmo de um número em outra base, chame o <xref:System.Numerics.BigInteger.Log%28System.Numerics.BigInteger%2CSystem.Double%29> método.  
  
 Você pode encontrar a raiz quadrada de um número chamando o <xref:System.Numerics.BigInteger.Log%2A> método junto com o <xref:System.Math.Exp%2A?displayProperty=nameWithType> método. Observe que o resultado será <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> se o resultado for maior que <xref:System.Double.MaxValue?displayProperty=nameWithType>. O exemplo a seguir calcula a raiz quadrada de cada elemento em uma matriz de <xref:System.Numerics.BigInteger> valores.  
  
 [!code-csharp[System.Numerics.BigInteger.Log#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.biginteger.log/cs/log1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Log#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.biginteger.log/vb/log1.vb#1)]
  
 Esse método corresponde à <xref:System.Math.Log%28System.Double%29?displayProperty=nameWithType> método para os tipos numéricos primitivos.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">O log natural de <paramref name="value" /> está fora do intervalo do tipo de dados <see cref="T:System.Double" />.</exception>
        <altmember cref="M:System.Numerics.BigInteger.Log10(System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public static double Log (System.Numerics.BigInteger value, double baseValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Log(valuetype System.Numerics.BigInteger value, float64 baseValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Log(System.Numerics.BigInteger,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log (value As BigInteger, baseValue As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Log(System::Numerics::BigInteger value, double baseValue);" />
      <MemberSignature Language="F#" Value="static member Log : System.Numerics.BigInteger * double -&gt; double" Usage="System.Numerics.BigInteger.Log (value, baseValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
        <Parameter Name="baseValue" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">Um número cujo logaritmo deve ser localizado.</param>
        <param name="baseValue">A base do logaritmo.</param>
        <summary>Retorna o logaritmo de um número especificado em uma base especificada.</summary>
        <returns>O logaritmo de base <paramref name="baseValue" /> de <paramref name="value" />, conforme mostrado na tabela na seção Comentários.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `value` e `baseValue` são especificados como 10 números de base.  
  
 Retorna o exato depende do valor do método do sinal de `value` e de entrada e o valor de `baseValue`, como mostra a tabela a seguir.  
  
|Parâmetro `value`|Parâmetro `baseValue`|Valor retornado|  
|-----------------------|---------------------------|------------------|  
|`value` > 0|(0 < `baseValue` < 1) - ou -(`baseValue` > 1)|logbaseValue(`value`)|  
|`value` < 0|(nenhum valor)|<xref:System.Double.NaN?displayProperty=nameWithType>|  
|(nenhum valor)|`baseValue` < 0|<xref:System.Double.NaN?displayProperty=nameWithType>|  
|`value` != 1|`baseValue` = 0|<xref:System.Double.NaN?displayProperty=nameWithType>|  
|`value` != 1|`baseValue` = <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>|<xref:System.Double.NaN?displayProperty=nameWithType>|  
|(nenhum valor)|`baseValue` = <xref:System.Double.NaN?displayProperty=nameWithType>|<xref:System.Double.NaN?displayProperty=nameWithType>|  
|(nenhum valor)|`baseValue` = 1|<xref:System.Double.NaN?displayProperty=nameWithType>|  
|`value` = 0|0 < `baseValue` < 1|<xref:System.Double.PositiveInfinity?displayProperty=nameWithType>|  
|`value` = 0|`baseValue` > 1|<xref:System.Double.PositiveInfinity?displayProperty=nameWithType>|  
|`value` = 1|`baseValue` = 0|0|  
|`value` = 1|`baseValue` = <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>|0|  
  
 Para calcular o logaritmo de base 10 de um <xref:System.Numerics.BigInteger> de valor, chame o <xref:System.Numerics.BigInteger.Log10%2A> método. Para calcular o logaritmo natural de um número, chame o <xref:System.Numerics.BigInteger.Log%28System.Numerics.BigInteger%29> método.  
  
 Esse método corresponde à <xref:System.Math.Log%2A?displayProperty=nameWithType> método para os tipos numéricos primitivos.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">O log de <paramref name="value" /> está fora do intervalo do tipo de dados <see cref="T:System.Double" />.</exception>
        <altmember cref="M:System.Numerics.BigInteger.Log10(System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="Log10">
      <MemberSignature Language="C#" Value="public static double Log10 (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Log10(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Log10(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log10 (value As BigInteger) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Log10(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member Log10 : System.Numerics.BigInteger -&gt; double" Usage="System.Numerics.BigInteger.Log10 value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Um número cujo logaritmo deve ser localizado.</param>
        <summary>Retorna o logaritmo de base 10 de um número especificado.</summary>
        <returns>O logaritmo de base 10 de <paramref name="value" />, conforme mostrado na tabela na seção Comentários.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `value` parâmetro é especificado como um número de base 10.  
  
 Retorna o exato depende do valor do método o sinal do `value`, como mostra a tabela a seguir.  
  
|Entrada de parâmetro de valor|Valor retornado|  
|-----------------------------|------------------|  
|Positivo|O log de base 10 `value`; ou seja, log10`value`.|  
|Zero|<xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.|  
|Negativo|<xref:System.Double.NaN?displayProperty=nameWithType>.|  
  
 Para calcular o logaritmo natural de um <xref:System.Numerics.BigInteger> de valor, chame o <xref:System.Numerics.BigInteger.Log%28System.Numerics.BigInteger%29?displayProperty=nameWithType> método. Para calcular o logaritmo de um número em outra base, chame o <xref:System.Numerics.BigInteger.Log%28System.Numerics.BigInteger%2CSystem.Double%29?displayProperty=nameWithType> método.  
  
 Esse método corresponde à <xref:System.Math.Log10%2A?displayProperty=nameWithType> método para os tipos numéricos primitivos.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">O log de base 10 de <paramref name="value" /> está fora do intervalo do tipo de dados <see cref="T:System.Double" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Max (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Max(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Max(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Max (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Max(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member Max : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Max (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">O primeiro valor a ser comparado.</param>
        <param name="right">O segundo valor a ser comparado.</param>
        <summary>Retorna o maior dos dois valores <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>O parâmetro <paramref name="left" /> ou <paramref name="right" />, o que for maior.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método corresponde à <xref:System.Math.Max%2A?displayProperty=nameWithType> método para tipos numéricos primitivos.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.Numerics.BigInteger.Max%2A> método para selecionar o maior número em uma matriz de <xref:System.Numerics.BigInteger> valores.  
  
 [!code-csharp[System.Numerics.BigInteger.Max#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Max/cs/Max1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Max#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Max/vb/Max1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.Min(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Min (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Min(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Min(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Min (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Min(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member Min : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Min (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">O primeiro valor a ser comparado.</param>
        <param name="right">O segundo valor a ser comparado.</param>
        <summary>Retorna o menor de dois valores <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>O parâmetro <paramref name="left" /> ou <paramref name="right" />, o que for menor.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método corresponde à <xref:System.Math.Min%2A?displayProperty=nameWithType> método para tipos numéricos primitivos.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.Numerics.BigInteger.Min%2A> método para selecionar o menor número em uma matriz de <xref:System.Numerics.BigInteger> valores.  
  
 [!code-csharp[System.Numerics.BigInteger.Min#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Min/cs/Min1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Min#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Min/vb/Min1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.Max(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="MinusOne">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger MinusOne { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Numerics.BigInteger MinusOne" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.MinusOne" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MinusOne As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Numerics::BigInteger MinusOne { System::Numerics::BigInteger get(); };" />
      <MemberSignature Language="F#" Value="member this.MinusOne : System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.MinusOne" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que representa o número um negativo (-1).</summary>
        <value>Um inteiro cujo valor é um negativo (-1).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Numerics.BigInteger.MinusOne%2A> propriedade é usada para comparar uma <xref:System.Numerics.BigInteger> valor -1 ou -1 para atribuir um <xref:System.Numerics.BigInteger> objeto.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.BigInteger.One" />
        <altmember cref="P:System.Numerics.BigInteger.IsOne" />
      </Docs>
    </Member>
    <Member MemberName="ModPow">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger ModPow (System.Numerics.BigInteger value, System.Numerics.BigInteger exponent, System.Numerics.BigInteger modulus);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger ModPow(valuetype System.Numerics.BigInteger value, valuetype System.Numerics.BigInteger exponent, valuetype System.Numerics.BigInteger modulus) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ModPow(System.Numerics.BigInteger,System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ModPow (value As BigInteger, exponent As BigInteger, modulus As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger ModPow(System::Numerics::BigInteger value, System::Numerics::BigInteger exponent, System::Numerics::BigInteger modulus);" />
      <MemberSignature Language="F#" Value="static member ModPow : System.Numerics.BigInteger * System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.ModPow (value, exponent, modulus)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
        <Parameter Name="exponent" Type="System.Numerics.BigInteger" />
        <Parameter Name="modulus" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">O número a ser elevado à potência <paramref name="exponent" />.</param>
        <param name="exponent">O expoente pelo qual <paramref name="value" /> será elevado.</param>
        <param name="modulus">O número pelo qual dividir o <paramref name="value" /> elevado à potência <paramref name="exponent" />.</param>
        <summary>Executa a divisão de módulo em um número elevado à potência de outro número.</summary>
        <returns>O resto após dividir o <paramref name="value" /><sup>exponente</sup> por <paramref name="modulus" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Numerics.BigInteger.ModPow%2A> método avalia a expressão a seguir:  
  
 (baseValue ^ expoente) Módulo mod  
  
 Para executar a exponenciação na <xref:System.Numerics.BigInteger> valores sem divisão de módulo, use o <xref:System.Numerics.BigInteger.Pow%2A> método.  
  
   
  
## Examples  
 O exemplo a seguir fornece uma ilustração simples de chamar o <xref:System.Numerics.BigInteger.ModPow%2A> método.  
  
 [!code-csharp[System.Numerics.BigInteger.ModPow#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ModPow/cs/ModPow1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.ModPow#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ModPow/vb/ModPow1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException"><paramref name="modulus" /> é zero.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="exponent" /> é negativo.</exception>
        <altmember cref="M:System.Numerics.BigInteger.Pow(System.Numerics.BigInteger,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Multiply">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Multiply (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Multiply(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Multiply(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Multiply (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Multiply(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member Multiply : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Multiply (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">O primeiro número a multiplicar.</param>
        <param name="right">O segundo número a multiplicar.</param>
        <summary>Retorna o produto de dois valores <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>O produto dos parâmetros <paramref name="left" /> e <paramref name="right" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Numerics.BigInteger.Multiply%2A> método é implementado para idiomas que não dão suporte a sobrecarga de operador. Seu comportamento é idêntico a multiplicação usando o operador de multiplicação. Além disso, o <xref:System.Numerics.BigInteger.Multiply%2A> método é um substituto úteis para o operador de multiplicação ao instanciar um <xref:System.Numerics.BigInteger> variável atribuindo a ela um produto que resulta da multiplicação, conforme mostrado no exemplo a seguir.  
  
 [!code-csharp[System.Numerics.BigInteger.OperationMethods#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/cs/Multiply1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.OperationMethods#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/vb/Multiply1.vb#1)]  
  
 Se necessário, esse método executa automaticamente a conversão implícita de outros tipos integrais para <xref:System.Numerics.BigInteger> objetos. Isso é ilustrado no exemplo na próxima seção, onde o <xref:System.Numerics.BigInteger.Multiply%2A> método recebe dois <xref:System.Int64> valores.  
  
   
  
## Examples  
 O exemplo a seguir tenta executar uma multiplicação com dois inteiros longos. Porque o resultado excede o intervalo de um inteiro longo, um <xref:System.OverflowException> é acionada e o <xref:System.Numerics.BigInteger.Multiply%2A> método é chamado para manipular a multiplicação. Observe que c# requer que você use o `checked` palavra-chave (como neste exemplo) ou o `/checked+` opção de compilador para certificar-se de uma exceção é gerada em um estouro numérico.  
  
 [!code-csharp[System.Numeric.BigInteger.Class#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#7)]
 [!code-vb[System.Numeric.BigInteger.Class#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#7)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_Multiply(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="Negate">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Negate (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Negate(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Negate(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Negate (value As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Negate(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member Negate : System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Negate value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">O valor a ser negado.</param>
        <summary>Nega um valor <see cref="T:System.Numerics.BigInteger" /> especificado.</summary>
        <returns>O resultado do parâmetro <paramref name="value" /> multiplicado por um negativo (-1).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Negação obtém o inverso aditivo de um número. O inverso aditivo de um número é um número que produz um valor de zero quando ele é adicionado para o número original.  
  
 O <xref:System.Numerics.BigInteger.Negate%2A> método é implementado para idiomas que não dão suporte a operadores personalizados. Seu comportamento é idêntico ao usando o operador de negação unário de negação. Além disso, o <xref:System.Numerics.BigInteger.Negate%2A> método é um substituto úteis para o operador de negação ao instanciar um <xref:System.Numerics.BigInteger> variável, conforme mostrado no exemplo a seguir.  
  
 [!code-csharp[System.Numerics.BigInteger.OperationMethods#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/cs/Multiply1.cs#4)]
 [!code-vb[System.Numerics.BigInteger.OperationMethods#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/vb/Multiply1.vb#4)]  
  
   
  
## Examples  
 O exemplo a seguir ilustra três maneiras de nega o valor de um <xref:System.Numerics.BigInteger> objeto.  
  
 [!code-csharp[System.Numeric.BigInteger.Class#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#16)]
 [!code-vb[System.Numeric.BigInteger.Class#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#16)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_UnaryNegation(System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="One">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger One { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Numerics.BigInteger One" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.One" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property One As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Numerics::BigInteger One { System::Numerics::BigInteger get(); };" />
      <MemberSignature Language="F#" Value="member this.One : System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.One" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que representa o número um (1).</summary>
        <value>Um objeto cujo valor é um (1).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Numerics.BigInteger.One%2A> propriedade normalmente é usada para comparar uma <xref:System.Numerics.BigInteger> valor 1 ou atribuir 1 para um <xref:System.Numerics.BigInteger> objeto.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.BigInteger.IsOne" />
        <altmember cref="P:System.Numerics.BigInteger.MinusOne" />
      </Docs>
    </Member>
    <Member MemberName="op_Addition">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator + (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Addition(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Addition(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator + (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator +(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( + ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="left + right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">O primeiro valor a ser adicionado.</param>
        <param name="right">O segundo valor a ser adicionado.</param>
        <summary>Adiciona os valores dos dois objetos <see cref="T:System.Numerics.BigInteger" /> especificados.</summary>
        <returns>A soma de <paramref name="left" /> e <paramref name="right" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Numerics.BigInteger.op_Addition%2A> método define a operação de adição para <xref:System.Numerics.BigInteger> valores. Ele permite que o código seja o seguinte:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#12)]
 [!code-vb[System.Numeric.BigInteger.Class#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#12)]  
  
 Linguagens que não dão suporte a operadores personalizados podem chamar o método <xref:System.Numerics.BigInteger.Add%2A> em vez disso.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.Add(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="op_BitwiseAnd">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator &amp; (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_BitwiseAnd(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_BitwiseAnd(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator And (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator &amp;(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &amp;&amp;&amp; ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="left &amp;&amp;&amp; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">O primeiro valor.</param>
        <param name="right">O segundo valor.</param>
        <summary>Executa uma operação <see langword="And" /> bit a bit em dois valores <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>O resultado da operação <see langword="And" /> bit a bit.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Numerics.BigInteger.op_BitwiseAnd%2A> método define o bit a bit `And` operação para <xref:System.Numerics.BigInteger> valores. O bit a bit `And` operação define os bits correspondentes um se apenas de bit de resultado `left` e `right` também são definidas, conforme mostrado na tabela a seguir.  
  
|Bit no `left`|Bit no `right`|Bit no resultado|  
|-------------------|--------------------|-------------------|  
|0|0|0|  
|1|0|0|  
|1|1|1|  
|0|1|0|  
  
 O <xref:System.Numerics.BigInteger.op_BitwiseAnd%2A> método permite que o código como o seguinte:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Operators#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#1)]  
  
 O <xref:System.Numerics.BigInteger.op_BitwiseAnd%2A> método executa bit a bit `And` operação em dois <xref:System.Numerics.BigInteger> valores como se estivessem em um de dois complemento representação com a extensão de entrada virtual.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_BitwiseOr">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator | (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_BitwiseOr(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_BitwiseOr(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator Or (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator |(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( ||| ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="left ||| right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">O primeiro valor.</param>
        <param name="right">O segundo valor.</param>
        <summary>Executa uma operação <see langword="Or" /> bit a bit em dois valores <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>O resultado da operação <see langword="Or" /> bit a bit.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Numerics.BigInteger.op_BitwiseOr%2A> método define o bit a bit `Or` operação para <xref:System.Numerics.BigInteger> valores. O bit a bit `Or` operação define um se apenas de bit de resultado de um ou ambos os bits correspondentes `left` e `right` estiverem definidas, conforme mostrado na tabela a seguir.  
  
|Bit no `left`|Bit no `right`|Bit no resultado|  
|-------------------|--------------------|-------------------|  
|0|0|0|  
|1|0|1|  
|1|1|1|  
|0|1|1|  
  
 O <xref:System.Numerics.BigInteger.op_BitwiseOr%2A> método permite que o código como o seguinte:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.Operators#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#2)]  
  
 O <xref:System.Numerics.BigInteger.op_BitwiseOr%2A> método executa bit a bit `Or` operação em dois <xref:System.Numerics.BigInteger> valores como se estivessem em um de dois complemento representação com a extensão de entrada virtual.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Decrement">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator -- (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Decrement(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Decrement(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared op_Decrement (value As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator --(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Decrement : System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Decrement value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">O valor a ser diminuído.</param>
        <summary>Diminui um valor <see cref="T:System.Numerics.BigInteger" /> em 1.</summary>
        <returns>O valor do parâmetro <paramref name="value" /> diminuído em 1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Numerics.BigInteger.op_Decrement%2A> método define a operação de decremento para <xref:System.Numerics.BigInteger> valores. Ele permite que o código seja o seguinte:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#17)]  
  
 Linguagens que não dão suporte a operadores personalizados podem chamar o método <xref:System.Numerics.BigInteger.Subtract%2A> em vez disso. Por exemplo:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.Operators#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#3)]  
  
 Porque <xref:System.Numerics.BigInteger> objetos são imutáveis, a <xref:System.Numerics.BigInteger.op_Decrement%2A> operador cria uma nova <xref:System.Numerics.BigInteger> objeto cujo valor é um menor do que o <xref:System.Numerics.BigInteger> objeto representado pelo `value`. Isso significa que chamadas repetidas para <xref:System.Numerics.BigInteger.op_Decrement%2A> pode ser cara.  
  
 O método equivalente para esse operador é <xref:System.Numerics.BigInteger.Subtract%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_Increment(System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="op_Division">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator / (System.Numerics.BigInteger dividend, System.Numerics.BigInteger divisor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Division(valuetype System.Numerics.BigInteger dividend, valuetype System.Numerics.BigInteger divisor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Division(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator / (dividend As BigInteger, divisor As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator /(System::Numerics::BigInteger dividend, System::Numerics::BigInteger divisor);" />
      <MemberSignature Language="F#" Value="static member ( / ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="dividend / divisor" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dividend" Type="System.Numerics.BigInteger" />
        <Parameter Name="divisor" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="dividend">O valor a ser dividido.</param>
        <param name="divisor">O valor pelo qual dividir.</param>
        <summary>Divide um valor <see cref="T:System.Numerics.BigInteger" /> especificado por outro valor <see cref="T:System.Numerics.BigInteger" /> especificado usando a divisão de inteiros.</summary>
        <returns>O resultado integral da divisão.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Numerics.BigInteger.op_Division%2A> método define a operação de divisão para <xref:System.Numerics.BigInteger> valores. Ele permite que o código seja o seguinte:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#13)]
 [!code-vb[System.Numeric.BigInteger.Class#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#13)]  
  
 Idiomas que não dão suporte a operadores personalizados e sobrecarga de operador podem chamar o <xref:System.Numerics.BigInteger.Divide%2A> método em vez disso.  
  
 É o método equivalente para esse operador <xref:System.Numerics.BigInteger.Divide%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>  
  
## Examples  
 O exemplo a seguir cria uma matriz de <xref:System.Numerics.BigInteger> valores. Ele usa, em seguida, cada elemento como o quociente em uma operação de divisão que usa o <xref:System.Numerics.BigInteger.Divide%2A> método, o operador de divisão (/) e o <xref:System.Numerics.BigInteger.DivRem%2A> método.  
  
 [!code-csharp[System.Numerics.BigInteger.Divide#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Divide/cs/Divide1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Divide#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Divide/vb/Divide1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException"><paramref name="divisor" /> é 0 (zero).</exception>
        <altmember cref="M:System.Numerics.BigInteger.Divide(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Equality">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retorna um valor que indica se dois valores são iguais.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (long left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Equality(System.Int64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Long, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(long left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : int64 * System.Numerics.BigInteger -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">O primeiro valor a ser comparado.</param>
        <param name="right">O segundo valor a ser comparado.</param>
        <summary>Retorna um valor que indica se um valor inteiro longo com sinal e um valor <see cref="T:System.Numerics.BigInteger" /> são iguais.</summary>
        <returns><see langword="true" /> se os parâmetros <paramref name="left" /> e <paramref name="right" /> tiverem o mesmo valor; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Numerics.BigInteger.op_Equality%28System.Int64%2CSystem.Numerics.BigInteger%29> método define a operação de comparação de igualdade para <xref:System.Numerics.BigInteger> valores. Ele permite que o código seja o seguinte:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#4)]
 [!code-vb[System.Numerics.BigInteger.Operators#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#4)]  
  
 Linguagens que não dão suporte a operadores personalizados podem chamar o <xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType> em vez disso, o método de instância.  
  
 Se `left` é um <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, ou <xref:System.UInt32> valor, ele é convertido implicitamente em um <xref:System.Int64> valor quando a operação é executada.  
  
 O método equivalente para esse operador é <xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Inequality" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Numerics.BigInteger left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(valuetype System.Numerics.BigInteger left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Equality(System.Numerics.BigInteger,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As BigInteger, right As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Numerics::BigInteger left, long right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Numerics.BigInteger * int64 -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="left">O primeiro valor a ser comparado.</param>
        <param name="right">O segundo valor a ser comparado.</param>
        <summary>Retorna um valor que indica se um valor <see cref="T:System.Numerics.BigInteger" /> e um valor inteiro longo com sinal são iguais.</summary>
        <returns><see langword="true" /> se os parâmetros <paramref name="left" /> e <paramref name="right" /> tiverem o mesmo valor; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Numerics.BigInteger.op_Equality%28System.Numerics.BigInteger%2CSystem.Int64%29> método define a operação de comparação de igualdade para <xref:System.Numerics.BigInteger> valores. Ele permite que o código seja o seguinte:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#5)]
 [!code-vb[System.Numerics.BigInteger.Operators#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#5)]  
  
 Linguagens que não dão suporte a operadores personalizados podem chamar o <xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType> em vez disso, o método de instância.  
  
 Se `right` é um <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, ou <xref:System.UInt32> valor, ele é convertido implicitamente em um <xref:System.Int64> valor quando a operação é executada.  
  
 O método equivalente para esse operador é <xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Inequality" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Equality(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As BigInteger, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">O primeiro valor a ser comparado.</param>
        <param name="right">O segundo valor a ser comparado.</param>
        <summary>Retorna um valor que indica se os valores de dois objetos <see cref="T:System.Numerics.BigInteger" /> são iguais.</summary>
        <returns><see langword="true" /> se os parâmetros <paramref name="left" /> e <paramref name="right" /> tiverem o mesmo valor; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Numerics.BigInteger.op_Equality%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29> método define a operação do operador de igualdade para <xref:System.Numerics.BigInteger> valores. Ele permite que o código seja o seguinte:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#19)]
 [!code-vb[System.Numeric.BigInteger.Class#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#19)]  
  
 Linguagens que não dão suporte a operadores personalizados podem chamar o <xref:System.Numerics.BigInteger.Equals%28System.Numerics.BigInteger%29?displayProperty=nameWithType> em vez disso, o método de instância.  
  
 O método equivalente para esse operador é <xref:System.Numerics.BigInteger.Equals%28System.Numerics.BigInteger%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.Equals" />
        <altmember cref="Overload:System.Numerics.BigInteger.op_Inequality" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Numerics.BigInteger left, ulong right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(valuetype System.Numerics.BigInteger left, unsigned int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Equality(System.Numerics.BigInteger,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As BigInteger, right As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Numerics::BigInteger left, System::UInt64 right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Numerics.BigInteger * uint64 -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="left">O primeiro valor a ser comparado.</param>
        <param name="right">O segundo valor a ser comparado.</param>
        <summary>Retorna um valor que indica se um valor <see cref="T:System.Numerics.BigInteger" /> e um valor inteiro longo sem sinal são iguais.</summary>
        <returns><see langword="true" /> se os parâmetros <paramref name="left" /> e <paramref name="right" /> tiverem o mesmo valor; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Numerics.BigInteger.op_Equality%28System.Numerics.BigInteger%2CSystem.UInt64%29> método define a operação de comparação de igualdade para <xref:System.Numerics.BigInteger> valores. Ele permite que o código seja o seguinte:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#6)]
 [!code-vb[System.Numerics.BigInteger.Operators#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#6)]  
  
 Linguagens que não dão suporte a operadores personalizados podem chamar o <xref:System.Numerics.BigInteger.Equals%28System.UInt64%29?displayProperty=nameWithType> em vez disso, o método de instância.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Inequality" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (ulong left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(unsigned int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Equality(System.UInt64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As ULong, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::UInt64 left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : uint64 * System.Numerics.BigInteger -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">O primeiro valor a ser comparado.</param>
        <param name="right">O segundo valor a ser comparado.</param>
        <summary>Retorna um valor que indica se um valor inteiro longo sem sinal e um valor <see cref="T:System.Numerics.BigInteger" /> são iguais.</summary>
        <returns><see langword="true" /> se os parâmetros <paramref name="left" /> e <paramref name="right" /> tiverem o mesmo valor; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Numerics.BigInteger.op_Equality%28System.UInt64%2CSystem.Numerics.BigInteger%29> método define a operação de comparação de igualdade para <xref:System.Numerics.BigInteger> valores. Ele permite que o código seja o seguinte:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#7)]
 [!code-vb[System.Numerics.BigInteger.Operators#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#7)]  
  
 Linguagens que não dão suporte a operadores personalizados podem chamar o <xref:System.Numerics.BigInteger.Equals%28System.UInt64%29?displayProperty=nameWithType> em vez disso, o método de instância.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Inequality" />
      </Docs>
    </Member>
    <Member MemberName="op_ExclusiveOr">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator ^ (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_ExclusiveOr(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_ExclusiveOr(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator Xor (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator ^(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( ^^^ ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="left ^^^ right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">O primeiro valor.</param>
        <param name="right">O segundo valor.</param>
        <summary>Executa uma operação exclusiva <see langword="Or" /> bit a bit (<see langword="XOr" />) em dois valores <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>O resultado da operação <see langword="Or" /> bit a bit.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O resultado de um exclusivo bit a bit `Or` operação é `true` se os valores dos dois bits forem diferentes; caso contrário, ele será `false`. A tabela a seguir ilustra o exclusivo `Or` operação.  
  
|Bit x em `left`|Bit x em `right`|Valor retornado|  
|---------------------|----------------------|------------------|  
|0|0|0|  
|0|1|1|  
|1|0|1|  
|1|1|0|  
  
 O <xref:System.Numerics.BigInteger.op_ExclusiveOr%2A> método permite que o código como o seguinte:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#8)]
 [!code-vb[System.Numerics.BigInteger.Operators#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#8)]  
  
 O <xref:System.Numerics.BigInteger.op_ExclusiveOr%2A> método executa o bit a bit exclusivo `Or` operação em dois <xref:System.Numerics.BigInteger> valores como se estivessem em um de dois complemento representação com a extensão de entrada virtual.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Explicit">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Define uma conversão explícita entre um objeto <see cref="T:System.Numerics.BigInteger" /> e outro tipo.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Numerics.BigInteger (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Explicit(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Decimal) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Numerics::BigInteger(System::Decimal value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : decimal -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">O valor a ser convertido para um <see cref="T:System.Numerics.BigInteger" />.</param>
        <summary>Define uma conversão explícita de um objeto <see cref="T:System.Decimal" /> em um valor <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>Um objeto que contém o valor do parâmetro <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Qualquer parte fracionária de `value` parâmetro é truncado antes da conversão.

 As sobrecargas do <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> método para definir os tipos para o qual ou do qual um <xref:System.Numerics.BigInteger> objeto pode ser convertido. Porque a conversão de <xref:System.Decimal> à <xref:System.Numerics.BigInteger> pode envolver truncando qualquer parte fracionária `value`, compiladores de linguagem não realizar essa conversão automaticamente. Em vez disso, eles realizam a conversão somente se um operador de conversão (em c#) ou uma função de conversão (como `CType` no Visual Basic) é usado. Caso contrário, eles exibem um erro do compilador.   

 Para idiomas que não dão suporte a operadores personalizados, o método alternativo é <xref:System.Numerics.BigInteger.%23ctor%28System.Decimal%29?displayProperty=nameWithType>.


## Examples
 O exemplo a seguir converte os elementos individuais em uma matriz de <xref:System.Decimal> valores <xref:System.Numerics.BigInteger> objetos e, em seguida, exibe o resultado de cada conversão. Observe que quaisquer fracionários faz parte de um <xref:System.Decimal> valor é truncado durante a conversão.   

 [!code-csharp[System.Numerics.BigInteger.Explicit#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/cs/Explicit1.cs#1)]   
 [!code-vb[System.Numerics.BigInteger.Explicit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/vb/Explicit1.vb#1)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Numerics.BigInteger (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Explicit(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Double)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Double) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Numerics::BigInteger(double value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : double -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">O valor a ser convertido para um <see cref="T:System.Numerics.BigInteger" />.</param>
        <summary>Define uma conversão explícita de um valor <see cref="T:System.Double" /> para um valor <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>Um objeto que contém o valor do parâmetro <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Qualquer parte fracionária de `value` parâmetro é truncado antes da conversão.

 As sobrecargas do <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> método para definir os tipos para o qual ou do qual um <xref:System.Numerics.BigInteger> objeto pode ser convertido. Porque a conversão de <xref:System.Double> à <xref:System.Numerics.BigInteger> pode envolver truncando qualquer parte fracionária `value`, compiladores de linguagem não realizar essa conversão automaticamente. Em vez disso, eles realizam a conversão somente se um operador de conversão (em c#) ou uma função de conversão (como `CType` no Visual Basic) é usado. Caso contrário, eles exibem um erro do compilador.

 Para idiomas que não dão suporte a operadores personalizados, o método alternativo é <xref:System.Numerics.BigInteger.%23ctor%28System.Double%29?displayProperty=nameWithType>.


## Examples
 O exemplo a seguir converte os elementos individuais em uma matriz de <xref:System.Double> valores <xref:System.Numerics.BigInteger> objetos e, em seguida, exibe o resultado de cada conversão. Observe que quaisquer fracionários faz parte de um <xref:System.Double> valor é truncado durante a conversão.   
    
 [!code-csharp[System.Numerics.BigInteger.Explicit#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/cs/Explicit1.cs#2)]   
 [!code-vb[System.Numerics.BigInteger.Explicit#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/vb/Explicit1.vb#2)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><paramref name="value" /> é <see cref="F:System.Double.NaN" />, <see cref="F:System.Double.PositiveInfinity" /> ou <see cref="F:System.Double.NegativeInfinity" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator byte (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname unsigned int8 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Byte" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Byte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Byte(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; byte" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">O valor a ser convertido para um <see cref="T:System.Byte" />.</param>
        <summary>Define uma conversão explícita de um objeto <see cref="T:System.Numerics.BigInteger" /> em um valor de byte sem sinal.</summary>
        <returns>Um objeto que contém o valor do parâmetro <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 As sobrecargas do <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> método para definir os tipos para o qual ou do qual um <xref:System.Numerics.BigInteger> objeto pode ser convertido. Compiladores de linguagem não realizar essa conversão automaticamente porque ele pode envolver a perda de dados. Em vez disso, eles realizam a conversão somente se um operador de conversão (em c#) ou uma função de conversão (como `CType` ou `CByte` no Visual Basic) é usado. Caso contrário, eles exibem um erro do compilador.   

 Como essa operação define uma conversão de redução, ela pode lançar uma <xref:System.OverflowException> no tempo de execução se o <xref:System.Numerics.BigInteger> valor está fora do intervalo da <xref:System.Byte> tipo de dados. Não há nenhuma perda de precisão na resultante <xref:System.Byte> valor se a conversão for bem-sucedida.

## Examples
 O exemplo a seguir ilustra a conversão de <xref:System.Numerics.BigInteger> para <xref:System.Byte> valores. Ele também lida com um <xref:System.OverflowException> que é gerada porque o <xref:System.Numerics.BigInteger> valor está fora do intervalo da <xref:System.Byte> tipo de dados.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#1)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#1)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><paramref name="value" /> é menor que <see cref="F:System.Byte.MinValue" /> ou maior que <see cref="F:System.Byte.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator decimal (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Decimal op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Decimal" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Decimal(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; decimal" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">O valor a ser convertido para um <see cref="T:System.Decimal" />.</param>
        <summary>Define uma conversão explícita de um objeto <see cref="T:System.Numerics.BigInteger" /> em um valor <see cref="T:System.Decimal" />.</summary>
        <returns>Um objeto que contém o valor do parâmetro <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 As sobrecargas do <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> método para definir os tipos para o qual ou do qual um <xref:System.Numerics.BigInteger> objeto pode ser convertido. Compiladores de linguagem não realizar essa conversão automaticamente porque ele pode envolver a perda de dados. Em vez disso, eles realizam a conversão somente se um operador de conversão (em c#) ou uma função de conversão (como `CType` ou `CDec` no Visual Basic) é usado.   

 Como essa operação define uma conversão de redução, ela pode lançar uma <xref:System.OverflowException> no tempo de execução se o <xref:System.Numerics.BigInteger> valor está fora do intervalo da <xref:System.Decimal> tipo de dados. 

## Examples
 O exemplo a seguir ilustra a conversão de <xref:System.Numerics.BigInteger> para <xref:System.Decimal> valores. Ele também lida com um <xref:System.OverflowException> que é gerada porque o <xref:System.Numerics.BigInteger> valor está fora do intervalo da <xref:System.Decimal> tipo de dados.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#2)]
 [!code-vb[System.Numeric.BigInteger.Explicit#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#2)]  

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><paramref name="value" /> é menor que <see cref="F:System.Decimal.MinValue" /> ou maior que <see cref="F:System.Decimal.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator double (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname float64 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Double" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator double(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; double" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">O valor a ser convertido para um <see cref="T:System.Double" />.</param>
        <summary>Define uma conversão explícita de um objeto <see cref="T:System.Numerics.BigInteger" /> em um valor <see cref="T:System.Double" />.</summary>
        <returns>Um objeto que contém o valor do parâmetro <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 As sobrecargas do <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> método para definir os tipos para o qual ou do qual um <xref:System.Numerics.BigInteger> objeto pode ser convertido. Compiladores de linguagem não realizar essa conversão automaticamente porque ele pode envolver a perda de dados. Em vez disso, eles realizam a conversão somente se um operador de conversão (em c#) ou uma função de conversão (como `CType` ou `CDbl` no Visual Basic) é usado.   

 Porque o <xref:System.Numerics.BigInteger> valor pode ser fora do intervalo da <xref:System.Double> de tipo de dados, essa operação é uma conversão de estreitamento. Se a conversão for bem-sucedida, ela não gera um <xref:System.OverflowException>. Em vez disso, se o <xref:System.Numerics.BigInteger> valor é menor que <xref:System.Double.MinValue?displayProperty=nameWithType>, resultante <xref:System.Double> valor é <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>. Se o <xref:System.Numerics.BigInteger> valor é maior que <xref:System.Double.MaxValue?displayProperty=nameWithType>, resultante <xref:System.Double> valor é <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>.
 
 A conversão de um <xref:System.Numerics.BigInteger> para um <xref:System.Double> pode envolver uma perda de precisão. Em alguns casos, a perda de precisão pode causar a operação de conversão seja bem-sucedida, mesmo se o <xref:System.Numerics.BigInteger> valor está fora do intervalo da <xref:System.Double> tipo de dados. O exemplo a seguir fornece uma ilustração. Ele atribui o valor máximo de um <xref:System.Double> para dois <xref:System.Numerics.BigInteger> variáveis, incrementa um <xref:System.Numerics.BigInteger> variável 9.999e291 e as duas variáveis testa a igualdade. Conforme o esperado, a chamada para o <xref:System.Numerics.BigInteger.Equals%28System.Numerics.BigInteger%29?displayProperty=nameWithType> método mostra que elas são diferentes. No entanto, a conversão do maior <xref:System.Numerics.BigInteger> valor de volta para um <xref:System.Double> for bem-sucedida, embora o <xref:System.Numerics.BigInteger> excede o valor agora <xref:System.Double.MaxValue?displayProperty=nameWithType>.   
    
 [!code-csharp[System.Numerics.BigInteger.Explicit#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/cs/Explicit1.cs#4)]   
 [!code-vb[System.Numerics.BigInteger.Explicit#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/vb/Explicit1.vb#4)]   



## Examples
 O exemplo a seguir ilustra a conversão de <xref:System.Numerics.BigInteger> para <xref:System.Double> valores.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#3)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#3)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator short (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname int16 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Int16" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator short(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; int16" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">O valor a ser convertido em um inteiro com sinal de 16 bits.</param>
        <summary>Define uma conversão explícita de um objeto <see cref="T:System.Numerics.BigInteger" /> em um valor inteiro com sinal de 16 bits.</summary>
        <returns>Um objeto que contém o valor do parâmetro <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 As sobrecargas do <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> método para definir os tipos para o qual ou do qual um <xref:System.Numerics.BigInteger> objeto pode ser convertido. Compiladores de linguagem não realizar essa conversão automaticamente porque ele pode envolver a perda de dados. Em vez disso, eles realizam a conversão somente se um operador de conversão (em c#) ou uma função de conversão (como `CType` ou `CShort` no Visual Basic) é usado. Caso contrário, eles exibem um erro do compilador.   

 Como essa operação define uma conversão de redução, ela pode lançar uma <xref:System.OverflowException> no tempo de execução se o <xref:System.Numerics.BigInteger> valor está fora do intervalo da <xref:System.Int16> tipo de dados. Não há nenhuma perda de precisão na resultante <xref:System.Int16> valor se a conversão for bem-sucedida.

## Examples
 O exemplo a seguir ilustra a conversão de <xref:System.Numerics.BigInteger> para <xref:System.Int16> valores. Ele também lida com um <xref:System.OverflowException> que é gerada porque o <xref:System.Numerics.BigInteger> valor está fora do intervalo da <xref:System.Int16> tipo de dados.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#4)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#4)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><paramref name="value" /> é menor que <see cref="F:System.Int16.MinValue" /> ou maior que <see cref="F:System.Int16.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator int (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname int32 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Int32" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator int(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; int" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">O valor a ser convertido em um inteiro com sinal de 32 bits.</param>
        <summary>Define uma conversão explícita de um objeto <see cref="T:System.Numerics.BigInteger" /> para um valor inteiro com sinal de 32 bits.</summary>
        <returns>Um objeto que contém o valor do parâmetro <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 As sobrecargas do <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> método para definir os tipos para o qual ou do qual um <xref:System.Numerics.BigInteger> objeto pode ser convertido. Compiladores de linguagem não realizar essa conversão automaticamente porque ele pode envolver a perda de dados. Em vez disso, eles realizam a conversão somente se um operador de conversão (em c#) ou uma função de conversão (como `CType` ou `CInt` no Visual Basic) é usado. Caso contrário, eles exibem um erro do compilador.   

 Como essa operação define uma conversão de redução, ela pode lançar uma <xref:System.OverflowException> no tempo de execução se o <xref:System.Numerics.BigInteger> valor está fora do intervalo da <xref:System.Int32> tipo de dados. Não há nenhuma perda de precisão na resultante <xref:System.Int16> valor se a conversão for bem-sucedida.

## Examples
 O exemplo a seguir ilustra a conversão de <xref:System.Numerics.BigInteger> para <xref:System.Int32> valores. Ele também lida com um <xref:System.OverflowException> que é gerada porque o <xref:System.Numerics.BigInteger> valor está fora do intervalo da <xref:System.Int32> tipo de dados.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#5)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#5)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><paramref name="value" /> é menor que <see cref="F:System.Int32.MinValue" /> ou maior que <see cref="F:System.Int32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator long (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname int64 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Int64" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator long(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; int64" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">O valor a ser convertido em um inteiro com sinal de 64 bits.</param>
        <summary>Define uma conversão explícita de um objeto <see cref="T:System.Numerics.BigInteger" /> para um valor inteiro com sinal de 64 bits.</summary>
        <returns>Um objeto que contém o valor do parâmetro <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 As sobrecargas do <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> método para definir os tipos para o qual ou do qual um <xref:System.Numerics.BigInteger> objeto pode ser convertido. Compiladores de linguagem não realizar essa conversão automaticamente porque ele pode envolver a perda de dados. Em vez disso, eles realizam a conversão somente se um operador de conversão (em c#) ou uma função de conversão (como `CType` ou `CLng` no Visual Basic) é usado. Caso contrário, eles exibem um erro do compilador.  

 Como essa operação define uma conversão de redução, ela pode lançar uma <xref:System.OverflowException> no tempo de execução se o <xref:System.Numerics.BigInteger> valor está fora do intervalo da <xref:System.Int64> tipo de dados. 

## Examples
 O exemplo a seguir ilustra a conversão de <xref:System.Numerics.BigInteger> para <xref:System.Int64> valores. Ele também lida com um <xref:System.OverflowException> que é gerada porque o <xref:System.Numerics.BigInteger> valor está fora do intervalo da <xref:System.Int64> tipo de dados.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#6)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#6)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><paramref name="value" /> é menor que <see cref="F:System.Int64.MinValue" /> ou maior que <see cref="F:System.Int64.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator sbyte (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname int8 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.SByte" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As SByte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::SByte(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; sbyte" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">O valor a ser convertido em um valor de 8 bits com sinal.</param>
        <summary>Define uma conversão explícita de um objeto <see cref="T:System.Numerics.BigInteger" /> em um valor de 8 bits com sinal.  
  
Esta API não compatível com CLS. A alternativa em conformidade é <see cref="T:System.Int16" />.</summary>
        <returns>Um objeto que contém o valor do parâmetro <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 As sobrecargas do <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> método para definir os tipos para o qual ou do qual um <xref:System.Numerics.BigInteger> objeto pode ser convertido. Compiladores de linguagem não realizar essa conversão automaticamente porque ele pode envolver a perda de dados. Em vez disso, eles realizam a conversão somente se um operador de conversão (em c#) ou uma função de conversão (como `CType` ou `CSByte` no Visual Basic) é usado. Caso contrário, eles exibem um erro do compilador.  

 Como essa operação define uma conversão de redução, ela pode lançar uma <xref:System.OverflowException> no tempo de execução se o <xref:System.Numerics.BigInteger> valor está fora do intervalo da <xref:System.SByte> tipo de dados. Não há nenhuma perda de precisão na resultante <xref:System.SByte> valor se a conversão for bem-sucedida.

## Examples
 O exemplo a seguir ilustra a conversão de <xref:System.Numerics.BigInteger> para <xref:System.SByte> valores. Ele também lida com um <xref:System.OverflowException> que é gerada porque o <xref:System.Numerics.BigInteger> valor está fora do intervalo da <xref:System.SByte> tipo de dados.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#7)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#7)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><paramref name="value" /> é menor que <see cref="F:System.SByte.MinValue" /> ou maior que <see cref="F:System.SByte.MaxValue" />.</exception>
        <altCompliant cref="T:System.Int16" />
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator float (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname float32 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Single" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator float(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; single" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">O valor a ser convertido em um ponto flutuante de precisão simples.</param>
        <summary>Define uma conversão explícita de um objeto <see cref="T:System.Numerics.BigInteger" /> em um valor de ponto flutuante de precisão simples.</summary>
        <returns>Um objeto que contém a representação mais próxima possível do parâmetro <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 As sobrecargas do <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> método para definir os tipos para o qual ou do qual um <xref:System.Numerics.BigInteger> objeto pode ser convertido. Compiladores de linguagem não realizar essa conversão automaticamente porque ele pode envolver a perda de dados ou uma perda de precisão. Em vez disso, eles realizam a conversão somente se um operador de conversão (em c#) ou uma função de conversão (como `CType` ou `CSng` no Visual Basic) é usado. Caso contrário, eles exibem um erro do compilador.    

 Porque o <xref:System.Numerics.BigInteger> valor pode ser fora do intervalo da <xref:System.Single> de tipo de dados, essa operação é uma conversão de estreitamento. Se a conversão for bem-sucedida, ela não gera um <xref:System.OverflowException>. Em vez disso, se o <xref:System.Numerics.BigInteger> valor é menor que <xref:System.Single.MinValue?displayProperty=nameWithType>, resultante <xref:System.Single> valor é <xref:System.Single.NegativeInfinity?displayProperty=nameWithType>. Se o <xref:System.Numerics.BigInteger> valor é maior que <xref:System.Single.MaxValue?displayProperty=nameWithType>, resultante <xref:System.Single> valor é <xref:System.Single.PositiveInfinity?displayProperty=nameWithType>.

 A conversão de um <xref:System.Numerics.BigInteger> para um <xref:System.Single> pode envolver uma perda de precisão. Em alguns casos, a perda de precisão pode causar a operação de conversão seja bem-sucedida, mesmo se o <xref:System.Numerics.BigInteger> valor está fora do intervalo da <xref:System.Single> tipo de dados. O exemplo a seguir fornece uma ilustração. Ele atribui o valor máximo de um <xref:System.Single> para dois <xref:System.Numerics.BigInteger> variáveis, incrementa um <xref:System.Numerics.BigInteger> variável 9.999e291 e as duas variáveis testa a igualdade. Conforme o esperado, a chamada para o <xref:System.Numerics.BigInteger.Equals%28System.Numerics.BigInteger%29?displayProperty=nameWithType> método mostra que elas são diferentes. No entanto, a conversão do maior <xref:System.Numerics.BigInteger> valor de volta para um <xref:System.Single> for bem-sucedida, embora o <xref:System.Numerics.BigInteger> excede o valor agora <xref:System.Single.MaxValue?displayProperty=nameWithType>.   
    
 [!code-csharp[System.Numerics.BigInteger.Explicit#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/cs/Explicit1.cs#5)]   
 [!code-vb[System.Numerics.BigInteger.Explicit#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/vb/Explicit1.vb#5)]   



## Examples
 O exemplo a seguir ilustra a conversão de <xref:System.Numerics.BigInteger> para <xref:System.Single> valores.   
     
 [!code-csharp[System.Numeric.BigInteger.Explicit#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#8)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#8)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator ushort (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname unsigned int16 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.UInt16" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As UShort" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::UInt16(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; uint16" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">O valor a ser convertido em um inteiro sem sinal de 16 bits.</param>
        <summary>Define uma conversão explícita de um objeto <see cref="T:System.Numerics.BigInteger" /> em um valor inteiro sem sinal de 16 bits.  
  
Esta API não compatível com CLS. A alternativa em conformidade é <see cref="T:System.Int32" />.</summary>
        <returns>Um objeto que contém o valor do parâmetro <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 As sobrecargas do <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> método para definir os tipos para o qual ou do qual um <xref:System.Numerics.BigInteger> objeto pode ser convertido. Compiladores de linguagem não realizar essa conversão automaticamente porque ele pode envolver a perda de dados. Em vez disso, eles realizam a conversão somente se um operador de conversão (em c#) ou uma função de conversão (como `CType` ou `CUShort` no Visual Basic) é usado. Caso contrário, eles exibem um erro do compilador.    

 Como essa operação define uma conversão de redução, ela pode lançar uma <xref:System.OverflowException> no tempo de execução se o <xref:System.Numerics.BigInteger> valor está fora do intervalo da <xref:System.UInt16> tipo de dados. Não há nenhuma perda de precisão na resultante <xref:System.UInt16> valor se a conversão for bem-sucedida.

## Examples
 O exemplo a seguir ilustra a conversão de <xref:System.Numerics.BigInteger> para <xref:System.UInt16> valores. Ele também lida com um <xref:System.OverflowException> que é gerada porque o <xref:System.Numerics.BigInteger> valor está fora do intervalo da <xref:System.UInt16> tipo de dados.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#9)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#9)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><paramref name="value" /> é menor que <see cref="F:System.UInt16.MinValue" /> ou maior que <see cref="F:System.UInt16.MaxValue" />.</exception>
        <altCompliant cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator uint (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname unsigned int32 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.UInt32" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As UInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::UInt32(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; uint32" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">O valor a ser convertido em um inteiro sem sinal de 32 bits.</param>
        <summary>Define uma conversão explícita de um objeto <see cref="T:System.Numerics.BigInteger" /> em um valor inteiro sem sinal de 32 bits.  
  
Esta API não compatível com CLS. A alternativa em conformidade é <see cref="T:System.Int64" />.</summary>
        <returns>Um objeto que contém o valor do parâmetro <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 As sobrecargas do <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> método para definir os tipos para o qual ou do qual um <xref:System.Numerics.BigInteger> objeto pode ser convertido. Compiladores de linguagem não realizar essa conversão automaticamente porque ele pode envolver a perda de dados. Em vez disso, eles realizam a conversão somente se um operador de conversão (em c#) ou uma função de conversão (como `CType` ou `CUInt` no Visual Basic) é usado. Caso contrário, eles exibem um erro do compilador.    

 Como essa operação define uma conversão de redução, ela pode lançar uma <xref:System.OverflowException> no tempo de execução se o <xref:System.Numerics.BigInteger> valor está fora do intervalo da <xref:System.UInt32> tipo de dados. Não há nenhuma perda de precisão na resultante <xref:System.UInt32> valor se a conversão for bem-sucedida.

## Examples
 O exemplo a seguir ilustra a conversão de <xref:System.Numerics.BigInteger> para <xref:System.UInt32> valores. Ele também lida com um <xref:System.OverflowException> que é gerada porque o <xref:System.Numerics.BigInteger> valor está fora do intervalo da <xref:System.UInt32> tipo de dados.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#10)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#10)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><paramref name="value" /> é menor que <see cref="F:System.UInt32.MinValue" /> ou maior que <see cref="F:System.UInt32.MaxValue" />.</exception>
        <altCompliant cref="T:System.Int64" />
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator ulong (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname unsigned int64 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.UInt64" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As ULong" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::UInt64(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; uint64" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">O valor a ser convertido em um inteiro sem sinal de 64 bits.</param>
        <summary>Define uma conversão explícita de um objeto <see cref="T:System.Numerics.BigInteger" /> em um valor inteiro sem sinal de 64 bits.  
  
Esta API não compatível com CLS. A alternativa em conformidade é <see cref="T:System.Double" />.</summary>
        <returns>Um objeto que contém o valor do parâmetro <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 As sobrecargas do <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> método para definir os tipos para o qual ou do qual um <xref:System.Numerics.BigInteger> objeto pode ser convertido. Compiladores de linguagem não realizar essa conversão automaticamente porque ele pode envolver a perda de dados. Em vez disso, eles realizam a conversão somente se um operador de conversão (em c#) ou uma função de conversão (como `CType` ou `CULng` no Visual Basic) é usado. Caso contrário, eles exibem um erro do compilador.    

 Como essa operação define uma conversão de redução, ela pode lançar uma <xref:System.OverflowException> no tempo de execução se o <xref:System.Numerics.BigInteger> valor está fora do intervalo da <xref:System.UInt64> tipo de dados. Não há nenhuma perda de precisão na resultante <xref:System.UInt64> valor se a conversão for bem-sucedida.

## Examples
 O exemplo a seguir ilustra a conversão de <xref:System.Numerics.BigInteger> para <xref:System.UInt64> valores. Ele também lida com um <xref:System.OverflowException> que é gerada porque o <xref:System.Numerics.BigInteger> valor está fora do intervalo da <xref:System.UInt64> tipo de dados.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#11)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#11)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><paramref name="value" /> é menor que <see cref="F:System.UInt64.MinValue" /> ou maior que <see cref="F:System.UInt64.MaxValue" />.</exception>
        <altCompliant cref="T:System.Double" />
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Numerics.BigInteger (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Explicit(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Single)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Single) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Numerics::BigInteger(float value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : single -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">O valor a ser convertido para um <see cref="T:System.Numerics.BigInteger" />.</param>
        <summary>Define uma conversão explícita de um valor <see cref="T:System.Single" /> para um valor <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>Um objeto que contém o valor do parâmetro <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Qualquer parte fracionária de `value` parâmetro é truncado antes da conversão.
 
 As sobrecargas do <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> método para definir os tipos para o qual ou do qual um <xref:System.Numerics.BigInteger> objeto pode ser convertido. Porque a conversão de <xref:System.Single> à <xref:System.Numerics.BigInteger> pode envolver truncando qualquer parte fracionária `value`, compiladores de linguagem não realizar essa conversão automaticamente. Em vez disso, eles realizam a conversão somente se um operador de conversão (em c#) ou uma função de conversão (como `CType` no Visual Basic) é usado. Caso contrário, eles exibem um erro do compilador.

 Para idiomas que não dão suporte a operadores personalizados, o método alternativo é <xref:System.Numerics.BigInteger.%23ctor%28System.Single%29?displayProperty=nameWithType>.


## Examples
 O exemplo a seguir converte os elementos individuais em uma matriz de <xref:System.Single> valores <xref:System.Numerics.BigInteger> objetos e, em seguida, exibe o resultado de cada conversão. Observe que quaisquer fracionários faz parte de um <xref:System.Single> valor é truncado durante a conversão.
 
 [!code-csharp[System.Numerics.BigInteger.Explicit#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/cs/Explicit1.cs#3)]   
 [!code-vb[System.Numerics.BigInteger.Explicit#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/vb/Explicit1.vb#3)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><paramref name="value" /> é <see cref="F:System.Single.NaN" />, <see cref="F:System.Single.PositiveInfinity" /> ou <see cref="F:System.Single.NegativeInfinity" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="op_GreaterThan">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retorna um valor que indica se um valor especificado é maior que outro valor especificado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (long left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThan(System.Int64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt; (left As Long, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;(long left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &gt; ) : int64 * System.Numerics.BigInteger -&gt; bool" Usage="left &gt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">O primeiro valor a ser comparado.</param>
        <param name="right">O segundo valor a ser comparado.</param>
        <summary>Retorna um valor que indica se um inteiro com sinal de 64 bits é maior que um valor <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns><see langword="true" /> caso <paramref name="left" /> seja maior que <paramref name="right" />; do contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Numerics.BigInteger.op_GreaterThan%2A> método define a operação de maior que o operador para <xref:System.Numerics.BigInteger> valores. Ele permite que o código seja o seguinte:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#9)]
 [!code-vb[System.Numerics.BigInteger.Operators#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#9)]  
  
 Linguagens que não dão suporte a operadores personalizados podem chamar o <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> em vez disso, o método de instância. Algumas linguagens também podem chamar o <xref:System.Numerics.BigInteger.op_GreaterThan%28System.Int64%2CSystem.Numerics.BigInteger%29> método diretamente, como o exemplo a seguir mostra.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#10)]  
  
 Se `left` é um <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, ou <xref:System.UInt32> valor, ele é convertido implicitamente em um <xref:System.Int64> valor quando a operação é executada.  
  
 O método equivalente para esse operador é <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThanOrEqual" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (System.Numerics.BigInteger left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(valuetype System.Numerics.BigInteger left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThan(System.Numerics.BigInteger,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt; (left As BigInteger, right As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;(System::Numerics::BigInteger left, long right);" />
      <MemberSignature Language="F#" Value="static member ( &gt; ) : System.Numerics.BigInteger * int64 -&gt; bool" Usage="left &gt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="left">O primeiro valor a ser comparado.</param>
        <param name="right">O segundo valor a ser comparado.</param>
        <summary>Retorna um valor que indica se um <see cref="T:System.Numerics.BigInteger" /> é maior que um valor inteiro com sinal de 64 bits.</summary>
        <returns><see langword="true" /> caso <paramref name="left" /> seja maior que <paramref name="right" />; do contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Numerics.BigInteger.op_GreaterThan%2A> método define a operação de maior que o operador para <xref:System.Numerics.BigInteger> valores. Ele permite que o código seja o seguinte:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#11)]
 [!code-vb[System.Numerics.BigInteger.Operators#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#11)]  
  
 Linguagens que não dão suporte a operadores personalizados podem chamar o método <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> em vez disso. Algumas linguagens também podem chamar o <xref:System.Numerics.BigInteger.op_GreaterThan%28System.Numerics.BigInteger%2CSystem.Int64%29> método diretamente, como o exemplo a seguir mostra.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#12)]  
  
 Se `right` é um <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, ou <xref:System.UInt32> valor, ele é convertido implicitamente em um <xref:System.Int64> valor quando a operação é executada.  
  
 O método equivalente para esse operador é <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThanOrEqual" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThan(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt; (left As BigInteger, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &gt; ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; bool" Usage="left &gt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">O primeiro valor a ser comparado.</param>
        <param name="right">O segundo valor a ser comparado.</param>
        <summary>Retorna um valor que indica se um valor <see cref="T:System.Numerics.BigInteger" /> é maior que outro valor <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns><see langword="true" /> caso <paramref name="left" /> seja maior que <paramref name="right" />; do contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Numerics.BigInteger.op_GreaterThan%2A> método define a operação de maior que o operador para <xref:System.Numerics.BigInteger> valores. Ele permite que o código seja o seguinte:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#20)]
 [!code-vb[System.Numeric.BigInteger.Class#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#20)]  
  
 Linguagens que não dão suporte a operadores personalizados podem chamar o método <xref:System.Numerics.BigInteger.Compare%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType> em vez disso. Eles também podem chamar o <xref:System.Numerics.BigInteger.op_GreaterThan%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29> método diretamente, como o exemplo a seguir mostra.  
  
 [!code-vb[System.Numeric.BigInteger.Class#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#21)]  
  
 O método equivalente para esse operador é <xref:System.Numerics.BigInteger.CompareTo(System.Numerics.BigInteger)?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThanOrEqual" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (System.Numerics.BigInteger left, ulong right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(valuetype System.Numerics.BigInteger left, unsigned int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThan(System.Numerics.BigInteger,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt; (left As BigInteger, right As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;(System::Numerics::BigInteger left, System::UInt64 right);" />
      <MemberSignature Language="F#" Value="static member ( &gt; ) : System.Numerics.BigInteger * uint64 -&gt; bool" Usage="left &gt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="left">O primeiro valor a ser comparado.</param>
        <param name="right">O segundo valor a ser comparado.</param>
        <summary>Retorna um valor que indica se um valor <see cref="T:System.Numerics.BigInteger" /> é maior que um inteiro sem sinal de 64 bits.</summary>
        <returns><see langword="true" /> caso <paramref name="left" /> seja maior que <paramref name="right" />; do contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Numerics.BigInteger.op_GreaterThan%2A> método define a operação de maior que o operador para <xref:System.Numerics.BigInteger> valores. Ele permite que o código seja o seguinte:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#13)]
 [!code-vb[System.Numerics.BigInteger.Operators#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#13)]  
  
 Linguagens que não dão suporte a operadores personalizados podem chamar o método <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> em vez disso. Algumas linguagens também podem chamar o <xref:System.Numerics.BigInteger.op_GreaterThan%28System.Numerics.BigInteger%2CSystem.UInt64%29> método diretamente, como o exemplo a seguir mostra.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#14)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (ulong left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(unsigned int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThan(System.UInt64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt; (left As ULong, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;(System::UInt64 left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &gt; ) : uint64 * System.Numerics.BigInteger -&gt; bool" Usage="left &gt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">O primeiro valor a ser comparado.</param>
        <param name="right">O segundo valor a ser comparado.</param>
        <summary>Retorna um valor que indica se um valor <see cref="T:System.Numerics.BigInteger" /> é maior que um inteiro sem sinal de 64 bits.</summary>
        <returns><see langword="true" /> caso <paramref name="left" /> seja maior que <paramref name="right" />; do contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Numerics.BigInteger.op_GreaterThan%2A> método define a operação de maior que o operador para <xref:System.Numerics.BigInteger> valores. Ele permite que o código seja o seguinte:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#15)]
 [!code-vb[System.Numerics.BigInteger.Operators#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#15)]  
  
 Linguagens que não dão suporte a operadores personalizados podem chamar o método <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> em vez disso. Algumas linguagens também podem chamar o <xref:System.Numerics.BigInteger.op_GreaterThan%28System.UInt64%2CSystem.Numerics.BigInteger%29> método diretamente, como o exemplo a seguir mostra.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#16)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThanOrEqual" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_GreaterThanOrEqual">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retorna um valor que indica se um valor especificado é maior ou igual a outro valor especificado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (long left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.Int64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;= (left As Long, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;=(long left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &gt;= ) : int64 * System.Numerics.BigInteger -&gt; bool" Usage="left &gt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">O primeiro valor a ser comparado.</param>
        <param name="right">O segundo valor a ser comparado.</param>
        <summary>Retorna um valor que indica se um inteiro com sinal de 64 bits é maior ou igual a um valor <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns><see langword="true" /> caso <paramref name="left" /> seja maior que <paramref name="right" />; do contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%2A> método define a operação de maior que ou igual ao operador para <xref:System.Numerics.BigInteger> valores. Ele permite que o código seja o seguinte:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#17)]
 [!code-vb[System.Numerics.BigInteger.Operators#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#17)]  
  
 Linguagens que não dão suporte a operadores personalizados podem chamar o método <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> em vez disso. Algumas linguagens também podem chamar o <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%28System.Int64%2CSystem.Numerics.BigInteger%29> método diretamente, como o exemplo a seguir mostra.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#18)]  
  
 Se `left` é um <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, ou <xref:System.UInt32> valor, ele é convertido implicitamente em um <xref:System.Int64> valor quando a operação é executada.  
  
 O método equivalente para esse operador é <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThan" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (System.Numerics.BigInteger left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(valuetype System.Numerics.BigInteger left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.Numerics.BigInteger,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;= (left As BigInteger, right As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;=(System::Numerics::BigInteger left, long right);" />
      <MemberSignature Language="F#" Value="static member ( &gt;= ) : System.Numerics.BigInteger * int64 -&gt; bool" Usage="left &gt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="left">O primeiro valor a ser comparado.</param>
        <param name="right">O segundo valor a ser comparado.</param>
        <summary>Retorna um valor que indica se um valor de <see cref="T:System.Numerics.BigInteger" /> é maior ou igual a um valor inteiro com sinal de 64 bits.</summary>
        <returns><see langword="true" /> caso <paramref name="left" /> seja maior que <paramref name="right" />; do contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%2A> método define a operação de maior que ou igual ao operador para <xref:System.Numerics.BigInteger> valores. Ele permite que o código seja o seguinte:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#19)]
 [!code-vb[System.Numerics.BigInteger.Operators#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#19)]  
  
 Linguagens que não dão suporte a operadores personalizados podem chamar o método <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> em vez disso. Algumas linguagens também podem chamar o <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%28System.Numerics.BigInteger%2CSystem.Int64%29> método diretamente, como o exemplo a seguir mostra.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#20)]  
  
 Se `right` é um <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, ou <xref:System.UInt32> valor, ele é convertido implicitamente em um <xref:System.Int64> valor quando a operação é executada.  
  
 O método equivalente para esse operador é <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThan" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;= (left As BigInteger, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;=(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &gt;= ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; bool" Usage="left &gt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">O primeiro valor a ser comparado.</param>
        <param name="right">O segundo valor a ser comparado.</param>
        <summary>Retorna um valor que indica se um valor <see cref="T:System.Numerics.BigInteger" /> é maior ou igual a outro valor <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns><see langword="true" /> caso <paramref name="left" /> seja maior que <paramref name="right" />; do contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%2A> método define a operação de maior que ou igual ao operador para <xref:System.Numerics.BigInteger> valores. Ele permite que o código seja o seguinte:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#22)]
 [!code-vb[System.Numeric.BigInteger.Class#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#22)]  
  
 Linguagens que não dão suporte a operadores personalizados podem chamar o método <xref:System.Numerics.BigInteger.Compare%2A?displayProperty=nameWithType> em vez disso. Algumas linguagens também podem chamar o <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29> método diretamente, como o exemplo a seguir mostra.  
  
 [!code-vb[System.Numeric.BigInteger.Class#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#23)]  
  
 O método equivalente para esse operador é <xref:System.Numerics.BigInteger.CompareTo(System.Numerics.BigInteger)?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThan" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (System.Numerics.BigInteger left, ulong right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(valuetype System.Numerics.BigInteger left, unsigned int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.Numerics.BigInteger,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;= (left As BigInteger, right As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;=(System::Numerics::BigInteger left, System::UInt64 right);" />
      <MemberSignature Language="F#" Value="static member ( &gt;= ) : System.Numerics.BigInteger * uint64 -&gt; bool" Usage="left &gt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="left">O primeiro valor a ser comparado.</param>
        <param name="right">O segundo valor a ser comparado.</param>
        <summary>Retorna um valor que indica se um valor <see cref="T:System.Numerics.BigInteger" /> é maior ou igual a um valor inteiro sem sinal de 64 bits.</summary>
        <returns><see langword="true" /> caso <paramref name="left" /> seja maior que <paramref name="right" />; do contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%2A> método define a operação de maior que ou igual ao operador para <xref:System.Numerics.BigInteger> valores. Ele permite que o código seja o seguinte:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#21)]
 [!code-vb[System.Numerics.BigInteger.Operators#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#21)]  
  
 Linguagens que não dão suporte a operadores personalizados podem chamar o método <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> em vez disso. Algumas linguagens também podem chamar o <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%28System.Numerics.BigInteger%2CSystem.UInt64%29> método diretamente, como o exemplo a seguir mostra.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#22)]  
  
 O método equivalente para esse operador é <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThan" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (ulong left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(unsigned int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.UInt64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;= (left As ULong, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;=(System::UInt64 left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &gt;= ) : uint64 * System.Numerics.BigInteger -&gt; bool" Usage="left &gt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">O primeiro valor a ser comparado.</param>
        <param name="right">O segundo valor a ser comparado.</param>
        <summary>Retorna um valor que indica se um inteiro sem sinal de 64 bits é maior ou igual a um valor <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns><see langword="true" /> caso <paramref name="left" /> seja maior que <paramref name="right" />; do contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%2A> método define a operação de maior que ou igual ao operador para <xref:System.Numerics.BigInteger> valores. Ele permite que o código seja o seguinte:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#23)]
 [!code-vb[System.Numerics.BigInteger.Operators#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#23)]  
  
 Linguagens que não dão suporte a operadores personalizados podem chamar o método <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> em vez disso. Algumas linguagens também podem chamar o <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%28System.UInt64%2CSystem.Numerics.BigInteger%29> método diretamente, como o exemplo a seguir mostra.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#24)]  
  
 O método equivalente para esse operador é <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThan" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Implicit">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Define uma conversão implícita entre um objeto <see cref="T:System.Numerics.BigInteger" /> e outro tipo.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Byte) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(System::Byte value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : byte -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">O valor a ser convertido para um <see cref="T:System.Numerics.BigInteger" />.</param>
        <summary>Define uma conversão implícita de um byte sem sinal em um valor <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>Um objeto que contém o valor do parâmetro <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Qualquer parte fracionária de `value` parâmetro é truncado antes da conversão.

 Para idiomas que não dão suporte a operadores implícitos, o método alternativo é <xref:System.Numerics.BigInteger.%23ctor%28System.Int32%29?displayProperty=nameWithType>.   

 As sobrecargas do <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> método para definir os tipos de qual ou para que um compilador pode converter automaticamente um <xref:System.Numerics.BigInteger> valor sem um operador de conversão explícita (em c#) ou uma chamada para uma função de conversão (no Visual Basic). Elas são conversões de ampliação que não envolvem perda de dados e não geram um <xref:System.OverflowException>. Essa sobrecarga permite que o compilador trate as conversões de um <xref:System.Byte> de valor para um <xref:System.Numerics.BigInteger> valor, como mostra o exemplo a seguir.   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#1)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#1)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.Int16)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Short) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(short value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : int16 -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="value">O valor a ser convertido para um <see cref="T:System.Numerics.BigInteger" />.</param>
        <summary>Define uma conversão implícita de um inteiro com sinal de 16 bits em um valor <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>Um objeto que contém o valor do parâmetro <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para idiomas que não dão suporte a operadores implícitos, o método alternativo é <xref:System.Numerics.BigInteger.%23ctor%28System.Int32%29?displayProperty=nameWithType>.   

 As sobrecargas do <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> método para definir os tipos de qual ou para que um compilador pode converter automaticamente um <xref:System.Numerics.BigInteger> valor sem um operador de conversão explícita (em c#) ou uma chamada para uma função de conversão (no Visual Basic). Elas são conversões de ampliação que não envolvem perda de dados e não geram um <xref:System.OverflowException>. Essa sobrecarga permite que o compilador trate as conversões de um <xref:System.Int16> de valor para um <xref:System.Numerics.BigInteger> valor, como mostra o exemplo a seguir.   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#2)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#2)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.Int32)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Integer) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(int value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : int -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">O valor a ser convertido para um <see cref="T:System.Numerics.BigInteger" />.</param>
        <summary>Define uma conversão implícita de um inteiro com sinal de 32 bits em um valor <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>Um objeto que contém o valor do parâmetro <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para idiomas que não dão suporte a operadores implícitos, o método alternativo é <xref:System.Numerics.BigInteger.%23ctor%28System.Int32%29?displayProperty=nameWithType>.  

 As sobrecargas do <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> método para definir os tipos de qual ou para que um compilador pode converter automaticamente um <xref:System.Numerics.BigInteger> valor sem um operador de conversão explícita (em c#) ou uma chamada para uma função de conversão (no Visual Basic). Elas são conversões de ampliação que não envolvem perda de dados e não geram um <xref:System.OverflowException>. Essa sobrecarga permite que o compilador trate as conversões de um <xref:System.Int32> de valor para um <xref:System.Numerics.BigInteger> valor, como mostra o exemplo a seguir.   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#3)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#3)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.Int64)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Long) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(long value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : int64 -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">O valor a ser convertido para um <see cref="T:System.Numerics.BigInteger" />.</param>
        <summary>Define uma conversão implícita de um inteiro com sinal de 64 bits em um valor <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>Um objeto que contém o valor do parâmetro <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para idiomas que não dão suporte a operadores implícitos, o método alternativo é <xref:System.Numerics.BigInteger.%23ctor%28System.Int64%29?displayProperty=nameWithType>.   
 
 As sobrecargas do <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> método para definir os tipos de qual ou para que um compilador pode converter automaticamente um <xref:System.Numerics.BigInteger> valor sem um operador de conversão explícita (em c#) ou uma chamada para uma função de conversão (no Visual Basic). Elas são conversões de ampliação que não envolvem perda de dados e não geram um <xref:System.OverflowException>. Essa sobrecarga permite que o compilador trate as conversões de um <xref:System.Int64> de valor para um <xref:System.Numerics.BigInteger> valor, como mostra o exemplo a seguir.   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#4)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#4)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.SByte)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As SByte) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(System::SByte value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : sbyte -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="value">O valor a ser convertido para um <see cref="T:System.Numerics.BigInteger" />.</param>
        <summary>Define uma conversão implícita de um inteiro com sinal de 8 bits em um valor <see cref="T:System.Numerics.BigInteger" />.  
  
Esta API não compatível com CLS. A alternativa em conformidade é <see cref="M:System.Numerics.BigInteger.#ctor(System.Int32)" />.</summary>
        <returns>Um objeto que contém o valor do parâmetro <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para idiomas que não dão suporte a operadores implícitos, o método alternativo é <xref:System.Numerics.BigInteger.%23ctor%28System.Int32%29?displayProperty=nameWithType>.   

 As sobrecargas do <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> método para definir os tipos de qual ou para que um compilador pode converter automaticamente um <xref:System.Numerics.BigInteger> valor sem um operador de conversão explícita (em c#) ou uma chamada para uma função de conversão (no Visual Basic). Elas são conversões de ampliação que não envolvem perda de dados e não geram um <xref:System.OverflowException>. Essa sobrecarga permite que o compilador trate as conversões de um <xref:System.SByte> de valor para um <xref:System.Numerics.BigInteger> valor, como mostra o exemplo a seguir.   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#5)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#5)]   

 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Numerics.BigInteger.#ctor(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.UInt16)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As UShort) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(System::UInt16 value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : uint16 -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="value">O valor a ser convertido para um <see cref="T:System.Numerics.BigInteger" />.</param>
        <summary>Define uma conversão implícita de um inteiro sem sinal de 16 bits em um valor <see cref="T:System.Numerics.BigInteger" />.  
  
Esta API não compatível com CLS. A alternativa em conformidade é <see cref="M:System.Numerics.BigInteger.op_Implicit(System.Int32)~System.Numerics.BigInteger" />.</summary>
        <returns>Um objeto que contém o valor do parâmetro <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para idiomas que não dão suporte a operadores implícitos, o método alternativo é <xref:System.Numerics.BigInteger.%23ctor%28System.UInt32%29?displayProperty=nameWithType>.   

 As sobrecargas do <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> método para definir os tipos de qual ou para que um compilador pode converter automaticamente um <xref:System.Numerics.BigInteger> valor sem um operador de conversão explícita (em c#) ou uma chamada para uma função de conversão (no Visual Basic). Elas são conversões de ampliação que não envolvem perda de dados e não geram um <xref:System.OverflowException>. Essa sobrecarga permite que o compilador trate as conversões de um <xref:System.UInt16> de valor para um <xref:System.Numerics.BigInteger> valor, como mostra o exemplo a seguir.   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#6)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#6)]   

 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Numerics.BigInteger.op_Implicit(System.Int32)~System.Numerics.BigInteger" />
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.UInt32)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As UInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(System::UInt32 value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : uint32 -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value">O valor a ser convertido para um <see cref="T:System.Numerics.BigInteger" />.</param>
        <summary>Define uma conversão implícita de um inteiro sem sinal de 32 bits em um valor <see cref="T:System.Numerics.BigInteger" />.  
  
Esta API não compatível com CLS. A alternativa em conformidade é <see cref="M:System.Numerics.BigInteger.op_Implicit(System.Int64)~System.Numerics.BigInteger" />.</summary>
        <returns>Um objeto que contém o valor do parâmetro <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para idiomas que não dão suporte a operadores implícitos, o método alternativo é <xref:System.Numerics.BigInteger.%23ctor%28System.UInt32%29?displayProperty=nameWithType>.   

 As sobrecargas do <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> método para definir os tipos de qual ou para que um compilador pode converter automaticamente um <xref:System.Numerics.BigInteger> valor sem um operador de conversão explícita (em c#) ou uma chamada para uma função de conversão (no Visual Basic). Elas são conversões de ampliação que não envolvem perda de dados e não geram um <xref:System.OverflowException>. Essa sobrecarga permite que o compilador trate as conversões de um <xref:System.UInt32> de valor para um <xref:System.Numerics.BigInteger> valor, como mostra o exemplo a seguir.   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#7)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#7)]   

 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Numerics.BigInteger.op_Implicit(System.Int64)~System.Numerics.BigInteger" />
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.UInt64)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As ULong) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(System::UInt64 value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : uint64 -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value">O valor a ser convertido para um <see cref="T:System.Numerics.BigInteger" />.</param>
        <summary>Define uma conversão implícita de um inteiro sem sinal de 64 bits em um valor <see cref="T:System.Numerics.BigInteger" />.  
  
Esta API não compatível com CLS. A alternativa em conformidade é <see cref="T:System.Double" />.</summary>
        <returns>Um objeto que contém o valor do parâmetro <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para idiomas que não dão suporte a operadores implícitos, o método alternativo é <xref:System.Numerics.BigInteger.%23ctor%28System.UInt64%29?displayProperty=nameWithType>.   

 As sobrecargas do <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> método para definir os tipos de qual ou para que um compilador pode converter automaticamente um <xref:System.Numerics.BigInteger> valor sem um operador de conversão explícita (em c#) ou uma chamada para uma função de conversão (no Visual Basic). Elas são conversões de ampliação que não envolvem perda de dados e não geram um <xref:System.OverflowException>. Essa sobrecarga permite que o compilador trate as conversões de um <xref:System.UInt64> de valor para um <xref:System.Numerics.BigInteger> valor, como mostra o exemplo a seguir.   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#8)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#8)]   

 ]]></format>
        </remarks>
        <altCompliant cref="T:System.Double" />
      </Docs>
    </Member>
    <Member MemberName="op_Increment">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator ++ (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Increment(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Increment(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared op_Increment (value As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator ++(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Increment : System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Increment value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">O valor a ser incrementado.</param>
        <summary>Incrementa um valor <see cref="T:System.Numerics.BigInteger" /> em 1.</summary>
        <returns>O valor do parâmetro <paramref name="value" /> incrementado em 1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Numerics.BigInteger.op_Increment%2A> método define a operação de incremento para <xref:System.Numerics.BigInteger> valores. Ele permite que o código seja o seguinte:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#24)]  
  
 Algumas linguagens (como Visual Basic) que não têm um operador de incremento ou não dão suporte a sobrecarga de operador podem chamar o <xref:System.Numerics.BigInteger.op_Increment%2A> método diretamente, como o exemplo a seguir mostra.  
  
 [!code-vb[System.Numeric.BigInteger.Class#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#25)]  
  
 Porque <xref:System.Numerics.BigInteger> objetos são imutáveis, a <xref:System.Numerics.BigInteger.op_Increment%2A> operador cria uma nova <xref:System.Numerics.BigInteger> objeto cujo valor é um mais do que o <xref:System.Numerics.BigInteger> objeto representado pelo `value`. Portanto, chamadas repetidas para <xref:System.Numerics.BigInteger.op_Increment%2A> pode ser cara.  
  
 O método equivalente para esse operador é <xref:System.Numerics.BigInteger.Add%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_Decrement(System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Inequality">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retorna um valor que indica se dois valores numéricos não são iguais.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (long left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Inequality(System.Int64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Long, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(long left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : int64 * System.Numerics.BigInteger -&gt; bool" Usage="System.Numerics.BigInteger.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">O primeiro valor a ser comparado.</param>
        <param name="right">O segundo valor a ser comparado.</param>
        <summary>Retorna um valor que indica se um inteiro com sinal de 64 bits e um valor <see cref="T:System.Numerics.BigInteger" /> não são iguais.</summary>
        <returns><see langword="true" /> se <paramref name="left" /> e <paramref name="right" /> não forem iguais; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Numerics.BigInteger.op_Inequality%2A> método define a operação do operador de desigualdade para <xref:System.Numerics.BigInteger> valores. Ele permite que o código seja o seguinte:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#25)]
 [!code-vb[System.Numerics.BigInteger.Operators#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#25)]  
  
 Idiomas que não dão suporte a operadores personalizados podem testar quanto à desigualdade usando uma das seguintes técnicas:  
  
-   Chamar o <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> instância de método, que indica a relação entre um <xref:System.Numerics.BigInteger> e um valor inteiro longo com sinal.  
  
-   Chamar o <xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType> da instância de método e Revertendo seu valor.  
  
 Se `left` é um <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, ou <xref:System.UInt32> valor, ele é convertido implicitamente em um <xref:System.Int64> valor quando a operação é executada.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Equality" />
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Numerics.BigInteger left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(valuetype System.Numerics.BigInteger left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Inequality(System.Numerics.BigInteger,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As BigInteger, right As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Numerics::BigInteger left, long right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Numerics.BigInteger * int64 -&gt; bool" Usage="System.Numerics.BigInteger.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="left">O primeiro valor a ser comparado.</param>
        <param name="right">O segundo valor a ser comparado.</param>
        <summary>Retorna um valor que indica se um valor <see cref="T:System.Numerics.BigInteger" /> e um inteiro com sinal de 64 bits não são iguais.</summary>
        <returns><see langword="true" /> se <paramref name="left" /> e <paramref name="right" /> não forem iguais; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Numerics.BigInteger.op_Inequality%2A> método define a operação do operador de desigualdade para <xref:System.Numerics.BigInteger> valores. Ele permite que o código seja o seguinte:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#26)]
 [!code-vb[System.Numerics.BigInteger.Operators#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#26)]  
  
 Idiomas que não dão suporte a operadores personalizados podem testar quanto à desigualdade usando uma das seguintes técnicas:  
  
-   Chamar o <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> método, que indica a relação entre um <xref:System.Numerics.BigInteger> e um valor inteiro longo com sinal.  
  
-   Chamar o <xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType> método e Revertendo seu valor.  
  
 Se `right` é um <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, ou <xref:System.UInt32> valor, ele é convertido implicitamente em um <xref:System.Int64> valor quando a operação é executada.  
  
 O método equivalente para esse operador é <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Equality" />
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Inequality(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As BigInteger, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; bool" Usage="System.Numerics.BigInteger.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">O primeiro valor a ser comparado.</param>
        <param name="right">O segundo valor a ser comparado.</param>
        <summary>Retorna um valor que indica se dois objetos <see cref="T:System.Numerics.BigInteger" /> têm valores diferentes.</summary>
        <returns><see langword="true" /> se <paramref name="left" /> e <paramref name="right" /> não forem iguais; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Numerics.BigInteger.op_Inequality%2A> método define a operação do operador de desigualdade para <xref:System.Numerics.BigInteger> valores. Ele permite que o código seja o seguinte:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#26)]
 [!code-vb[System.Numeric.BigInteger.Class#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#26)]  
  
 Idiomas que não dão suporte a operadores personalizados podem testar quanto à desigualdade usando uma das seguintes técnicas:  
  
-   Chamar o <xref:System.Numerics.BigInteger.Compare%2A?displayProperty=nameWithType> método, que indica a relação entre duas <xref:System.Numerics.BigInteger> objetos.  
  
-   Chamar o <xref:System.Numerics.BigInteger.Equals%28System.Numerics.BigInteger%29?displayProperty=nameWithType> método e Revertendo seu valor.  
  
 O método equivalente para esse operador é <xref:System.Numerics.BigInteger.Compare%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Equality" />
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Numerics.BigInteger left, ulong right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(valuetype System.Numerics.BigInteger left, unsigned int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Inequality(System.Numerics.BigInteger,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As BigInteger, right As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Numerics::BigInteger left, System::UInt64 right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Numerics.BigInteger * uint64 -&gt; bool" Usage="System.Numerics.BigInteger.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="left">O primeiro valor a ser comparado.</param>
        <param name="right">O segundo valor a ser comparado.</param>
        <summary>Retorna um valor que indica se um valor <see cref="T:System.Numerics.BigInteger" /> e um inteiro sem sinal de 64 bits não são iguais.</summary>
        <returns><see langword="true" /> se <paramref name="left" /> e <paramref name="right" /> não forem iguais; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Numerics.BigInteger.op_Inequality%2A> método define a operação do operador de desigualdade para <xref:System.Numerics.BigInteger> valores. Ele permite que o código seja o seguinte:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#27](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#27)]
 [!code-vb[System.Numerics.BigInteger.Operators#27](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#27)]  
  
 Idiomas que não dão suporte a operadores personalizados podem testar quanto à desigualdade usando uma das seguintes técnicas:  
  
-   Chamar o <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> método, que indica a relação entre um <xref:System.Numerics.BigInteger> e um valor inteiro longo sem sinal.  
  
-   Chamar o <xref:System.Numerics.BigInteger.Equals%28System.UInt64%29?displayProperty=nameWithType> método e Revertendo seu valor.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Equality" />
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (ulong left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(unsigned int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Inequality(System.UInt64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As ULong, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::UInt64 left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : uint64 * System.Numerics.BigInteger -&gt; bool" Usage="System.Numerics.BigInteger.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">O primeiro valor a ser comparado.</param>
        <param name="right">O segundo valor a ser comparado.</param>
        <summary>Retorna um valor que indica se um inteiro sem sinal de 64 bits e um valor <see cref="T:System.Numerics.BigInteger" /> não são iguais.</summary>
        <returns><see langword="true" /> se <paramref name="left" /> e <paramref name="right" /> não forem iguais; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Numerics.BigInteger.op_Inequality%2A> método define a operação do operador de desigualdade para <xref:System.Numerics.BigInteger> valores. Ele permite que o código seja o seguinte:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#28](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#28)]
 [!code-vb[System.Numerics.BigInteger.Operators#28](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#28)]  
  
 Idiomas que não dão suporte a operadores personalizados podem testar quanto à desigualdade usando uma das seguintes técnicas:  
  
-   Chamar o <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> método, que indica a relação entre um <xref:System.Numerics.BigInteger> e um valor inteiro longo sem sinal.  
  
-   Chamar o <xref:System.Numerics.BigInteger.Equals%28System.UInt64%29?displayProperty=nameWithType> método e Revertendo seu valor.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Equality" />
      </Docs>
    </Member>
    <Member MemberName="op_LeftShift">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator &lt;&lt; (System.Numerics.BigInteger value, int shift);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_LeftShift(valuetype System.Numerics.BigInteger value, int32 shift) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LeftShift(System.Numerics.BigInteger,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;&lt; (value As BigInteger, shift As Integer) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator &lt;&lt;(System::Numerics::BigInteger value, int shift);" />
      <MemberSignature Language="F#" Value="static member ( &lt;&lt;&lt; ) : System.Numerics.BigInteger * int -&gt; System.Numerics.BigInteger" Usage="value &lt;&lt;&lt; shift" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
        <Parameter Name="shift" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">O valor cujos bits devem ser deslocados.</param>
        <param name="shift">O número de bits a deslocar <paramref name="value" /> para a esquerda.</param>
        <summary>Desloca um valor <see cref="T:System.Numerics.BigInteger" /> um número especificado de bits para a esquerda.</summary>
        <returns>Um valor que foi sido deslocado para a esquerda pelo número especificado de bits.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Numerics.BigInteger.op_LeftShift%2A> método define a operação do operador bit a bit de deslocamento à esquerda para <xref:System.Numerics.BigInteger> valores. Ele permite que o código seja o seguinte:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#29](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#29)]
 [!code-vb[System.Numerics.BigInteger.Operators#29](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#29)]  
  
> [!NOTE]
>  Ao contrário a operação bit a bit de deslocamento à esquerda com primitivos de inteiro, o <xref:System.Numerics.BigInteger.op_LeftShift%2A> método preserva o sinal do original <xref:System.Numerics.BigInteger> valor.  
  
 Idiomas que não dão suporte a operadores personalizados podem executar uma operação bit a bit de deslocamento à esquerda multiplicando `value` por `BigInteger.Pow(2, shift)`. O exemplo a seguir mostra que os resultados são idênticos aos resultados do uso desse operador.  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#30](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#30)]
 [!code-vb[System.Numerics.BigInteger.Operators#30](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#30)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_RightShift(System.Numerics.BigInteger,System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_LessThan">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retorna um valor que indica se um valor especificado é menor que um segundo valor especificado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (long left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThan(System.Int64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt; (left As Long, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;(long left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &lt; ) : int64 * System.Numerics.BigInteger -&gt; bool" Usage="left &lt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">O primeiro valor a ser comparado.</param>
        <param name="right">O segundo valor a ser comparado.</param>
        <summary>Retorna um valor que indica se um inteiro com sinal de 64 bits é menor que um valor <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns><see langword="true" /> caso <paramref name="left" /> seja menor que <paramref name="right" />; do contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Numerics.BigInteger.op_LessThan%2A> método define a operação pelo menor que o operador para <xref:System.Numerics.BigInteger> valores. Ele permite que o código seja o seguinte:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#31](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#31)]
 [!code-vb[System.Numerics.BigInteger.Operators#31](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#31)]  
  
 Linguagens que não dão suporte a operadores personalizados podem chamar o método <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> em vez disso. Algumas linguagens também podem chamar o <xref:System.Numerics.BigInteger.op_LessThan%28System.Int64%2CSystem.Numerics.BigInteger%29> método diretamente, como o exemplo a seguir mostra.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#32](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#32)]  
  
 Se `left` é um <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, ou <xref:System.UInt32> valor, ele é convertido implicitamente em um <xref:System.Int64> valor quando a operação é executada.  
  
 O método equivalente para esse operador é <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThanOrEqual" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (System.Numerics.BigInteger left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(valuetype System.Numerics.BigInteger left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThan(System.Numerics.BigInteger,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt; (left As BigInteger, right As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;(System::Numerics::BigInteger left, long right);" />
      <MemberSignature Language="F#" Value="static member ( &lt; ) : System.Numerics.BigInteger * int64 -&gt; bool" Usage="left &lt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="left">O primeiro valor a ser comparado.</param>
        <param name="right">O segundo valor a ser comparado.</param>
        <summary>Retorna um valor que indica se um valor <see cref="T:System.Numerics.BigInteger" /> é menor que um inteiro com sinal de 64 bits.</summary>
        <returns><see langword="true" /> caso <paramref name="left" /> seja menor que <paramref name="right" />; do contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Numerics.BigInteger.op_LessThan%2A> método define a operação pelo menor que o operador para <xref:System.Numerics.BigInteger> valores. Ele permite que o código seja o seguinte:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#33](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#33)]
 [!code-vb[System.Numerics.BigInteger.Operators#33](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#33)]  
  
 Linguagens que não dão suporte a operadores personalizados podem chamar o método <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> em vez disso. Algumas linguagens também podem chamar o <xref:System.Numerics.BigInteger.op_LessThan%28System.Numerics.BigInteger%2CSystem.Int64%29> método diretamente, como o exemplo a seguir mostra.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#34](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#34)]  
  
 Se `right` é um <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, ou <xref:System.UInt32> valor, ele é convertido implicitamente em um <xref:System.Int64> valor quando a operação é executada.  
  
 O método equivalente para esse operador é <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThanOrEqual" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThan(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt; (left As BigInteger, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &lt; ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; bool" Usage="left &lt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">O primeiro valor a ser comparado.</param>
        <param name="right">O segundo valor a ser comparado.</param>
        <summary>Retorna um valor que indica se um valor <see cref="T:System.Numerics.BigInteger" /> é menor que outro valor <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns><see langword="true" /> caso <paramref name="left" /> seja menor que <paramref name="right" />; do contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Numerics.BigInteger.op_LessThan%2A> método define a operação pelo menor que o operador para <xref:System.Numerics.BigInteger> valores. Ele permite que o código seja o seguinte:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#27](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#27)]
 [!code-vb[System.Numeric.BigInteger.Class#27](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#27)]  
  
 Linguagens que não dão suporte a operadores personalizados podem chamar o método <xref:System.Numerics.BigInteger.Compare%2A?displayProperty=nameWithType> em vez disso. Algumas linguagens também podem chamar o <xref:System.Numerics.BigInteger.op_LessThan%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29> método diretamente, como o exemplo a seguir mostra.  
  
 [!code-vb[System.Numeric.BigInteger.Class#28](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#28)]  
  
 O método equivalente para esse operador é <xref:System.Numerics.BigInteger.Compare%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThanOrEqual" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (System.Numerics.BigInteger left, ulong right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(valuetype System.Numerics.BigInteger left, unsigned int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThan(System.Numerics.BigInteger,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt; (left As BigInteger, right As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;(System::Numerics::BigInteger left, System::UInt64 right);" />
      <MemberSignature Language="F#" Value="static member ( &lt; ) : System.Numerics.BigInteger * uint64 -&gt; bool" Usage="left &lt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="left">O primeiro valor a ser comparado.</param>
        <param name="right">O segundo valor a ser comparado.</param>
        <summary>Retorna um valor que indica se um valor <see cref="T:System.Numerics.BigInteger" /> é menor que um inteiro sem sinal de 64 bits.</summary>
        <returns><see langword="true" /> caso <paramref name="left" /> seja menor que <paramref name="right" />; do contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Numerics.BigInteger.op_LessThan%2A> método define a operação pelo menor que o operador para <xref:System.Numerics.BigInteger> valores. Ele permite que o código seja o seguinte:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#35](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#35)]
 [!code-vb[System.Numerics.BigInteger.Operators#35](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#35)]  
  
 Linguagens que não dão suporte a operadores personalizados podem chamar o método <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> em vez disso. Eles também podem chamar o <xref:System.Numerics.BigInteger.op_LessThan%28System.Numerics.BigInteger%2CSystem.UInt64%29> método diretamente, como o exemplo a seguir mostra.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#36](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#36)]  
  
 O método equivalente para esse operador é <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThanOrEqual" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (ulong left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(unsigned int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThan(System.UInt64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt; (left As ULong, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;(System::UInt64 left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &lt; ) : uint64 * System.Numerics.BigInteger -&gt; bool" Usage="left &lt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">O primeiro valor a ser comparado.</param>
        <param name="right">O segundo valor a ser comparado.</param>
        <summary>Retorna um valor que indica se um inteiro sem sinal de 64 bits é menor que um valor <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns><see langword="true" /> caso <paramref name="left" /> seja menor que <paramref name="right" />; do contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Numerics.BigInteger.op_LessThan%2A> método define a operação pelo menor que o operador para <xref:System.Numerics.BigInteger> valores. Ele permite que o código seja o seguinte:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#37](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#37)]
 [!code-vb[System.Numerics.BigInteger.Operators#37](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#37)]  
  
 Linguagens que não dão suporte a operadores personalizados podem chamar o método <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> em vez disso. Eles também podem chamar o <xref:System.Numerics.BigInteger.op_LessThan%28System.UInt64%2CSystem.Numerics.BigInteger%29> método diretamente, como o exemplo a seguir mostra.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#38](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#38)]  
  
 O método equivalente para esse operador é <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThanOrEqual" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_LessThanOrEqual">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retorna um valor que indica se um valor especificado é menor ou igual a outro valor especificado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (long left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.Int64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;= (left As Long, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;=(long left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &lt;= ) : int64 * System.Numerics.BigInteger -&gt; bool" Usage="left &lt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">O primeiro valor a ser comparado.</param>
        <param name="right">O segundo valor a ser comparado.</param>
        <summary>Retorna um valor que indica se um inteiro com sinal de 64 bits é menor ou igual a um valor <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns><see langword="true" /> se <paramref name="left" /> for menor ou igual a <paramref name="right" />; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Numerics.BigInteger.op_LessThanOrEqual%2A> método define a operação de menor que ou igual ao operador para <xref:System.Numerics.BigInteger> valores. Ele permite que o código seja o seguinte:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#39](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#39)]
 [!code-vb[System.Numerics.BigInteger.Operators#39](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#39)]  
  
 Linguagens que não dão suporte a operadores personalizados podem chamar o método <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> em vez disso. Eles também podem chamar o <xref:System.Numerics.BigInteger.op_LessThanOrEqual%28System.Int64%2CSystem.Numerics.BigInteger%29> método diretamente, como o exemplo a seguir mostra.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#40](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#40)]  
  
 Se `left` é um <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, ou <xref:System.UInt32> valor, ele é convertido implicitamente em um <xref:System.Int64> valor quando a operação é executada.  
  
 O método equivalente para esse operador é <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThan" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (System.Numerics.BigInteger left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(valuetype System.Numerics.BigInteger left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.Numerics.BigInteger,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;= (left As BigInteger, right As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;=(System::Numerics::BigInteger left, long right);" />
      <MemberSignature Language="F#" Value="static member ( &lt;= ) : System.Numerics.BigInteger * int64 -&gt; bool" Usage="left &lt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="left">O primeiro valor a ser comparado.</param>
        <param name="right">O segundo valor a ser comparado.</param>
        <summary>Retorna um valor que indica se um valor <see cref="T:System.Numerics.BigInteger" /> é menor ou igual a um inteiro com sinal de 64 bits.</summary>
        <returns><see langword="true" /> se <paramref name="left" /> for menor ou igual a <paramref name="right" />; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Numerics.BigInteger.op_LessThanOrEqual%2A> método define a operação de menor que ou igual ao operador para <xref:System.Numerics.BigInteger> valores. Ele permite que o código seja o seguinte:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#41](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#41)]
 [!code-vb[System.Numerics.BigInteger.Operators#41](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#41)]  
  
 Linguagens que não dão suporte a operadores personalizados podem chamar o método <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> em vez disso. Eles também podem chamar o <xref:System.Numerics.BigInteger.op_LessThanOrEqual%28System.Numerics.BigInteger%2CSystem.Int64%29> método diretamente, como o exemplo a seguir mostra.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#42](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#42)]  
  
 Se `right` é um <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, ou <xref:System.UInt32> valor, ele é convertido implicitamente em um <xref:System.Int64> valor quando a operação é executada.  
  
 O método equivalente para esse operador é <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThan" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;= (left As BigInteger, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;=(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &lt;= ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; bool" Usage="left &lt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">O primeiro valor a ser comparado.</param>
        <param name="right">O segundo valor a ser comparado.</param>
        <summary>Retorna um valor que indica se um valor <see cref="T:System.Numerics.BigInteger" /> é menor ou igual a outro valor <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns><see langword="true" /> se <paramref name="left" /> for menor ou igual a <paramref name="right" />; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Numerics.BigInteger.op_LessThanOrEqual%2A> método define a operação de menor que ou igual ao operador para <xref:System.Numerics.BigInteger> valores. Ele permite que o código seja o seguinte:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#29](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#29)]
 [!code-vb[System.Numeric.BigInteger.Class#29](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#29)]  
  
 Linguagens que não dão suporte a operadores personalizados podem chamar o método <xref:System.Numerics.BigInteger.Compare%2A> em vez disso. Eles também podem chamar o <xref:System.Numerics.BigInteger.op_LessThanOrEqual%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29> método diretamente, como o exemplo a seguir mostra.  
  
 [!code-vb[System.Numeric.BigInteger.Class#30](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#30)]  
  
 O método equivalente para esse operador é <xref:System.Numerics.BigInteger.Compare%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThan" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (System.Numerics.BigInteger left, ulong right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(valuetype System.Numerics.BigInteger left, unsigned int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.Numerics.BigInteger,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;= (left As BigInteger, right As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;=(System::Numerics::BigInteger left, System::UInt64 right);" />
      <MemberSignature Language="F#" Value="static member ( &lt;= ) : System.Numerics.BigInteger * uint64 -&gt; bool" Usage="left &lt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="left">O primeiro valor a ser comparado.</param>
        <param name="right">O segundo valor a ser comparado.</param>
        <summary>Retorna um valor que indica se um valor <see cref="T:System.Numerics.BigInteger" /> é menor ou igual a um inteiro sem sinal de 64 bits.</summary>
        <returns><see langword="true" /> se <paramref name="left" /> for menor ou igual a <paramref name="right" />; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Numerics.BigInteger.op_LessThanOrEqual%2A> método define a operação de menor que ou igual ao operador para <xref:System.Numerics.BigInteger> valores. Ele permite que o código seja o seguinte:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#43](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#43)]
 [!code-vb[System.Numerics.BigInteger.Operators#43](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#43)]  
  
 Linguagens que não dão suporte a operadores personalizados podem chamar o método <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> em vez disso. Eles também podem chamar o <xref:System.Numerics.BigInteger.op_LessThanOrEqual%28System.Numerics.BigInteger%2CSystem.UInt64%29> método diretamente, como o exemplo a seguir mostra.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#44](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#44)]  
  
 O método equivalente para esse operador é <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThan" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (ulong left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(unsigned int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.UInt64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;= (left As ULong, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;=(System::UInt64 left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &lt;= ) : uint64 * System.Numerics.BigInteger -&gt; bool" Usage="left &lt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">O primeiro valor a ser comparado.</param>
        <param name="right">O segundo valor a ser comparado.</param>
        <summary>Retorna um valor que indica se um inteiro sem sinal de 64 bits é menor ou igual a um valor <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns><see langword="true" /> se <paramref name="left" /> for menor ou igual a <paramref name="right" />; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Numerics.BigInteger.op_LessThanOrEqual%2A> método define a operação de menor que ou igual ao operador para <xref:System.Numerics.BigInteger> valores. Ele permite que o código seja o seguinte:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#45](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#45)]
 [!code-vb[System.Numerics.BigInteger.Operators#45](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#45)]  
  
 Linguagens que não dão suporte a operadores personalizados podem chamar o método <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> em vez disso. Eles também podem chamar o <xref:System.Numerics.BigInteger.op_LessThanOrEqual%28System.UInt64%2CSystem.Numerics.BigInteger%29> método diretamente, como o exemplo a seguir mostra.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#46](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#46)]  
  
 O método equivalente para esse operador é <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThan" />
      </Docs>
    </Member>
    <Member MemberName="op_Modulus">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator % (System.Numerics.BigInteger dividend, System.Numerics.BigInteger divisor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Modulus(valuetype System.Numerics.BigInteger dividend, valuetype System.Numerics.BigInteger divisor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Modulus(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator Mod (dividend As BigInteger, divisor As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator %(System::Numerics::BigInteger dividend, System::Numerics::BigInteger divisor);" />
      <MemberSignature Language="F#" Value="static member ( % ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="dividend % divisor" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dividend" Type="System.Numerics.BigInteger" />
        <Parameter Name="divisor" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="dividend">O valor a ser dividido.</param>
        <param name="divisor">O valor pelo qual dividir.</param>
        <summary>Retorna o resto que resulta da divisão com dois valores especificados <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>O resto que resulta da divisão.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Numerics.BigInteger.op_Modulus%2A> método define a operação do operador de módulo para <xref:System.Numerics.BigInteger> valores. Ele permite que o código seja o seguinte:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#31](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#31)]
 [!code-vb[System.Numeric.BigInteger.Class#31](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#31)]  
  
 Linguagens que não dão suporte a operadores personalizados podem chamar o método <xref:System.Numerics.BigInteger.Remainder%2A?displayProperty=nameWithType> em vez disso.  
  
 O sinal do valor retornado pela operação de módulo depende do sinal de `dividend`: Se `dividend` for positivo, a operação de módulo retorna um resultado positivo; se for negativo, a operação de módulo retornará um resultado negativo. O comportamento da operação modulus com <xref:System.Numerics.BigInteger> valores é idêntica à operação de módulo com outros tipos integrais.  
  
 O método equivalente para esse operador é <xref:System.Numerics.BigInteger.Remainder%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException"><paramref name="divisor" /> é 0 (zero).</exception>
        <altmember cref="M:System.Numerics.BigInteger.op_Division(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
        <altmember cref="M:System.Numerics.BigInteger.DivRem(System.Numerics.BigInteger,System.Numerics.BigInteger,System.Numerics.BigInteger@)" />
      </Docs>
    </Member>
    <Member MemberName="op_Multiply">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator * (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Multiply(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Multiply(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator * (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator *(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( * ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="left * right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">O primeiro valor a ser multiplicado.</param>
        <param name="right">O segundo valor a ser multiplicado.</param>
        <summary>Multiplica dois valores <see cref="T:System.Numerics.BigInteger" /> especificados.</summary>
        <returns>O produto de <paramref name="left" /> e <paramref name="right" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Numerics.BigInteger.op_Multiply%2A> método define a operação do operador de multiplicação para <xref:System.Numerics.BigInteger> valores. Ele permite que o código seja o seguinte:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#11)]
 [!code-vb[System.Numeric.BigInteger.Class#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#11)]  
  
 O método equivalente para esse operador é <xref:System.Numerics.BigInteger.Multiply(System.Numerics.BigInteger,System.Numerics.BigInteger)?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.Multiply(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="op_OnesComplement">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator ~ (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_OnesComplement(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_OnesComplement(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator Not (value As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator ~(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_OnesComplement : System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_OnesComplement value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Um valor inteiro.</param>
        <summary>Retorna o complemento bit a bit de um valor <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>O complemento bit a bit de <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Numerics.BigInteger.op_OnesComplement%2A> método define a operação de bit a bit de um operador de complemento para <xref:System.Numerics.BigInteger> valores. O bit a bit de um operador de complemento reverte cada bit em um valor numérico. Ou seja, o bits no `value` que são 0 são definidos como 1 no resultado e os bits forem 1 são definidos como 0 no resultado. O <xref:System.Numerics.BigInteger.op_OnesComplement%2A> método permite que o código como o seguinte:  
  
 [!code-csharp[System.Numerics.BigInteger.OnesComplement#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.OnesComplement/cs/OnesComplement1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.OnesComplement#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.OnesComplement/vb/OnesComplement1.vb#1)]  
  
 Idiomas que não dão suporte a operadores personalizados podem ser capazes de chamar o <xref:System.Numerics.BigInteger.op_OnesComplement%2A> diretamente para realizar um bit a bit de um método de operação de complemento. Por exemplo:  
  
 [!code-vb[System.Numerics.BigInteger.OnesComplement#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.OnesComplement/vb/onescomplement2.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_RightShift">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator &gt;&gt; (System.Numerics.BigInteger value, int shift);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_RightShift(valuetype System.Numerics.BigInteger value, int32 shift) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_RightShift(System.Numerics.BigInteger,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;&gt; (value As BigInteger, shift As Integer) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator &gt;&gt;(System::Numerics::BigInteger value, int shift);" />
      <MemberSignature Language="F#" Value="static member ( &gt;&gt;&gt; ) : System.Numerics.BigInteger * int -&gt; System.Numerics.BigInteger" Usage="value &gt;&gt;&gt; shift" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
        <Parameter Name="shift" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">O valor cujos bits devem ser deslocados.</param>
        <param name="shift">O número de bits a deslocar <paramref name="value" /> para a direita.</param>
        <summary>Desloca um valor <see cref="T:System.Numerics.BigInteger" /> um número especificado de bits para a direita.</summary>
        <returns>Um valor que foi sido deslocado para a direita pelo número especificado de bits.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Numerics.BigInteger.op_RightShift%2A> método define a operação do operador de deslocamento à direita bit a bit para <xref:System.Numerics.BigInteger> valores. Ele permite que o código seja o seguinte:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#47](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/RightShift1.cs#47)]
 [!code-vb[System.Numerics.BigInteger.Operators#47](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#47)]  
  
 Idiomas que não dão suporte a operadores personalizados podem executar uma operação bit a bit de deslocamento à direita, dividindo `value` pela `BigInteger.Pow(2, shift)` e subtraindo 1 vezes `shift` para valores negativos. O exemplo a seguir mostra que os resultados são idênticos aos resultados do uso desse operador.  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#48](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/RightShift1.cs#48)]
 [!code-vb[System.Numerics.BigInteger.Operators#48](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#48)]  
  
 Se `shift` é maior que ou igual ao número de bits em um positivo <xref:System.Numerics.BigInteger> valor, o resultado da operação de deslocamento à direita é <xref:System.Numerics.BigInteger.Zero%2A?displayProperty=nameWithType>. Se `shift` é maior que o número de bits em um negativo <xref:System.Numerics.BigInteger> valor, o resultado da operação de deslocamento à direita é <xref:System.Numerics.BigInteger.MinusOne%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_LeftShift(System.Numerics.BigInteger,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="op_Subtraction">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator - (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Subtraction(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Subtraction(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator - (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator -(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( - ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="left - right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">O valor do qual um valor será subtraído (o minuendo).</param>
        <param name="right">O valor a ser subtraído (o subtraendo).</param>
        <summary>Subtrai um valor <see cref="T:System.Numerics.BigInteger" /> de outro valor <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>O resultado da subtração de <paramref name="right" /> de <paramref name="left" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Numerics.BigInteger.op_Subtraction%2A> método define a operação do operador de subtração para <xref:System.Numerics.BigInteger> valores. Ele permite que o código seja o seguinte:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#14)]
 [!code-vb[System.Numeric.BigInteger.Class#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#14)]  
  
 Linguagens que não dão suporte a operadores personalizados podem chamar o método <xref:System.Numerics.BigInteger.Subtract%2A?displayProperty=nameWithType> em vez disso.  
  
 O método equivalente para esse operador é <xref:System.Numerics.BigInteger.Subtract%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.Subtract(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="op_UnaryNegation">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator - (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_UnaryNegation(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_UnaryNegation(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator - (value As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator -(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member ( ~- ) : System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="- value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">O valor a ser negado.</param>
        <summary>Nega um valor BigInteger especificado.</summary>
        <returns>O resultado do parâmetro <paramref name="value" /> multiplicado por um negativo (-1).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Numerics.BigInteger.op_UnaryNegation%2A> método define a operação do operador de negação unário (ou o operador inverso de aditivo) para <xref:System.Numerics.BigInteger> valores. A operação produz um valor que resulta em 0 (zero) quando ele é adicionado para o número original. Linguagens que não dão suporte a operadores personalizados podem chamar o método <xref:System.Numerics.BigInteger.Negate%2A> em vez disso.  
  
 É o método equivalente para esse operador <xref:System.Numerics.BigInteger.Negate%28System.Numerics.BigInteger%29?displayProperty=nameWithType>  
  
## Examples  
 O exemplo a seguir ilustra três maneiras diferentes de nega o valor de um <xref:System.Numerics.BigInteger> objeto.  
  
 [!code-csharp[System.Numeric.BigInteger.Class#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#16)]
 [!code-vb[System.Numeric.BigInteger.Class#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#16)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_UnaryPlus">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator + (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_UnaryPlus(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_UnaryPlus(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator + (value As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator +(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member ( ~+ ) : System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="+ value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Um valor inteiro.</param>
        <summary>Retorna o valor do operando <see cref="T:System.Numerics.BigInteger" />. (O sinal do operando permanece inalterado).</summary>
        <returns>O valor do operando <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Numerics.BigInteger.op_UnaryPlus%2A> método define a operação do operador unário positivo para <xref:System.Numerics.BigInteger> valores.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Parse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Converte a representação da cadeia de caracteres de um número no <see cref="T:System.Numerics.BigInteger" /> equivalente.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Parse (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Parse(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Parse(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (value As String) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Parse(System::String ^ value);" />
      <MemberSignature Language="F#" Value="static member Parse : string -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Parse value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Uma cadeia de caracteres que contém o número a ser convertido.</param>
        <summary>Converte a representação da cadeia de caracteres de um número no <see cref="T:System.Numerics.BigInteger" /> equivalente.</summary>
        <returns>Um valor equivalente ao número especificado no parâmetro <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `value` parâmetro deve ser a representação de cadeia de caracteres de um número da seguinte forma.  
  
 [*ws*][*sign*]*digits*[*ws*]  
  
 Os elementos entre colchetes ([ e ]) são opcionais. A tabela a seguir descreve cada elemento.  
  
|Elemento|Descrição|  
|-------------|-----------------|  
|*ws*|Espaço em branco opcional.|  
|*sign*|Um sinal opcional. Os caracteres de sinal válido são determinados pelas propriedades <xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType> e <xref:System.Globalization.NumberFormatInfo.PositiveSign%2A?displayProperty=nameWithType> da cultura atual.|  
|*digits*|Uma sequência de dígitos que varia de 0 a 9. Todos os zeros à esquerda são ignorados.|  
  
> [!NOTE]
>  A cadeia de caracteres especificada pelo `value` parâmetro é interpretado usando o <xref:System.Globalization.NumberStyles.Integer?displayProperty=nameWithType> estilo. Ele não pode conter nenhum separador de grupo ou decimal, e não pode ter uma parte decimal.  
  
 O parâmetro `value` é analisado usando-se as informações de formatação em um objeto <xref:System.Globalization.NumberFormatInfo?displayProperty=nameWithType> que é inicializado para a cultura do sistema atual. Para obter mais informações, consulte <xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A?displayProperty=nameWithType>. Para analisar uma cadeia de caracteres usando as informações de formatação de uma cultura específica, use o <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.IFormatProvider%29> método.  
  
> [!IMPORTANT]
>  Se você usar o <xref:System.Numerics.BigInteger.Parse%2A> método para a representação de cadeia de caracteres de ida e volta de um <xref:System.Numerics.BigInteger> valor que foi a saída pela <xref:System.Numerics.BigInteger.ToString%2A> método, você deve usar o <xref:System.Numerics.BigInteger.ToString%28System.String%29?displayProperty=nameWithType> método com o especificador de formato "R" para gerar a representação de cadeia de caracteres da <xref:System.Numerics.BigInteger> valor. Caso contrário, a representação de cadeia de caracteres da <xref:System.Numerics.BigInteger> preserva apenas os 50 dígitos mais significativos do valor original e os dados podem ser perdidos quando você usa o <xref:System.Numerics.BigInteger.Parse%2A> método para restaurar o <xref:System.Numerics.BigInteger> valor.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.Numerics.BigInteger.Parse%28System.String%29> método para instanciar dois <xref:System.Numerics.BigInteger> objetos. Ele multiplica cada objeto por outro número e, em seguida, chama o <xref:System.Numerics.BigInteger.Compare%2A> método para determinar a relação entre os dois valores.  
  
 [!code-csharp[System.Numerics.BigInteger.Parse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/cs/Parse1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Parse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/vb/Parse1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> é <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="value" /> não está no formato correto.</exception>
        <altmember cref="Overload:System.Numerics.BigInteger.TryParse" />
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Parse (string value, System.Globalization.NumberStyles style);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Parse(string value, valuetype System.Globalization.NumberStyles style) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (value As String, style As NumberStyles) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Parse(System::String ^ value, System::Globalization::NumberStyles style);" />
      <MemberSignature Language="F#" Value="static member Parse : string * System.Globalization.NumberStyles -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Parse (value, style)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
      </Parameters>
      <Docs>
        <param name="value">Uma cadeia de caracteres que contém um número a ser convertido.</param>
        <param name="style">Um combinação bit a bit de valores de enumeração que especificam o formato permitido de <paramref name="value" />.</param>
        <summary>Converte a representação de cadeia de caracteres de um número em um estilo especificado em seu <see cref="T:System.Numerics.BigInteger" /> equivalente.</summary>
        <returns>Um valor equivalente ao número especificado no parâmetro <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `style` parâmetro define os elementos de estilo (como espaço em branco, o símbolo de sinal positivo ou negativo, o símbolo de separador de grupo ou o símbolo de ponto decimal) que são permitidos no `value` parâmetro para a operação de análise seja bem-sucedida. `styles` deve ser uma combinação de sinalizadores de bit do <xref:System.Globalization.NumberStyles> enumeração. O `style` parâmetro torna esse método de sobrecarga útil quando `value` contém a representação de cadeia de caracteres de um valor hexadecimal, quando o sistema de número (decimal ou hexadecimal) representado por `value` for conhecido somente em tempo de execução, ou quando você para não permitir espaço em branco ou um sinal de símbolo no `value`.  
  
 Dependendo do valor de `style`, o parâmetro `value` pode incluir os seguintes elementos:  
  
 [*ws*] [*$*] [*entrada*] [*dígitos*,]*dígitos*[. *dígitos fracionários*] [E [*sinal*]*exponential_digits*] [*ws*]  
  
 Caso `style` inclua <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType>, o parâmetro `value` pode conter os seguintes elementos:  
  
 [*ws*]*hexdigits*[*ws*]  
  
 Os elementos entre colchetes ([ e ]) são opcionais. A tabela a seguir descreve cada elemento.  
  
|Elemento|Descrição|  
|-------------|-----------------|  
|*ws*|Espaço em branco opcional. Espaço em branco podem aparecer no início da `value` se `style` inclui as <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> sinalizador e ele podem ser exibido no final da `value` se `style` inclui o <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType> sinalizador.|  
|*$*|Um símbolo de moeda específico de cultura. A posição na cadeia de caracteres é definida pelas propriedades <xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType> e <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> da cultura atual. O símbolo de moeda da cultura atual pode ser exibido em `value` caso `style` inclua o sinalizador <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType>.|  
|*sign*|Um sinal opcional. O sinal pode ser exibido no início de `value` caso `style` inclua o sinalizador <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType> e ele pode ser exibido no final de `value` caso `style` inclua o sinalizador <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType>. Os parênteses podem ser usados em `value` para indicar um valor negativo caso `style` inclua o sinalizador <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType>.|  
|*digits*<br /><br /> *fractional_digits*<br /><br /> *exponential_digits*|Uma sequência de dígitos de 0 a 9. Para *fractional_digits*, apenas o dígito 0 é válido.|  
|*,*|Um símbolo de separador do grupo específico da cultura. Separador de grupo da cultura atual pode aparecer em `value` se `style` inclui o <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> sinalizador.|  
|*.*|Um símbolo de vírgula decimal específico de cultura. O símbolo da vírgula decimal da cultura atual pode ser exibido em `value` caso `style` inclua o sinalizador <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType>. Apenas o dígito 0 pode aparecer como um dígito fracionário para que a operação de análise seja bem-sucedida; Se *fractional_digits* inclua qualquer outro dígito, um <xref:System.FormatException> é gerada.|  
|E|O caractere "e" ou "E", que indica que o valor é representado em notação exponencial (científica). O parâmetro `value` pode representar um número em notação exponencial caso `style` inclua o sinalizador <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType>.|  
|*hexdigits*|Uma sequência de dígitos hexadecimais de 0 a f ou de 0 a F.|  
  
> [!NOTE]
> Quaisquer caracteres de (U + 0000) terminação NUL no `s` são ignorados pela operação de análise, independentemente do valor de `style` argumento.

 Uma cadeia de caracteres apenas com dígitos (que corresponde ao estilo <xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType> ) sempre é analisada com êxito. A maioria dos elementos de controle de membros <xref:System.Globalization.NumberStyles> restantes que podem estar presentes, mas que não precisam estar presentes, na cadeia de caracteres de entrada. A tabela a seguir indica como os membros <xref:System.Globalization.NumberStyles> individuais afetam os elementos que podem estar presentes em `value`.  
  
|Valor `NumberStyles`|Elementos permitidos em `value` além de dígitos|  
|--------------------------|---------------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|O *dígitos* apenas o elemento.|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|O vírgula decimal (,) e *dígitos fracionários* elementos.|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|O "e" ou o caractere "E, que indica a notação exponencial, juntamente com" *exponential_digits*.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|O *ws* elemento no início de `value`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|O elemento *ws* no final de `value`.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|O *sinal* elemento no início de `value`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|O elemento *sinal* no final de `value`.|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|O elemento *sinal* na forma de parênteses que incluem o valor numérico.|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|O elemento separador do grupo (,).|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|O elemento de moeda ($).|  
|<xref:System.Globalization.NumberStyles.Currency>|Todos os elementos. No entanto, `value` não pode representar um número hexadecimal ou um número em notação exponencial.|  
|<xref:System.Globalization.NumberStyles.Float>|O *ws* elemento no início ou final do `value`, *sign* no início do `value`e o ponto decimal (*.*) símbolo. O parâmetro `value` também pode usar notação exponencial.|  
|<xref:System.Globalization.NumberStyles.Number>|O `ws`, `sign`, separador de grupo (*,*) e o ponto decimal (*.*) elementos.|  
|<xref:System.Globalization.NumberStyles.Any>|Todos os elementos. No entanto, `value` não pode representar um número hexadecimal.|  
  
> [!IMPORTANT]
>  Se você usar o <xref:System.Numerics.BigInteger.Parse%2A> método para a representação de cadeia de caracteres de ida e volta de um <xref:System.Numerics.BigInteger> valor que foi a saída pela <xref:System.Numerics.BigInteger.ToString%2A> método, você deve usar o <xref:System.Numerics.BigInteger.ToString%28System.String%29?displayProperty=nameWithType> método com o especificador de formato "R" para gerar a representação de cadeia de caracteres da <xref:System.Numerics.BigInteger> valor. Caso contrário, a representação de cadeia de caracteres da <xref:System.Numerics.BigInteger> preserva apenas os 50 dígitos mais significativos do valor original e os dados podem ser perdidos quando você usa o <xref:System.Numerics.BigInteger.Parse%2A> método para restaurar o <xref:System.Numerics.BigInteger> valor.  
  
 Ao contrário de outros <xref:System.Globalization.NumberStyles> valores, que permitem, mas não exigem a presença de elementos de estilo específico `value`, o <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType> valor de estilo significa que os caracteres individuais nos `value` sempre são interpretados como caracteres hexadecimais. Os caracteres hexadecimais válidos são 0-9, A-F e a-f. Os únicos outros sinalizadores que podem ser combinados com o parâmetro `style` são <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> e <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType>. (A enumeração de <xref:System.Globalization.NumberStyles> inclui um estilo de número composto, <xref:System.Globalization.NumberStyles.HexNumber>, que inclui ambos os sinalizadores de espaço em branco.)  
  
> [!NOTE]
>  Caso `value` seja a representação da cadeia de caracteres de um número hexadecimal, ele não pode ser precedido por qualquer decoração (como `0x` ou `&h`) que o diferencia como um número hexadecimal. Isso faz a conversão falhar.  
  
 Se `value` é uma cadeia de caracteres hexadecimal, o <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%29> método interpreta `value` como um número negativo armazenado usando a representação de complemento de dois se seus dois primeiros dígitos hexadecimais são maiores que ou igual a `0x80`. Em outras palavras, o método interpreta o bit de ordem mais alta do primeiro byte em `value` como o bit de sinal. Para certificar-se de que uma cadeia de caracteres hexadecimal é interpretada corretamente como um número positivo, o primeiro dígito em `value` deve ter um valor igual a zero. Por exemplo, o método interpreta `0x80` como um valor negativo, mas ele interpreta o `0x080` ou `0x0080` como um valor positivo. O exemplo a seguir ilustra a diferença entre cadeias de caracteres hexadecimais que representam valores positivos e negativos.  
  
 [!code-csharp[System.Numerics.BigInteger.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/cs/ParseHex1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/vb/ParseHex1.vb#3)]  
  
 O parâmetro `value` é analisado usando-se as informações de formatação em um objeto <xref:System.Globalization.NumberFormatInfo> que é inicializado para a cultura do sistema atual. Para especificar a cultura cujas informações de formatação são usadas para a operação de análise, chame o <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> de sobrecarga.  
  
   
  
## Examples  
 O exemplo a seguir ilustra chamadas para o <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%29> método com vários valores possíveis para o `style` parâmetro. Ele ilustra como uma cadeia de caracteres como um valor hexadecimal de interpretar e como não permitir espaços e entre símbolos.  
  
 [!code-csharp[System.Numeric.BigInteger.Parse#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/cs/System.Numeric.BigInteger.Parse.cs#5)]
 [!code-vb[System.Numeric.BigInteger.Parse#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/vb/System.Numeric.BigInteger.Parse.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="style" /> não é um valor <see cref="T:System.Globalization.NumberStyles" />.  
  
- ou - 
 <paramref name="style" /> inclui o sinalizador <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" /> ou <see cref="F:System.Globalization.NumberStyles.HexNumber" /> em conjunto com outro valor.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> é <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="value" /> não é compatível com o padrão de entrada especificado por <see cref="T:System.Globalization.NumberStyles" />.</exception>
        <altmember cref="Overload:System.Numerics.BigInteger.TryParse" />
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Parse (string value, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Parse(string value, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Parse(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (value As String, provider As IFormatProvider) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Parse(System::String ^ value, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="static member Parse : string * IFormatProvider -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Parse (value, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="value">Uma cadeia de caracteres que contém um número a ser convertido.</param>
        <param name="provider">Um objeto que fornece informações de formatação específicas à cultura sobre <paramref name="value" />.</param>
        <summary>Converte a representação de cadeia de caracteres de um número em um formato específico da cultura especificado em seu equivalente de <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>Um valor equivalente ao número especificado no parâmetro <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `value` parâmetro deve ser a representação de cadeia de caracteres de um número da seguinte forma:  
  
 [*ws*][*sign*]*digits*[*ws*]  
  
 Os elementos entre colchetes ([ e ]) são opcionais. A tabela a seguir descreve cada elemento.  
  
|Elemento|Descrição|  
|-------------|-----------------|  
|*ws*|Espaço em branco opcional.|  
|*sign*|Um sinal opcional. Caracteres de sinal válido são determinados pelo <xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType> e <xref:System.Globalization.NumberFormatInfo.PositiveSign%2A?displayProperty=nameWithType> propriedades da <xref:System.Globalization.NumberFormatInfo> objeto que é retornado pelo `provider` do objeto <xref:System.IFormatProvider.GetFormat%2A> método.|  
|*digits*|Uma sequência de dígitos que varia de 0 a 9. Todos os zeros à esquerda são ignorados.|  
  
> [!NOTE]
>  A cadeia de caracteres especificada pelo `value` parâmetro é interpretado usando o <xref:System.Globalization.NumberStyles.Integer?displayProperty=nameWithType> estilo. Ele não pode conter nenhum separador de grupo ou decimal, e não pode ter uma parte decimal.  
  
> [!IMPORTANT]
>  Se você usar o <xref:System.Numerics.BigInteger.Parse%2A> método para a representação de cadeia de caracteres de ida e volta de um <xref:System.Numerics.BigInteger> valor que foi a saída pela <xref:System.Numerics.BigInteger.ToString%2A> método, você deve usar o <xref:System.Numerics.BigInteger.ToString%28System.String%29?displayProperty=nameWithType> método com o especificador de formato "R" para gerar a representação de cadeia de caracteres da <xref:System.Numerics.BigInteger> valor. Caso contrário, a representação de cadeia de caracteres da <xref:System.Numerics.BigInteger> preserva apenas os 50 dígitos mais significativos do valor original e os dados podem ser perdidos quando você usa o <xref:System.Numerics.BigInteger.Parse%2A> método para restaurar o <xref:System.Numerics.BigInteger> valor.  
  
 O `provider` parâmetro é um <xref:System.IFormatProvider> implementação cuja <xref:System.IFormatProvider.GetFormat%2A> método retorna um <xref:System.Globalization.NumberFormatInfo> objeto que fornece informações de formatação específicas da cultura. Quando o <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.IFormatProvider%29> método é invocado, ele chama o `provider` do parâmetro <xref:System.IFormatProvider.GetFormat%2A> método e passa um <xref:System.Type> objeto que representa o <xref:System.Globalization.NumberFormatInfo> tipo. O <xref:System.IFormatProvider.GetFormat%2A> método retorna, em seguida, o <xref:System.Globalization.NumberFormatInfo> objeto que fornece informações sobre o formato do `value` parâmetro. Existem três maneiras de usar o parâmetro `provider` para fornecer informações de formatação personalizadas para a operação de análise:  
  
-   É possível passar um objeto <xref:System.Globalization.CultureInfo> que representa a cultura que fornece informações de formatação. O método <xref:System.Globalization.CultureInfo.GetFormat%2A> retorna o objeto <xref:System.Globalization.NumberFormatInfo> que fornece informações de formatação numérica para essa cultura.  
  
-   É possível passar o objeto real <xref:System.Globalization.NumberFormatInfo> que fornece informações de formatação numérica. (Sua implementação de <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> retorna apenas ele próprio.)  
  
-   É possível passar um objeto personalizado que implementa <xref:System.IFormatProvider>. O método <xref:System.IFormatProvider.GetFormat%2A> cria uma instância e retorna o objeto <xref:System.Globalization.NumberFormatInfo> que fornece informações de formatação.  
  
 Se `provider` está `null`, a formatação da `value` interpretado com base no <xref:System.Globalization.NumberFormatInfo> objeto da cultura atual.  
  
   
  
## Examples  
 Os exemplos a seguir mostram duas maneiras de definir o til (~) como um sinal negativo para a formatação <xref:System.Numerics.BigInteger> valores. Observe que, para exibir o <xref:System.Numerics.BigInteger> valores no mesmo formato que as cadeias de caracteres originais, seu código deve chamar o <xref:System.Numerics.BigInteger.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> método e passá-lo a <xref:System.Globalization.NumberFormatInfo> objeto que fornece informações de formatação.  
  
 O primeiro exemplo define uma classe que implementa <xref:System.IFormatProvider> e usa o <xref:System.IFormatProvider.GetFormat%2A> método para retornar o <xref:System.Globalization.NumberFormatInfo> objeto que fornece informações de formatação.  
  
 [!code-csharp[System.Numeric.BigInteger.Parse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/cs/System.Numeric.BigInteger.Parse.cs#2)]
 [!code-vb[System.Numeric.BigInteger.Parse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/vb/System.Numeric.BigInteger.Parse.vb#2)]  
  
 Um <xref:System.Numerics.BigInteger> objeto, em seguida, pode ser instanciado com o código a seguir:  
  
 [!code-csharp[System.Numeric.BigInteger.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/cs/System.Numeric.BigInteger.Parse.cs#3)]
 [!code-vb[System.Numeric.BigInteger.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/vb/System.Numeric.BigInteger.Parse.vb#3)]  
  
 O segundo exemplo é mais simples. Ele passa a <xref:System.Globalization.NumberFormatInfo> objeto que fornece informações de formatação para o `provider` parâmetro.  
  
 [!code-csharp[System.Numeric.BigInteger.Parse#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/cs/System.Numeric.BigInteger.Parse.cs#4)]
 [!code-vb[System.Numeric.BigInteger.Parse#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/vb/System.Numeric.BigInteger.Parse.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> é <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="value" /> não está no formato correto.</exception>
        <altmember cref="Overload:System.Numerics.BigInteger.TryParse" />
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Parse (ReadOnlySpan&lt;char&gt; value, System.Globalization.NumberStyles style = System.Globalization.NumberStyles.Integer, IFormatProvider provider = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Parse(valuetype System.ReadOnlySpan`1&lt;char&gt; value, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Parse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (value As ReadOnlySpan(Of Char), Optional style As NumberStyles = System.Globalization.NumberStyles.Integer, Optional provider As IFormatProvider = null) As BigInteger" />
      <MemberSignature Language="F#" Value="static member Parse : ReadOnlySpan&lt;char&gt; * System.Globalization.NumberStyles * IFormatProvider -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Parse (value, style, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="style">To be added.</param>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Parse (string value, System.Globalization.NumberStyles style, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Parse(string value, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (value As String, style As NumberStyles, provider As IFormatProvider) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Parse(System::String ^ value, System::Globalization::NumberStyles style, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="static member Parse : string * System.Globalization.NumberStyles * IFormatProvider -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Parse (value, style, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="value">Uma cadeia de caracteres que contém um número a ser convertido.</param>
        <param name="style">Um combinação bit a bit de valores de enumeração que especificam o formato permitido de <paramref name="value" />.</param>
        <param name="provider">Um objeto que fornece informações de formatação específicas à cultura sobre <paramref name="value" />.</param>
        <summary>Converte a representação de cadeia de caracteres de um número com um estilo especificado e um formato específico à cultura para seu <see cref="T:System.Numerics.BigInteger" /> equivalente.</summary>
        <returns>Um valor equivalente ao número especificado no parâmetro <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `style` parâmetro define os elementos de estilo (como espaço em branco, o símbolo de sinal positivo ou negativo, o símbolo de separador de grupo ou o símbolo de ponto decimal) que são permitidos no `value` parâmetro para a operação de análise seja bem-sucedida. `styles` deve ser uma combinação de sinalizadores de bit do <xref:System.Globalization.NumberStyles> enumeração. O `style` parâmetro torna esse método de sobrecarga útil quando `value` contém a representação de cadeia de caracteres de um valor hexadecimal, quando o sistema de número (decimal ou hexadecimal) representado por `value` for conhecido somente em tempo de execução, ou quando você para não permitir espaço em branco ou um sinal de símbolo no `value`.  
  
 Dependendo do valor de `style`, o parâmetro `value` pode incluir os seguintes elementos:  
  
 [*ws*][*$*][*sign*][*digits*,]*digits*[*.fractional_digits*][E[*sign*]*exponential_digits*][*ws*]  
  
 Se `style` inclui <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType>, o `value` parâmetro pode incluir os seguintes elementos:  
  
 [*ws*]*hexdigits*[*ws*]  
  
 Os elementos entre colchetes ([ e ]) são opcionais. A tabela a seguir descreve cada elemento.  
  
|Elemento|Descrição|  
|-------------|-----------------|  
|*ws*|Espaço em branco opcional. Espaço em branco podem aparecer no início da `value` se `style` inclui as <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> sinalizador e ele podem ser exibido no final da `value` se `style` inclui o <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType> sinalizador.|  
|*$*|Um símbolo de moeda específico de cultura. A posição na cadeia de caracteres é definida pelo <xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType> e <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> propriedades da cultura indicada pela `provider` parâmetro. O símbolo de moeda da cultura atual pode ser exibido em `value` caso `style` inclua o sinalizador <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType>.|  
|*sign*|Um sinal opcional. O sinal pode ser exibido no início de `value` caso `style` inclua o sinalizador <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType> e ele pode ser exibido no final de `value` caso `style` inclua o sinalizador <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType>. Os parênteses podem ser usados em `value` para indicar um valor negativo caso `style` inclua o sinalizador <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType>.|  
|*digits*<br /><br /> *fractional_digits*<br /><br /> *exponential_digits*|Uma sequência de dígitos de 0 a 9. Para *fractional_digits*, apenas o dígito 0 é válido.|  
|*,*|Um símbolo de separador do grupo específico da cultura. O símbolo de separador de grupo da cultura especificada por `provider` pode aparecer em `value` se `style` inclui o <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> sinalizador.|  
|*.*|Um símbolo de vírgula decimal específico de cultura. O símbolo de vírgula decimal da cultura designado por `provider` pode aparecer em `value` se `style` inclui o <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> sinalizador. Apenas o dígito 0 pode aparecer como um dígito fracionário para que a operação de análise seja bem-sucedida; Se *fractional_digits* inclua qualquer outro dígito, um <xref:System.FormatException> é gerada.|  
|E|O caractere "e" ou "E", que indica que o valor é representado em notação exponencial (científica). O parâmetro `value` pode representar um número em notação exponencial caso `style` inclua o sinalizador <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType>.|  
|*hexdigits*|Uma sequência de dígitos hexadecimais de 0 a f ou de 0 a F.|  
  
> [!NOTE]
> Quaisquer caracteres de (U + 0000) terminação NUL no `s` são ignorados pela operação de análise, independentemente do valor de `style` argumento.

 Uma cadeia de caracteres apenas com dígitos (que corresponde ao estilo <xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType> ) sempre é analisada com êxito. A maioria dos elementos de controle de membros <xref:System.Globalization.NumberStyles> restantes que podem estar presentes, mas que não precisam estar presentes, na cadeia de caracteres de entrada. A tabela a seguir indica como os membros <xref:System.Globalization.NumberStyles> individuais afetam os elementos que podem estar presentes em `value`.  
  
|Valor NumberStyles|Elementos permitidos no valor além de dígitos|  
|------------------------|-------------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|O *dígitos* apenas o elemento.|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|O vírgula decimal (,) e *dígitos fracionários* elementos.|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|O caractere "e" ou "E", que indica a notação exponencial. junto com *exponential_digits*.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|O *ws* elemento no início de `value`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|O elemento *ws* no final de `value`.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|O *sinal* elemento no início de `value`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|O elemento *sinal* no final de `value`.|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|O elemento *sinal* na forma de parênteses que incluem o valor numérico.|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|O elemento separador do grupo (,).|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|O elemento de moeda ($).|  
|<xref:System.Globalization.NumberStyles.Currency>|Todos os elementos. No entanto, `value` não pode representar um número hexadecimal ou um número em notação exponencial.|  
|<xref:System.Globalization.NumberStyles.Float>|O *ws* elemento no início ou final do `value`, *sign* no início de `value`e o símbolo de vírgula decimal (.). O parâmetro `value` também pode usar notação exponencial.|  
|<xref:System.Globalization.NumberStyles.Number>|O `ws`, `sign`, separador de grupo (,) e elementos de vírgula decimal (.).|  
|<xref:System.Globalization.NumberStyles.Any>|Todos os elementos. No entanto, `value` não pode representar um número hexadecimal.|  
  
> [!IMPORTANT]
>  Se você usar o <xref:System.Numerics.BigInteger.Parse%2A> método para a representação de cadeia de caracteres de ida e volta de um <xref:System.Numerics.BigInteger> valor que foi a saída pela <xref:System.Numerics.BigInteger.ToString%2A> método, você deve usar o <xref:System.Numerics.BigInteger.ToString%28System.String%29?displayProperty=nameWithType> método com o especificador de formato "R" para gerar a representação de cadeia de caracteres da <xref:System.Numerics.BigInteger> valor. Caso contrário, a representação de cadeia de caracteres da <xref:System.Numerics.BigInteger> preserva apenas os 50 dígitos mais significativos do valor original e os dados podem ser perdidos quando você usa o <xref:System.Numerics.BigInteger.Parse%2A> método para restaurar o <xref:System.Numerics.BigInteger> valor.  
  
 Ao contrário de outros <xref:System.Globalization.NumberStyles> valores, que permitem, mas não exigem a presença de elementos de estilo específico `value`, o <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType> valor de estilo significa que os caracteres individuais nos `value` sempre são interpretados como caracteres hexadecimais. Os caracteres hexadecimais válidos são 0-9, A-F e a-f. Os únicos outros sinalizadores que podem ser combinados com o parâmetro `style` são <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> e <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType>. (A enumeração de <xref:System.Globalization.NumberStyles> inclui um estilo de número composto, <xref:System.Globalization.NumberStyles.HexNumber>, que inclui ambos os sinalizadores de espaço em branco.)  
  
> [!NOTE]
>  Caso `value` seja a representação da cadeia de caracteres de um número hexadecimal, ele não pode ser precedido por qualquer decoração (como `0x` ou `&h`) que o diferencia como um número hexadecimal. Isso faz a conversão falhar.  
  
 Se `value` é uma cadeia de caracteres hexadecimal, o <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%29> método interpreta `value` como um número negativo armazenado usando a representação de complemento de dois se seus dois primeiros dígitos hexadecimais são maiores que ou igual a `0x80`. Em outras palavras, o método interpreta o bit de ordem mais alta do primeiro byte em `value` como o bit de sinal. Para certificar-se de que uma cadeia de caracteres hexadecimal é interpretada corretamente como um número positivo, o primeiro dígito em `value` deve ter um valor igual a zero. Por exemplo, o método interpreta `0x80` como um valor negativo, mas ele interpreta o `0x080` ou `0x0080` como um valor positivo. O exemplo a seguir ilustra a diferença entre cadeias de caracteres hexadecimais que representam valores positivos e negativos.  
  
 [!code-csharp[System.Numerics.BigInteger.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/cs/ParseHex1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/vb/ParseHex1.vb#3)]  
  
 O parâmetro `provider` é uma implementação de <xref:System.IFormatProvider>. O método <xref:System.IFormatProvider.GetFormat%2A> retorna um objeto <xref:System.Globalization.NumberFormatInfo> que fornece informações específicas de cultura sobre o formato de `value`. Normalmente, `provider` pode ser qualquer um dos seguintes:  
  
-   Um <xref:System.Globalization.CultureInfo> objeto que representa a cultura que fornece informações de formatação numérica. Sua <xref:System.Globalization.CultureInfo.GetFormat%2A> método retorna o <xref:System.Globalization.NumberFormatInfo> objeto que fornece informações de formatação numérica.  
  
-   Um <xref:System.Globalization.NumberFormatInfo> objeto que fornece informações de formatação. (Sua implementação de <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> retorna apenas ele próprio.)  
  
-   Um objeto personalizado que implementa <xref:System.IFormatProvider> e usa o <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> método para instanciar e retornar o <xref:System.Globalization.NumberFormatInfo> objeto que fornece informações de formatação.  
  
 Caso `provider` seja `null`, o objeto <xref:System.Globalization.NumberFormatInfo> da cultura atual é usado.  
  
   
  
## Examples  
 O exemplo a seguir faz várias chamadas para o <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> método usando várias combinações de valores para o `style` e `provider` parâmetros.  
  
 [!code-csharp[System.Numerics.BigInteger.Parse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/cs/Parse1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.Parse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/vb/Parse1.vb#2)]  
  
 Um número de chamadas individuais para o <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> método passar uma instância das seguintes `BigIntegerFormatProvider` classe, que define um til (~) como o sinal negativo.  
  
 [!code-csharp[System.Numerics.BigInteger.Parse#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/cs/Parse1.cs#4)]
 [!code-vb[System.Numerics.BigInteger.Parse#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/vb/Parse1.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="style" /> não é um valor <see cref="T:System.Globalization.NumberStyles" />.  
  
- ou - 
 <paramref name="style" /> inclui o sinalizador <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" /> ou <see cref="F:System.Globalization.NumberStyles.HexNumber" /> em conjunto com outro valor.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> é <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="value" /> não é compatível com o padrão de entrada especificado por <paramref name="style" />.</exception>
        <altmember cref="Overload:System.Numerics.BigInteger.TryParse" />
      </Docs>
    </Member>
    <Member MemberName="Pow">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Pow (System.Numerics.BigInteger value, int exponent);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Pow(valuetype System.Numerics.BigInteger value, int32 exponent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Pow(System.Numerics.BigInteger,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Pow (value As BigInteger, exponent As Integer) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Pow(System::Numerics::BigInteger value, int exponent);" />
      <MemberSignature Language="F#" Value="static member Pow : System.Numerics.BigInteger * int -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Pow (value, exponent)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
        <Parameter Name="exponent" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">O número a ser elevado à potência <paramref name="exponent" />.</param>
        <param name="exponent">O expoente pelo qual <paramref name="value" /> será elevado.</param>
        <summary>Gera um valor <see cref="T:System.Numerics.BigInteger" /> à potência de um valor especificado.</summary>
        <returns>O resultado da elevação <paramref name="value" /> para a potência <paramref name="exponent" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Numerics.BigInteger.Pow%2A> método retornará 1 se o valor do parâmetro expoente é 0, ou se os valores de ambos os `value` e `exponent` parâmetros são 0. Se `exponent` for 1, o <xref:System.Numerics.BigInteger.Pow%2A> retorno do método `value`. Se `value` é negativo, o método retorna um resultado negativo.  
  
 Esse método corresponde à <xref:System.Math.Pow%2A?displayProperty=nameWithType> método para tipos numéricos primitivos.  
  
   
  
## Examples  
 O exemplo a seguir ilustra o uso de exponenciação um <xref:System.Numerics.BigInteger> valor e um expoente cujo valor varia de 0 a 10.  
  
 [!code-csharp[System.Numeric.BigInteger.Class#32](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#32)]
 [!code-vb[System.Numeric.BigInteger.Class#32](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#32)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="exponent" /> é negativo.</exception>
      </Docs>
    </Member>
    <Member MemberName="Remainder">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Remainder (System.Numerics.BigInteger dividend, System.Numerics.BigInteger divisor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Remainder(valuetype System.Numerics.BigInteger dividend, valuetype System.Numerics.BigInteger divisor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Remainder(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Remainder (dividend As BigInteger, divisor As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Remainder(System::Numerics::BigInteger dividend, System::Numerics::BigInteger divisor);" />
      <MemberSignature Language="F#" Value="static member Remainder : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Remainder (dividend, divisor)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dividend" Type="System.Numerics.BigInteger" />
        <Parameter Name="divisor" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="dividend">O valor a ser dividido.</param>
        <param name="divisor">O valor pelo qual dividir.</param>
        <summary>Executa a divisão do inteiro em dois valores <see cref="T:System.Numerics.BigInteger" /> e retorna o restante.</summary>
        <returns>O resto após dividir <paramref name="dividend" /> por <paramref name="divisor" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O sinal do resto é o sinal do `dividend` parâmetro.  
  
 O <xref:System.Numerics.BigInteger.Remainder%2A> método é implementado para idiomas que não dão suporte a operadores personalizados. Seu comportamento é idêntico à divisão usando o operador de módulo.  
  
 Se necessário, o método executa automaticamente a conversão implícita de outros tipos integrais para <xref:System.Numerics.BigInteger> objetos antes de executar a operação de módulo.  
  
   
  
## Examples  
 O exemplo a seguir compara o restante dos <xref:System.Numerics.BigInteger.DivRem%2A> método com o restante retornado pelo <xref:System.Numerics.BigInteger.Remainder%2A> método para estabelecer que os dois métodos calculam restos idênticos.  
  
 [!code-csharp[System.Numerics.BigInteger.Remainder#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Remainder/cs/Remainder1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Remainder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Remainder/vb/Remainder1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException"><paramref name="divisor" /> é 0 (zero).</exception>
        <altmember cref="M:System.Numerics.BigInteger.DivRem(System.Numerics.BigInteger,System.Numerics.BigInteger,System.Numerics.BigInteger@)" />
        <altmember cref="M:System.Numerics.BigInteger.op_Modulus(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="Sign">
      <MemberSignature Language="C#" Value="public int Sign { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Sign" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.Sign" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Sign As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Sign { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Sign : int" Usage="System.Numerics.BigInteger.Sign" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um número que indica o sinal (negativo, positivo ou zero) do objeto <see cref="T:System.Numerics.BigInteger" /> atual.</summary>
        <value>Um número que indica o sinal do objeto <see cref="T:System.Numerics.BigInteger" />, conforme mostrado na tabela a seguir.  
  
 <list type="table"><listheader><term> Número 
 </term><description> Descrição 
 </description></listheader><item><term> -1 
 </term><description> O valor desse objeto é negativo.  
  
 </description></item><item><term> 0 
 </term><description> O valor desse objeto é 0 (zero).  
  
 </description></item><item><term> 1 
 </term><description> O valor desse objeto é positivo.  
  
 </description></item></list></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Numerics.BigInteger.Sign%2A> propriedade é equivalente de <xref:System.Math.Sign%2A?displayProperty=nameWithType> método para os tipos numéricos primitivos.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Subtract">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Subtract (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Subtract(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Subtract(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Subtract (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Subtract(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member Subtract : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Subtract (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">O valor do qual um valor será subtraído (o minuendo).</param>
        <param name="right">O valor a ser subtraído (o subtraendo).</param>
        <summary>Subtrai um valor <see cref="T:System.Numerics.BigInteger" /> de outro e retorna o resultado.</summary>
        <returns>O resultado da subtração de <paramref name="right" /> de <paramref name="left" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Idiomas que não dão suporte a operadores personalizados podem usar o <xref:System.Numerics.BigInteger.Subtract%2A> método para executar a subtração usando <xref:System.Numerics.BigInteger> valores.  
  
 O <xref:System.Numerics.BigInteger.Subtract%2A> método é um substituto úteis para o operador de subtração ao instanciar um <xref:System.Numerics.BigInteger> variável atribuindo-a diferença que resulta da subtração, como mostrado no exemplo a seguir.  
  
 [!code-csharp[System.Numerics.BigInteger.OperationMethods#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/cs/Multiply1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.OperationMethods#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/vb/Multiply1.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_Subtraction(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="System.IComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IComparable.CompareTo (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IComparable.CompareTo(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.System#IComparable#CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function CompareTo (obj As Object) As Integer Implements IComparable.CompareTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IComparable.CompareTo(System::Object ^ obj) = IComparable::CompareTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToByteArray">
      <MemberSignature Language="C#" Value="public byte[] ToByteArray ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] ToByteArray() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ToByteArray" />
      <MemberSignature Language="VB.NET" Value="Public Function ToByteArray () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ ToByteArray();" />
      <MemberSignature Language="F#" Value="member this.ToByteArray : unit -&gt; byte[]" Usage="bigInteger.ToByteArray " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Converte um valor de <see cref="T:System.Numerics.BigInteger" /> em uma matriz de bytes.</summary>
        <returns>O valor do objeto <see cref="T:System.Numerics.BigInteger" /> atual convertido em uma matriz de bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Os bytes individuais na matriz retornada por esse método aparecem em ordem little endian. Ou seja, os bytes de ordem inferior do valor de precedência sobre os bytes de ordem superior. O primeiro byte da matriz reflete os primeiros oito bits do <xref:System.Numerics.BigInteger> valor, o segundo byte reflete o próximo oito bits e assim por diante. Por exemplo, o valor 1024 ou 0x0400, é armazenada como a seguinte matriz de dois bytes:  
  
|Elemento|Valor de byte|  
|-------------|----------------|  
|0|0x00|  
|1|0x04|  
  
 Valores negativos são gravados para a matriz usando a representação de complemento de dois da possível de forma mais compacta. Por exemplo, -1 é representado como um único byte cujo valor é `0xFF` em vez de como uma matriz com vários elementos, tais como `0xFF`, `0xFF` ou `0xFF`, `0xFF`, `0xFF`, `0xFF`.  
  
 Porque do complemento de dois representação sempre interpreta o bit de ordem mais alta do último byte na matriz (o byte na posição <xref:System.Array.Length%2A?displayProperty=nameWithType> `- 1`) como o bit de sinal, o método retorna uma matriz de bytes com um elemento adicional, cujo valor é zero para resolver a ambiguidade de valores positivos que caso contrário, podem ser interpretados como tendo os bits de entrada definido. Por exemplo, o valor de 120 ou `0x78` é representada como uma matriz de byte único: `0x78`. No entanto, 128, ou `0x80`, é representado como uma matriz de dois bytes: `0x80`, `0x00`.  
  
 Você pode ir e voltar uma <xref:System.Numerics.BigInteger> valor armazenando-o para uma matriz de bytes e, em seguida, restaurá-lo usando o <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> construtor.  
  
> [!CAUTION]
>  Se seu código modifica o valor de bytes individuais na matriz retornada por esse método antes de ele restaura o valor, certifique-se de que você não altere acidentalmente o bit de sinal. Por exemplo, se suas modificações aumentam um valor positivo, de modo que o bit de ordem mais alta no último elemento da matriz de bytes torna-se definido, que você pode adicionar uma nova cujo valor é zero para o final da matriz de bytes.  
  
   
  
## Examples  
 O exemplo a seguir ilustra como algumas <xref:System.Numerics.BigInteger> valores são representados em matrizes de bytes.  
  
 [!code-csharp[System.Numerics.BigInteger.ToByteArray#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToByteArray/cs/ToByteArray1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.ToByteArray#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToByteArray/vb/ToByteArray1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToByteArray">
      <MemberSignature Language="C#" Value="public byte[] ToByteArray (bool isUnsigned = false, bool isBigEndian = false);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] ToByteArray(bool isUnsigned, bool isBigEndian) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ToByteArray(System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToByteArray (Optional isUnsigned As Boolean = false, Optional isBigEndian As Boolean = false) As Byte()" />
      <MemberSignature Language="F#" Value="member this.ToByteArray : bool * bool -&gt; byte[]" Usage="bigInteger.ToByteArray (isUnsigned, isBigEndian)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="isUnsigned" Type="System.Boolean" />
        <Parameter Name="isBigEndian" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="isUnsigned">To be added.</param>
        <param name="isBigEndian">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Converte o valor numérico do objeto <see cref="T:System.Numerics.BigInteger" /> atual na representação da cadeia de caracteres equivalente.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="bigInteger.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Converte o valor numérico do objeto <see cref="T:System.Numerics.BigInteger" /> atual na representação da cadeia de caracteres equivalente.</summary>
        <returns>Uma representação de cadeia de caracteres do valor <see cref="T:System.Numerics.BigInteger" /> atual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Numerics.BigInteger.ToString> formatos do método um <xref:System.Numerics.BigInteger> valor em "R" ou ida e volta, formato da cultura atual. Se você quiser especificar um formato diferente ou uma cultura, use as outras sobrecargas do <xref:System.Numerics.BigInteger.ToString%2A> método, da seguinte maneira:  
  
|Para usar o formato|Para a cultura|Use a sobrecarga|  
|-------------------|-----------------|----------------------|  
|Formato de round-trip ("R")|Uma cultura específica|<xref:System.Numerics.BigInteger.ToString%2A>|  
|Um formato específico|Padrão de cultura (atual)|<xref:System.Numerics.BigInteger.ToString%28System.String%29>|  
|Um formato específico|Uma cultura específica|<xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 A representação de cadeia de caracteres da <xref:System.Numerics.BigInteger> valor inclui um sinal negativo se o valor for negativo e uma sequência de dígitos, variando de 0 a 9 sem zeros à esquerda. O sinal de negativo é definido pelo <xref:System.Globalization.NumberFormatInfo> objeto para a cultura atual.  
  
   
  
## Examples  
 O exemplo a seguir exibe uma <xref:System.Numerics.BigInteger> valor, usando o padrão <xref:System.Numerics.BigInteger.ToString> método. Ele também exibe as representações de cadeia de caracteres da <xref:System.Numerics.BigInteger> valor resultante do uso de alguns especificadores de formato padrão. Os exemplos são exibidos usando-se as convenções de formatação da cultura en-US.  
  
 [!code-csharp[System.Numerics.BigInteger.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToString/cs/ToString1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToString/vb/ToString1.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Cadeias de caracteres de formato numérico padrão</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Cadeias de caracteres de formato numérico personalizado</related>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : IFormatProvider -&gt; string" Usage="bigInteger.ToString provider" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Um objeto que fornece informações de formatação específicas de cultura.</param>
        <summary>Converte o valor numérico do objeto <see cref="T:System.Numerics.BigInteger" /> atual em sua representação de cadeia de caracteres equivalente usando as informações especificadas de formatação específicas de cultura.</summary>
        <returns>A representação de cadeia de caracteres do valor <see cref="T:System.Numerics.BigInteger" /> atual no formato especificado pelo parâmetro <paramref name="provider" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Numerics.BigInteger.ToString%28System.IFormatProvider%29> formatos do método uma <xref:System.Numerics.BigInteger> valor em "R", ou ida e volta, formatar usando a <xref:System.Globalization.NumberFormatInfo> objeto de uma cultura específica. Se você quiser especificar um formato diferente ou a cultura atual, use as outras sobrecargas do <xref:System.Numerics.BigInteger.ToString%2A> método, da seguinte maneira:  
  
|Para usar o formato|Para a cultura|Use a sobrecarga|  
|-------------------|-----------------|----------------------|  
|Formato de round-trip ("R")|Padrão de cultura (atual)|<xref:System.Numerics.BigInteger.ToString>|  
|Um formato específico|Padrão de cultura (atual)|<xref:System.Numerics.BigInteger.ToString%28System.String%29>|  
|Um formato específico|Uma cultura específica|<xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 O parâmetro `provider` é uma implementação de <xref:System.IFormatProvider>. O método <xref:System.IFormatProvider.GetFormat%2A> retorna um objeto <xref:System.Globalization.NumberFormatInfo> que fornece informações específicas de cultura sobre o formato da cadeia de caracteres retornada por esse método. Se `provider` está `null`, o <xref:System.Numerics.BigInteger> valor é formatado usando o <xref:System.Globalization.NumberFormatInfo> objeto da cultura atual. A única propriedade do <xref:System.Globalization.NumberFormatInfo> objeto que controla a representação de cadeia de caracteres da <xref:System.Numerics.BigInteger> valor usando o especificador de formato geral é <xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType>, que define o caractere que representa o sinal negativo.  
  
 O parâmetro `provider` pode ser um dos seguintes:  
  
-   Um objeto <xref:System.Globalization.CultureInfo> que representa a cultura que fornece informações de formatação.  
  
-   O objeto <xref:System.Globalization.NumberFormatInfo> que fornece informações de formatação.  
  
-   Um objeto personalizado que implementa <xref:System.IFormatProvider>. O método <xref:System.IFormatProvider.GetFormat%2A> retorna o objeto <xref:System.Globalization.NumberFormatInfo> que fornece informações de formatação.  
  
   
  
## Examples  
 O exemplo a seguir cria uma instância de um personalizado <xref:System.Globalization.NumberFormatInfo> objeto que define o til (~) como um sinal negativo. O <xref:System.Numerics.BigInteger.ToString%28System.IFormatProvider%29> método, em seguida, usa o personalizado <xref:System.Globalization.NumberFormatInfo> objeto para exibir um negativo <xref:System.Numerics.BigInteger> valor.  
  
 [!code-csharp[System.Numeric.BigInteger.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.ToString/cs/System.Numeric.BigInteger.ToString.cs#1)]
 [!code-vb[System.Numeric.BigInteger.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.ToString/vb/System.Numeric.BigInteger.ToString.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(string format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ToString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(System::String ^ format);" />
      <MemberSignature Language="F#" Value="override this.ToString : string -&gt; string" Usage="bigInteger.ToString format" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="format">Uma cadeia de caracteres padrão ou de formato numérico personalizado.</param>
        <summary>Converte o valor numérico do objeto <see cref="T:System.Numerics.BigInteger" /> atual para sua representação de cadeia de caracteres equivalente usando o formato especificado.</summary>
        <returns>A representação de cadeia de caracteres do valor <see cref="T:System.Numerics.BigInteger" /> atual no formato especificado pelo parâmetro <paramref name="format" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Numerics.BigInteger.ToString%28System.String%29> formatos do método uma <xref:System.Numerics.BigInteger> valor em um formato especificado usando um <xref:System.Globalization.NumberFormatInfo> objeto que representa as convenções da cultura atual. Se você quiser usar o "R" ou ida e volta, formatar ou especificar uma cultura diferente, use as outras sobrecargas de <xref:System.Numerics.BigInteger.ToString%2A> método, da seguinte maneira:  
  
|Para usar o formato|Para a cultura|Use a sobrecarga|  
|-------------------|-----------------|----------------------|  
|Formato de round-trip ("R")|Padrão de cultura (atual)|<xref:System.Numerics.BigInteger.ToString>|  
|Formato de round-trip ("R")|Uma cultura específica|<xref:System.Numerics.BigInteger.ToString%28System.IFormatProvider%29>|  
|Um formato específico|Uma cultura específica|<xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 O `format` parâmetro pode ser qualquer [cadeia de caracteres numérica padrão](~/docs/standard/base-types/standard-numeric-format-strings.md), ou qualquer combinação [cadeias de caracteres de formato numérico personalizado](~/docs/standard/base-types/custom-numeric-format-strings.md). Se `format` é igual a <xref:System.String.Empty?displayProperty=nameWithType> ou está `null`, o valor de retorno do atual <xref:System.Numerics.BigInteger> objeto é formatado com o especificador de formato de ida e volta ("R"). Caso `format` tenha qualquer outro valor, o método lança um <xref:System.FormatException>.  
  
 O .NET Framework fornece extenso suporte à formatação, que é descrito com mais detalhes nos seguintes tópicos de formatação:  
  
-   Para obter mais informações sobre especificadores de formato numérico, consulte [cadeias de caracteres de formato numérico padrão](~/docs/standard/base-types/standard-numeric-format-strings.md) e [às cadeias de caracteres de formato numérico personalizado](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Para obter mais informações sobre o suporte para formatação no .NET Framework, consulte [tipos de formatação](~/docs/standard/base-types/formatting-types.md).  
  
 O formato da cadeia de caracteres retornada é determinado pelo objeto <xref:System.Globalization.NumberFormatInfo> para a cultura atual. Dependendo do parâmetro `format`, esse objeto controla símbolos como o sinal negativo, o separador do grupo e o símbolo da vírgula decimal na cadeia de caracteres de saída. Para fornecer informações de formatação para culturas diferentes da cultura atual, chame o <xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29> de sobrecarga.  
  
   
  
## Examples  
 O exemplo a seguir inicializa um <xref:System.Numerics.BigInteger> de valor e o exibe usando cada cadeia de caracteres de formato padrão e algumas cadeias de caracteres de formato personalizado.  
  
 [!code-csharp[System.Numerics.BigInteger.ToString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToString/cs/ToString1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.ToString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToString/vb/ToString1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException"><paramref name="format" /> não é uma cadeia de caracteres de formato válida.</exception>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Cadeias de caracteres de formato numérico padrão</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Cadeias de caracteres de formato numérico personalizado</related>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(string format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ToString(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String, provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(System::String ^ format, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : string * IFormatProvider -&gt; string" Usage="bigInteger.ToString (format, provider)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IFormattable.ToString(System.String,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="format">Uma cadeia de caracteres padrão ou de formato numérico personalizado.</param>
        <param name="provider">Um objeto que fornece informações de formatação específicas de cultura.</param>
        <summary>Converte o valor numérico do objeto <see cref="T:System.Numerics.BigInteger" /> atual em sua representação de cadeia de caracteres equivalente usando o formato especificado e as informações de formato específicas de cultura.</summary>
        <returns>A representação de cadeia de caracteres do valor <see cref="T:System.Numerics.BigInteger" /> atual, conforme especificado pelos parâmetros <paramref name="format" /> e <paramref name="provider" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29> formatos do método uma <xref:System.Numerics.BigInteger> valor em um formato especificado usando o <xref:System.Globalization.NumberFormatInfo> objeto de uma cultura específica. Se você quiser usar o formato de ida e volta ou configurações de cultura padrão, use as outras sobrecargas do <xref:System.Numerics.BigInteger.ToString%2A> método, da seguinte maneira:  
  
|Para usar o formato|Para a cultura|Use a sobrecarga|  
|-------------------|-----------------|----------------------|  
|Formato de round-trip ("R")|Padrão de cultura (atual)|<xref:System.Numerics.BigInteger.ToString>|  
|Formato de round-trip ("R")|Uma cultura específica|<xref:System.Numerics.BigInteger.ToString%28System.IFormatProvider%29>|  
|Um formato específico|Padrão de cultura (atual)|<xref:System.Numerics.BigInteger.ToString%28System.String%29>|  
  
 O `format` parâmetro pode ser qualquer [cadeia de caracteres numérica padrão](~/docs/standard/base-types/standard-numeric-format-strings.md), ou qualquer combinação [cadeias de caracteres de formato numérico personalizado](~/docs/standard/base-types/custom-numeric-format-strings.md). Se `format` é igual a <xref:System.String.Empty?displayProperty=nameWithType> ou está `null`, o valor de retorno do atual <xref:System.Numerics.BigInteger> objeto é formatado com o especificador de formato de ida e volta ("R"). Caso `format` tenha qualquer outro valor, o método lança um <xref:System.FormatException>.  
  
 O .NET Framework fornece extenso suporte à formatação, que é descrito com mais detalhes nos seguintes tópicos de formatação:  
  
-   Para obter mais informações sobre especificadores de formato numérico, consulte [cadeias de caracteres de formato numérico padrão](~/docs/standard/base-types/standard-numeric-format-strings.md) e [às cadeias de caracteres de formato numérico personalizado](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Para obter mais informações sobre o suporte para formatação no .NET Framework, consulte [tipos de formatação](~/docs/standard/base-types/formatting-types.md).  
  
 O parâmetro `provider` é uma implementação de <xref:System.IFormatProvider>. O método <xref:System.IFormatProvider.GetFormat%2A> retorna um objeto <xref:System.Globalization.NumberFormatInfo> que fornece informações específicas de cultura sobre o formato da cadeia de caracteres retornada por esse método. Quando o <xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29> método é invocado, ele chama o `provider` do parâmetro <xref:System.IFormatProvider.GetFormat%2A> método e passa um <xref:System.Type> objeto que representa o <xref:System.Globalization.NumberFormatInfo> tipo. O <xref:System.IFormatProvider.GetFormat%2A> método retorna, em seguida, o <xref:System.Globalization.NumberFormatInfo> objeto que fornece informações de formatação a `value` parâmetro, como o símbolo de sinal negativo, o símbolo de separador de grupo ou o símbolo da vírgula decimal. Há três maneiras de usar o `provider` parâmetro para fornecer informações de formatação para o <xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29> método:  
  
-   É possível passar um objeto <xref:System.Globalization.CultureInfo> que representa a cultura que fornece informações de formatação. O método <xref:System.Globalization.CultureInfo.GetFormat%2A> retorna o objeto <xref:System.Globalization.NumberFormatInfo> que fornece informações de formatação numérica para essa cultura.  
  
-   É possível passar o objeto real <xref:System.Globalization.NumberFormatInfo> que fornece informações de formatação numérica. (Sua implementação de <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> retorna apenas ele próprio.)  
  
-   É possível passar um objeto personalizado que implementa <xref:System.IFormatProvider>. O método <xref:System.IFormatProvider.GetFormat%2A> cria uma instância e retorna o objeto <xref:System.Globalization.NumberFormatInfo> que fornece informações de formatação.  
  
 Caso `provider` seja `null`, a formatação da cadeia de caracteres retornada baseia-se no objeto <xref:System.Globalization.NumberFormatInfo> da cultura atual.  
  
   
  
## Examples  
 O exemplo a seguir inicializa um <xref:System.Numerics.BigInteger> de valor e o exibe no console usando uma cadeia de caracteres de formato padrão e um <xref:System.Globalization.NumberFormatInfo> objeto que define o til (~) como um sinal negativo.  
  
 [!code-csharp[System.Numerics.BigInteger.ToString#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToString/cs/ToString1.cs#4)]
 [!code-vb[System.Numerics.BigInteger.ToString#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToString/vb/ToString1.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException"><paramref name="format" /> não é uma cadeia de caracteres de formato válida.</exception>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Cadeias de caracteres de formato numérico padrão</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Cadeias de caracteres de formato numérico personalizado</related>
      </Docs>
    </Member>
    <Member MemberName="TryFormat">
      <MemberSignature Language="C#" Value="public bool TryFormat (Span&lt;char&gt; destination, out int charsWritten, ReadOnlySpan&lt;char&gt; format = null, IFormatProvider provider = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryFormat(valuetype System.Span`1&lt;char&gt; destination, [out] int32&amp; charsWritten, valuetype System.ReadOnlySpan`1&lt;char&gt; format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.TryFormat(System.Span{System.Char},System.Int32@,System.ReadOnlySpan{System.Char},System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryFormat (destination As Span(Of Char), ByRef charsWritten As Integer, Optional format As ReadOnlySpan(Of Char) = null, Optional provider As IFormatProvider = null) As Boolean" />
      <MemberSignature Language="F#" Value="member this.TryFormat : Span&lt;char&gt; *  * ReadOnlySpan&lt;char&gt; * IFormatProvider -&gt; bool" Usage="bigInteger.TryFormat (destination, charsWritten, format, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" />
        <Parameter Name="charsWritten" Type="System.Int32" RefType="out" />
        <Parameter Name="format" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="destination">To be added.</param>
        <param name="charsWritten">To be added.</param>
        <param name="format">To be added.</param>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryParse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tenta converter a representação de cadeia de caracteres de seu equivalente de <see cref="T:System.Numerics.BigInteger" /> e retorna um valor que indica se a conversão foi bem-sucedida.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; value, out System.Numerics.BigInteger result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; value, [out] valuetype System.Numerics.BigInteger&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.TryParse(System.ReadOnlySpan{System.Char},System.Numerics.BigInteger@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (value As ReadOnlySpan(Of Char), ByRef result As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; value, [Runtime::InteropServices::Out] System::Numerics::BigInteger % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : ReadOnlySpan&lt;char&gt; *  -&gt; bool" Usage="System.Numerics.BigInteger.TryParse (value, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="result" Type="System.Numerics.BigInteger" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string value, out System.Numerics.BigInteger result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string value, [out] valuetype System.Numerics.BigInteger&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.TryParse(System.String,System.Numerics.BigInteger@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (value As String, ByRef result As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ value, [Runtime::InteropServices::Out] System::Numerics::BigInteger % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : string *  -&gt; bool" Usage="System.Numerics.BigInteger.TryParse (value, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="result" Type="System.Numerics.BigInteger" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value">A representação de cadeia de caracteres de um número.</param>
        <param name="result">Quando este método retorna, ele contém o <see cref="T:System.Numerics.BigInteger" /> equivalente ao número contido em <paramref name="value" /> ou zero (0) quando a conversão falha. A conversão falhará se o parâmetro de <paramref name="value" /> for <see langword="null" /> ou não estiver no formato correto. Este parâmetro é passado não inicializado.</param>
        <summary>Tenta converter a representação de cadeia de caracteres de seu equivalente de <see cref="T:System.Numerics.BigInteger" /> e retorna um valor que indica se a conversão foi bem-sucedida.</summary>
        <returns><see langword="true" /> caso <paramref name="value" /> tenha sido convertido com êxito; do contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Numerics.BigInteger%40%29> método é como o <xref:System.Numerics.BigInteger.Parse%28System.String%29> método, exceto que ele não gerará uma exceção se a conversão falhar. Esse método elimina a necessidade de usar o tratamento de exceções para testar se um <xref:System.FormatException> se `value` é inválido e não pode ser analisado com êxito.  
  
 O parâmetro `value` deve ser a representação da cadeia de caracteres de um número decimal na seguinte forma:  
  
 [*ws*][*sign*]*digits*[*ws*]  
  
 Os elementos entre colchetes ([ e ]) são opcionais. A tabela a seguir descreve cada elemento.  
  
|Elemento|Descrição|  
|-------------|-----------------|  
|*ws*|Espaço em branco opcional.|  
|*sign*|Um sinal opcional. Os caracteres de sinal válido são determinados pelas propriedades <xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType> e <xref:System.Globalization.NumberFormatInfo.PositiveSign%2A?displayProperty=nameWithType> da cultura atual.|  
|*digits*|Uma sequência de dígitos decimais que varia de 0 a 9.|  
  
> [!NOTE]
>  A cadeia de caracteres especificada pelo `value` parâmetro não pode conter qualquer separadores de grupo ou o separador decimal e ele não pode ter uma parte decimal.  
  
 O parâmetro `value` é interpretado usando-se o estilo <xref:System.Globalization.NumberStyles.Integer?displayProperty=nameWithType>. Além dos dígitos decimais, apenas os espaço à esquerda e à direita com um sinal à esquerda são permitidos. Para definir explicitamente os elementos de estilo com as informações de formatação específicas da cultura podem estar presentes em `value`, chame o <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29> método.  
  
 O `value` parâmetro é analisado usando as informações de formatação em um <xref:System.Globalization.NumberFormatInfo> objeto para a cultura atual. Para obter mais informações, consulte <xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A?displayProperty=nameWithType>.  
  
 Essa sobrecarga interpreta todos os dígitos no `value` parâmetro como dígitos decimais. Para analisar a representação de cadeia de caracteres de um número hexadecimal, chame o <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29> sobrecarga em vez disso.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Numerics.BigInteger%40%29> método para instanciar dois <xref:System.Numerics.BigInteger> objetos. Se as conversões tiverem êxito, ele multiplica cada objeto por outro número e, em seguida, chama o <xref:System.Numerics.BigInteger.Compare%2A> método para determinar a relação entre os dois objetos.  
  
 [!code-csharp[System.Numeric.BigInteger.TryParse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.TryParse/cs/System.Numeric.BigInteger.TryParse.cs#1)]
 [!code-vb[System.Numeric.BigInteger.TryParse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.TryParse/vb/System.Numeric.BigInteger.TryParse.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> é <see langword="null" />.</exception>
        <altmember cref="M:System.Numerics.BigInteger.ToString(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; value, System.Globalization.NumberStyles style, IFormatProvider provider, out System.Numerics.BigInteger result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; value, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider, [out] valuetype System.Numerics.BigInteger&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.TryParse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (value As ReadOnlySpan(Of Char), style As NumberStyles, provider As IFormatProvider, ByRef result As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; value, System::Globalization::NumberStyles style, IFormatProvider ^ provider, [Runtime::InteropServices::Out] System::Numerics::BigInteger % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : ReadOnlySpan&lt;char&gt; * System.Globalization.NumberStyles * IFormatProvider *  -&gt; bool" Usage="System.Numerics.BigInteger.TryParse (value, style, provider, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="result" Type="System.Numerics.BigInteger" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="style">To be added.</param>
        <param name="provider">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string value, System.Globalization.NumberStyles style, IFormatProvider provider, out System.Numerics.BigInteger result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string value, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider, [out] valuetype System.Numerics.BigInteger&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (value As String, style As NumberStyles, provider As IFormatProvider, ByRef result As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ value, System::Globalization::NumberStyles style, IFormatProvider ^ provider, [Runtime::InteropServices::Out] System::Numerics::BigInteger % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : string * System.Globalization.NumberStyles * IFormatProvider *  -&gt; bool" Usage="System.Numerics.BigInteger.TryParse (value, style, provider, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="result" Type="System.Numerics.BigInteger" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value">A representação de cadeia de caracteres de um número. A cadeia de caracteres é interpretada usando-se o estilo especificado por <paramref name="style" />.</param>
        <param name="style">Um combinação bit a bit de valores de enumeração que indica os elementos de estilo que podem estar presentes em <paramref name="value" />. Um valor típico a ser especificado é <see cref="F:System.Globalization.NumberStyles.Integer" />.</param>
        <param name="provider">Um objeto que fornece informações de formatação específicas de cultura sobre <paramref name="value" />.</param>
        <param name="result">Quando esse método é retornado, contém o equivalente <see cref="T:System.Numerics.BigInteger" /> do número contido em <paramref name="value" /> ou <see cref="P:System.Numerics.BigInteger.Zero" /> se a conversão falhou. A conversão falhará se o parâmetro <paramref name="value" /> for <see langword="null" /> ou não estiver em um formato em conformidade com <paramref name="style" />. Este parâmetro é passado não inicializado.</param>
        <summary>Tenta converter a representação de cadeia de caracteres de um número em um estilo e formato específico à cultura especificados no equivalente <see cref="T:System.Numerics.BigInteger" /> e retorna um valor que indica se a conversão foi bem-sucedida.</summary>
        <returns><see langword="true" /> caso o parâmetro <paramref name="value" /> tenha sido convertido com êxito; do contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29> método é como o <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> método, exceto que ele não gerará uma exceção se a conversão falhar. Esse método elimina a necessidade de usar o tratamento de exceções para testar se um <xref:System.FormatException> se `value` é inválido e não pode ser analisado com êxito.  
  
 O parâmetro `style` define os elementos de estilo (como o espaço em branco ou um sinal positivo ou negativo) que são permitidos no parâmetro `value` para que a operação de análise seja bem-sucedida. Ele deve ser uma combinação de sinalizadores de bits da enumeração <xref:System.Globalization.NumberStyles>. Dependendo do valor de `style`, o parâmetro `value` pode incluir os seguintes elementos:  
  
 [*ws*] [*$*] [*entrada*] [*dígitos*,]*dígitos*[. *dígitos fracionários*] [E [*sinal*]*exponential_digits*] [*ws*]  
  
 Se o `style` parâmetro inclui <xref:System.Globalization.NumberStyles.AllowHexSpecifier>, o `value` parâmetro pode incluir os seguintes elementos:  
  
 [*ws*]*hexdigits*[*ws*]  
  
 Os elementos entre colchetes ([ e ]) são opcionais. A tabela a seguir descreve cada elemento.  
  
|Elemento|Descrição|  
|-------------|-----------------|  
|*ws*|Espaço em branco opcional. Espaço em branco podem aparecer no início da `value` se `style` inclui as <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> sinalizador, ou no final da `value` se `style` inclui o <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType> sinalizador.|  
|*$*|Um símbolo de moeda específico de cultura. A posição na cadeia de caracteres é definida pela propriedade <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A> do objeto <xref:System.Globalization.NumberFormatInfo> retornado pelo método <xref:System.IFormatProvider.GetFormat%2A> do parâmetro `provider`. O símbolo de moeda pode ser exibido em `value` caso `style` inclua o sinalizador <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType>.|  
|*sign*|Um sinal opcional. O sinal pode ser exibido no início de `value` caso `style` inclua o sinalizador <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType> e ele pode ser exibido no final de `value` caso `style` inclua o sinalizador <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType>. Os parênteses podem ser usados em `value` para indicar um valor negativo caso `style` inclua o sinalizador <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType>.|  
|*digits*|Uma sequência de dígitos de 0 a 9.|  
|*,*|Um separador de grupo específico de cultura. O separador de grupo da cultura especificada por `provider` pode aparecer em `value` se `style` inclui o <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> sinalizador.|  
|*.*|Um símbolo de vírgula decimal específico de cultura. O símbolo da vírgula decimal da cultura especificada por `provider` pode ser exibido em `value` caso `style` inclua o sinalizador <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType>.|  
|*fractional_digits*|Uma ou mais ocorrências de dígito 0. Os dígitos fracionários só podem ser exibidos em `value` caso `style` inclua o sinalizador <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType>.|  
|E|O caractere "e" ou "E", que indica que o valor é representado em notação exponencial (científica). O parâmetro `value` pode representar um número em notação exponencial caso `style` inclua o sinalizador <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType>.|  
|*exponential_digits*|Uma sequência de dígitos de 0 a 9. O parâmetro `value` pode representar um número em notação exponencial caso `style` inclua o sinalizador <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType>.|  
|*hexdigits*|Uma sequência de dígitos hexadecimais de 0 a f ou de 0 a F.|  
  
> [!NOTE]
> Quaisquer caracteres de (U + 0000) terminação NUL no `s` são ignorados pela operação de análise, independentemente do valor de `style` argumento.

 Uma cadeia de caracteres apenas com dígitos decimais (que corresponde ao sinalizador <xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType> ) sempre é analisada com êxito. A maioria dos elementos de controle de membros <xref:System.Globalization.NumberStyles> restantes que podem estar presentes, mas que não precisam estar presentes, na cadeia de caracteres de entrada. A tabela a seguir indica como os membros <xref:System.Globalization.NumberStyles> individuais afetam os elementos que podem estar presentes em `value`.  
  
|Valores `NumberStyles` não compostos|Elementos permitidos no valor além de dígitos|  
|------------------------------------------|-------------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|Somente dígitos decimais.|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|O ponto decimal (*.*) e *dígitos fracionários* elementos. No entanto, *fractional_digits* deve consistir em apenas um ou mais dígitos 0 ou o método retorna `false`.|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|O "e" ou o caractere "E, que indica a notação exponencial, juntamente com" *exponential_digits*. Se `value` representa um número em notação exponencial, ele não pode ter um componente diferente de zero, a fração.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|O *ws* elemento no início de `value`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|O elemento *ws* no final de `value`.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|O *sinal* elemento antes *dígitos*.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|O *sinal* elemento após *dígitos*.|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|O elemento *sinal* na forma de parênteses que incluem o valor numérico.|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|O separador de grupo (*,*) elemento.|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|A moeda (*$*) elemento.|  
|<xref:System.Globalization.NumberStyles.Currency>|Todos os elementos. No entanto, `value` não pode representar um número hexadecimal ou um número em notação exponencial.|  
|<xref:System.Globalization.NumberStyles.Float>|O *ws* elemento no início ou final do `value`, *sign* no início do `value`e o ponto decimal (*.*) símbolo. O parâmetro `value` também pode usar notação exponencial.|  
|<xref:System.Globalization.NumberStyles.Number>|O *ws*, *sinal*, separador de grupo (*,*) e o ponto decimal (*.*) elementos.|  
|<xref:System.Globalization.NumberStyles.Any>|Todos os elementos. No entanto, `value` não pode representar um número hexadecimal.|  
  
> [!IMPORTANT]
>  Se você usar o <xref:System.Numerics.BigInteger.TryParse%2A> método para a representação de cadeia de caracteres de ida e volta de um <xref:System.Numerics.BigInteger> valor que foi a saída pela <xref:System.Numerics.BigInteger.ToString%2A> método, você deve usar o <xref:System.Numerics.BigInteger.ToString%28System.String%29?displayProperty=nameWithType> método com o especificador de formato "R" para gerar a representação de cadeia de caracteres da <xref:System.Numerics.BigInteger> valor. Caso contrário, a representação de cadeia de caracteres da <xref:System.Numerics.BigInteger> preserva apenas os 50 dígitos mais significativos do valor original e os dados podem ser perdidos quando você usa o <xref:System.Numerics.BigInteger.TryParse%2A> método para restaurar o <xref:System.Numerics.BigInteger> valor.  
  
 Caso o sinalizador <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType> seja usado, `value` deve ser um valor hexadecimal. Os únicos outros sinalizadores que podem estar presentes em `style` são <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> e <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType>. (A enumeração <xref:System.Globalization.NumberStyles> tem um estilo composto, <xref:System.Globalization.NumberStyles.HexNumber>, que inclui ambos os sinalizadores de espaço em branco.)  
  
> [!NOTE]
>  Caso `value` seja a representação da cadeia de caracteres de um número hexadecimal, ele não pode ser precedido por qualquer decoração (como `0x` ou `&h`) que o diferencia como um número hexadecimal. Isso faz a conversão falhar.  
  
 Se `value` é uma cadeia de caracteres hexadecimal, o <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29> método interpreta `value` como um número negativo armazenado usando a representação de complemento de dois se seus dois primeiros dígitos hexadecimais são maiores que ou igual a `0x80`. Em outras palavras, o método interpreta o bit de ordem mais alta do primeiro byte em `value` como o bit de sinal. Para certificar-se de que uma cadeia de caracteres hexadecimal é interpretada corretamente como um número positivo, o primeiro dígito em `value` deve ter um valor igual a zero. Por exemplo, o método interpreta `0x80` como um valor negativo, mas ele interpreta o `0x080` ou `0x0080` como um valor positivo. O exemplo a seguir ilustra a diferença entre cadeias de caracteres hexadecimais que representam valores positivos e negativos.  
  
 [!code-csharp[System.Numerics.BigInteger.TryParse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.TryParse/cs/TryParseHex1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.TryParse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.TryParse/vb/TryParseHex1.vb#1)]  
  
 O parâmetro `provider` é uma implementação de <xref:System.IFormatProvider>. O método <xref:System.IFormatProvider.GetFormat%2A> retorna um objeto <xref:System.Globalization.NumberFormatInfo> que fornece informações específicas de cultura sobre o formato de `value`. O parâmetro `provider` pode ser qualquer um dos seguintes:  
  
-   Um objeto <xref:System.Globalization.CultureInfo> que representa a cultura que fornece informações de formatação. O método <xref:System.Globalization.CultureInfo.GetFormat%2A> retorna o objeto <xref:System.Globalization.NumberFormatInfo> que fornece informações de formatação numérica para essa cultura.  
  
-   Um objeto <xref:System.Globalization.NumberFormatInfo> que fornece informações de formatação numérica. (Sua implementação de <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> retorna apenas ele próprio.)  
  
-   Um objeto personalizado que implementa <xref:System.IFormatProvider>. O método <xref:System.IFormatProvider.GetFormat%2A> cria uma instância e retorna o objeto <xref:System.Globalization.NumberFormatInfo> que fornece informações de formatação.  
  
 Caso `provider` seja `null`, o objeto <xref:System.Globalization.NumberFormatInfo> da cultura atual é usado.  
  
   
  
## Examples  
 O exemplo a seguir faz algumas chamadas para o <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29> método usando várias combinações de valores para o `style` e `provider` parâmetros.  
  
 [!code-csharp[System.Numerics.BigInteger.TryParse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.TryParse/cs/TryParse1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.TryParse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.TryParse/vb/TryParse1.vb#2)]  
  
 Um número de chamadas individuais para o <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29> método passar uma instância das seguintes `BigIntegerFormatProvider` classe, que define um til (~) como o sinal negativo.  
  
 [!code-csharp[System.Numerics.BigInteger.TryParse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.TryParse/cs/TryParse1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.TryParse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.TryParse/vb/TryParse1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="style" /> não é um valor <see cref="T:System.Globalization.NumberStyles" />.  
  
- ou - 
 <paramref name="style" /> inclui o sinalizador <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" /> ou <see cref="F:System.Globalization.NumberStyles.HexNumber" /> em conjunto com outro valor.</exception>
        <altmember cref="Overload:System.Numerics.BigInteger.ToString" />
      </Docs>
    </Member>
    <Member MemberName="TryWriteBytes">
      <MemberSignature Language="C#" Value="public bool TryWriteBytes (Span&lt;byte&gt; destination, out int bytesWritten, bool isUnsigned = false, bool isBigEndian = false);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryWriteBytes(valuetype System.Span`1&lt;unsigned int8&gt; destination, [out] int32&amp; bytesWritten, bool isUnsigned, bool isBigEndian) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.TryWriteBytes(System.Span{System.Byte},System.Int32@,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryWriteBytes (destination As Span(Of Byte), ByRef bytesWritten As Integer, Optional isUnsigned As Boolean = false, Optional isBigEndian As Boolean = false) As Boolean" />
      <MemberSignature Language="F#" Value="member this.TryWriteBytes : Span&lt;byte&gt; *  * bool * bool -&gt; bool" Usage="bigInteger.TryWriteBytes (destination, bytesWritten, isUnsigned, isBigEndian)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="bytesWritten" Type="System.Int32" RefType="out" />
        <Parameter Name="isUnsigned" Type="System.Boolean" />
        <Parameter Name="isBigEndian" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="destination">To be added.</param>
        <param name="bytesWritten">To be added.</param>
        <param name="isUnsigned">To be added.</param>
        <param name="isBigEndian">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Zero">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Zero { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Numerics.BigInteger Zero" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.Zero" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Zero As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Numerics::BigInteger Zero { System::Numerics::BigInteger get(); };" />
      <MemberSignature Language="F#" Value="member this.Zero : System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Zero" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que representa o número 0 (zero).</summary>
        <value>Um inteiro cujo valor é 0 (zero).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Numerics.BigInteger> objeto retornado por essa propriedade fornece uma fonte conveniente de um valor de zero para uso em comparações e atribuições.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.BigInteger.IsZero" />
      </Docs>
    </Member>
  </Members>
</Type>