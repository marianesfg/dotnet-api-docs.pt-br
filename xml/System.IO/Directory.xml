<Type Name="Directory" FullName="System.IO.Directory">
  <Metadata><Meta Name="ms.openlocfilehash" Value="44209ba33e15ee4058f21b09c8012e7d58e23cbc" /><Meta Name="ms.sourcegitcommit" Value="9e3550fb2088d4faf2043f0acb29da4555519937" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="pt-BR" /><Meta Name="ms.lasthandoff" Value="12/12/2018" /><Meta Name="ms.locfileid" Value="53299460" /></Metadata><TypeSignature Language="C#" Value="public static class Directory" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Directory extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.IO.Directory" />
  <TypeSignature Language="VB.NET" Value="Public Class Directory" />
  <TypeSignature Language="C++ CLI" Value="public ref class Directory abstract sealed" />
  <TypeSignature Language="F#" Value="type Directory = class" />
  <AssemblyInfo>
    <AssemblyName>System.IO.FileSystem</AssemblyName>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Expõe métodos estáticos para criar, mover e enumerar em diretórios e subdiretórios. Essa classe não pode ser herdada.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use o <xref:System.IO.Directory> classe para operações comuns, como copiar, mover, renomear, criando e excluindo diretórios.  
  
-   Para criar um diretório, use um do <xref:System.IO.Directory.CreateDirectory%2A> métodos.  
  
-   Para excluir um diretório, use um do <xref:System.IO.Directory.Delete%2A> métodos.  
  
-   Para obter ou definir o diretório atual para um aplicativo, use o <xref:System.IO.Directory.GetCurrentDirectory%2A> ou <xref:System.IO.Directory.SetCurrentDirectory%2A> método.  
  
-   Para manipular <xref:System.DateTime> informações relacionadas à criação, acesso e a gravação de um diretório, usam os métodos, como <xref:System.IO.Directory.SetLastAccessTime%2A> e <xref:System.IO.Directory.SetCreationTime%2A>.  
  
 Os métodos estáticos do <xref:System.IO.Directory> classe executar verificações de segurança em todos os métodos. Se você for reutilizar um objeto várias vezes, considere usar o método de instância correspondente do <xref:System.IO.DirectoryInfo> em vez disso, porque a verificação de segurança do será nem sempre seja necessário.  
  
 Se você estiver executando apenas uma ação relacionada ao diretório, talvez seja mais eficiente usar estático <xref:System.IO.Directory> método em vez de um correspondente <xref:System.IO.DirectoryInfo> um método de instância. A maioria dos <xref:System.IO.Directory> métodos requerem o caminho para o diretório que você está manipulando.  
  
> [!NOTE]
>  Em membros que aceitam uma cadeia de caracteres `path` parâmetro, esse caminho deve ser bem formado ou uma exceção será gerada. Por exemplo, se um caminho totalmente qualificado, mas começa com um espaço ("c:\temp"), a cadeia de caracteres de caminho não é cortada, portanto, o caminho é considerado mal formado e uma exceção será gerada. Além disso, um caminho ou uma combinação de caminhos não pode ser totalmente qualificada duas vezes. Por exemplo, "c:\windows c:\temp" também gerará uma exceção. Certifique-se de que seus caminhos são bem formados, ao usar os métodos que aceitam uma cadeia de caracteres de caminho. Para obter mais informações, consulte <xref:System.IO.Path>.  
  
 Em membros que aceitam um caminho, o caminho pode consultar um arquivo ou diretório. Você pode usar um caminho completo, um caminho relativo ou um caminho de convenção de nomenclatura Universal (UNC) para um nome de servidor e compartilhamento. Por exemplo, todos os itens a seguir é caminhos aceitáveis:  
  
-   "c:\\\MyDir" em c# ou "c:\MyDir" no Visual Basic.  
  
-   "MyDir\\\MySubdir" em c# ou "MyDir\MySubDir" no Visual Basic.  
  
-   "\\\\\\\MyServer\\\MyShare" no c#, ou "\\\MyServer\MyShare" no Visual Basic.  
  
 Por padrão, o acesso de leitura/gravação completa para novos diretórios é concedido a todos os usuários. No entanto, o aplicativo deve ter a segurança correta para acessar diretórios existentes.  
  
 Para solicitar permissões para um diretório e todos os seus subdiretórios, a fim de cadeia de caracteres de caminho com o caractere separador de diretório. (Por exemplo, "C:\Temp\\" concede acesso ao C:\Temp\ e todos os seus subdiretórios.) Para solicitar permissões somente para um diretório específico, a cadeia de caracteres de caminho com um ponto de término. (Por exemplo, "C:\Temp\\." concede acesso apenas a C:\Temp\\, e não seus subdiretórios.)  
  
 Em membros que aceitam um `searchPattern` parâmetro, a cadeia de caracteres de pesquisa pode ser qualquer combinação de caracteres literais e dois caracteres curinga; \* e?. Esse parâmetro não reconhece expressões regulares. Para obter mais informações, consulte o <xref:System.IO.Directory.EnumerateDirectories%28System.String%2CSystem.String%29> método ou qualquer outro método que usa o `searchPattern` parâmetro.  
  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
 <xref:System.IO.Directory> e <xref:System.IO.DirectoryInfo> não há suporte para uso em [!INCLUDE[win8_appstore_long](~/includes/win8-appstore-long-md.md)] aplicativos. Para obter informações sobre como acessar arquivos e pastas no [!INCLUDE[win8_appstore_long](~/includes/win8-appstore-long-md.md)] aplicativos, consulte [acesso a dados e arquivos (aplicativos da Windows Store)](https://msdn.microsoft.com/library/windows/apps/hh758319.aspx).  
  
   
  
## Examples  
 O exemplo a seguir mostra como recuperar todos os arquivos de texto de um diretório e movê-los para um novo diretório. Depois que os arquivos são movidos, eles não existem mais no diretório original.  
  
 [!code-csharp[System.IO.Directory#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class2.cs#10)]
 [!code-vb[System.IO.Directory#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class2.vb#10)]  
  
 O exemplo a seguir demonstra como usar o <xref:System.IO.Directory.EnumerateFiles%2A> método para recuperar uma coleção de arquivos de texto de um diretório e, em seguida, usar essa coleção em uma consulta para localizar todas as linhas que contêm "Exemplo".  
  
 [!code-csharp[System.IO.Directory#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class3.cs#11)]
 [!code-vb[System.IO.Directory#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class3.vb#11)]  
  
 O exemplo a seguir demonstra como mover um diretório e todos os seus arquivos para um novo diretório. O diretório original não existe mais depois que ele foi movido.  
  
 [!code-csharp[System.IO.Directory#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class6.cs#14)]
 [!code-vb[System.IO.Directory#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class6.vb#14)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.IO.DriveInfo" />
    <altmember cref="T:System.IO.File" />
    <altmember cref="T:System.IO.DirectoryInfo" />
    <altmember cref="T:System.IO.FileInfo" />
    <altmember cref="T:System.IO.FileSystemWatcher" />
    <related type="Article" href="~/docs/standard/io/index.md">E/S de arquivo e de fluxo</related>
    <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Como ler texto de um arquivo</related>
    <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Como gravar texto em um arquivo</related>
    <related type="Article" href="~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md">Como ler e gravar em um arquivo de dados recém-criado</related>
  </Docs>
  <Members>
    <MemberGroup MemberName="CreateDirectory">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Cria todos os diretórios em um caminho especificado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateDirectory">
      <MemberSignature Language="C#" Value="public static System.IO.DirectoryInfo CreateDirectory (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.DirectoryInfo CreateDirectory(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.CreateDirectory(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDirectory (path As String) As DirectoryInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::DirectoryInfo ^ CreateDirectory(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member CreateDirectory : string -&gt; System.IO.DirectoryInfo" Usage="System.IO.Directory.CreateDirectory path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">O diretório a ser criado.</param>
        <summary>Cria todos os diretórios e subdiretórios no caminho especificado, a menos que eles já existam.</summary>
        <returns>Um objeto que representa o diretório no caminho especificado. Esse objeto é retornado, independentemente se já existir um diretório no caminho especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Todos os diretórios especificados em `path` são criados, a menos que elas já existem ou a menos que alguma parte do `path` é inválido. Se o diretório já existir, esse método não cria um novo diretório, mas ele retorna um <xref:System.IO.DirectoryInfo> objeto para o diretório existente.  
  
 O `path` parâmetro especifica um caminho de diretório, não um caminho de arquivo.  
  
 Espaços à direita são removidos do final do `path` parâmetro antes de criar o diretório.  
  
 Você pode criar um diretório em um computador remoto, em um compartilhamento que você tem acesso de gravação. Há suporte para caminhos UNC; Por exemplo, você pode especificar o seguinte para `path`: `\\2009\Archives\December` no Visual Basic, e `\\\\2009\\Archives\\December` em c#.  
  
 Criação de um diretório com apenas o caractere dois-pontos (:) não tem suporte e fará com que um `NotSupportedException` seja lançada.  
  
   
  
## Examples  
 O exemplo a seguir cria e exclui o diretório especificado.  
  
 [!code-cpp[Dir_CreateDir#1](~/samples/snippets/cpp/VS_Snippets_CLR/Dir_CreateDir/CPP/dir_createdir.cpp#1)]
 [!code-csharp[Dir_CreateDir#1](~/samples/snippets/csharp/VS_Snippets_CLR/Dir_CreateDir/CS/dir_createdir.cs#1)]
 [!code-vb[Dir_CreateDir#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dir_CreateDir/VB/dir_createdir.vb#1)]  
  
 Para criar o diretório C:\Users\User1\Public\Html quando o diretório atual é C:\Users\User1, use qualquer uma das seguintes chamadas para garantir que a barra invertida seja interpretada corretamente.  
  
 No Visual Basic:  
  
```  
Directory.CreateDirectory("Public\Html")   
    Directory.CreateDirectory("\Users\User1\Public\Html")   
    Directory.CreateDirectory("c:\Users\User1\Public\Html")  
```  
  
 No C#:  
  
```  
Directory.CreateDirectory("Public\\Html");  
    Directory.CreateDirectory("\\Users\\User1\\Public\\Html");  
    Directory.CreateDirectory("c:\\Users\\User1\\Public\\Html");  
```  
  
 Em C++:  
  
```  
Directory::CreateDirectory("Public\\Html");  
    Directory::CreateDirectory("\\Users\\User1\\Public\\Html");  
    Directory::CreateDirectory("c:\\Users\\User1\\Public\\Html");  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">O diretório especificado por <paramref name="path" /> é um arquivo.  
  
- ou - 
O nome da rede não é conhecido.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou um ou mais caracteres inválidos. Consulte caracteres inválidos usando o método <see cref="M:System.IO.Path.GetInvalidPathChars" />.  
  
- ou - 
 <paramref name="path" /> é prefixado ou contém somente um caractere de dois-pontos (:).</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">O caminho especificado é inválido (por exemplo, ele está em uma unidade não mapeada).</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" /> contém um caractere de dois-pontos (:) que não faz parte de um rótulo da unidade (“C:\\”).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para ler e gravar arquivos ou diretórios. Enumerações associadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.DirectoryInfo" />
        <related type="Article" href="~/docs/standard/io/index.md">E/S de arquivo e de fluxo</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Como ler texto de um arquivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Como gravar texto em um arquivo</related>
      </Docs>
    </Member>
    <Member MemberName="CreateDirectory">
      <MemberSignature Language="C#" Value="public static System.IO.DirectoryInfo CreateDirectory (string path, System.Security.AccessControl.DirectorySecurity directorySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.DirectoryInfo CreateDirectory(string path, class System.Security.AccessControl.DirectorySecurity directorySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.CreateDirectory(System.String,System.Security.AccessControl.DirectorySecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::DirectoryInfo ^ CreateDirectory(System::String ^ path, System::Security::AccessControl::DirectorySecurity ^ directorySecurity);" />
      <MemberSignature Language="F#" Value="static member CreateDirectory : string * System.Security.AccessControl.DirectorySecurity -&gt; System.IO.DirectoryInfo" Usage="System.IO.Directory.CreateDirectory (path, directorySecurity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="directorySecurity" Type="System.Security.AccessControl.DirectorySecurity" />
      </Parameters>
      <Docs>
        <param name="path">O diretório a ser criado.</param>
        <param name="directorySecurity">O controle de acesso a ser aplicado ao diretório.</param>
        <summary>Cria todos os diretórios no caminho especificado, a menos que o já existir, aplicando a segurança do Windows especificada.</summary>
        <returns>Um objeto que representa o diretório no caminho especificado. Esse objeto é retornado, independentemente se já existir um diretório no caminho especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use essa sobrecarga de método para criar um diretório com controle de acesso, portanto, não há nenhuma chance de que diretório pode ser acessado antes que a segurança é aplicada.  
  
 Todos os diretórios especificados na `path` parâmetro são criados, a menos que elas já existem ou a menos que alguma parte do `path` é inválido. O `path` parâmetro especifica um caminho de diretório, não um caminho de arquivo. Se o diretório já existir, esse método não cria um novo diretório, mas ele retorna um <xref:System.IO.DirectoryInfo> objeto para o diretório existente.  
  
 Espaços à direita são removidos do final do `path` parâmetro antes de criar o diretório.  
  
 Você pode criar um diretório em um computador remoto, em um compartilhamento que você tem acesso de gravação. Há suporte para caminhos UNC; Por exemplo, você pode especificar o seguinte para `path`: `\\2009\Archives\December` no Visual Basic, e `\\\\2009\\Archives\\December` em c#.  
  
 Criar um diretório com apenas o caractere dois-pontos (:) não é suportado e faz com que um `NotSupportedException` seja lançada.  
  
   
  
## Examples  
 O exemplo a seguir cria um novo diretório com regras de acesso para duas contas de usuário.  
  
 [!code-csharp[System.IO.Directory#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class7.cs#15)]
 [!code-vb[System.IO.Directory#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class7.vb#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">O diretório especificado por <paramref name="path" /> é um arquivo.  
  
- ou - 
O nome da rede não é conhecido.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou um ou mais caracteres inválidos. Consulte caracteres inválidos usando o método <see cref="M:System.IO.Path.GetInvalidPathChars" />.  
  
- ou - 
 <paramref name="path" /> é prefixado ou contém somente um caractere de dois-pontos (:).</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">O caminho especificado é inválido (por exemplo, ele está em uma unidade não mapeada).</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" /> contém um caractere de dois-pontos (:) que não faz parte de um rótulo da unidade (“C:\\”).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para ler e gravar arquivos e diretórios e para acesso ao diretório de destino. Enumerações associadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /> ação de segurança: <see cref="F:System.Security.Permissions.SecurityAction.Demand" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Delete">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Exclui um diretório especificado e, opcionalmente, todos os subdiretórios.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static void Delete (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Delete(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.Delete(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Delete (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Delete(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member Delete : string -&gt; unit" Usage="System.IO.Directory.Delete path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">O nome do diretório vazio a ser removido. Este diretório deve estar vazio e ser gravável.</param>
        <summary>Exclui um diretório vazio de um caminho especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método se comporta de forma idêntica ao <xref:System.IO.Directory.Delete%28System.String%2CSystem.Boolean%29> com `false` especificado para o segundo parâmetro.  
  
 O `path` parâmetro pode especificar informações de caminho relativo ou absoluto. As informações do caminho relativo são interpretadas como relativas ao diretório de trabalho atual. Para obter o diretório de trabalho atual, consulte <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Espaços à direita são removidos do final do `path` parâmetro antes de excluir o diretório.  
  
 Este método lança um <xref:System.IO.IOException> se o diretório especificado no `path` parâmetro contém arquivos ou subdiretórios.  
  
 O `path` parâmetro não diferencia maiusculas de minúsculas.  
  
 Em alguns casos, se você tiver o diretório especificado abrir no Explorador de arquivos, o <xref:System.IO.Directory.Delete%2A> método pode não ser capaz de excluí-lo.  
  
   
  
## Examples  
 O exemplo a seguir mostra como criar um novo diretório e um subdiretório e, em seguida, exclua apenas o subdiretório.  
  
 [!code-csharp[System.IO.Directory.Delete#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.directory.delete/cs/class1.cs#1)]
 [!code-vb[System.IO.Directory.Delete#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.directory.delete/vb/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Já existe um arquivo com o mesmo nome e local especificado pelo <paramref name="path" />.  
  
- ou - 
O diretório é o diretório de trabalho atual do aplicativo.  
  
- ou - 
O diretório especificado por <paramref name="path" /> não está vazio.  
  
- ou - 
O diretório é somente leitura ou contém um arquivo somente leitura.  
  
- ou - 
O diretório está sendo usado por outro processo.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou um ou mais caracteres inválidos. Consulte caracteres inválidos usando o método <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException"><paramref name="path" /> não existe ou não pôde ser encontrado.  
  
- ou - 
O caminho especificado é inválido (por exemplo, ele está em uma unidade não mapeada).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para gravar no diretório especificado. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">E/S de arquivo e de fluxo</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Como ler texto de um arquivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Como gravar texto em um arquivo</related>
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static void Delete (string path, bool recursive);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Delete(string path, bool recursive) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.Delete(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Delete (path As String, recursive As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Delete(System::String ^ path, bool recursive);" />
      <MemberSignature Language="F#" Value="static member Delete : string * bool -&gt; unit" Usage="System.IO.Directory.Delete (path, recursive)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="recursive" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">O nome do diretório a ser removido.</param>
        <param name="recursive"><see langword="true" /> para remover diretórios, subdiretórios e arquivos no <paramref name="path" />; caso contrário, <see langword="false" />.</param>
        <summary>Exclui o diretório especificado e, se indicado, todos os subdiretórios e arquivos no diretório.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `path` parâmetro pode especificar informações de caminho relativo ou absoluto. As informações do caminho relativo são interpretadas como relativas ao diretório de trabalho atual. Para obter o diretório de trabalho atual, consulte <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Espaços à direita são removidos do final do `path` parâmetro antes de excluir o diretório.  
  
 O `path` parâmetro não diferencia maiusculas de minúsculas.  
  
 Se o `recursive` parâmetro é `true`, o usuário deve ter permissão de gravação para o diretório atual, bem como para todos os subdiretórios.  
  
 O comportamento desse método é ligeiramente diferente ao excluir um diretório que contém um ponto de nova análise, como um link simbólico ou um ponto de montagem. Se o ponto de nova análise é um diretório, como um ponto de montagem é desmontado, e o ponto de montagem é excluído. Esse método não é recursivo através do ponto de nova análise. Se o ponto de nova análise é um link simbólico para um arquivo, o ponto de nova análise é excluído e não o destino do link simbólico.  
  
 Em alguns casos, se você tiver o diretório especificado abrir no Explorador de arquivos, o <xref:System.IO.Directory.Delete%2A> método pode não ser capaz de excluí-lo.  
  
   
  
## Examples  
 O exemplo a seguir mostra como criar um novo diretório, o subdiretório e o arquivo na subpasta e, em seguida, excluir todos os novos itens de recursivamente.  
  
 [!code-csharp[System.IO.Directory.Delete#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.directory.delete/cs/class2.cs#2)]
 [!code-vb[System.IO.Directory.Delete#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.directory.delete/vb/class2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Já existe um arquivo com o mesmo nome e local especificado pelo <paramref name="path" />.  
  
- ou - 
O diretório especificado por <paramref name="path" /> é somente leitura, ou <paramref name="recursive" /> é <see langword="false" /> e <paramref name="path" /> não é um diretório vazio.  
  
- ou - 
O diretório é o diretório de trabalho atual do aplicativo.  
  
- ou - 
O diretório contém um arquivo somente leitura.  
  
- ou - 
O diretório está sendo usado por outro processo.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou um ou mais caracteres inválidos. Consulte caracteres inválidos usando o método <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException"><paramref name="path" /> não existe ou não pôde ser encontrado.  
  
- ou - 
O caminho especificado é inválido (por exemplo, ele está em uma unidade não mapeada).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para gravar no diretório especificado. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">E/S de arquivo e de fluxo</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Como ler texto de um arquivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Como gravar texto em um arquivo</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="EnumerateDirectories">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retorna uma coleção enumerável de nomes de diretório que atendem ao critério especificado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EnumerateDirectories">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateDirectories (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateDirectories(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateDirectories(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EnumerateDirectories (path As String) As IEnumerable(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateDirectories(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member EnumerateDirectories : string -&gt; seq&lt;string&gt;" Usage="System.IO.Directory.EnumerateDirectories path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">O caminho relativo ou absoluto para o diretório a ser pesquisado. Esta cadeia de caracteres não diferencia maiúsculas de minúsculas.</param>
        <summary>Retorna uma coleção enumerável de nomes de diretório em um caminho especificado.</summary>
        <returns>Uma coleção enumerável de nomes completos (incluindo caminhos) para os diretórios no diretório especificado por <paramref name="path" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você pode especificar informações de caminho relativo ou absoluto no `path` parâmetro. Informações de caminho relativo são interpretadas como relativo ao diretório de trabalho atual, você pode determinar usando o <xref:System.IO.Directory.GetCurrentDirectory%2A> método. Os nomes de diretório retornados são prefixados com o valor fornecido no `path` parâmetro. Por exemplo, se você fornecer um caminho relativo no `path` parâmetro, os nomes de diretório retornada conterá um caminho relativo.  
  
 O <xref:System.IO.Directory.EnumerateDirectories%2A> e <xref:System.IO.Directory.GetDirectories%2A> métodos diferem da seguinte maneira: Quando você usa <xref:System.IO.Directory.EnumerateDirectories%2A>, você pode começar a enumerar a coleção de nomes antes da coleção inteira é retornada; quando você usa <xref:System.IO.Directory.GetDirectories%2A>, você deverá aguardar por toda a matriz de nomes a serem retornados antes de poder acessar a matriz. Portanto, quando você estiver trabalhando com muitos arquivos e diretórios, <xref:System.IO.Directory.EnumerateDirectories%2A> pode ser mais eficiente.  
  
 Não é armazenado em cache a coleção retornada; cada chamada para o <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> coleção iniciará uma nova enumeração.  
  
   
  
## Examples  
 O exemplo a seguir enumera os diretórios de nível superior em um caminho especificado.  
  
 [!code-csharp[System.IO.EnumDirs1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.enumdirs1/cs/program.cs#1)]
 [!code-vb[System.IO.EnumDirs1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.enumdirs1/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou caracteres inválidos. Consulte caracteres inválidos usando o método <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException"><paramref name="path" /> é inválido, como referenciar uma unidade não mapeada.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> é um nome de arquivo.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema.</exception>
        <exception cref="T:System.Security.SecurityException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O chamador não tem a permissão necessária.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnumerateDirectories">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateDirectories (string path, string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateDirectories(string path, string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateDirectories(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EnumerateDirectories (path As String, searchPattern As String) As IEnumerable(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateDirectories(System::String ^ path, System::String ^ searchPattern);" />
      <MemberSignature Language="F#" Value="static member EnumerateDirectories : string * string -&gt; seq&lt;string&gt;" Usage="System.IO.Directory.EnumerateDirectories (path, searchPattern)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="searchPattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">O caminho relativo ou absoluto para o diretório a ser pesquisado. Esta cadeia de caracteres não diferencia maiúsculas de minúsculas.</param>
        <param name="searchPattern">A cadeia de caracteres de pesquisa para correspondência com os nomes dos diretórios em <paramref name="path" />.  Esse parâmetro pode conter uma combinação de caracteres curinga (* e ?) e caminho de literal, mas não dá suporte a expressões regulares.</param>
        <summary>Retorna uma coleção enumerável de nomes de diretório que correspondem a um padrão de pesquisa em um caminho especificado.</summary>
        <returns>Uma coleção enumerável de nomes completos (incluindo caminhos) para os diretórios no diretório especificado por <paramref name="path" /> e que correspondem ao padrão de pesquisa especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` pode ser uma combinação de caracteres literais e curinga, mas ele não dá suporte a expressões regulares. Os seguintes especificadores de curinga são permitidos em `searchPattern`.  
  
|Especificador de curinga|Correspondências|  
|------------------------|-------------|  
|\* (asterisco)|Zero ou mais caracteres nessa posição.|  
|? (ponto de interrogação)|Zero ou um caractere nessa posição.|  
  
 Os caracteres que não seja o caractere curinga são caracteres literais. Por exemplo, o `searchPattern` cadeia de caracteres "\*t" procura todos os nomes no `path` terminando com a letra "t". O `searchPattern` cadeia de caracteres "s\*" procura todos os nomes no `path` começando com a letra "s".  
  
 `searchPattern` não pode terminar com dois pontos finais ("..") ou conter dois pontos ("..") seguido por <xref:System.IO.Path.DirectorySeparatorChar> ou <xref:System.IO.Path.AltDirectorySeparatorChar>, nem pode conter caracteres inválidos. Consulte caracteres inválidos usando o método <xref:System.IO.Path.GetInvalidPathChars%2A>.  
  
 Você pode especificar informações de caminho relativo ou absoluto no `path` parâmetro. Informações de caminho relativo são interpretadas como relativo ao diretório de trabalho atual, você pode determinar usando o <xref:System.IO.Directory.GetCurrentDirectory%2A> método. Os nomes de diretório retornados são prefixados com o valor fornecido no `path` parâmetro. Por exemplo, se você fornecer um caminho relativo no `path` parâmetro, os nomes de diretório retornada conterá um caminho relativo.  
  
 O <xref:System.IO.Directory.EnumerateDirectories%2A> e <xref:System.IO.Directory.GetDirectories%2A> métodos diferem da seguinte maneira: Quando você usa <xref:System.IO.Directory.EnumerateDirectories%2A>, você pode começar a enumerar a coleção de nomes antes da coleção inteira é retornada; quando você usa <xref:System.IO.Directory.GetDirectories%2A>, você deverá aguardar por toda a matriz de nomes a serem retornados antes de poder acessar a matriz. Portanto, quando você estiver trabalhando com muitos arquivos e diretórios, <xref:System.IO.Directory.EnumerateDirectories%2A> pode ser mais eficiente.  
  
 Não é armazenado em cache a coleção retornada; cada chamada para o <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> coleção iniciará uma nova enumeração.  
  
   
  
## Examples  
 O exemplo a seguir enumera os diretórios de nível superior em um caminho especificado que correspondem a um padrão de pesquisa especificado.  
  
 [!code-csharp[System.IO.EnumDirs2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.enumdirs2/cs/program.cs#1)]
 [!code-vb[System.IO.EnumDirs2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.enumdirs2/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou caracteres inválidos. Consulte caracteres inválidos com o método <see cref="M:System.IO.Path.GetInvalidPathChars" />.  
  
\- ou - 
 <paramref name="searchPattern" /> não contém um padrão válido.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="searchPattern" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException"><paramref name="path" /> é inválido, como referenciar uma unidade não mapeada.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> é um nome de arquivo.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema.</exception>
        <exception cref="T:System.Security.SecurityException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O chamador não tem a permissão necessária.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnumerateDirectories">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateDirectories (string path, string searchPattern, System.IO.EnumerationOptions enumerationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateDirectories(string path, string searchPattern, class System.IO.EnumerationOptions enumerationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateDirectories(System.String,System.String,System.IO.EnumerationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateDirectories(System::String ^ path, System::String ^ searchPattern, System::IO::EnumerationOptions ^ enumerationOptions);" />
      <MemberSignature Language="F#" Value="static member EnumerateDirectories : string * string * System.IO.EnumerationOptions -&gt; seq&lt;string&gt;" Usage="System.IO.Directory.EnumerateDirectories (path, searchPattern, enumerationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="enumerationOptions" Type="System.IO.EnumerationOptions" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="searchPattern">To be added.</param>
        <param name="enumerationOptions">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EnumerateDirectories">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateDirectories (string path, string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateDirectories(string path, string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateDirectories(System.String,System.String,System.IO.SearchOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateDirectories(System::String ^ path, System::String ^ searchPattern, System::IO::SearchOption searchOption);" />
      <MemberSignature Language="F#" Value="static member EnumerateDirectories : string * string * System.IO.SearchOption -&gt; seq&lt;string&gt;" Usage="System.IO.Directory.EnumerateDirectories (path, searchPattern, searchOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" />
      </Parameters>
      <Docs>
        <param name="path">O caminho relativo ou absoluto para o diretório a ser pesquisado. Esta cadeia de caracteres não diferencia maiúsculas de minúsculas.</param>
        <param name="searchPattern">A cadeia de caracteres de pesquisa para correspondência com os nomes dos diretórios em <paramref name="path" />.  Esse parâmetro pode conter uma combinação de caracteres curinga (* e ?) e caminho de literal, mas não dá suporte a expressões regulares.</param>
        <param name="searchOption">Um dos valores de enumeração que especifica se a operação de pesquisa deve incluir somente o diretório atual ou todos os subdiretórios.  
  
O valor padrão é <see cref="F:System.IO.SearchOption.TopDirectoryOnly" />.</param>
        <summary>Retorna uma coleção enumerável de nomes de diretório que correspondem a um padrão de pesquisa em um caminho especificado e, opcionalmente, pesquisa subdiretórios.</summary>
        <returns>Uma coleção enumerável de nomes completos (incluindo caminhos) para os diretórios no diretório especificado por <paramref name="path" /> e que correspondem à opção e ao padrão de pesquisa especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` pode ser uma combinação de caracteres literais e curinga, mas ele não dá suporte a expressões regulares. Os seguintes especificadores de curinga são permitidos em `searchPattern`.  
  
|Especificador de curinga|Correspondências|  
|------------------------|-------------|  
|\* (asterisco)|Zero ou mais caracteres nessa posição.|  
|? (ponto de interrogação)|Exatamente um caractere nessa posição.|  
  
 Os caracteres que não seja o caractere curinga são caracteres literais. Por exemplo, o `searchPattern` cadeia de caracteres "\*t" procura todos os nomes no `path` terminando com a letra "t". O `searchPattern` cadeia de caracteres "s\*" procura todos os nomes no `path` começando com a letra "s".  
  
 `searchPattern` não pode terminar com dois pontos finais ("..") ou conter dois pontos ("..") seguido por <xref:System.IO.Path.DirectorySeparatorChar> ou <xref:System.IO.Path.AltDirectorySeparatorChar>, nem pode conter caracteres inválidos. Consulte caracteres inválidos usando o método <xref:System.IO.Path.GetInvalidPathChars%2A>.  
  
 Você pode especificar informações de caminho relativo ou absoluto no `path` parâmetro. Informações de caminho relativo são interpretadas como relativo ao diretório de trabalho atual, você pode determinar usando o <xref:System.IO.Directory.GetCurrentDirectory%2A> método. Os nomes de diretório retornados são prefixados com o valor fornecido no `path` parâmetro. Por exemplo, se você fornecer um caminho relativo no `path` parâmetro, os nomes de diretório retornada conterá um caminho relativo.  
  
 O <xref:System.IO.Directory.EnumerateDirectories%2A> e <xref:System.IO.Directory.GetDirectories%2A> métodos diferem da seguinte maneira: Quando você usa <xref:System.IO.Directory.EnumerateDirectories%2A>, você pode começar a enumerar a coleção de nomes antes da coleção inteira é retornada; quando você usa <xref:System.IO.Directory.GetDirectories%2A>, você deverá aguardar por toda a matriz de nomes a serem retornados antes de poder acessar a matriz. Portanto, quando você estiver trabalhando com muitos arquivos e diretórios, <xref:System.IO.Directory.EnumerateDirectories%2A> pode ser mais eficiente.  
  
 Não é armazenado em cache a coleção retornada; cada chamada para o <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> coleção iniciará uma nova enumeração.  
  
   
  
## Examples  
 O exemplo a seguir enumera os diretórios em um caminho especificado que correspondem a um padrão de pesquisa especificado. Ele usa o `searchOption` parâmetro para especificar que todos os subdiretórios devem ser incluídos na pesquisa.  
  
 [!code-csharp[System.IO.EnumDirs3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.enumdirs3/cs/program.cs#1)]
 [!code-vb[System.IO.EnumDirs3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.enumdirs3/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou caracteres inválidos. Consulte caracteres inválidos usando o método <see cref="M:System.IO.Path.GetInvalidPathChars" />.  
  
\- ou - 
 <paramref name="searchPattern" /> não contém um padrão válido.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="searchPattern" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="searchOption" /> não é um valor <see cref="T:System.IO.SearchOption" /> válido.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException"><paramref name="path" /> é inválido, como referenciar uma unidade não mapeada.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> é um nome de arquivo.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema.</exception>
        <exception cref="T:System.Security.SecurityException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O chamador não tem a permissão necessária.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EnumerateFiles">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retorna uma coleção enumerável de nomes de arquivo que atendem ao critério especificado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EnumerateFiles">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateFiles (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateFiles(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateFiles(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EnumerateFiles (path As String) As IEnumerable(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateFiles(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member EnumerateFiles : string -&gt; seq&lt;string&gt;" Usage="System.IO.Directory.EnumerateFiles path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">O caminho relativo ou absoluto para o diretório a ser pesquisado. Esta cadeia de caracteres não diferencia maiúsculas de minúsculas.</param>
        <summary>Retorna uma coleção enumerável de nomes de arquivo em um caminho especificado.</summary>
        <returns>Uma coleção enumerável de nomes completos (incluindo caminhos) para os arquivos no diretório especificado por <paramref name="path" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você pode especificar informações de caminho relativo com o `path` parâmetro. Informações de caminho relativo são interpretadas como relativo ao diretório de trabalho atual, você pode determinar usando o <xref:System.IO.Directory.GetCurrentDirectory%2A> método.  
  
 O <xref:System.IO.Directory.EnumerateFiles%2A> e <xref:System.IO.Directory.GetFiles%2A> métodos diferem da seguinte maneira: Quando você usa <xref:System.IO.Directory.EnumerateFiles%2A>, você pode começar a enumerar a coleção de nomes antes da coleção inteira é retornada; quando você usa <xref:System.IO.Directory.GetFiles%2A>, você deverá aguardar por toda a matriz de nomes a serem retornados antes de poder acessar a matriz. Portanto, quando você estiver trabalhando com muitos arquivos e diretórios, <xref:System.IO.Directory.EnumerateFiles%2A> pode ser mais eficiente.  
  
 Não é armazenado em cache a coleção retornada; cada chamada para o <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> coleção iniciará uma nova enumeração.  
  
   
  
## Examples  
 O exemplo a seguir mostra como recuperar todos os arquivos em um diretório e movê-los para um novo diretório. Depois que os arquivos são movidos, eles não existem mais no diretório original.  
  
 [!code-csharp[System.IO.Directory#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class4.cs#12)]
 [!code-vb[System.IO.Directory#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class4.vb#12)]  
  
 O exemplo a seguir enumera os arquivos no diretório especificado, lê cada linha do arquivo e exibe a linha se ela contém a cadeia de caracteres "Europa".  
  
 [!code-csharp[System.IO.Directory.EnumFiles#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.directory.enumfiles/cs/program.cs#1)]
 [!code-vb[System.IO.Directory.EnumFiles#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.directory.enumfiles/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou caracteres inválidos. Consulte caracteres inválidos usando o método <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException"><paramref name="path" /> é inválido, como referenciar uma unidade não mapeada.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> é um nome de arquivo.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema.</exception>
        <exception cref="T:System.Security.SecurityException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O chamador não tem a permissão necessária.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnumerateFiles">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateFiles (string path, string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateFiles(string path, string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateFiles(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EnumerateFiles (path As String, searchPattern As String) As IEnumerable(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateFiles(System::String ^ path, System::String ^ searchPattern);" />
      <MemberSignature Language="F#" Value="static member EnumerateFiles : string * string -&gt; seq&lt;string&gt;" Usage="System.IO.Directory.EnumerateFiles (path, searchPattern)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="searchPattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">O caminho relativo ou absoluto para o diretório a ser pesquisado. Esta cadeia de caracteres não diferencia maiúsculas de minúsculas.</param>
        <param name="searchPattern">A cadeia de caracteres de pesquisa para correspondência com os nomes dos arquivos em <paramref name="path" />.  Esse parâmetro pode conter uma combinação de caracteres curinga (* e ?) e caminho de literal, mas não dá suporte a expressões regulares.</param>
        <summary>Retorna uma coleção enumerável de nomes de arquivo que correspondem a um padrão de pesquisa em um caminho especificado.</summary>
        <returns>Uma coleção enumerável de nomes completos (incluindo caminhos) para os arquivos no diretório especificado por <paramref name="path" /> e que correspondem ao padrão de pesquisa especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` pode ser uma combinação de caracteres literais e curinga, mas ele não dá suporte a expressões regulares. Os seguintes especificadores de curinga são permitidos em `searchPattern`.  
  
|Especificador de curinga|Correspondências|  
|------------------------|-------------|  
|\* (asterisco)|Zero ou mais caracteres nessa posição.|  
|? (ponto de interrogação)|Zero ou um caractere nessa posição.|  
  
 Os caracteres que não seja o caractere curinga são caracteres literais. Por exemplo, o `searchPattern` cadeia de caracteres "\*t" procura todos os nomes no `path` terminando com a letra "t". O `searchPattern` cadeia de caracteres "s\*" procura todos os nomes no `path` começando com a letra "s".  
  
> [!NOTE]
>  Quando você usa o caractere curinga de asterisco em um `searchPattern` como "\*. txt", o número de caracteres em que a extensão especificada afeta a pesquisa da seguinte maneira:  
>   
> -   Se a extensão especificada é exatamente três caracteres, o método retorna arquivos com extensões que começam com a extensão especificada. Por exemplo, "\*. xls" retorna "book.xls" e "book.xlsx".  
> -   Em todos os outros casos, o método retorna arquivos que correspondem exatamente a extensão especificada. Por exemplo, "\*. AI" retorna "file.ai", mas não "file.aif".  
>   
>  Quando você usa o caractere curinga de ponto de interrogação, esse método retorna apenas os arquivos que correspondem a extensão de arquivo especificado. Por exemplo, considerando dois arquivos, "file1.txt" e "file1.txtother", em um diretório, um padrão de pesquisa de "arquivo?. txt"retorna apenas o primeiro arquivo, enquanto um padrão de pesquisa de" arquivo\*. txt "retorna os dois arquivos.  
  
 `searchPattern` não pode terminar com dois pontos finais ("..") ou conter dois pontos ("..") seguido por <xref:System.IO.Path.DirectorySeparatorChar> ou <xref:System.IO.Path.AltDirectorySeparatorChar>, nem pode conter caracteres inválidos. Consulte caracteres inválidos usando o método <xref:System.IO.Path.GetInvalidPathChars%2A>.  
  
 Você pode especificar informações de caminho relativo com o `path` parâmetro. Informações de caminho relativo são interpretadas como relativo ao diretório de trabalho atual, você pode determinar usando o <xref:System.IO.Directory.GetCurrentDirectory%2A> método.  
  
 O <xref:System.IO.Directory.EnumerateFiles%2A> e <xref:System.IO.Directory.GetFiles%2A> métodos diferem da seguinte maneira: Quando você usa <xref:System.IO.Directory.EnumerateFiles%2A>, você pode começar a enumerar a coleção de nomes antes da coleção inteira é retornada; quando você usa <xref:System.IO.Directory.GetFiles%2A>, você deverá aguardar por toda a matriz de nomes a serem retornados antes de poder acessar a matriz. Portanto, quando você estiver trabalhando com muitos arquivos e diretórios, <xref:System.IO.Directory.EnumerateFiles%2A> pode ser mais eficiente.  
  
 Não é armazenado em cache a coleção retornada; cada chamada para o <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> coleção iniciará uma nova enumeração.  
  
   
  
## Examples  
 O exemplo a seguir mostra como recuperar todos os arquivos de texto em um diretório e movê-los para um novo diretório. Depois que os arquivos são movidos, eles não existem mais no diretório original.  
  
 [!code-csharp[System.IO.Directory#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class2.cs#10)]
 [!code-vb[System.IO.Directory#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class2.vb#10)]  
  
 O exemplo a seguir enumera os arquivos no diretório especificado que têm uma extensão. txt, lê cada linha do arquivo e exibe a linha se ela contém a cadeia de caracteres "Europa".  
  
 [!code-csharp[System.IO.Directory.EnumFiles2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.directory.enumfiles2/cs/program.cs#1)]
 [!code-vb[System.IO.Directory.EnumFiles2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.directory.enumfiles2/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou caracteres inválidos. Consulte caracteres inválidos usando o método <see cref="M:System.IO.Path.GetInvalidPathChars" />.  
  
\- ou - 
 <paramref name="searchPattern" /> não contém um padrão válido.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="searchPattern" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException"><paramref name="path" /> é inválido, como referenciar uma unidade não mapeada.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> é um nome de arquivo.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema.</exception>
        <exception cref="T:System.Security.SecurityException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O chamador não tem a permissão necessária.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnumerateFiles">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateFiles (string path, string searchPattern, System.IO.EnumerationOptions enumerationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateFiles(string path, string searchPattern, class System.IO.EnumerationOptions enumerationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateFiles(System.String,System.String,System.IO.EnumerationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateFiles(System::String ^ path, System::String ^ searchPattern, System::IO::EnumerationOptions ^ enumerationOptions);" />
      <MemberSignature Language="F#" Value="static member EnumerateFiles : string * string * System.IO.EnumerationOptions -&gt; seq&lt;string&gt;" Usage="System.IO.Directory.EnumerateFiles (path, searchPattern, enumerationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="enumerationOptions" Type="System.IO.EnumerationOptions" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="searchPattern">To be added.</param>
        <param name="enumerationOptions">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EnumerateFiles">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateFiles (string path, string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateFiles(string path, string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateFiles(System.String,System.String,System.IO.SearchOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateFiles(System::String ^ path, System::String ^ searchPattern, System::IO::SearchOption searchOption);" />
      <MemberSignature Language="F#" Value="static member EnumerateFiles : string * string * System.IO.SearchOption -&gt; seq&lt;string&gt;" Usage="System.IO.Directory.EnumerateFiles (path, searchPattern, searchOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" />
      </Parameters>
      <Docs>
        <param name="path">O caminho relativo ou absoluto para o diretório a ser pesquisado. Esta cadeia de caracteres não diferencia maiúsculas de minúsculas.</param>
        <param name="searchPattern">A cadeia de caracteres de pesquisa para correspondência com os nomes dos arquivos em <paramref name="path" />.  Esse parâmetro pode conter uma combinação de caracteres curinga (* e ?) e caminho de literal, mas não dá suporte a expressões regulares.</param>
        <param name="searchOption">Um dos valores de enumeração que especifica se a operação de pesquisa deve incluir somente o diretório atual ou todos os subdiretórios.  
  
O valor padrão é <see cref="F:System.IO.SearchOption.TopDirectoryOnly" />.</param>
        <summary>Retorna uma coleção enumerável de nomes de arquivo que correspondem a um padrão de pesquisa em um caminho especificado e, opcionalmente, pesquisa subdiretórios.</summary>
        <returns>Uma coleção enumerável de nomes completos (incluindo caminhos) para os arquivos no diretório especificado por <paramref name="path" /> e que correspondem à opção e ao padrão de pesquisa especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` pode ser uma combinação de caracteres literais e curinga, mas ele não dá suporte a expressões regulares. Os seguintes especificadores de curinga são permitidos em `searchPattern`.  
  
|Especificador de curinga|Correspondências|  
|------------------------|-------------|  
|\* (asterisco)|Zero ou mais caracteres nessa posição.|  
|? (ponto de interrogação)|Zero ou um caractere nessa posição.|  
  
 Os caracteres que não seja o caractere curinga são caracteres literais. Por exemplo, o `searchPattern` cadeia de caracteres "\*t" procura todos os nomes no `path` terminando com a letra "t". O `searchPattern` cadeia de caracteres "s\*" procura todos os nomes no `path` começando com a letra "s".  
  
> [!NOTE]
>  Quando você usa o caractere curinga de asterisco em um `searchPattern` como "\*. txt", o número de caracteres em que a extensão especificada afeta a pesquisa da seguinte maneira:  
>   
> -   Se a extensão especificada é exatamente três caracteres, o método retorna arquivos com extensões que começam com a extensão especificada. Por exemplo, "\*. xls" retorna "book.xls" e "book.xlsx".  
> -   Em todos os outros casos, o método retorna arquivos que correspondem exatamente a extensão especificada. Por exemplo, "\*. AI" retorna "file.ai", mas não "file.aif".  
>   
>  Quando você usa o caractere curinga de ponto de interrogação, esse método retorna apenas os arquivos que correspondem a extensão de arquivo especificado. Por exemplo, considerando dois arquivos, "file1.txt" e "file1.txtother", em um diretório, um padrão de pesquisa de "arquivo?. txt"retorna apenas o primeiro arquivo, enquanto um padrão de pesquisa de" arquivo\*. txt "retorna os dois arquivos.  
  
 `searchPattern` não pode terminar com dois pontos finais ("..") ou conter dois pontos ("..") seguido por <xref:System.IO.Path.DirectorySeparatorChar> ou <xref:System.IO.Path.AltDirectorySeparatorChar>, nem pode conter caracteres inválidos. Consulte caracteres inválidos usando o método <xref:System.IO.Path.GetInvalidPathChars%2A>.  
  
 Você pode especificar informações de caminho relativo com o `path` parâmetro. Informações de caminho relativo são interpretadas como relativo ao diretório de trabalho atual, você pode determinar usando o <xref:System.IO.Directory.GetCurrentDirectory%2A> método.  
  
 O <xref:System.IO.Directory.EnumerateFiles%2A> e <xref:System.IO.Directory.GetFiles%2A> métodos diferem da seguinte maneira: Quando você usa <xref:System.IO.Directory.EnumerateFiles%2A>, você pode começar a enumerar a coleção de nomes antes da coleção inteira é retornada; quando você usa <xref:System.IO.Directory.GetFiles%2A>, você deverá aguardar por toda a matriz de nomes a serem retornados antes de poder acessar a matriz. Portanto, quando você estiver trabalhando com muitos arquivos e diretórios, <xref:System.IO.Directory.EnumerateFiles%2A> pode ser mais eficiente.  
  
 Não é armazenado em cache a coleção retornada; cada chamada para o <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> coleção iniciará uma nova enumeração.  
  
   
  
## Examples  
 O exemplo a seguir mostra como recuperar todos os arquivos de texto em um diretório e seus subdiretórios e movê-los para um novo diretório. Depois que os arquivos são movidos, eles não existem mais nos diretórios do originais.  
  
 [!code-csharp[System.IO.Directory#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class5.cs#13)]
 [!code-vb[System.IO.Directory#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class5.vb#13)]  
  
 Recursivamente o exemplo a seguir enumera todos os arquivos que têm uma extensão. txt, lê cada linha do arquivo e exibe a linha se ela contém a cadeia de caracteres "Microsoft".  
  
 [!code-csharp[System.IO.Directory.EnumerateFiles#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.directory.enumeratefiles/cs/program.cs#1)]
 [!code-vb[System.IO.Directory.EnumerateFiles#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.directory.enumeratefiles/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou caracteres inválidos. Consulte caracteres inválidos usando o método <see cref="M:System.IO.Path.GetInvalidPathChars" />.  
  
\- ou - 
 <paramref name="searchPattern" /> não contém um padrão válido.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="searchPattern" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="searchOption" /> não é um valor <see cref="T:System.IO.SearchOption" /> válido.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException"><paramref name="path" /> é inválido, como referenciar uma unidade não mapeada.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> é um nome de arquivo.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema.</exception>
        <exception cref="T:System.Security.SecurityException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O chamador não tem a permissão necessária.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EnumerateFileSystemEntries">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retorna uma coleção enumerável de entradas do sistema de arquivos que atendem ao critério especificado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EnumerateFileSystemEntries">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateFileSystemEntries (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateFileSystemEntries(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateFileSystemEntries(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EnumerateFileSystemEntries (path As String) As IEnumerable(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateFileSystemEntries(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member EnumerateFileSystemEntries : string -&gt; seq&lt;string&gt;" Usage="System.IO.Directory.EnumerateFileSystemEntries path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">O caminho relativo ou absoluto para o diretório a ser pesquisado. Esta cadeia de caracteres não diferencia maiúsculas de minúsculas.</param>
        <summary>Retorna uma coleção enumerável de nomes de arquivo e de diretório em um caminho especificado.</summary>
        <returns>Uma coleção enumerável de entradas de sistema de arquivos no diretório especificado por <paramref name="path" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você pode especificar informações de caminho relativo com o `path` parâmetro. Informações de caminho relativo são interpretadas como relativo ao diretório de trabalho atual, você pode determinar usando o <xref:System.IO.Directory.GetCurrentDirectory%2A> método.  
  
 O <xref:System.IO.Directory.EnumerateFileSystemEntries%2A> e <xref:System.IO.Directory.GetFileSystemEntries%2A> métodos diferem da seguinte maneira: Quando você usa <xref:System.IO.Directory.EnumerateFileSystemEntries%2A>, você pode começar a enumerar a coleção de entradas antes da coleção inteira é retornada; quando você usa <xref:System.IO.Directory.GetFileSystemEntries%2A>, você deve aguardar a matriz inteira de entradas a serem retornadas antes de poder acessar a matriz. Portanto, quando você estiver trabalhando com muitos arquivos e diretórios, <xref:System.IO.Directory.EnumerateFiles%2A> pode ser mais eficiente.  
  
 Não é armazenado em cache a coleção retornada; cada chamada para o <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> coleção iniciará uma nova enumeração.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou caracteres inválidos. Consulte caracteres inválidos usando o método <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException"><paramref name="path" /> é inválido, como referenciar uma unidade não mapeada.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> é um nome de arquivo.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema.</exception>
        <exception cref="T:System.Security.SecurityException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O chamador não tem a permissão necessária.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnumerateFileSystemEntries">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateFileSystemEntries (string path, string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateFileSystemEntries(string path, string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateFileSystemEntries(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EnumerateFileSystemEntries (path As String, searchPattern As String) As IEnumerable(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateFileSystemEntries(System::String ^ path, System::String ^ searchPattern);" />
      <MemberSignature Language="F#" Value="static member EnumerateFileSystemEntries : string * string -&gt; seq&lt;string&gt;" Usage="System.IO.Directory.EnumerateFileSystemEntries (path, searchPattern)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="searchPattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">O caminho relativo ou absoluto para o diretório a ser pesquisado. Esta cadeia de caracteres não diferencia maiúsculas de minúsculas.</param>
        <param name="searchPattern">A cadeia de caracteres de pesquisa para correspondência com os nomes das entradas do sistema de arquivos em <paramref name="path" />.  Esse parâmetro pode conter uma combinação de caracteres curinga (* e ?) e caminho de literal, mas não dá suporte a expressões regulares.</param>
        <summary>Retorna uma coleção enumerável de nomes de arquivo e nomes de diretório que correspondem a um padrão de pesquisa em um caminho especificado.</summary>
        <returns>Uma coleção enumerável de entradas do sistema de arquivos no diretório especificado por <paramref name="path" /> e que correspondem ao padrão de pesquisa especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` pode ser uma combinação de caracteres literais e curinga, mas ele não dá suporte a expressões regulares. Os seguintes especificadores de curinga são permitidos em `searchPattern`. 
  
|Especificador de curinga|Correspondências|  
|------------------------|-------------|  
|\* (asterisco)|Zero ou mais caracteres nessa posição.|  
|? (ponto de interrogação)|Zero ou um caractere nessa posição.|  
  
 Os caracteres que não seja o caractere curinga são caracteres literais. Por exemplo, o `searchPattern` cadeia de caracteres "\*t" procura todos os nomes no `path` terminando com a letra "t". O `searchPattern` cadeia de caracteres "s\*" procura todos os nomes no `path` começando com a letra "s".  
  
> [!NOTE]
>  Quando você usa o caractere curinga de asterisco em um `searchPattern` como "\*. txt", o número de caracteres em que a extensão especificada afeta a pesquisa da seguinte maneira:  
>   
> -   Se a extensão especificada é exatamente três caracteres, o método retorna arquivos com extensões que começam com a extensão especificada. Por exemplo, "\*. xls" retorna "book.xls" e "book.xlsx".  
> -   Em todos os outros casos, o método retorna arquivos que correspondem exatamente a extensão especificada. Por exemplo, "\*. AI" retorna "file.ai", mas não "file.aif".  
>   
>  Quando você usa o caractere curinga de ponto de interrogação, esse método retorna apenas os arquivos que correspondem a extensão de arquivo especificado. Por exemplo, considerando dois arquivos, "file1.txt" e "file1.txtother", em um diretório, um padrão de pesquisa de "arquivo?. txt"retorna apenas o primeiro arquivo, enquanto um padrão de pesquisa de" arquivo\*. txt "retorna os dois arquivos.  
  
 `searchPattern` não pode terminar com dois pontos finais ("..") ou conter dois pontos ("..") seguido por <xref:System.IO.Path.DirectorySeparatorChar> ou <xref:System.IO.Path.AltDirectorySeparatorChar>, nem pode conter caracteres inválidos. Consulte caracteres inválidos usando o método <xref:System.IO.Path.GetInvalidPathChars%2A>.  
  
 Você pode especificar informações de caminho relativo com o `path` parâmetro. Informações de caminho relativo são interpretadas como relativo ao diretório de trabalho atual, você pode determinar usando o <xref:System.IO.Directory.GetCurrentDirectory%2A> método.  
  
 O <xref:System.IO.Directory.EnumerateFileSystemEntries%2A> e <xref:System.IO.Directory.GetFileSystemEntries%2A> métodos diferem da seguinte maneira: Quando você usa <xref:System.IO.Directory.EnumerateFileSystemEntries%2A>, você pode começar a enumerar a coleção de entradas antes da coleção inteira é retornada; quando você usa <xref:System.IO.Directory.GetFileSystemEntries%2A>, você deve aguardar a matriz inteira de entradas a serem retornadas antes de poder acessar a matriz. Portanto, quando você estiver trabalhando com muitos arquivos e diretórios, <xref:System.IO.Directory.EnumerateFiles%2A> pode ser mais eficiente.  
  
 Não é armazenado em cache a coleção retornada; cada chamada para o <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> coleção iniciará uma nova enumeração.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou caracteres inválidos. Consulte caracteres inválidos usando o método <see cref="M:System.IO.Path.GetInvalidPathChars" />.  
  
\- ou - 
 <paramref name="searchPattern" /> não contém um padrão válido.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="searchPattern" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException"><paramref name="path" /> é inválido, como referenciar uma unidade não mapeada.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> é um nome de arquivo.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema.</exception>
        <exception cref="T:System.Security.SecurityException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O chamador não tem a permissão necessária.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnumerateFileSystemEntries">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateFileSystemEntries (string path, string searchPattern, System.IO.EnumerationOptions enumerationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateFileSystemEntries(string path, string searchPattern, class System.IO.EnumerationOptions enumerationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateFileSystemEntries(System.String,System.String,System.IO.EnumerationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateFileSystemEntries(System::String ^ path, System::String ^ searchPattern, System::IO::EnumerationOptions ^ enumerationOptions);" />
      <MemberSignature Language="F#" Value="static member EnumerateFileSystemEntries : string * string * System.IO.EnumerationOptions -&gt; seq&lt;string&gt;" Usage="System.IO.Directory.EnumerateFileSystemEntries (path, searchPattern, enumerationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="enumerationOptions" Type="System.IO.EnumerationOptions" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="searchPattern">To be added.</param>
        <param name="enumerationOptions">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EnumerateFileSystemEntries">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateFileSystemEntries (string path, string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateFileSystemEntries(string path, string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateFileSystemEntries(System.String,System.String,System.IO.SearchOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateFileSystemEntries(System::String ^ path, System::String ^ searchPattern, System::IO::SearchOption searchOption);" />
      <MemberSignature Language="F#" Value="static member EnumerateFileSystemEntries : string * string * System.IO.SearchOption -&gt; seq&lt;string&gt;" Usage="System.IO.Directory.EnumerateFileSystemEntries (path, searchPattern, searchOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" />
      </Parameters>
      <Docs>
        <param name="path">O caminho relativo ou absoluto para o diretório a ser pesquisado. Esta cadeia de caracteres não diferencia maiúsculas de minúsculas.</param>
        <param name="searchPattern">A cadeia de caracteres de pesquisa para correspondência com as entradas do sistema de arquivos no <paramref name="path" />.  Esse parâmetro pode conter uma combinação de caracteres curinga (* e ?) e caminho de literal, mas não dá suporte a expressões regulares.</param>
        <param name="searchOption">Um dos valores de enumeração que especifica se a operação de pesquisa deve incluir somente o diretório atual ou todos os subdiretórios.  
  
O valor padrão é <see cref="F:System.IO.SearchOption.TopDirectoryOnly" />.</param>
        <summary>Retorna uma coleção enumerável de nomes de arquivo e nomes de diretório que correspondem a um padrão de pesquisa em um caminho especificado e, opcionalmente, pesquisa subdiretórios.</summary>
        <returns>Uma coleção enumerável de entradas do sistema de arquivos no diretório especificado por <paramref name="path" /> e que corresponde à opção e ao padrão de pesquisa especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` pode ser uma combinação de caracteres literais e curinga, mas ele não dá suporte a expressões regulares. Os seguintes especificadores de curinga são permitidos em `searchPattern`.  
  
|Especificador de curinga|Correspondências|  
|------------------------|-------------|  
|\* (asterisco)|Zero ou mais caracteres nessa posição.|  
|? (ponto de interrogação)|Zero ou um caractere nessa posição.|  
  
 Os caracteres que não seja o caractere curinga são caracteres literais. Por exemplo, o `searchPattern` cadeia de caracteres "\*t" procura todos os nomes no `path` terminando com a letra "t". O `searchPattern` cadeia de caracteres "s\*" procura todos os nomes no `path` começando com a letra "s".  
  
> [!NOTE]
>  Quando você usa o caractere curinga de asterisco em um `searchPattern` como "\*. txt", o número de caracteres em que a extensão especificada afeta a pesquisa da seguinte maneira:  
>   
> -   Se a extensão especificada é exatamente três caracteres, o método retorna arquivos com extensões que começam com a extensão especificada. Por exemplo, "\*. xls" retorna "book.xls" e "book.xlsx".  
> -   Em todos os outros casos, o método retorna arquivos que correspondem exatamente a extensão especificada. Por exemplo, "\*. AI" retorna "file.ai", mas não "file.aif".  
>   
>  Quando você usa o caractere curinga de ponto de interrogação, esse método retorna apenas os arquivos que correspondem a extensão de arquivo especificado. Por exemplo, considerando dois arquivos, "file1.txt" e "file1.txtother", em um diretório, um padrão de pesquisa de "arquivo?. txt"retorna apenas o primeiro arquivo, enquanto um padrão de pesquisa de" arquivo\*. txt "retorna os dois arquivos.  
  
 `searchPattern` não pode terminar com dois pontos finais ("..") ou conter dois pontos ("..") seguido por <xref:System.IO.Path.DirectorySeparatorChar> ou <xref:System.IO.Path.AltDirectorySeparatorChar>, nem pode conter caracteres inválidos. Consulte caracteres inválidos usando o método <xref:System.IO.Path.GetInvalidPathChars%2A>.  
  
 Você pode especificar informações de caminho relativo com o `path` parâmetro. Informações de caminho relativo são interpretadas como relativo ao diretório de trabalho atual, você pode determinar usando o <xref:System.IO.Directory.GetCurrentDirectory%2A> método.  
  
 O <xref:System.IO.Directory.EnumerateFileSystemEntries%2A> e <xref:System.IO.Directory.GetFileSystemEntries%2A> métodos diferem da seguinte maneira: Quando você usa <xref:System.IO.Directory.EnumerateFileSystemEntries%2A>, você pode começar a enumerar a coleção de entradas antes da coleção inteira é retornada; quando você usa <xref:System.IO.Directory.GetFileSystemEntries%2A>, você deve aguardar a matriz inteira de entradas a serem retornadas antes de poder acessar a matriz. Portanto, quando você estiver trabalhando com muitos arquivos e diretórios, <xref:System.IO.Directory.EnumerateFiles%2A> pode ser mais eficiente.  
  
 Não é armazenado em cache a coleção retornada; cada chamada para o <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> coleção iniciará uma nova enumeração.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou caracteres inválidos. Consulte caracteres inválidos usando o método <see cref="M:System.IO.Path.GetInvalidPathChars" />.  
  
\- ou - 
 <paramref name="searchPattern" /> não contém um padrão válido.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="searchPattern" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="searchOption" /> não é um valor <see cref="T:System.IO.SearchOption" /> válido.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException"><paramref name="path" /> é inválido, como referenciar uma unidade não mapeada.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> é um nome de arquivo.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema.</exception>
        <exception cref="T:System.Security.SecurityException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O chamador não tem a permissão necessária.</exception>
      </Docs>
    </Member>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public static bool Exists (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.Exists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exists (path As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Exists(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member Exists : string -&gt; bool" Usage="System.IO.Directory.Exists path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">O caminho a ser testado.</param>
        <summary>Determina se o caminho especificado se refere a um diretório existente em disco.</summary>
        <returns><see langword="true" /> se <paramref name="path" /> se referir a um diretório existente; <see langword="false" /> se o diretório não existir ou ocorrer um erro ao tentar determinar se o diretório especificado existe.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `path` parâmetro tem permissão para especificar informações de caminho relativo ou absoluto. As informações do caminho relativo são interpretadas como relativas ao diretório de trabalho atual.  
  
 Espaços à direita são removidos do final do `path` parâmetro antes de verificar se o diretório existe.  
  
 O `path` parâmetro não diferencia maiusculas de minúsculas.  
  
 Se você não tiver uma permissão mínima de somente leitura para o diretório, o <xref:System.IO.Directory.Exists%2A> método retornará `false`.  
  
 O <xref:System.IO.Directory.Exists%2A> método retorna `false` se ocorrer algum erro ao tentar determinar se o arquivo especificado existe. Isso pode ocorrer em situações que geram exceções, como passar um nome de arquivo com caracteres inválidos ou número excessivo de caracteres, um disco com falha ou ausente, ou se o chamador não tem permissão para ler o arquivo.  
  
   
  
## Examples  
 O exemplo a seguir usa uma matriz de nomes de arquivo ou diretório na linha de comando, determina que tipo de nome é e processa-os adequadamente.  
  
 [!code-cpp[Recursive file finder#2](~/samples/snippets/cpp/VS_Snippets_CLR/Recursive file finder/CPP/directorylisting.cpp#2)]
 [!code-csharp[Recursive file finder#2](~/samples/snippets/csharp/VS_Snippets_CLR/Recursive file finder/CS/directorylisting.cs#2)]
 [!code-vb[Recursive file finder#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Recursive file finder/VB/directorylisting.vb#2)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para ler arquivos. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.DirectoryInfo" />
        <related type="Article" href="~/docs/standard/io/index.md">E/S de arquivo e de fluxo</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Como ler texto de um arquivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Como gravar texto em um arquivo</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetAccessControl">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retorna a ACL (lista de controle de acesso) do Windows para um diretório.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public static System.Security.AccessControl.DirectorySecurity GetAccessControl (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.AccessControl.DirectorySecurity GetAccessControl(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetAccessControl(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetAccessControl (path As String) As DirectorySecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::AccessControl::DirectorySecurity ^ GetAccessControl(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetAccessControl : string -&gt; System.Security.AccessControl.DirectorySecurity" Usage="System.IO.Directory.GetAccessControl path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.DirectorySecurity</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">O caminho para um diretório que contém um objeto <see cref="T:System.Security.AccessControl.DirectorySecurity" /> que descreve as informações da ACL (lista de controle de acesso) do arquivo.</param>
        <summary>Obtém um objeto <see cref="T:System.Security.AccessControl.DirectorySecurity" /> que encapsula as entradas da ACL (lista de controle de acesso) para um diretório especificado.</summary>
        <returns>Um objeto que encapsula as regras de controle de acesso para o arquivo descrito pelo parâmetro <paramref name="path" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use o <xref:System.IO.Directory.GetAccessControl%2A> método para recuperar as entradas ACL (lista) de controle de acesso para um diretório.  
  
 Uma ACL descreve indivíduos e/ou grupos que têm ou não tem direitos para ações específicas em um determinado arquivo ou diretório. Para saber mais, confira [Como adicionar ou remover entradas da lista de controle de acesso](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md).  
  
 Em ambientes de NTFS <xref:System.Security.AccessControl.FileSystemRights.ReadAttributes> e <xref:System.Security.AccessControl.FileSystemRights.ReadExtendedAttributes> são concedidas ao usuário se o usuário tiver <xref:System.Security.AccessControl.FileSystemRights.ListDirectory> direitos na pasta pai. Negar <xref:System.Security.AccessControl.FileSystemRights.ReadAttributes> e <xref:System.Security.AccessControl.FileSystemRights.ReadExtendedAttributes>, negar <xref:System.Security.AccessControl.FileSystemRights.ListDirectory> no diretório pai.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.IO.Directory.GetAccessControl%2A> e o <xref:System.IO.Directory.SetAccessControl%2A> métodos para adicionar um acesso de entrada ACL (lista) de controle e, em seguida, remover uma entrada de ACL de um diretório.  Você deve fornecer uma conta de grupo ou de usuário válida para executar este exemplo.  
  
 [!code-cpp[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/cpp/sample.cpp#1)]
 [!code-csharp[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/CS/sample.cs#1)]
 [!code-vb[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S ao abrir o diretório.</exception>
        <exception cref="T:System.PlatformNotSupportedException">O sistema operacional atual não é o Windows 2000 ou posterior.</exception>
        <exception cref="T:System.SystemException">Ocorreu um erro no nível do sistema, por exemplo, não foi possível encontrar o diretório. A exceção específica pode ser uma subclasse de <see cref="T:System.SystemException" />.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O parâmetro <paramref name="path" /> especificou um diretório somente leitura.  
  
- ou - 
Não há suporte para essa operação na plataforma atual.  
  
- ou - 
O chamador não tem a permissão necessária.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">permissão enumerar a lista de controle de acesso (ACL) para um diretório. Enumerações associadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.NoAccess" /> , <see cref="F:System.Security.AccessControl.AccessControlActions.View" />  
  
Ação de segurança: Por demanda.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public static System.Security.AccessControl.DirectorySecurity GetAccessControl (string path, System.Security.AccessControl.AccessControlSections includeSections);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.AccessControl.DirectorySecurity GetAccessControl(string path, valuetype System.Security.AccessControl.AccessControlSections includeSections) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetAccessControl(System.String,System.Security.AccessControl.AccessControlSections)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetAccessControl (path As String, includeSections As AccessControlSections) As DirectorySecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::AccessControl::DirectorySecurity ^ GetAccessControl(System::String ^ path, System::Security::AccessControl::AccessControlSections includeSections);" />
      <MemberSignature Language="F#" Value="static member GetAccessControl : string * System.Security.AccessControl.AccessControlSections -&gt; System.Security.AccessControl.DirectorySecurity" Usage="System.IO.Directory.GetAccessControl (path, includeSections)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.DirectorySecurity</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="includeSections" Type="System.Security.AccessControl.AccessControlSections" />
      </Parameters>
      <Docs>
        <param name="path">O caminho para um diretório que contém um objeto <see cref="T:System.Security.AccessControl.DirectorySecurity" /> que descreve as informações da ACL (lista de controle de acesso) do arquivo.</param>
        <param name="includeSections">Um dos valores <see cref="T:System.Security.AccessControl.AccessControlSections" /> que especifica o tipo de informações de ACL (lista de controle de acesso) a serem recebidas.</param>
        <summary>Obtém um objeto <see cref="T:System.Security.AccessControl.DirectorySecurity" /> que encapsula o tipo especificado de entradas ACL (lista de controle de acesso) para um diretório especificado.</summary>
        <returns>Um objeto que encapsula as regras de controle de acesso para o arquivo descrito pelo parâmetro <paramref name="path" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use o <xref:System.IO.Directory.GetAccessControl%2A> método para recuperar as entradas ACL (lista) de controle de acesso para um diretório.  
  
 Uma ACL descreve indivíduos e/ou grupos que têm ou não tem direitos para ações específicas em um determinado arquivo ou diretório. Para saber mais, confira [Como adicionar ou remover entradas da lista de controle de acesso](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md).  
  
 Em ambientes de NTFS <xref:System.Security.AccessControl.FileSystemRights.ReadAttributes> e <xref:System.Security.AccessControl.FileSystemRights.ReadExtendedAttributes> são concedidas ao usuário se o usuário tiver <xref:System.Security.AccessControl.FileSystemRights.ListDirectory> direitos na pasta pai. Negar <xref:System.Security.AccessControl.FileSystemRights.ReadAttributes> e <xref:System.Security.AccessControl.FileSystemRights.ReadExtendedAttributes>, negar <xref:System.Security.AccessControl.FileSystemRights.ListDirectory> no diretório pai.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S ao abrir o diretório.</exception>
        <exception cref="T:System.PlatformNotSupportedException">O sistema operacional atual não é o Windows 2000 ou posterior.</exception>
        <exception cref="T:System.SystemException">Ocorreu um erro no nível do sistema, por exemplo, não foi possível encontrar o diretório. A exceção específica pode ser uma subclasse de <see cref="T:System.SystemException" />.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O parâmetro <paramref name="path" /> especificou um diretório somente leitura.  
  
- ou - 
Não há suporte para essa operação na plataforma atual.  
  
- ou - 
O chamador não tem a permissão necessária.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">permissão enumerar a lista de controle de acesso (ACL) para um diretório. Enumerações associadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.NoAccess" /> , <see cref="F:System.Security.AccessControl.AccessControlActions.View" />  
  
Ação de segurança: Por demanda.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetCreationTime">
      <MemberSignature Language="C#" Value="public static DateTime GetCreationTime (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime GetCreationTime(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetCreationTime(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCreationTime (path As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime GetCreationTime(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetCreationTime : string -&gt; DateTime" Usage="System.IO.Directory.GetCreationTime path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">O caminho do diretório.</param>
        <summary>Obtém a data e a hora de criação de um diretório.</summary>
        <returns>Uma estrutura que é definida como a data e a hora de criação para o diretório especificado. Esse valor é expresso no horário local.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Esse método pode retornar um valor incorreto, pois ela usa as funções nativas cujos valores não podem ser atualizados continuamente pelo sistema operacional.  
  
 Esse método é equivalente a <xref:System.IO.File.GetCreationTime%2A?displayProperty=nameWithType>.  
  
 Se o diretório descrito o `path` parâmetro não existe, este método retorna meia-noite, 1º de janeiro de 1601 D.C. (C.E.) Tempo Universal Coordenado (UTC), ajustado para o horário local.  
  
 O `path` parâmetro tem permissão para especificar informações de caminho relativo ou absoluto. As informações do caminho relativo são interpretadas como relativas ao diretório de trabalho atual. Para obter o diretório de trabalho atual, consulte <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 O `path` parâmetro não diferencia maiusculas de minúsculas.  
  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 O exemplo a seguir obtém a hora de criação do diretório especificado.  
  
 [!code-cpp[Dir_GetCreation#1](~/samples/snippets/cpp/VS_Snippets_CLR/Dir_GetCreation/CPP/dir_getcreation.cpp#1)]
 [!code-csharp[Dir_GetCreation#1](~/samples/snippets/csharp/VS_Snippets_CLR/Dir_GetCreation/CS/dir_getcreation.cs#1)]
 [!code-vb[Dir_GetCreation#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dir_GetCreation/VB/dir_getcreation.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou um ou mais caracteres inválidos. Consulte caracteres inválidos usando o método <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para ler o arquivo ou diretório especificado. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">E/S de arquivo e de fluxo</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Como ler texto de um arquivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Como gravar texto em um arquivo</related>
      </Docs>
    </Member>
    <Member MemberName="GetCreationTimeUtc">
      <MemberSignature Language="C#" Value="public static DateTime GetCreationTimeUtc (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime GetCreationTimeUtc(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetCreationTimeUtc(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCreationTimeUtc (path As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime GetCreationTimeUtc(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetCreationTimeUtc : string -&gt; DateTime" Usage="System.IO.Directory.GetCreationTimeUtc path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">O caminho do diretório.</param>
        <summary>Obtém a data e hora de criação, no formato UTC (Tempo Universal Coordenado), de um diretório.</summary>
        <returns>Uma estrutura que é definida como a data e a hora de criação para o diretório especificado. Esse valor é expresso em horário UTC.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Esse método pode retornar um valor incorreto, pois ela usa as funções nativas cujos valores não podem ser atualizados continuamente pelo sistema operacional.  
  
 Se o diretório descrito o `path` parâmetro não existe, este método retorna meia-noite, 1º de janeiro de 1601 D.C. (C.E.) Tempo Universal Coordenado (UTC).  
  
 Use esse método para obter a hora de criação de um diretório com base no tempo Universal Coordenado (UTC).  
  
   
  
## Examples  
 O exemplo a seguir ilustra as diferenças na saída ao usar a saída de tempo Universal Coordenado (UTC).  
  
 [!code-cpp[System.IO.UTCExample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.UTCExample/CPP/example.cpp#1)]
 [!code-csharp[System.IO.UTCExample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.UTCExample/CS/example.cs#1)]
 [!code-vb[System.IO.UTCExample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.UTCExample/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou um ou mais caracteres inválidos. Consulte caracteres inválidos usando o método <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para ler o arquivo ou diretório especificado. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">E/S de arquivo e de fluxo</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Como ler texto de um arquivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Como gravar texto em um arquivo</related>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentDirectory">
      <MemberSignature Language="C#" Value="public static string GetCurrentDirectory ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetCurrentDirectory() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetCurrentDirectory" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCurrentDirectory () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetCurrentDirectory();" />
      <MemberSignature Language="F#" Value="static member GetCurrentDirectory : unit -&gt; string" Usage="System.IO.Directory.GetCurrentDirectory " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtém o diretório de trabalho atual do aplicativo.</summary>
        <returns>Uma cadeia de caracteres que contém o caminho do diretório de trabalho atual e não termina com uma barra invertida (\\).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O diretório atual é diferente do diretório original, que é aquele do qual o processo foi iniciado.  
  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 O exemplo a seguir demonstra como usar o `GetCurrentDirectory` método.  
  
 [!code-cpp[Dir_GetCurDir#1](~/samples/snippets/cpp/VS_Snippets_CLR/Dir_GetCurDir/CPP/dir_getcurdir.cpp#1)]
 [!code-csharp[Dir_GetCurDir#1](~/samples/snippets/csharp/VS_Snippets_CLR/Dir_GetCurDir/CS/dir_getcurdir.cs#1)]
 [!code-vb[Dir_GetCurDir#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dir_GetCurDir/VB/dir_getcurdir.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.NotSupportedException">O sistema operacional é Windows CE, que não tem a funcionalidade de diretório atual.  
  
Esse método está disponível no .NET Compact Framework, mas não tem suporte no momento.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para acesso às informações de caminho para o diretório atual. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">E/S de arquivo e de fluxo</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Como ler texto de um arquivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Como gravar texto em um arquivo</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetDirectories">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retorna os nomes de subdiretórios que atendem ao critério especificado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetDirectories">
      <MemberSignature Language="C#" Value="public static string[] GetDirectories (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetDirectories(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetDirectories(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDirectories (path As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetDirectories(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetDirectories : string -&gt; string[]" Usage="System.IO.Directory.GetDirectories path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">O caminho relativo ou absoluto para o diretório a ser pesquisado. Esta cadeia de caracteres não diferencia maiúsculas de minúsculas.</param>
        <summary>Retorna os nomes de subdiretórios (inclusive os caminhos) no diretório especificado.</summary>
        <returns>Uma matriz de nomes completos (incluindo caminhos) dos subdiretórios no caminho especificado, ou uma matriz vazia, se nenhum diretório for encontrado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é idêntico ao <xref:System.IO.Directory.GetDirectories%28System.String%2CSystem.String%29> com o asterisco (\*) especificado como o padrão de pesquisa, portanto, ele retorna todos os subdiretórios. Se você precisar pesquisar os subdiretórios, use o <xref:System.IO.Directory.GetDirectories%28System.String%2CSystem.String%2CSystem.IO.SearchOption%29> método, que permite que você especifique uma pesquisa de subdiretórios com o `searchOption` parâmetro.  
  
 O <xref:System.IO.Directory.EnumerateDirectories%2A> e <xref:System.IO.Directory.GetDirectories%2A> métodos diferem da seguinte maneira: Quando você usa <xref:System.IO.Directory.EnumerateDirectories%2A>, você pode começar a enumerar a coleção de nomes antes da coleção inteira é retornada; quando você usa <xref:System.IO.Directory.GetDirectories%2A>, você deverá aguardar por toda a matriz de nomes a serem retornados antes de poder acessar a matriz. Portanto, quando você estiver trabalhando com muitos arquivos e diretórios, <xref:System.IO.Directory.EnumerateDirectories%2A> pode ser mais eficiente.  
  
 O `path` parâmetro pode especificar informações de caminho relativo ou absoluto. As informações do caminho relativo são interpretadas como relativas ao diretório de trabalho atual. Para obter o diretório de trabalho atual, consulte <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Os nomes retornados por esse método são prefixados com as informações do diretório fornecidas no `path`.  
  
 O `path` parâmetro não diferencia maiusculas de minúsculas.  
  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 O exemplo a seguir usa uma matriz de nomes de arquivo ou diretório na linha de comando, determina que tipo de nome é e processa-os adequadamente.  
  
 [!code-cpp[Recursive file finder#1](~/samples/snippets/cpp/VS_Snippets_CLR/Recursive file finder/CPP/directorylisting.cpp#1)]
 [!code-csharp[Recursive file finder#1](~/samples/snippets/csharp/VS_Snippets_CLR/Recursive file finder/CS/directorylisting.cs#1)]
 [!code-vb[Recursive file finder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Recursive file finder/VB/directorylisting.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou um ou mais caracteres inválidos. Consulte caracteres inválidos usando o método <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> é um nome de arquivo.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">O caminho especificado é inválido (por exemplo, ele está em uma unidade não mapeada).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para acessar informações de caminho para o diretório atual. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <altmember cref="M:System.IO.Directory.GetCurrentDirectory" />
        <related type="Article" href="~/docs/standard/io/index.md">E/S de arquivo e de fluxo</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Como ler texto de um arquivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Como gravar texto em um arquivo</related>
      </Docs>
    </Member>
    <Member MemberName="GetDirectories">
      <MemberSignature Language="C#" Value="public static string[] GetDirectories (string path, string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetDirectories(string path, string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetDirectories(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDirectories (path As String, searchPattern As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetDirectories(System::String ^ path, System::String ^ searchPattern);" />
      <MemberSignature Language="F#" Value="static member GetDirectories : string * string -&gt; string[]" Usage="System.IO.Directory.GetDirectories (path, searchPattern)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="searchPattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">O caminho relativo ou absoluto para o diretório a ser pesquisado. Esta cadeia de caracteres não diferencia maiúsculas de minúsculas.</param>
        <param name="searchPattern">A cadeia de caracteres de pesquisa para correspondência com os nomes dos subdiretórios em <paramref name="path" />. Esse parâmetro pode conter uma combinação de caracteres literais e curinga válidos, mas não dá suporte a expressões regulares.</param>
        <summary>Retorna os nomes de subdiretórios (incluindo os caminhos) que correspondem ao padrão de pesquisa especificado no diretório especificado.</summary>
        <returns>Uma matriz de nomes completos (incluindo caminhos) dos subdiretórios que correspondem ao padrão de pesquisa no diretório especificado, ou uma matriz vazia, se nenhum diretório for encontrado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método retorna todos os subdiretórios diretamente sob o diretório especificado que correspondem ao padrão de pesquisa especificado. Se o diretório especificado não tem nenhum subdiretório ou nenhum subdiretório corresponde o `searchPattern` parâmetro, esse método retorna uma matriz vazia. Somente o diretório superior é pesquisado. Se você deseja pesquisar também os subdiretórios, use o <xref:System.IO.Directory.GetDirectories%28System.String%2CSystem.String%2CSystem.IO.SearchOption%29> método e especifique <xref:System.IO.SearchOption.AllDirectories> no `searchOption` parâmetro.  
  
 `searchPattern` pode ser uma combinação de caracteres literais e curinga, mas ele não dá suporte a expressões regulares. Os seguintes especificadores de curinga são permitidos em `searchPattern`.  
  
|Especificador de curinga|Correspondências|  
|------------------------|-------------|  
|\* (asterisco)|Zero ou mais caracteres nessa posição.|  
|? (ponto de interrogação)|Zero ou um caractere nessa posição.|  
  
 Os caracteres que não seja o caractere curinga são caracteres literais. Por exemplo, o `searchPattern` cadeia de caracteres "\*t" procura todos os nomes no `path` terminando com a letra "t". O `searchPattern` cadeia de caracteres "s\*" procura todos os nomes no `path` começando com a letra "s".  
  
 `searchPattern` não pode terminar com dois pontos finais ("..") ou conter dois pontos ("..") seguido por <xref:System.IO.Path.DirectorySeparatorChar> ou <xref:System.IO.Path.AltDirectorySeparatorChar>, nem pode conter caracteres inválidos. Consulte caracteres inválidos usando o método <xref:System.IO.Path.GetInvalidPathChars%2A>.  
  
 O `path` parâmetro pode especificar informações de caminho relativo ou absoluto e não diferencia maiusculas de minúsculas.  As informações do caminho relativo são interpretadas como relativas ao diretório de trabalho atual. Para obter o diretório de trabalho atual, consulte <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 O <xref:System.IO.Directory.EnumerateDirectories%2A> e <xref:System.IO.Directory.GetDirectories%2A> métodos diferem da seguinte maneira: Quando você usa <xref:System.IO.Directory.EnumerateDirectories%2A>, você pode começar a enumerar a coleção de nomes antes da coleção inteira é retornada; quando você usa <xref:System.IO.Directory.GetDirectories%2A>, você deverá aguardar por toda a matriz de nomes a serem retornados antes de poder acessar a matriz. Portanto, quando você estiver trabalhando com muitos arquivos e diretórios, <xref:System.IO.Directory.EnumerateDirectories%2A> pode ser mais eficiente.  
  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 O exemplo a seguir conta o número de diretórios em um caminho que começam com a letra especificada.  
  
 [!code-cpp[Dir_GetDirs2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Dir_GetDirs2/CPP/dir_getdirs2.cpp#1)]
 [!code-csharp[Dir_GetDirs2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Dir_GetDirs2/CS/dir_getdirs2.cs#1)]
 [!code-vb[Dir_GetDirs2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dir_GetDirs2/VB/dir_getdirs2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou um ou mais caracteres inválidos. É possível consultar caracteres inválidos usando <see cref="M:System.IO.Path.GetInvalidPathChars" />.  
  
- ou - 
 <paramref name="searchPattern" /> não contém um padrão válido.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> ou <paramref name="searchPattern" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> é um nome de arquivo.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">O caminho especificado é inválido (por exemplo, ele está em uma unidade não mapeada).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para acesso às informações de caminho para o diretório atual. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <altmember cref="M:System.IO.Directory.GetCurrentDirectory" />
        <related type="Article" href="~/docs/standard/io/index.md">E/S de arquivo e de fluxo</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Como ler texto de um arquivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Como gravar texto em um arquivo</related>
      </Docs>
    </Member>
    <Member MemberName="GetDirectories">
      <MemberSignature Language="C#" Value="public static string[] GetDirectories (string path, string searchPattern, System.IO.EnumerationOptions enumerationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetDirectories(string path, string searchPattern, class System.IO.EnumerationOptions enumerationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetDirectories(System.String,System.String,System.IO.EnumerationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetDirectories(System::String ^ path, System::String ^ searchPattern, System::IO::EnumerationOptions ^ enumerationOptions);" />
      <MemberSignature Language="F#" Value="static member GetDirectories : string * string * System.IO.EnumerationOptions -&gt; string[]" Usage="System.IO.Directory.GetDirectories (path, searchPattern, enumerationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="enumerationOptions" Type="System.IO.EnumerationOptions" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="searchPattern">To be added.</param>
        <param name="enumerationOptions">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDirectories">
      <MemberSignature Language="C#" Value="public static string[] GetDirectories (string path, string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetDirectories(string path, string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetDirectories(System.String,System.String,System.IO.SearchOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetDirectories(System::String ^ path, System::String ^ searchPattern, System::IO::SearchOption searchOption);" />
      <MemberSignature Language="F#" Value="static member GetDirectories : string * string * System.IO.SearchOption -&gt; string[]" Usage="System.IO.Directory.GetDirectories (path, searchPattern, searchOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" />
      </Parameters>
      <Docs>
        <param name="path">O caminho relativo ou absoluto para o diretório a ser pesquisado. Esta cadeia de caracteres não diferencia maiúsculas de minúsculas.</param>
        <param name="searchPattern">A cadeia de caracteres de pesquisa para correspondência com os nomes dos subdiretórios em <paramref name="path" />. Esse parâmetro pode conter uma combinação de caracteres literais e curinga válidos, mas não dá suporte a expressões regulares.</param>
        <param name="searchOption">Um dos valores de enumeração que especifica se a operação de pesquisa deve incluir todos os subdiretórios ou apenas o diretório atual.</param>
        <summary>Retorna os nomes dos subdiretórios (incluindo os caminhos) que correspondem ao padrão de pesquisa especificado no diretório especificado e, opcionalmente, subdiretórios de pesquisas.</summary>
        <returns>Uma matriz de nomes completos (incluindo caminhos) dos subdiretórios que correspondem aos critérios especificados, ou uma matriz vazia, se nenhum diretório for encontrado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `path` parâmetro pode especificar informações de caminho relativo ou absoluto e não diferencia maiusculas de minúsculas. As informações do caminho relativo são interpretadas como relativas ao diretório de trabalho atual. Para obter o diretório de trabalho atual, consulte <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 `searchPattern` pode ser uma combinação de caracteres literais e curinga, mas ele não dá suporte a expressões regulares. Os seguintes especificadores de curinga são permitidos em `searchPattern`.  
  
|Especificador de curinga|Correspondências|  
|------------------------|-------------|  
|\* (asterisco)|Zero ou mais caracteres nessa posição.|  
|? (ponto de interrogação)|Zero ou um caractere nessa posição.|  
  
 Os caracteres que não seja o caractere curinga são caracteres literais. Por exemplo, o `searchPattern` cadeia de caracteres "\*t" procura todos os nomes no `path` terminando com a letra "t". O `searchPattern` cadeia de caracteres "s\*" procura todos os nomes no `path` começando com a letra "s".  
  
 `searchPattern` não pode terminar com dois pontos finais ("..") ou conter dois pontos ("..") seguido por <xref:System.IO.Path.DirectorySeparatorChar> ou <xref:System.IO.Path.AltDirectorySeparatorChar>, nem pode conter caracteres inválidos. Consulte caracteres inválidos usando o método <xref:System.IO.Path.GetInvalidPathChars%2A>.  
  
 O <xref:System.IO.Directory.EnumerateDirectories%2A> e <xref:System.IO.Directory.GetDirectories%2A> métodos diferem da seguinte maneira: Quando você usa <xref:System.IO.Directory.EnumerateDirectories%2A>, você pode começar a enumerar a coleção de nomes antes da coleção inteira é retornada; quando você usa <xref:System.IO.Directory.GetDirectories%2A>, você deverá aguardar por toda a matriz de nomes a serem retornados antes de poder acessar a matriz. Portanto, quando você estiver trabalhando com muitos arquivos e diretórios, <xref:System.IO.Directory.EnumerateDirectories%2A> pode ser mais eficiente.  
  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 O exemplo a seguir conta o número de diretórios que começam com a letra especificada em um caminho. Somente o diretório de nível superior é pesquisado.  
  
 [!code-csharp[Dir_GetDirs2#2](~/samples/snippets/csharp/VS_Snippets_CLR/Dir_GetDirs2/CS/dir_getdirs3.cs#2)]
 [!code-vb[Dir_GetDirs2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dir_GetDirs2/VB/dir_getdirs3.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou um ou mais caracteres inválidos. Consulte caracteres inválidos usando o método <see cref="M:System.IO.Path.GetInvalidPathChars" />.  
  
- ou - 
 <paramref name="searchPattern" /> não contém um padrão válido.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> ou <paramref name="searchPattern" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="searchOption" /> não é um valor <see cref="T:System.IO.SearchOption" /> válido.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> é um nome de arquivo.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">O caminho especificado é inválido (por exemplo, ele está em uma unidade não mapeada).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para acesso às informações de caminho para o diretório atual. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <altmember cref="M:System.IO.Directory.GetCurrentDirectory" />
        <related type="Article" href="~/docs/standard/io/index.md">E/S de arquivo e de fluxo</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Como ler texto de um arquivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Como gravar texto em um arquivo</related>
      </Docs>
    </Member>
    <Member MemberName="GetDirectoryRoot">
      <MemberSignature Language="C#" Value="public static string GetDirectoryRoot (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetDirectoryRoot(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetDirectoryRoot(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDirectoryRoot (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetDirectoryRoot(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetDirectoryRoot : string -&gt; string" Usage="System.IO.Directory.GetDirectoryRoot path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">O caminho de um arquivo ou diretório.</param>
        <summary>Retorna as informações de volume, raiz ou ambas para o caminho especificado.</summary>
        <returns>Uma cadeia de caracteres que contém as informações de volume, de raiz ou ambas do caminho especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método obtém o nome de caminho totalmente qualificado `path`, conforme retornado por <xref:System.IO.Path.GetFullPath%2A>, e retorna informações de diretório de raiz. O caminho especificado não deve existir.  
  
 O `path` parâmetro tem permissão para especificar informações de caminho relativo ou absoluto. As informações do caminho relativo são interpretadas como relativas ao diretório de trabalho atual. Para obter o diretório de trabalho atual, consulte <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 O `path` parâmetro não diferencia maiusculas de minúsculas.  
  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 O exemplo a seguir ilustra como definir o diretório atual e exibir o diretório raiz.  
  
 [!code-cpp[System.IO.DirectoryRoot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.DirectoryRoot/CPP/example.cpp#1)]
 [!code-csharp[System.IO.DirectoryRoot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.DirectoryRoot/CS/example.cs#1)]
 [!code-vb[System.IO.DirectoryRoot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.DirectoryRoot/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou um ou mais caracteres inválidos. Consulte caracteres inválidos com <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para acesso às informações de caminho para o diretório atual. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">E/S de arquivo e de fluxo</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Como ler texto de um arquivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Como gravar texto em um arquivo</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFiles">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retorna os nomes dos arquivos que atendem aos critérios especificados.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public static string[] GetFiles (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetFiles(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetFiles(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFiles (path As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetFiles(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetFiles : string -&gt; string[]" Usage="System.IO.Directory.GetFiles path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">O caminho relativo ou absoluto para o diretório a ser pesquisado. Esta cadeia de caracteres não diferencia maiúsculas de minúsculas.</param>
        <summary>Retorna os nomes de arquivos (inclusive os caminhos) no diretório especificado.</summary>
        <returns>Uma matriz de nomes completos (incluindo caminhos) para os arquivos no diretório especificado, ou uma matriz vazia se nenhum arquivo foi encontrado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.IO.Directory.EnumerateFiles%2A> e <xref:System.IO.Directory.GetFiles%2A> métodos diferem da seguinte maneira: Quando você usa <xref:System.IO.Directory.EnumerateFiles%2A>, você pode começar a enumerar a coleção de nomes antes da coleção inteira é retornada; quando você usa <xref:System.IO.Directory.GetFiles%2A>, você deverá aguardar por toda a matriz de nomes a serem retornados antes de poder acessar a matriz. Portanto, quando você estiver trabalhando com muitos arquivos e diretórios, <xref:System.IO.Directory.EnumerateFiles%2A> pode ser mais eficiente.  
  
 Os nomes de arquivos retornados são acrescentados ao fornecido `path` parâmetro.  
  
 Esse método é idêntico ao <xref:System.IO.Directory.GetFiles%28System.String%2CSystem.String%29> com o asterisco (\*) especificado como o padrão de pesquisa.  
  
 O `path` parâmetro pode especificar informações de caminho relativo ou absoluto. As informações do caminho relativo são interpretadas como relativas ao diretório de trabalho atual. Para obter o diretório de trabalho atual, consulte <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 A ordem dos nomes de arquivo retornado não é garantida; Use o <xref:System.Array.Sort%2A> método se a ordem de classificação específica for necessária.  
  
 O `path` parâmetro não diferencia maiusculas de minúsculas.  
  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 O exemplo a seguir demonstra como usar o <xref:System.IO.Directory.GetFiles%2A> método para retornar nomes de arquivo de um local especificado pelo usuário. O exemplo está configurado para capturar todas as erros comuns para esse método.  
  
 [!code-cpp[Recursive file finder#1](~/samples/snippets/cpp/VS_Snippets_CLR/Recursive file finder/CPP/directorylisting.cpp#1)]
 [!code-csharp[Recursive file finder#1](~/samples/snippets/csharp/VS_Snippets_CLR/Recursive file finder/CS/directorylisting.cs#1)]
 [!code-vb[Recursive file finder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Recursive file finder/VB/directorylisting.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> é um nome de arquivo.  
  
- ou - 
Erro de rede.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou um ou mais caracteres inválidos. Consulte caracteres inválidos usando o método <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">O caminho especificado não foi encontrado ou é inválido (por exemplo, ele está em uma unidade não mapeada).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para acesso às informações de caminho para o diretório atual. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">E/S de arquivo e de fluxo</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Como ler texto de um arquivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Como gravar texto em um arquivo</related>
      </Docs>
    </Member>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public static string[] GetFiles (string path, string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetFiles(string path, string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetFiles(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFiles (path As String, searchPattern As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetFiles(System::String ^ path, System::String ^ searchPattern);" />
      <MemberSignature Language="F#" Value="static member GetFiles : string * string -&gt; string[]" Usage="System.IO.Directory.GetFiles (path, searchPattern)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="searchPattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">O caminho relativo ou absoluto para o diretório a ser pesquisado. Esta cadeia de caracteres não diferencia maiúsculas de minúsculas.</param>
        <param name="searchPattern">A cadeia de caracteres de pesquisa para correspondência com os nomes dos arquivos em <paramref name="path" />.  Esse parâmetro pode conter uma combinação de caracteres curinga (* e ?) e caminho de literal, mas não dá suporte a expressões regulares.</param>
        <summary>Retorna os nomes de arquivo (incluindo os caminhos) que correspondem ao padrão de pesquisa especificado no diretório especificado.</summary>
        <returns>Uma matriz de nomes completos (incluindo caminhos) para os arquivos no diretório especificado que correspondem ao padrão de pesquisa especificada, ou uma matriz vazia, se nenhum arquivo foi encontrado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Os nomes de arquivos retornados são acrescentados ao fornecido `path` parâmetro e a ordem dos nomes de arquivo retornado não é garantido; use o <xref:System.Array.Sort%2A> método se a ordem de classificação específica for necessária.  
  
 `searchPattern` pode ser uma combinação de caracteres literais e curinga, mas ele não dá suporte a expressões regulares. Os seguintes especificadores de curinga são permitidos em `searchPattern`.  
  
|Especificador de curinga|Correspondências|  
|------------------------|-------------|  
|\* (asterisco)|Zero ou mais caracteres nessa posição.|  
|? (ponto de interrogação)|Zero ou um caractere nessa posição.|  
  
 Os caracteres que não seja o caractere curinga são caracteres literais. Por exemplo, o `searchPattern` cadeia de caracteres "\*t" procura todos os nomes no `path` terminando com a letra "t". O `searchPattern` cadeia de caracteres "s\*" procura todos os nomes no `path` começando com a letra "s".  
  
 `searchPattern` não pode terminar com dois pontos finais ("..") ou conter dois pontos ("..") seguido por <xref:System.IO.Path.DirectorySeparatorChar> ou <xref:System.IO.Path.AltDirectorySeparatorChar>, nem pode conter caracteres inválidos. Consulte caracteres inválidos usando o método <xref:System.IO.Path.GetInvalidPathChars%2A>.  
  
> [!NOTE]
>  Quando você usa o caractere curinga de asterisco em um `searchPattern` como "\*. txt", o número de caracteres em que a extensão especificada afeta a pesquisa da seguinte maneira:  
>   
> -   Se a extensão especificada é exatamente três caracteres, o método retorna arquivos com extensões que começam com a extensão especificada. Por exemplo, "\*. xls" retorna "book.xls" e "book.xlsx".  
> -   Em todos os outros casos, o método retorna arquivos que correspondem exatamente a extensão especificada. Por exemplo, "\*. AI" retorna "file.ai", mas não "file.aif".  
>   
>  Quando você usa o caractere curinga de ponto de interrogação, esse método retorna apenas os arquivos que correspondem a extensão de arquivo especificado. Por exemplo, considerando dois arquivos, "file1.txt" e "file1.txtother", em um diretório, um padrão de pesquisa de "arquivo?. txt"retorna apenas o primeiro arquivo, enquanto um padrão de pesquisa de" arquivo\*. txt "retorna os dois arquivos.  
  
> [!NOTE]
>  Como esse método verifica em relação a nomes de arquivo com o formato de nome de 8.3 arquivo e o formato de nome de arquivo longos, de uma pesquisa padrão semelhante ao "\*1\*. txt" pode retornar os nomes de arquivo inesperado. Por exemplo, usando um padrão de pesquisa de "\*1\*. txt" retorna "nomearquivolongo" porque o formato de nome de 8.3 arquivo equivalente é "LONGFI~1.TXT".  
  
 O <xref:System.IO.Directory.EnumerateFiles%2A> e <xref:System.IO.Directory.GetFiles%2A> métodos diferem da seguinte maneira: Quando você usa <xref:System.IO.Directory.EnumerateFiles%2A>, você pode começar a enumerar a coleção de nomes antes da coleção inteira é retornada; quando você usa <xref:System.IO.Directory.GetFiles%2A>, você deverá aguardar por toda a matriz de nomes a serem retornados antes de poder acessar a matriz. Portanto, quando você estiver trabalhando com muitos arquivos e diretórios, <xref:System.IO.Directory.EnumerateFiles%2A> pode ser mais eficiente.  
  
 O `path` parâmetro pode especificar informações de caminho relativo ou absoluto. As informações do caminho relativo são interpretadas como relativas ao diretório de trabalho atual. Para obter o diretório de trabalho atual, consulte <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 O `path` parâmetro não diferencia maiusculas de minúsculas.  
  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 O exemplo a seguir conta o número de arquivos que começam com a letra especificada.  
  
 [!code-cpp[Dir_GetFiles2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Dir_GetFiles2/CPP/dir_getfiles2.cpp#1)]
 [!code-csharp[Dir_GetFiles2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Dir_GetFiles2/CS/dir_getfiles2.cs#1)]
 [!code-vb[Dir_GetFiles2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dir_GetFiles2/VB/dir_getfiles2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> é um nome de arquivo.  
  
- ou - 
Erro de rede.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou um ou mais caracteres inválidos. É possível consultar caracteres inválidos usando <see cref="M:System.IO.Path.GetInvalidPathChars" />.  
  
- ou - 
 <paramref name="searchPattern" /> não contém um padrão válido.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> ou <paramref name="searchPattern" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">O caminho especificado não foi encontrado ou é inválido (por exemplo, ele está em uma unidade não mapeada).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para acesso às informações de caminho para o diretório atual. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">E/S de arquivo e de fluxo</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Como ler texto de um arquivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Como gravar texto em um arquivo</related>
      </Docs>
    </Member>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public static string[] GetFiles (string path, string searchPattern, System.IO.EnumerationOptions enumerationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetFiles(string path, string searchPattern, class System.IO.EnumerationOptions enumerationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetFiles(System.String,System.String,System.IO.EnumerationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetFiles(System::String ^ path, System::String ^ searchPattern, System::IO::EnumerationOptions ^ enumerationOptions);" />
      <MemberSignature Language="F#" Value="static member GetFiles : string * string * System.IO.EnumerationOptions -&gt; string[]" Usage="System.IO.Directory.GetFiles (path, searchPattern, enumerationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="enumerationOptions" Type="System.IO.EnumerationOptions" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="searchPattern">To be added.</param>
        <param name="enumerationOptions">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public static string[] GetFiles (string path, string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetFiles(string path, string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetFiles(System.String,System.String,System.IO.SearchOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetFiles(System::String ^ path, System::String ^ searchPattern, System::IO::SearchOption searchOption);" />
      <MemberSignature Language="F#" Value="static member GetFiles : string * string * System.IO.SearchOption -&gt; string[]" Usage="System.IO.Directory.GetFiles (path, searchPattern, searchOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" />
      </Parameters>
      <Docs>
        <param name="path">O caminho relativo ou absoluto para o diretório a ser pesquisado. Esta cadeia de caracteres não diferencia maiúsculas de minúsculas.</param>
        <param name="searchPattern">A cadeia de caracteres de pesquisa para correspondência com os nomes dos arquivos em <paramref name="path" />.  Esse parâmetro pode conter uma combinação de caracteres curinga (* e ?) e caminho de literal, mas não dá suporte a expressões regulares.</param>
        <param name="searchOption">Um dos valores de enumeração que especifica se a operação de pesquisa deve incluir todos os subdiretórios ou apenas o diretório atual.</param>
        <summary>Retorna os nomes de arquivo (incluindo os caminhos) que correspondem ao padrão de pesquisa especificado no diretório especificado, usando um valor para determinar se as subpastas devem ser pesquisadas.</summary>
        <returns>Uma matriz de nomes completos (incluindo caminhos) para os arquivos no diretório especificado que correspondem ao padrão e à opção de pesquisa especificada, ou uma matriz vazia, se nenhum arquivo foi encontrado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Os nomes de arquivos retornados são acrescentados com o parâmetro fornecido `path` e a ordem dos nomes de arquivo retornado não é garantida; use o <xref:System.Array.Sort%2A> método se a ordem de classificação específica for necessária.  
  
 `searchPattern` pode ser uma combinação de caracteres literais e curinga, mas ele não dá suporte a expressões regulares. Os seguintes especificadores de curinga são permitidos em `searchPattern`.  
  
|Especificador de curinga|Correspondências|  
|------------------------|-------------|  
|\* (asterisco)|Zero ou mais caracteres nessa posição.|  
|? (ponto de interrogação)|Zero ou um caractere nessa posição.|  
  
 Os caracteres que não seja o caractere curinga são caracteres literais. Por exemplo, o `searchPattern` cadeia de caracteres "\*t" procura todos os nomes no `path` terminando com a letra "t". O `searchPattern` cadeia de caracteres "s\*" procura todos os nomes no `path` começando com a letra "s".  
  
 `searchPattern` não pode terminar com dois pontos finais ("..") ou conter dois pontos ("..") seguido por <xref:System.IO.Path.DirectorySeparatorChar> ou <xref:System.IO.Path.AltDirectorySeparatorChar>, nem pode conter caracteres inválidos. Consulte caracteres inválidos usando o método <xref:System.IO.Path.GetInvalidPathChars%2A>.  
  
> [!NOTE]
>  Quando você usa o caractere curinga de asterisco em um `searchPattern` como "\*. txt", o número de caracteres em que a extensão especificada afeta a pesquisa da seguinte maneira:  
>   
> -   Se a extensão especificada é exatamente três caracteres, o método retorna arquivos com extensões que começam com a extensão especificada. Por exemplo, "\*. xls" retorna "book.xls" e "book.xlsx".  
> -   Em todos os outros casos, o método retorna arquivos que correspondem exatamente a extensão especificada. Por exemplo, "\*. AI" retorna "file.ai", mas não "file.aif".  
>   
>  Quando você usa o caractere curinga de ponto de interrogação, esse método retorna apenas os arquivos que correspondem a extensão de arquivo especificado. Por exemplo, considerando dois arquivos, "file1.txt" e "file1.txtother", em um diretório, um padrão de pesquisa de "arquivo?. txt"retorna apenas o primeiro arquivo, enquanto um padrão de pesquisa de"file*.txt"retorna os dois arquivos.  
  
> [!NOTE]
>  Como esse método verifica em relação a nomes de arquivo com o formato de nome de 8.3 arquivo e o formato de nome de arquivo longos, de uma pesquisa padrão semelhante ao "\*1\*. txt" pode retornar os nomes de arquivo inesperado. Por exemplo, usando um padrão de pesquisa de "\*1\*. txt" retorna "nomearquivolongo" porque o formato de nome de 8.3 arquivo equivalente é "LONGFI~1.TXT".  
  
 O <xref:System.IO.Directory.EnumerateFiles%2A> e <xref:System.IO.Directory.GetFiles%2A> métodos diferem da seguinte maneira: Quando você usa <xref:System.IO.Directory.EnumerateFiles%2A>, você pode começar a enumerar a coleção de nomes antes da coleção inteira é retornada; quando você usa <xref:System.IO.Directory.GetFiles%2A>, você deverá aguardar por toda a matriz de nomes a serem retornados antes de poder acessar a matriz. Portanto, quando você estiver trabalhando com muitos arquivos e diretórios, <xref:System.IO.Directory.EnumerateFiles%2A> pode ser mais eficiente.  
  
 Os nomes de arquivo incluem o caminho completo.  
  
 O `path` parâmetro pode especificar informações de caminho relativo ou absoluto. As informações do caminho relativo são interpretadas como relativas ao diretório de trabalho atual. Para obter o diretório de trabalho atual, consulte <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 O `path` parâmetro não diferencia maiusculas de minúsculas.  
  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou um ou mais caracteres inválidos. Consulte caracteres inválidos com o método <see cref="M:System.IO.Path.GetInvalidPathChars" />.  
  
- ou - 
 <paramref name="searchPattern" /> não contém um padrão válido.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> ou <paramref name="searchpattern" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="searchOption" /> não é um valor <see cref="T:System.IO.SearchOption" /> válido.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">O caminho especificado não foi encontrado ou é inválido (por exemplo, ele está em uma unidade não mapeada).</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> é um nome de arquivo.  
  
- ou - 
Erro de rede.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para acesso às informações de caminho para o diretório atual. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">E/S de arquivo e de fluxo</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Como ler texto de um arquivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Como gravar texto em um arquivo</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFileSystemEntries">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retorna os nomes de todos os arquivos e subdiretórios que atendem ao critério especificado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFileSystemEntries">
      <MemberSignature Language="C#" Value="public static string[] GetFileSystemEntries (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetFileSystemEntries(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetFileSystemEntries(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFileSystemEntries (path As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetFileSystemEntries(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetFileSystemEntries : string -&gt; string[]" Usage="System.IO.Directory.GetFileSystemEntries path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">O caminho relativo ou absoluto para o diretório a ser pesquisado. Esta cadeia de caracteres não diferencia maiúsculas de minúsculas.</param>
        <summary>Retorna os nomes de todos os arquivos e subdiretórios em um caminho especificado.</summary>
        <returns>Uma matriz de nomes de arquivos e subdiretórios no diretório especificado ou uma matriz vazia se nenhum arquivo ou subdiretório for encontrado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A ordem dos nomes de diretório e arquivo retornado não é garantida; Use o <xref:System.Array.Sort%2A> método se a ordem de classificação específica for necessária.  
  
 O <xref:System.IO.Directory.EnumerateFileSystemEntries%2A> e <xref:System.IO.Directory.GetFileSystemEntries%2A> métodos diferem da seguinte maneira: Quando você usa <xref:System.IO.Directory.EnumerateFileSystemEntries%2A>, você pode começar a enumerar a coleção de entradas antes da coleção inteira é retornada; quando você usa <xref:System.IO.Directory.GetFileSystemEntries%2A>, você deve aguardar a matriz inteira de entradas a serem retornadas antes de poder acessar a matriz. Portanto, quando você estiver trabalhando com muitos arquivos e diretórios, <xref:System.IO.Directory.EnumerateFiles%2A> pode ser mais eficiente.  
  
 Esse método é idêntico ao <xref:System.IO.Directory.GetFileSystemEntries%2A> com o asterisco (\*) especificado como o padrão de pesquisa.  
  
 O `path` parâmetro tem permissão para especificar informações de caminho relativo ou absoluto. As informações do caminho relativo são interpretadas como relativas ao diretório de trabalho atual. Para obter o diretório de trabalho atual, consulte <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 O `path` parâmetro não diferencia maiusculas de minúsculas.  
  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.IO.Directory.GetFileSystemEntries%2A> método para preencher uma matriz de cadeias de caracteres com os nomes de todos os arquivos e subdiretórios em um local especificado pelo usuário e imprime cada cadeia de caracteres na matriz para o console. O exemplo está configurado para capturar todas as erros comuns para esse método.  
  
 [!code-cpp[System.IO.Directory#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Directory/CPP/class1.cpp#1)]
 [!code-csharp[System.IO.Directory#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class1.cs#1)]
 [!code-vb[System.IO.Directory#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou um ou mais caracteres inválidos. Consulte caracteres inválidos com <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> é um nome de arquivo.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">O caminho especificado é inválido (por exemplo, ele está em uma unidade não mapeada).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para acesso às informações de caminho para o diretório atual. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <altmember cref="T:System.IO.FileSystemInfo" />
        <related type="Article" href="~/docs/standard/io/index.md">E/S de arquivo e de fluxo</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Como ler texto de um arquivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Como gravar texto em um arquivo</related>
      </Docs>
    </Member>
    <Member MemberName="GetFileSystemEntries">
      <MemberSignature Language="C#" Value="public static string[] GetFileSystemEntries (string path, string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetFileSystemEntries(string path, string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetFileSystemEntries(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFileSystemEntries (path As String, searchPattern As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetFileSystemEntries(System::String ^ path, System::String ^ searchPattern);" />
      <MemberSignature Language="F#" Value="static member GetFileSystemEntries : string * string -&gt; string[]" Usage="System.IO.Directory.GetFileSystemEntries (path, searchPattern)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="searchPattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">O caminho relativo ou absoluto para o diretório a ser pesquisado. Esta cadeia de caracteres não diferencia maiúsculas de minúsculas.</param>
        <param name="searchPattern">A cadeia de caracteres de pesquisa para correspondência com os nomes de arquivo e de diretórios em <paramref name="path" />.  Esse parâmetro pode conter uma combinação de caracteres curinga (* e ?) e caminho de literal, mas não dá suporte a expressões regulares.</param>
        <summary>Retorna uma matriz de nomes de arquivo e nomes de diretório que correspondem a um padrão de pesquisa em um caminho especificado.</summary>
        <returns>Uma matriz de nomes de arquivo e nomes de diretório que correspondem aos critérios de pesquisa especificados ou uma matriz vazia se nenhum arquivo ou diretório for encontrado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A ordem dos nomes de diretório e arquivo retornado não é garantida; Use o <xref:System.Array.Sort%2A> método se a ordem de classificação específica for necessária.  
  
 `searchPattern` pode ser uma combinação de caracteres literais e curinga, mas ele não dá suporte a expressões regulares. Os seguintes especificadores de curinga são permitidos em `searchPattern`.  
  
|Especificador de curinga|Correspondências|  
|------------------------|-------------|  
|\* (asterisco)|Zero ou mais caracteres nessa posição.|  
|? (ponto de interrogação)|Zero ou um caractere nessa posição.|  
  
 Os caracteres que não seja o caractere curinga são caracteres literais. Por exemplo, o `searchPattern` cadeia de caracteres "\*t" procura todos os nomes no `path` terminando com a letra "t". O `searchPattern` cadeia de caracteres "s\*" procura todos os nomes no `path` começando com a letra "s".  
  
 `searchPattern` não pode terminar com dois pontos finais ("..") ou conter dois pontos ("..") seguido por <xref:System.IO.Path.DirectorySeparatorChar> ou <xref:System.IO.Path.AltDirectorySeparatorChar>, nem pode conter caracteres inválidos. Consulte caracteres inválidos usando o método <xref:System.IO.Path.GetInvalidPathChars%2A>.  
  
> [!NOTE]
>  Quando você usa o caractere curinga de asterisco em um `searchPattern` como "\*. txt", o número de caracteres em que a extensão especificada afeta a pesquisa da seguinte maneira:  
>   
> -   Se a extensão especificada é exatamente três caracteres, o método retorna arquivos com extensões que começam com a extensão especificada. Por exemplo, "\*. xls" retorna "book.xls" e "book.xlsx".  
> -   Em todos os outros casos, o método retorna arquivos que correspondem exatamente a extensão especificada. Por exemplo, "\*. AI" retorna "file.ai", mas não "file.aif".  
>   
>  Quando você usa o caractere curinga de ponto de interrogação, esse método retorna apenas os arquivos que correspondem a extensão de arquivo especificado. Por exemplo, considerando dois arquivos, "file1.txt" e "file1.txtother", em um diretório, um padrão de pesquisa de "arquivo?. txt"retorna apenas o primeiro arquivo, enquanto um padrão de pesquisa de" arquivo\*. txt "retorna os dois arquivos.  
  
 O `path` parâmetro tem permissão para especificar informações de caminho relativo ou absoluto. As informações do caminho relativo são interpretadas como relativas ao diretório de trabalho atual. Para obter o diretório de trabalho atual, consulte <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 O `path` parâmetro não diferencia maiusculas de minúsculas.  
  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.IO.Directory.GetFileSystemEntries%2A> método para preencher uma matriz de cadeias de caracteres com os nomes de todos os arquivos correspondendo a um filtro especificado pelo usuário em um local específico e imprime cada cadeia de caracteres na matriz para o console. O exemplo está configurado para capturar todas as erros comuns para esse método.  
  
 [!code-cpp[System.IO.Directory#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Directory/CPP/class1.cpp#2)]
 [!code-csharp[System.IO.Directory#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class1.cs#2)]
 [!code-vb[System.IO.Directory#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou um ou mais caracteres inválidos. Consulte caracteres inválidos com o método <see cref="M:System.IO.Path.GetInvalidPathChars" />.  
  
- ou - 
 <paramref name="searchPattern" /> não contém um padrão válido.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> ou <paramref name="searchPattern" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> é um nome de arquivo.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">O caminho especificado é inválido (por exemplo, ele está em uma unidade não mapeada).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para acesso às informações de caminho para o diretório atual. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <altmember cref="T:System.IO.FileSystemInfo" />
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">E/S de arquivo e de fluxo</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Como ler texto de um arquivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Como gravar texto em um arquivo</related>
      </Docs>
    </Member>
    <Member MemberName="GetFileSystemEntries">
      <MemberSignature Language="C#" Value="public static string[] GetFileSystemEntries (string path, string searchPattern, System.IO.EnumerationOptions enumerationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetFileSystemEntries(string path, string searchPattern, class System.IO.EnumerationOptions enumerationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetFileSystemEntries(System.String,System.String,System.IO.EnumerationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetFileSystemEntries(System::String ^ path, System::String ^ searchPattern, System::IO::EnumerationOptions ^ enumerationOptions);" />
      <MemberSignature Language="F#" Value="static member GetFileSystemEntries : string * string * System.IO.EnumerationOptions -&gt; string[]" Usage="System.IO.Directory.GetFileSystemEntries (path, searchPattern, enumerationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="enumerationOptions" Type="System.IO.EnumerationOptions" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="searchPattern">To be added.</param>
        <param name="enumerationOptions">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetFileSystemEntries">
      <MemberSignature Language="C#" Value="public static string[] GetFileSystemEntries (string path, string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetFileSystemEntries(string path, string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetFileSystemEntries(System.String,System.String,System.IO.SearchOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetFileSystemEntries(System::String ^ path, System::String ^ searchPattern, System::IO::SearchOption searchOption);" />
      <MemberSignature Language="F#" Value="static member GetFileSystemEntries : string * string * System.IO.SearchOption -&gt; string[]" Usage="System.IO.Directory.GetFileSystemEntries (path, searchPattern, searchOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" />
      </Parameters>
      <Docs>
        <param name="path">O caminho relativo ou absoluto para o diretório a ser pesquisado. Esta cadeia de caracteres não diferencia maiúsculas de minúsculas.</param>
        <param name="searchPattern">A cadeia de caracteres de pesquisa para correspondência com os nomes de arquivo e de diretórios em <paramref name="path" />.  Esse parâmetro pode conter uma combinação de caracteres curinga (* e ?) e caminho de literal, mas não dá suporte a expressões regulares.</param>
        <param name="searchOption">Um dos valores de enumeração que especifica se a operação de pesquisa deve incluir somente o diretório atual ou todos os subdiretórios.  
  
O valor padrão é <see cref="F:System.IO.SearchOption.TopDirectoryOnly" />.</param>
        <summary>Retorna uma matriz de todos os nomes de arquivo e nomes de diretórios que correspondem a um padrão de pesquisa em um caminho especificado e, opcionalmente, pesquisa subdiretórios.</summary>
        <returns>Uma matriz de nomes de arquivo e nomes de diretório que correspondem aos critérios de pesquisa especificados ou uma matriz vazia se nenhum arquivo ou diretório for encontrado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A ordem dos nomes de diretório e arquivo retornado não é garantida; Use o <xref:System.Array.Sort%2A> método se a ordem de classificação específica for necessária.  
  
 `searchPattern` pode ser uma combinação de caracteres literais e curinga, mas ele não dá suporte a expressões regulares. Os seguintes especificadores de curinga são permitidos em `searchPattern`.  
  
|Especificador de curinga|Correspondências|  
|------------------------|-------------|  
|\* (asterisco)|Zero ou mais caracteres nessa posição.|  
|? (ponto de interrogação)|Zero ou um caractere nessa posição.|  
  
 Os caracteres que não seja o caractere curinga são caracteres literais. Por exemplo, o `searchPattern` cadeia de caracteres "\*t" procura todos os nomes no `path` terminando com a letra "t". O `searchPattern` cadeia de caracteres "s\*" procura todos os nomes no `path` começando com a letra "s".  
  
 `searchPattern` não pode terminar com dois pontos finais ("..") ou conter dois pontos ("..") seguido por <xref:System.IO.Path.DirectorySeparatorChar> ou <xref:System.IO.Path.AltDirectorySeparatorChar>, nem pode conter caracteres inválidos. Consulte caracteres inválidos usando o método <xref:System.IO.Path.GetInvalidPathChars%2A>.  
  
> [!NOTE]
>  Quando você usa o caractere curinga de asterisco em um `searchPattern` como "\*. txt", o número de caracteres em que a extensão especificada afeta a pesquisa da seguinte maneira:  
>   
> -   Se a extensão especificada é exatamente três caracteres, o método retorna arquivos com extensões que começam com a extensão especificada. Por exemplo, "\*. xls" retorna "book.xls" e "book.xlsx".  
> -   Em todos os outros casos, o método retorna arquivos que correspondem exatamente a extensão especificada. Por exemplo, "\*. AI" retorna "file.ai", mas não "file.aif".  
>   
>  Quando você usa o caractere curinga de ponto de interrogação, esse método retorna apenas os arquivos que correspondem a extensão de arquivo especificado. Por exemplo, considerando dois arquivos, "file1.txt" e "file1.txtother", em um diretório, um padrão de pesquisa de "arquivo?. txt"retorna apenas o primeiro arquivo, enquanto um padrão de pesquisa de" arquivo\*. txt "retorna os dois arquivos.  
  
 O <xref:System.IO.Directory.EnumerateFileSystemEntries%2A> e <xref:System.IO.Directory.GetFileSystemEntries%2A> métodos diferem da seguinte maneira: Quando você usa <xref:System.IO.Directory.EnumerateFileSystemEntries%2A>, você pode começar a enumerar a coleção de entradas antes da coleção inteira é retornada; quando você usa <xref:System.IO.Directory.GetFileSystemEntries%2A>, você deve aguardar a matriz inteira de entradas a serem retornadas antes de poder acessar a matriz. Portanto, quando você estiver trabalhando com muitos arquivos e diretórios, <xref:System.IO.Directory.EnumerateFiles%2A> pode ser mais eficiente.  
  
 Você pode especificar informações de caminho relativo com o `path` parâmetro. Informações de caminho relativo são interpretadas como relativo ao diretório de trabalho atual, você pode determinar usando o <xref:System.IO.Directory.GetCurrentDirectory%2A> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou caracteres inválidos. Consulte caracteres inválidos usando o método <see cref="M:System.IO.Path.GetInvalidPathChars" />.  
  
\- ou - 
 <paramref name="searchPattern" /> não contém um padrão válido.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="searchPattern" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="searchOption" /> não é um valor <see cref="T:System.IO.SearchOption" /> válido.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException"><paramref name="path" /> é inválido, como referenciar uma unidade não mapeada.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> é um nome de arquivo.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema.</exception>
        <exception cref="T:System.Security.SecurityException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O chamador não tem a permissão necessária.</exception>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="GetLastAccessTime">
      <MemberSignature Language="C#" Value="public static DateTime GetLastAccessTime (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime GetLastAccessTime(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetLastAccessTime(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLastAccessTime (path As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime GetLastAccessTime(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetLastAccessTime : string -&gt; DateTime" Usage="System.IO.Directory.GetLastAccessTime path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">O arquivo ou diretório para o qual as informações de data e hora de acesso serão obtidas.</param>
        <summary>Retorna a data e hora em que o arquivo ou o diretório foi acessado pela última vez.</summary>
        <returns>Uma estrutura definida como a data e hora em que o arquivo ou diretório especificado foi acessado pela última vez. Esse valor é expresso no horário local.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Esse método pode retornar um valor incorreto, pois ela usa as funções nativas cujos valores não podem ser atualizados continuamente pelo sistema operacional.  
  
 Esse método é idêntico ao <xref:System.IO.File.GetLastAccessTime%2A?displayProperty=nameWithType>.  
  
 Se o diretório descrito o `path` parâmetro não existe, este método retorna meia-noite, 1º de janeiro de 1601 D.C. (C.E.) Tempo Universal Coordenado (UTC), ajustado para o horário local.  
  
 O `path` parâmetro tem permissão para especificar informações de caminho relativo ou absoluto. As informações do caminho relativo são interpretadas como relativas ao diretório de trabalho atual. Para obter o diretório de trabalho atual, consulte <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 O `path` parâmetro não diferencia maiusculas de minúsculas.  
  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 O exemplo a seguir demonstra como usar `GetLastAccessTime`.  
  
 [!code-cpp[Dir_GetLastAccess#1](~/samples/snippets/cpp/VS_Snippets_CLR/Dir_GetLastAccess/CPP/dir_getlastaccess.cpp#1)]
 [!code-csharp[Dir_GetLastAccess#1](~/samples/snippets/csharp/VS_Snippets_CLR/Dir_GetLastAccess/CS/dir_getlastaccess.cs#1)]
 [!code-vb[Dir_GetLastAccess#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dir_GetLastAccess/VB/dir_getlastaccess.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou um ou mais caracteres inválidos. Consulte caracteres inválidos com o método <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema.</exception>
        <exception cref="T:System.NotSupportedException">O parâmetro <paramref name="path" /> está em um formato inválido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para ler o arquivo ou diretório especificado. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">E/S de arquivo e de fluxo</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Como ler texto de um arquivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Como gravar texto em um arquivo</related>
      </Docs>
    </Member>
    <Member MemberName="GetLastAccessTimeUtc">
      <MemberSignature Language="C#" Value="public static DateTime GetLastAccessTimeUtc (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime GetLastAccessTimeUtc(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetLastAccessTimeUtc(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLastAccessTimeUtc (path As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime GetLastAccessTimeUtc(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetLastAccessTimeUtc : string -&gt; DateTime" Usage="System.IO.Directory.GetLastAccessTimeUtc path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">O arquivo ou diretório para o qual as informações de data e hora de acesso serão obtidas.</param>
        <summary>Retorna a data e hora, no formato UTC (Tempo Universal Coordenado), em que o arquivo ou diretório especificado foi acessado pela última vez.</summary>
        <returns>Uma estrutura definida como a data e hora em que o arquivo ou diretório especificado foi acessado pela última vez. Esse valor é expresso em horário UTC.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Esse método pode retornar um valor incorreto, pois ela usa as funções nativas cujos valores não podem ser atualizados continuamente pelo sistema operacional.  
  
 Se o diretório descrito o `path` parâmetro não existe, este método retorna meia-noite, 1º de janeiro de 1601 D.C. (C.E.) Tempo Universal Coordenado (UTC).  
  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 O exemplo a seguir ilustra as diferenças na saída ao usar a saída de tempo Universal Coordenado (UTC).  
  
 [!code-cpp[System.IO.UTCExample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.UTCExample/CPP/example.cpp#1)]
 [!code-csharp[System.IO.UTCExample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.UTCExample/CS/example.cs#1)]
 [!code-vb[System.IO.UTCExample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.UTCExample/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou um ou mais caracteres inválidos. Consulte caracteres inválidos com o método <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema.</exception>
        <exception cref="T:System.NotSupportedException">O parâmetro <paramref name="path" /> está em um formato inválido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para ler o arquivo ou diretório especificado. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">E/S de arquivo e de fluxo</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Como ler texto de um arquivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Como gravar texto em um arquivo</related>
      </Docs>
    </Member>
    <Member MemberName="GetLastWriteTime">
      <MemberSignature Language="C#" Value="public static DateTime GetLastWriteTime (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime GetLastWriteTime(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetLastWriteTime(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLastWriteTime (path As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime GetLastWriteTime(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetLastWriteTime : string -&gt; DateTime" Usage="System.IO.Directory.GetLastWriteTime path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">O arquivo ou diretório para o qual obter informações de data e hora da modificação.</param>
        <summary>Retorna a data e hora em que o arquivo ou diretório especificado foi usado para gravação pela última vez.</summary>
        <returns>Uma estrutura que está definida para a data e hora em que o arquivo ou diretório especificado foi gravado pela última vez. Esse valor é expresso no horário local.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Esse método pode retornar um valor incorreto, pois ela usa as funções nativas cujos valores não podem ser atualizados continuamente pelo sistema operacional.  
  
 Se o diretório descrito o `path` parâmetro não existe, este método retorna meia-noite, 1º de janeiro de 1601 D.C. (C.E.) Tempo Universal Coordenado (UTC), ajustado para o horário local.  
  
 O `path` parâmetro tem permissão para especificar informações de caminho relativo ou absoluto. As informações do caminho relativo são interpretadas como relativas ao diretório de trabalho atual. Para obter o diretório de trabalho atual, consulte <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 O `path` parâmetro não diferencia maiusculas de minúsculas.  
  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 O exemplo a seguir demonstra como usar `GetLastWriteTime`.  
  
 [!code-cpp[Dir_GetLastWrite#1](~/samples/snippets/cpp/VS_Snippets_CLR/Dir_GetLastWrite/CPP/dir_getlastwrite.cpp#1)]
 [!code-csharp[Dir_GetLastWrite#1](~/samples/snippets/csharp/VS_Snippets_CLR/Dir_GetLastWrite/CS/dir_getlastwrite.cs#1)]
 [!code-vb[Dir_GetLastWrite#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dir_GetLastWrite/VB/dir_getlastwrite.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou um ou mais caracteres inválidos. Consulte caracteres inválidos com o método <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para ler o arquivo ou diretório especificado. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">E/S de arquivo e de fluxo</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Como ler texto de um arquivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Como gravar texto em um arquivo</related>
      </Docs>
    </Member>
    <Member MemberName="GetLastWriteTimeUtc">
      <MemberSignature Language="C#" Value="public static DateTime GetLastWriteTimeUtc (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime GetLastWriteTimeUtc(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetLastWriteTimeUtc(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLastWriteTimeUtc (path As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime GetLastWriteTimeUtc(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetLastWriteTimeUtc : string -&gt; DateTime" Usage="System.IO.Directory.GetLastWriteTimeUtc path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">O arquivo ou diretório para o qual obter informações de data e hora da modificação.</param>
        <summary>Retorna a data e hora, no formato UTC (Tempo Universal Coordenado), em que o arquivo ou diretório especificado foi gravado pela última vez.</summary>
        <returns>Uma estrutura que está definida para a data e hora em que o arquivo ou diretório especificado foi gravado pela última vez. Esse valor é expresso em horário UTC.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Esse método pode retornar um valor incorreto, pois ela usa as funções nativas cujos valores não podem ser atualizados continuamente pelo sistema operacional.  
  
 Se o diretório descrito o `path` parâmetro não existe, este método retorna meia-noite, 1º de janeiro de 1601 D.C. (C.E.) Tempo Universal Coordenado (UTC).  
  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 O exemplo a seguir ilustra as diferenças na saída ao usar a saída de tempo Universal Coordenado (UTC).  
  
 [!code-cpp[System.IO.UTCExample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.UTCExample/CPP/example.cpp#1)]
 [!code-csharp[System.IO.UTCExample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.UTCExample/CS/example.cs#1)]
 [!code-vb[System.IO.UTCExample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.UTCExample/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou um ou mais caracteres inválidos. Consulte caracteres inválidos com o método <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para ler o arquivo ou diretório especificado. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">E/S de arquivo e de fluxo</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Como ler texto de um arquivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Como gravar texto em um arquivo</related>
      </Docs>
    </Member>
    <Member MemberName="GetLogicalDrives">
      <MemberSignature Language="C#" Value="public static string[] GetLogicalDrives ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetLogicalDrives() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetLogicalDrives" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLogicalDrives () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetLogicalDrives();" />
      <MemberSignature Language="F#" Value="static member GetLogicalDrives : unit -&gt; string[]" Usage="System.IO.Directory.GetLogicalDrives " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Recupera os nomes das unidades lógicas neste computador no formato "&lt;letra da unidade&gt;:\\".</summary>
        <returns>As unidades lógicas neste computador.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 GetLogicalDrives retorna todas as unidades acessíveis em um computador específico, incluindo a unidade de disquete e todas as unidades ópticas.  
  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.IO.Directory.GetLogicalDrives%2A> método para atribuir o nome de cada unidade no computador de chamada para uma matriz de cadeias de caracteres. Cada membro dessa matriz de cadeia de caracteres, em seguida, é impressa no console. O exemplo está configurado para capturar todas as erros comuns para esse método.  
  
 [!code-cpp[System.IO.Directory#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Directory/CPP/class1.cpp#3)]
 [!code-csharp[System.IO.Directory#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class1.cs#3)]
 [!code-vb[System.IO.Directory#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S (por exemplo, um erro de disco).</exception>
        <exception cref="T:System.UnauthorizedAccessException">O chamador não tem a permissão necessária.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para chamar código não gerenciado, como chamar código nativo com PInvoke ou a interoperabilidade COM. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">E/S de arquivo e de fluxo</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Como ler texto de um arquivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Como gravar texto em um arquivo</related>
      </Docs>
    </Member>
    <Member MemberName="GetParent">
      <MemberSignature Language="C#" Value="public static System.IO.DirectoryInfo GetParent (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.DirectoryInfo GetParent(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetParent(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetParent (path As String) As DirectoryInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::DirectoryInfo ^ GetParent(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetParent : string -&gt; System.IO.DirectoryInfo" Usage="System.IO.Directory.GetParent path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">O caminho no qual o diretório pai deve ser recuperado.</param>
        <summary>Recupera o diretório pai do caminho especificado, incluindo caminhos absolutos e relativos.</summary>
        <returns>O diretório pai, ou <see langword="null" />, se <paramref name="path" /> for o diretório raiz, incluindo a raiz de um nome do compartilhamento ou de servidor UNC.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `path` parâmetro pode especificar informações de caminho relativo ou absoluto. As informações do caminho relativo são interpretadas como relativas ao diretório de trabalho atual. Para obter o diretório de trabalho atual, consulte <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Espaços à direita são removidos do final do `path` parâmetro antes de obter o diretório.  
  
 A cadeia de caracteres retornada por esse método consiste em todos os caracteres no caminho até, mas não incluindo, a última <xref:System.IO.Path.DirectorySeparatorChar> ou <xref:System.IO.Path.AltDirectorySeparatorChar>. Por exemplo, passando o caminho "C:\Directory\SubDirectory\test.txt" para <xref:System.IO.Directory.GetParent%2A> retorna "C:\Directory\SubDirectory". Passar "C:\Directory\SubDirectory" retorna "C:\Directory". No entanto, passando "C:\Directory\SubDirectory\\" retorna "C:\Directory\SubDirectory", como o separador de diretório final está após "Subdiretório".  
  
 O `path` parâmetro não diferencia maiusculas de minúsculas.  
  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 O exemplo a seguir demonstra como usar o <xref:System.IO.Directory.GetParent%2A> método para recuperar o diretório pai de um local especificado pelo usuário, "caminho". O valor retornado pelo <xref:System.IO.Directory.GetParent%2A> método, em seguida, é impressa no console. O exemplo está configurado para capturar todas as erros comuns para esse método.  
  
 [!code-cpp[System.IO.Directory#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Directory/CPP/class1.cpp#4)]
 [!code-csharp[System.IO.Directory#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class1.cs#4)]
 [!code-vb[System.IO.Directory#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class1.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">O diretório especificado por <paramref name="path" /> é somente leitura.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou um ou mais caracteres inválidos. Consulte caracteres inválidos com o método <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema. Para obter mais informações, consulte o tópico <see cref="T:System.IO.PathTooLongException" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">O caminho especificado não foi encontrado.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" /> está em um formato inválido.</exception>
        <exception cref="T:System.Security.SecurityException">Somente .NET Framework: O chamador não tem as permissões necessárias.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para leitura de arquivos ou diretórios. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.DirectoryInfo" />
        <related type="Article" href="~/docs/standard/io/index.md">E/S de arquivo e de fluxo</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Como ler texto de um arquivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Como gravar texto em um arquivo</related>
      </Docs>
    </Member>
    <Member MemberName="Move">
      <MemberSignature Language="C#" Value="public static void Move (string sourceDirName, string destDirName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Move(string sourceDirName, string destDirName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.Move(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Move (sourceDirName As String, destDirName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Move(System::String ^ sourceDirName, System::String ^ destDirName);" />
      <MemberSignature Language="F#" Value="static member Move : string * string -&gt; unit" Usage="System.IO.Directory.Move (sourceDirName, destDirName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceDirName" Type="System.String" />
        <Parameter Name="destDirName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="sourceDirName">O caminho do arquivo ou diretório a ser movido.</param>
        <param name="destDirName">O caminho para o novo local do <paramref name="sourceDirName" />. Se <paramref name="sourceDirName" /> for um arquivo, <paramref name="destDirName" /> também deverá ser um nome de arquivo.</param>
        <summary>Move um arquivo ou um diretório e seu conteúdo para um novo local.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método cria um novo diretório com o nome especificado por `destDirName` e move o conteúdo de `sourceDirName` para o diretório de destino recém-criada. Se você tentar mover um diretório para um diretório que já existe um <xref:System.IO.IOException> ocorrerá. Por exemplo, uma exceção ocorrerá se você tenta mover c:\mydir para c:\public e c:\public já existe. Como alternativa, você pode especificar "c:\\\public\\\mydir" como o `destDirName` parâmetro, fornecido que "mydir" não existe sob "c:\\\public", ou especifique um novo nome de diretório, como "c:\\\newdir".  
  
 O `sourceDirName` e `destDirName` argumentos têm permissão para especificar informações de caminho relativo ou absoluto. As informações do caminho relativo são interpretadas como relativas ao diretório de trabalho atual. Para obter o diretório de trabalho atual, consulte <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Espaços à direita são removidos do final do caminho parâmetros antes de mover o diretório.  
  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 O exemplo a seguir demonstra como mover um diretório e todos os seus arquivos para um novo diretório. O diretório original não existe mais depois que ele foi movido.  
  
 [!code-csharp[System.IO.Directory#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class6.cs#14)]
 [!code-vb[System.IO.Directory#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class6.vb#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Tentativa de mover um diretório para um volume diferente.  
  
- ou - 
 <paramref name="destDirName" /> já existe.  
  
- ou - 
Os parâmetros <paramref name="sourceDirName" /> e <paramref name="destDirName" /> se referem ao mesmo arquivo ou diretório.  
  
- ou - 
O diretório ou um arquivo nele está sendo usado por outro processo.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="sourceDirName" /> ou <paramref name="destDirName" /> é uma cadeia de caracteres de comprimento zero, contém somente espaços em branco ou um ou mais caracteres inválidos. Consulte caracteres inválidos com o método <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="sourceDirName" /> ou <paramref name="destDirName" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">O caminho especificado por <paramref name="sourceDirName" /> é inválido (por exemplo, ele está em uma unidade não mapeada).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para leitura do <paramref name="sourceDirName" /> e gravando <paramref name="sourceDirName" /> e <paramref name="destDirName" />. Enumerações associadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">E/S de arquivo e de fluxo</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Como ler texto de um arquivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Como gravar texto em um arquivo</related>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public static void SetAccessControl (string path, System.Security.AccessControl.DirectorySecurity directorySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetAccessControl(string path, class System.Security.AccessControl.DirectorySecurity directorySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.SetAccessControl(System.String,System.Security.AccessControl.DirectorySecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetAccessControl(System::String ^ path, System::Security::AccessControl::DirectorySecurity ^ directorySecurity);" />
      <MemberSignature Language="F#" Value="static member SetAccessControl : string * System.Security.AccessControl.DirectorySecurity -&gt; unit" Usage="System.IO.Directory.SetAccessControl (path, directorySecurity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="directorySecurity" Type="System.Security.AccessControl.DirectorySecurity" />
      </Parameters>
      <Docs>
        <param name="path">Um diretório ao qual adicionar ou remover entradas de ACL (lista de controle de acesso).</param>
        <param name="directorySecurity">Um objeto <see cref="T:System.Security.AccessControl.DirectorySecurity" /> que descreve uma entrada de ACL a ser aplicada ao diretório descrito pelo parâmetro <paramref name="path" />.</param>
        <summary>Aplica entradas de ACL (lista de controle de acesso) descritas por um objeto <see cref="T:System.Security.AccessControl.DirectorySecurity" /> ao diretório especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.IO.Directory.SetAccessControl%2A> método se aplica a entradas ACL (lista) de controle de acesso a um arquivo que representa a lista ACL noninherited.  
  
> [!CAUTION]
>  A ACL é especificado para o `directorySecurity` parâmetro substitui a ACL existente para o diretório. Para adicionar permissões para um novo usuário, use o <xref:System.IO.Directory.GetAccessControl%2A> método para obter a ACL existente e modificá-lo.  
  
 Uma ACL descreve indivíduos e/ou grupos que têm ou não tem direitos para ações específicas em um determinado arquivo ou diretório. Para saber mais, confira [Como adicionar ou remover entradas da lista de controle de acesso](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md).  
  
 O <xref:System.IO.Directory.SetAccessControl%2A> método persiste somente <xref:System.Security.AccessControl.DirectorySecurity> objetos que foram modificados após a criação do objeto.  Se um <xref:System.Security.AccessControl.DirectorySecurity> objeto não tiver sido modificado, ele não será persistente em um arquivo.  Portanto, não é possível recuperar um <xref:System.Security.AccessControl.DirectorySecurity> do objeto de um arquivo e reaplicar o mesmo objeto para outro arquivo.  
  
 Para copiar informações de ACL de um arquivo para outro:  
  
1.  Use o <xref:System.IO.Directory.GetAccessControl%2A> método para recuperar o <xref:System.Security.AccessControl.DirectorySecurity> objeto do arquivo de origem.  
  
2.  Criar um novo <xref:System.Security.AccessControl.DirectorySecurity> objeto para o arquivo de destino.  
  
3.  Use o <xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorBinaryForm%2A> ou <xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorSddlForm%2A> método da fonte de <xref:System.Security.AccessControl.DirectorySecurity> objeto para recuperar as informações de ACL.  
  
4.  Use o <xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorBinaryForm%2A> ou <xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorSddlForm%2A> método para copiar as informações recuperadas na etapa 3 para o destino <xref:System.Security.AccessControl.DirectorySecurity> objeto.  
  
5.  Definir o destino <xref:System.Security.AccessControl.DirectorySecurity> objeto para o arquivo de destino usando o <xref:System.IO.Directory.SetAccessControl%2A> método.  
  
 Em ambientes de NTFS <xref:System.Security.AccessControl.FileSystemRights.ReadAttributes> e <xref:System.Security.AccessControl.FileSystemRights.ReadExtendedAttributes> são concedidas ao usuário se o usuário tiver <xref:System.Security.AccessControl.FileSystemRights.ListDirectory> direitos na pasta pai. Negar <xref:System.Security.AccessControl.FileSystemRights.ReadAttributes> e <xref:System.Security.AccessControl.FileSystemRights.ReadExtendedAttributes>, negar <xref:System.Security.AccessControl.FileSystemRights.ListDirectory> no diretório pai.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.IO.Directory.GetAccessControl%2A> e o <xref:System.IO.Directory.SetAccessControl%2A> métodos para adicionar um acesso de entrada ACL (lista) de controle e, em seguida, remover uma entrada de ACL de um diretório.  Você deve fornecer uma conta de grupo ou de usuário válida para executar este exemplo.  
  
 [!code-cpp[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/cpp/sample.cpp#1)]
 [!code-csharp[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/CS/sample.cs#1)]
 [!code-vb[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="directorySecurity" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Não foi possível encontrar o diretório.</exception>
        <exception cref="T:System.ArgumentException">O <paramref name="path" /> era inválido.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O processo atual não tem acesso ao diretório especificado por <paramref name="path" />.  
  
- ou - 
O processo atual não tem privilégios suficientes para configurar a entrada de ACL.</exception>
        <exception cref="T:System.PlatformNotSupportedException">O sistema operacional atual não é o Windows 2000 ou posterior.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">permissão enumerar a lista de controle de acesso (ACL) para um diretório. Enumerações associadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.NoAccess" /> , <see cref="F:System.Security.AccessControl.AccessControlActions.View" />  
  
Ação de segurança: Por demanda.</permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="SetCreationTime">
      <MemberSignature Language="C#" Value="public static void SetCreationTime (string path, DateTime creationTime);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetCreationTime(string path, valuetype System.DateTime creationTime) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.SetCreationTime(System.String,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetCreationTime (path As String, creationTime As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetCreationTime(System::String ^ path, DateTime creationTime);" />
      <MemberSignature Language="F#" Value="static member SetCreationTime : string * DateTime -&gt; unit" Usage="System.IO.Directory.SetCreationTime (path, creationTime)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="creationTime" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">O arquivo ou diretório para o qual as informações de data e hora de criação serão definidas.</param>
        <param name="creationTime">A data e hora em que o arquivo ou diretório foi usado para gravação pela última vez. Esse valor é expresso no horário local.</param>
        <summary>Define a data e hora de criação do arquivo ou diretório especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `path` parâmetro tem permissão para especificar informações de caminho relativo ou absoluto. As informações do caminho relativo são interpretadas como relativas ao diretório de trabalho atual. Para obter o diretório de trabalho atual, consulte <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 O `path` parâmetro não diferencia maiusculas de minúsculas.  
  
   
  
## Examples  
 O exemplo a seguir ilustra as diferenças na saída ao usar a saída de tempo Universal Coordenado (UTC).  
  
 [!code-cpp[System.IO.UTCExample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.UTCExample/CPP/example.cpp#1)]
 [!code-csharp[System.IO.UTCExample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.UTCExample/CS/example.cs#1)]
 [!code-vb[System.IO.UTCExample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.UTCExample/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">O caminho especificado não foi encontrado.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou um ou mais caracteres inválidos. Consulte caracteres inválidos com o método <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="creationTime" /> especifica um valor fora do intervalo de datas, horas permitido para esta operação.</exception>
        <exception cref="T:System.PlatformNotSupportedException">O sistema operacional atual não é o Windows NT ou posterior.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para gravar o arquivo ou diretório especificado. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">E/S de arquivo e de fluxo</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Como ler texto de um arquivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Como gravar texto em um arquivo</related>
      </Docs>
    </Member>
    <Member MemberName="SetCreationTimeUtc">
      <MemberSignature Language="C#" Value="public static void SetCreationTimeUtc (string path, DateTime creationTimeUtc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetCreationTimeUtc(string path, valuetype System.DateTime creationTimeUtc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.SetCreationTimeUtc(System.String,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetCreationTimeUtc (path As String, creationTimeUtc As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetCreationTimeUtc(System::String ^ path, DateTime creationTimeUtc);" />
      <MemberSignature Language="F#" Value="static member SetCreationTimeUtc : string * DateTime -&gt; unit" Usage="System.IO.Directory.SetCreationTimeUtc (path, creationTimeUtc)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="creationTimeUtc" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">O arquivo ou diretório para o qual as informações de data e hora de criação serão definidas.</param>
        <param name="creationTimeUtc">A data e a hora em que o diretório ou arquivo foi criado. Esse valor é expresso no horário local.</param>
        <summary>Define a data e hora de criação, no formato UTC (Tempo Universal Coordenado), do arquivo ou diretório especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `path` parâmetro tem permissão para especificar informações de caminho relativo ou absoluto. As informações do caminho relativo são interpretadas como relativas ao diretório de trabalho atual. Para obter o diretório de trabalho atual, consulte <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 O `path` parâmetro não diferencia maiusculas de minúsculas.  
  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">O caminho especificado não foi encontrado.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou um ou mais caracteres inválidos. Consulte caracteres inválidos com o método <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="creationTime" /> especifica um valor fora do intervalo de datas, horas permitido para esta operação.</exception>
        <exception cref="T:System.PlatformNotSupportedException">O sistema operacional atual não é o Windows NT ou posterior.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para gravar o arquivo ou diretório especificado. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">E/S de arquivo e de fluxo</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Como ler texto de um arquivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Como gravar texto em um arquivo</related>
      </Docs>
    </Member>
    <Member MemberName="SetCurrentDirectory">
      <MemberSignature Language="C#" Value="public static void SetCurrentDirectory (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetCurrentDirectory(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.SetCurrentDirectory(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetCurrentDirectory (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetCurrentDirectory(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member SetCurrentDirectory : string -&gt; unit" Usage="System.IO.Directory.SetCurrentDirectory path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">O caminho para o qual o diretório de trabalho atual é definido.</param>
        <summary>Define o atual diretório de trabalho do aplicativo como o diretório especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando o aplicativo é encerrado, o diretório de trabalho é restaurado para seu local original (o diretório em que o processo foi iniciado).  
  
 O `path` parâmetro tem permissão para especificar informações de caminho relativo ou absoluto. As informações do caminho relativo são interpretadas como relativas ao diretório de trabalho atual. Para obter o diretório de trabalho atual, consulte <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Espaços à direita são removidos do final do `path` parâmetro antes de definir o diretório.  
  
 O `path` parâmetro não diferencia maiusculas de minúsculas.  
  
 Se você estiver configurando o diretório para uma unidade com mídia removível, por exemplo, para ("r:" para uma unidade de disquete) ou "e": para uma unidade de CD-ROM, você pode determinar se a unidade estiver pronta, usando o <xref:System.IO.DriveInfo.IsReady%2A> propriedade.  
  
   
  
## Examples  
 O exemplo a seguir ilustra como definir o diretório atual e exibir o diretório raiz.  
  
 [!code-cpp[System.IO.DirectoryRoot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.DirectoryRoot/CPP/example.cpp#1)]
 [!code-csharp[System.IO.DirectoryRoot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.DirectoryRoot/CS/example.cs#1)]
 [!code-vb[System.IO.DirectoryRoot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.DirectoryRoot/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou um ou mais caracteres inválidos. Consulte caracteres inválidos com o método <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema.</exception>
        <exception cref="T:System.Security.SecurityException">O chamador não tem a permissão necessária para acessar código não gerenciado.</exception>
        <exception cref="T:System.IO.FileNotFoundException">O caminho especificado não foi encontrado.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">O diretório especificado não foi encontrado.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para gravar em arquivos ou diretórios. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para chamar código não gerenciado. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">E/S de arquivo e de fluxo</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Como ler texto de um arquivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Como gravar texto em um arquivo</related>
      </Docs>
    </Member>
    <Member MemberName="SetLastAccessTime">
      <MemberSignature Language="C#" Value="public static void SetLastAccessTime (string path, DateTime lastAccessTime);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetLastAccessTime(string path, valuetype System.DateTime lastAccessTime) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.SetLastAccessTime(System.String,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetLastAccessTime (path As String, lastAccessTime As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetLastAccessTime(System::String ^ path, DateTime lastAccessTime);" />
      <MemberSignature Language="F#" Value="static member SetLastAccessTime : string * DateTime -&gt; unit" Usage="System.IO.Directory.SetLastAccessTime (path, lastAccessTime)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="lastAccessTime" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">O arquivo ou diretório para o qual definir as informações de data e hora de acesso.</param>
        <param name="lastAccessTime">Um objeto que contém o valor a ser definido para a data e hora do último acesso de <paramref name="path" />. Esse valor é expresso no horário local.</param>
        <summary>Define a data e hora em que o arquivo ou o diretório foi acessado pela última vez.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `path` parâmetro tem permissão para especificar informações de caminho relativo ou absoluto. As informações do caminho relativo são interpretadas como relativas ao diretório de trabalho atual. Para obter o diretório de trabalho atual, consulte <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 O `path` parâmetro não diferencia maiusculas de minúsculas.  
  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 O exemplo a seguir demonstra como usar `SetLastAccessTime`.  
  
 [!code-cpp[Dir_SetLastAccess#1](~/samples/snippets/cpp/VS_Snippets_CLR/Dir_SetLastAccess/CPP/dir_setlastaccess.cpp#1)]
 [!code-csharp[Dir_SetLastAccess#1](~/samples/snippets/csharp/VS_Snippets_CLR/Dir_SetLastAccess/CS/dir_setlastaccess.cs#1)]
 [!code-vb[Dir_SetLastAccess#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dir_SetLastAccess/VB/dir_setlastaccess.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">O caminho especificado não foi encontrado.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou um ou mais caracteres inválidos. Consulte caracteres inválidos com o método <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.PlatformNotSupportedException">O sistema operacional atual não é o Windows NT ou posterior.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="lastAccessTime" /> especifica um valor fora do intervalo de datas, horas permitido para esta operação.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para gravar o arquivo ou diretório especificado. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">E/S de arquivo e de fluxo</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Como ler texto de um arquivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Como gravar texto em um arquivo</related>
      </Docs>
    </Member>
    <Member MemberName="SetLastAccessTimeUtc">
      <MemberSignature Language="C#" Value="public static void SetLastAccessTimeUtc (string path, DateTime lastAccessTimeUtc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetLastAccessTimeUtc(string path, valuetype System.DateTime lastAccessTimeUtc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.SetLastAccessTimeUtc(System.String,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetLastAccessTimeUtc (path As String, lastAccessTimeUtc As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetLastAccessTimeUtc(System::String ^ path, DateTime lastAccessTimeUtc);" />
      <MemberSignature Language="F#" Value="static member SetLastAccessTimeUtc : string * DateTime -&gt; unit" Usage="System.IO.Directory.SetLastAccessTimeUtc (path, lastAccessTimeUtc)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="lastAccessTimeUtc" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">O arquivo ou diretório para o qual definir as informações de data e hora de acesso.</param>
        <param name="lastAccessTimeUtc">Um objeto que contém o valor a ser definido para a data e hora do último acesso de <paramref name="path" />. Esse valor é expresso em horário UTC.</param>
        <summary>Define a data e hora, no formato UTC (Tempo Universal Coordenado), em que o arquivo ou diretório especificado foi acessado pela última vez.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `path` parâmetro tem permissão para especificar informações de caminho relativo ou absoluto. As informações do caminho relativo são interpretadas como relativas ao diretório de trabalho atual. Para obter o diretório de trabalho atual, consulte <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 O `path` parâmetro não diferencia maiusculas de minúsculas.  
  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 O exemplo a seguir ilustra as diferenças na saída ao usar a saída de tempo Universal Coordenado (UTC).  
  
 [!code-cpp[System.IO.UTCExample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.UTCExample/CPP/example.cpp#1)]
 [!code-csharp[System.IO.UTCExample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.UTCExample/CS/example.cs#1)]
 [!code-vb[System.IO.UTCExample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.UTCExample/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">O caminho especificado não foi encontrado.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou um ou mais caracteres inválidos. Consulte caracteres inválidos com o método <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.PlatformNotSupportedException">O sistema operacional atual não é o Windows NT ou posterior.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="lastAccessTimeUtc" /> especifica um valor fora do intervalo de datas, horas permitido para esta operação.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para gravar o arquivo ou diretório especificado. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">E/S de arquivo e de fluxo</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Como ler texto de um arquivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Como gravar texto em um arquivo</related>
      </Docs>
    </Member>
    <Member MemberName="SetLastWriteTime">
      <MemberSignature Language="C#" Value="public static void SetLastWriteTime (string path, DateTime lastWriteTime);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetLastWriteTime(string path, valuetype System.DateTime lastWriteTime) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.SetLastWriteTime(System.String,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetLastWriteTime (path As String, lastWriteTime As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetLastWriteTime(System::String ^ path, DateTime lastWriteTime);" />
      <MemberSignature Language="F#" Value="static member SetLastWriteTime : string * DateTime -&gt; unit" Usage="System.IO.Directory.SetLastWriteTime (path, lastWriteTime)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="lastWriteTime" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">O caminho do diretório.</param>
        <param name="lastWriteTime">A data e hora em que o diretório foi usado para gravação pela última vez. Esse valor é expresso no horário local.</param>
        <summary>Define a data e hora em que um diretório foi usado para gravação pela última vez.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `path` parâmetro tem permissão para especificar informações de caminho relativo ou absoluto. As informações do caminho relativo são interpretadas como relativas ao diretório de trabalho atual. Para obter o diretório de trabalho atual, consulte <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 O `path` parâmetro não diferencia maiusculas de minúsculas.  
  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 O exemplo a seguir demonstra como usar `SetLastWriteTime`.  
  
 [!code-cpp[Dir_SetLastWrite#1](~/samples/snippets/cpp/VS_Snippets_CLR/Dir_SetLastWrite/CPP/dir_setlastwrite.cpp#1)]
 [!code-csharp[Dir_SetLastWrite#1](~/samples/snippets/csharp/VS_Snippets_CLR/Dir_SetLastWrite/CS/dir_setlastwrite.cs#1)]
 [!code-vb[Dir_SetLastWrite#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dir_SetLastWrite/VB/dir_setlastwrite.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="path" /> não foi encontrado (por exemplo, o diretório não existe ou está em uma unidade não mapeada).</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException"><paramref name="path" /> não foi encontrado (por exemplo, o diretório não existe ou está em uma unidade não mapeada).</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou um ou mais caracteres inválidos. Consulte caracteres inválidos com o método <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.PlatformNotSupportedException">O sistema operacional atual não é o Windows NT ou posterior.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="lastWriteTime" /> especifica um valor fora do intervalo de datas, horas permitido para esta operação.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para gravar o arquivo ou diretório especificado. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">E/S de arquivo e de fluxo</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Como ler texto de um arquivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Como gravar texto em um arquivo</related>
      </Docs>
    </Member>
    <Member MemberName="SetLastWriteTimeUtc">
      <MemberSignature Language="C#" Value="public static void SetLastWriteTimeUtc (string path, DateTime lastWriteTimeUtc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetLastWriteTimeUtc(string path, valuetype System.DateTime lastWriteTimeUtc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.SetLastWriteTimeUtc(System.String,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetLastWriteTimeUtc (path As String, lastWriteTimeUtc As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetLastWriteTimeUtc(System::String ^ path, DateTime lastWriteTimeUtc);" />
      <MemberSignature Language="F#" Value="static member SetLastWriteTimeUtc : string * DateTime -&gt; unit" Usage="System.IO.Directory.SetLastWriteTimeUtc (path, lastWriteTimeUtc)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="lastWriteTimeUtc" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">O caminho do diretório.</param>
        <param name="lastWriteTimeUtc">A data e hora em que o diretório foi usado para gravação pela última vez. Esse valor é expresso em horário UTC.</param>
        <summary>Define a data e hora, no formato UTC (Tempo Universal Coordenado), em que o diretório foi gravado pela última vez.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `path` parâmetro tem permissão para especificar informações de caminho relativo ou absoluto. As informações do caminho relativo são interpretadas como relativas ao diretório de trabalho atual. Para obter o diretório de trabalho atual, consulte <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 O `path` parâmetro não diferencia maiusculas de minúsculas.  
  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 O exemplo a seguir ilustra as diferenças na saída ao usar a saída de tempo Universal Coordenado (UTC).  
  
 [!code-cpp[System.IO.UTCExample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.UTCExample/CPP/example.cpp#1)]
 [!code-csharp[System.IO.UTCExample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.UTCExample/CS/example.cs#1)]
 [!code-vb[System.IO.UTCExample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.UTCExample/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="path" /> não foi encontrado (por exemplo, o diretório não existe ou está em uma unidade não mapeada).</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException"><paramref name="path" /> não foi encontrado (por exemplo, o diretório não existe ou está em uma unidade não mapeada).</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou um ou mais caracteres inválidos. Consulte caracteres inválidos com o método <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.PlatformNotSupportedException">O sistema operacional atual não é o Windows NT ou posterior.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="lastWriteTimeUtc" /> especifica um valor fora do intervalo de datas, horas permitido para esta operação.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para gravar o arquivo ou diretório especificado. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">E/S de arquivo e de fluxo</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Como ler texto de um arquivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Como gravar texto em um arquivo</related>
      </Docs>
    </Member>
  </Members>
</Type>