<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="MemoryStream.xml" source-language="en-US" target-language="pt-BR">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac556075c59b69c82be733ba11b25325ec6183d2c6a.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">56075c59b69c82be733ba11b25325ec6183d2c6a</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.5,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.IO.MemoryStream">
          <source>Creates a stream whose backing store is memory.</source>
          <target state="translated">Cria um fluxo cujo repositório de backup é a memória.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.MemoryStream">
          <source>The current position of a stream is the position at which the next read or write operation could take place.</source>
          <target state="translated">A posição atual de um fluxo é a posição na qual a próxima leitura ou operação de gravação pode ocorrer.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.MemoryStream">
          <source>The current position can be retrieved or set through the <ph id="ph1">&lt;xref:System.IO.MemoryStream.Seek%2A&gt;</ph> method.</source>
          <target state="translated">A posição atual pode ser recuperada ou definida por meio de <ph id="ph1">&lt;xref:System.IO.MemoryStream.Seek%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.MemoryStream">
          <source>When a new instance of <ph id="ph1">&lt;xref:System.IO.MemoryStream&gt;</ph> is created, the current position is set to zero.</source>
          <target state="translated">Quando uma nova instância da <ph id="ph1">&lt;xref:System.IO.MemoryStream&gt;</ph> é criado, a atual posição é definida como zero.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.MemoryStream">
          <source>Memory streams created with an unsigned byte array provide a non-resizable stream of the data.</source>
          <target state="translated">Fluxos de memória criados com uma matriz de byte não atribuído fornecem um fluxo não redimensionável dos dados.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.MemoryStream">
          <source>When using a byte array, you can neither append to nor shrink the stream, although you might be able to modify the existing contents depending on the parameters passed into the constructor.</source>
          <target state="translated">Ao usar uma matriz de bytes, não é possível anexar ao nem reduzir o fluxo, embora você poderá modificar o conteúdo existente, dependendo dos parâmetros passados para o construtor.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.MemoryStream">
          <source>Empty memory streams are resizable, and can be written to and read from.</source>
          <target state="translated">Fluxos de memória vazia são redimensionáveis e podem ser gravados e lidos do.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.MemoryStream">
          <source>If a <ph id="ph1">&lt;xref:System.IO.MemoryStream&gt;</ph> object is added to a ResX file or a .resources file, call the <ph id="ph2">&lt;xref:System.Resources.ResourceManager.GetStream%2A&gt;</ph> method at runtime to retrieve it.</source>
          <target state="translated">Se um <ph id="ph1">&lt;xref:System.IO.MemoryStream&gt;</ph> objeto é adicionado a um arquivo ResX ou um arquivo. Resources, chame o <ph id="ph2">&lt;xref:System.Resources.ResourceManager.GetStream%2A&gt;</ph> método em tempo de execução para recuperá-lo.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.MemoryStream">
          <source>If a <ph id="ph1">&lt;xref:System.IO.MemoryStream&gt;</ph> object is serialized to a resource file it will actually be serialized as an <ph id="ph2">&lt;xref:System.IO.UnmanagedMemoryStream&gt;</ph>.</source>
          <target state="translated">Se um <ph id="ph1">&lt;xref:System.IO.MemoryStream&gt;</ph> objeto é serializado como um arquivo de recurso, na verdade, será serializado como um <ph id="ph2">&lt;xref:System.IO.UnmanagedMemoryStream&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.MemoryStream">
          <source>This behavior provides better performance, as well as the ability to get a pointer to the data directly, without having to go through <ph id="ph1">&lt;xref:System.IO.Stream&gt;</ph> methods.</source>
          <target state="translated">Esse comportamento fornece melhor desempenho, bem como a capacidade de obter um ponteiro para os dados diretamente, sem precisar passar por <ph id="ph1">&lt;xref:System.IO.Stream&gt;</ph> métodos.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.MemoryStream">
          <source>The following code example shows how to read and write data using memory as a backing store.</source>
          <target state="translated">O exemplo de código a seguir mostra como ler e gravar dados de uso da memória como um armazenamento de backup.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" uid="T:System.IO.MemoryStream">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.IO.MemoryStream" /&gt;</ph> class.</source>
          <target state="translated">Inicializa uma nova instância da classe <ph id="ph1">&lt;see cref="T:System.IO.MemoryStream" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.#ctor">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.IO.MemoryStream" /&gt;</ph> class with an expandable capacity initialized to zero.</source>
          <target state="translated">Inicializa uma nova instância da classe <ph id="ph1">&lt;see cref="T:System.IO.MemoryStream" /&gt;</ph> com uma capacidade expansível inicializada em zero.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.#ctor">
          <source>The <ph id="ph1">&lt;xref:System.IO.MemoryStream.CanRead%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.IO.MemoryStream.CanSeek%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.IO.MemoryStream.CanWrite%2A&gt;</ph> properties are all set to <ph id="ph4">`true`</ph>.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.IO.MemoryStream.CanRead%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.IO.MemoryStream.CanSeek%2A&gt;</ph>, e <ph id="ph3">&lt;xref:System.IO.MemoryStream.CanWrite%2A&gt;</ph> propriedades são definidas como <ph id="ph4">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.#ctor">
          <source>The capacity of the current stream automatically increases when you use the <ph id="ph1">&lt;xref:System.IO.MemoryStream.SetLength%2A&gt;</ph> method to set the length to a value larger than the capacity of the current stream.</source>
          <target state="translated">A capacidade do fluxo atual aumenta automaticamente quando você usa o <ph id="ph1">&lt;xref:System.IO.MemoryStream.SetLength%2A&gt;</ph> método para definir o comprimento para um valor maior do que a capacidade do fluxo atual.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.#ctor">
          <source>This constructor exposes the underlying stream, which <ph id="ph1">&lt;xref:System.IO.MemoryStream.GetBuffer%2A&gt;</ph> returns.</source>
          <target state="translated">Este construtor expõe subjacente de fluxo, que <ph id="ph1">&lt;xref:System.IO.MemoryStream.GetBuffer%2A&gt;</ph> retorna.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.#ctor(System.Byte[])">
          <source>The array of unsigned bytes from which to create the current stream.</source>
          <target state="translated">A matriz de bytes sem sinal com base na qual o fluxo atual será criado.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.#ctor(System.Byte[])">
          <source>Initializes a new non-resizable instance of the <ph id="ph1">&lt;see cref="T:System.IO.MemoryStream" /&gt;</ph> class based on the specified byte array.</source>
          <target state="translated">Inicializa uma nova instância não redimensionável da classe <ph id="ph1">&lt;see cref="T:System.IO.MemoryStream" /&gt;</ph> com base na matriz de bytes especificada.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.#ctor(System.Byte[])">
          <source>The <ph id="ph1">&lt;xref:System.IO.MemoryStream.CanRead%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.IO.MemoryStream.CanSeek%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.IO.MemoryStream.CanWrite%2A&gt;</ph> properties are all set to <ph id="ph4">`true`</ph>.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.IO.MemoryStream.CanRead%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.IO.MemoryStream.CanSeek%2A&gt;</ph>, e <ph id="ph3">&lt;xref:System.IO.MemoryStream.CanWrite%2A&gt;</ph> propriedades são definidas como <ph id="ph4">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.#ctor(System.Byte[])">
          <source><ph id="ph1">&lt;xref:System.IO.MemoryStream.Capacity%2A&gt;</ph> is set to the length of the specified byte array.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.MemoryStream.Capacity%2A&gt;</ph> é definido como o comprimento da matriz de bytes especificado.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.#ctor(System.Byte[])">
          <source>The new stream can be written to, but is not resizable.</source>
          <target state="translated">Novo fluxo pode ser gravado, mas não pode ser redimensionado.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.#ctor(System.Byte[])">
          <source>The length of the stream cannot be set to a value greater than the initial length of the specified byte array; however, the stream can be truncated (see <ph id="ph1">&lt;xref:System.IO.MemoryStream.SetLength%2A&gt;</ph>).</source>
          <target state="translated">O comprimento do fluxo não pode ser definido como um valor maior que o tamanho inicial da matriz de bytes especificada; No entanto, o fluxo pode ser truncado (consulte <ph id="ph1">&lt;xref:System.IO.MemoryStream.SetLength%2A&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.#ctor(System.Byte[])">
          <source>This constructor does not expose the underlying stream.</source>
          <target state="translated">Este construtor não expõe o fluxo subjacente.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.#ctor(System.Byte[])">
          <source><ph id="ph1">&lt;xref:System.IO.MemoryStream.GetBuffer%2A&gt;</ph> throws <ph id="ph2">&lt;xref:System.UnauthorizedAccessException&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.MemoryStream.GetBuffer%2A&gt;</ph> gera <ph id="ph2">&lt;xref:System.UnauthorizedAccessException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.#ctor(System.Byte[])">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.#ctor(System.Int32)">
          <source>The initial size of the internal array in bytes.</source>
          <target state="translated">O tamanho inicial da matriz interna em bytes.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.#ctor(System.Int32)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.IO.MemoryStream" /&gt;</ph> class with an expandable capacity initialized as specified.</source>
          <target state="translated">Inicializa uma nova instância da classe <ph id="ph1">&lt;see cref="T:System.IO.MemoryStream" /&gt;</ph> com uma capacidade expansível inicializada conforme especificado.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.#ctor(System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.IO.MemoryStream.CanRead%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.IO.MemoryStream.CanSeek%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.IO.MemoryStream.CanWrite%2A&gt;</ph> properties are all set to <ph id="ph4">`true`</ph>.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.IO.MemoryStream.CanRead%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.IO.MemoryStream.CanSeek%2A&gt;</ph>, e <ph id="ph3">&lt;xref:System.IO.MemoryStream.CanWrite%2A&gt;</ph> propriedades são definidas como <ph id="ph4">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.#ctor(System.Int32)">
          <source>The capacity automatically increases when you use the <ph id="ph1">&lt;xref:System.IO.MemoryStream.SetLength%2A&gt;</ph> method to set the length to a value larger than the capacity of the current stream.</source>
          <target state="translated">A capacidade aumenta automaticamente quando você usa o <ph id="ph1">&lt;xref:System.IO.MemoryStream.SetLength%2A&gt;</ph> método para definir o comprimento para um valor maior do que a capacidade do fluxo atual.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.#ctor(System.Int32)">
          <source>Except for a <ph id="ph1">`MemoryStream`</ph> constructed with a byte[] parameter, write operations at the end of a <ph id="ph2">`MemoryStream`</ph> expand the <ph id="ph3">`MemoryStream`</ph>.</source>
          <target state="translated">Exceto para uma <ph id="ph1">`MemoryStream`</ph> construído com um parâmetro de byte [], gravar operações no final de um <ph id="ph2">`MemoryStream`</ph> expandir o <ph id="ph3">`MemoryStream`</ph>.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.#ctor(System.Int32)">
          <source>This constructor exposes the underlying stream that <ph id="ph1">&lt;xref:System.IO.MemoryStream.GetBuffer%2A&gt;</ph> returns.</source>
          <target state="translated">Este construtor expõe subjacente de fluxo que <ph id="ph1">&lt;xref:System.IO.MemoryStream.GetBuffer%2A&gt;</ph> retorna.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.#ctor(System.Int32)">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.IO.MemoryStream&gt;</ph> class.</source>
          <target state="translated">Este exemplo de código é parte de um exemplo maior fornecido para a <ph id="ph1">&lt;xref:System.IO.MemoryStream&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.#ctor(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="capacity" /&gt;</ph> is negative.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="capacity" /&gt;</ph> é negativo.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Boolean)">
          <source>The array of unsigned bytes from which to create this stream.</source>
          <target state="translated">A matriz de bytes sem sinal da qual este fluxo deve ser criado.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Boolean)">
          <source>The setting of the <ph id="ph1">&lt;see cref="P:System.IO.MemoryStream.CanWrite" /&gt;</ph> property, which determines whether the stream supports writing.</source>
          <target state="translated">A configuração da propriedade <ph id="ph1">&lt;see cref="P:System.IO.MemoryStream.CanWrite" /&gt;</ph>, que determina se o fluxo dá suporte à gravação.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Boolean)">
          <source>Initializes a new non-resizable instance of the <ph id="ph1">&lt;see cref="T:System.IO.MemoryStream" /&gt;</ph> class based on the specified byte array with the <ph id="ph2">&lt;see cref="P:System.IO.MemoryStream.CanWrite" /&gt;</ph> property set as specified.</source>
          <target state="translated">Inicializa uma nova instância não redimensionável da classe <ph id="ph1">&lt;see cref="T:System.IO.MemoryStream" /&gt;</ph> com base na matriz de bytes especificada com a propriedade <ph id="ph2">&lt;see cref="P:System.IO.MemoryStream.CanWrite" /&gt;</ph> definida conforme especificado.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Boolean)">
          <source>The <ph id="ph1">&lt;xref:System.IO.MemoryStream.CanRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IO.MemoryStream.CanSeek%2A&gt;</ph> properties are both set to <ph id="ph3">`true`</ph>.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.IO.MemoryStream.CanRead%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.IO.MemoryStream.CanSeek%2A&gt;</ph> propriedades são definidas como <ph id="ph3">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Boolean)">
          <source><ph id="ph1">&lt;xref:System.IO.MemoryStream.Capacity%2A&gt;</ph> is set to the length of the specified byte array.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.MemoryStream.Capacity%2A&gt;</ph> é definido como o comprimento da matriz de bytes especificado.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Boolean)">
          <source>The length of the stream cannot be set to a value greater than the initial length of the specified byte array; however, the stream can be truncated (see <ph id="ph1">&lt;xref:System.IO.MemoryStream.SetLength%2A&gt;</ph>).</source>
          <target state="translated">O comprimento do fluxo não pode ser definido como um valor maior que o tamanho inicial da matriz de bytes especificada; No entanto, o fluxo pode ser truncado (consulte <ph id="ph1">&lt;xref:System.IO.MemoryStream.SetLength%2A&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Boolean)">
          <source>This constructor does not expose the underlying stream.</source>
          <target state="translated">Este construtor não expõe o fluxo subjacente.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Boolean)">
          <source><ph id="ph1">&lt;xref:System.IO.MemoryStream.GetBuffer%2A&gt;</ph> throws <ph id="ph2">&lt;xref:System.UnauthorizedAccessException&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.MemoryStream.GetBuffer%2A&gt;</ph> gera <ph id="ph2">&lt;xref:System.UnauthorizedAccessException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32)">
          <source>The array of unsigned bytes from which to create this stream.</source>
          <target state="translated">A matriz de bytes sem sinal da qual este fluxo deve ser criado.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32)">
          <source>The index into <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> at which the stream begins.</source>
          <target state="translated">O índice no <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> no qual o fluxo começa.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32)">
          <source>The length of the stream in bytes.</source>
          <target state="translated">O comprimento do fluxo em bytes.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32)">
          <source>Initializes a new non-resizable instance of the <ph id="ph1">&lt;see cref="T:System.IO.MemoryStream" /&gt;</ph> class based on the specified region (index) of a byte array.</source>
          <target state="translated">Inicializa uma nova instância não redimensionável da classe <ph id="ph1">&lt;see cref="T:System.IO.MemoryStream" /&gt;</ph> com base na região (índice) especificada de uma matriz bytes.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.IO.MemoryStream.CanRead%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.IO.MemoryStream.CanSeek%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.IO.MemoryStream.CanWrite%2A&gt;</ph> properties are all set to <ph id="ph4">`true`</ph>, but the capacity cannot be changed.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.IO.MemoryStream.CanRead%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.IO.MemoryStream.CanSeek%2A&gt;</ph>, e <ph id="ph3">&lt;xref:System.IO.MemoryStream.CanWrite%2A&gt;</ph> propriedades são definidas como <ph id="ph4">`true`</ph>, mas a capacidade não pode ser alterada.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.IO.MemoryStream.Capacity%2A&gt;</ph> is set to <ph id="ph2">`count`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.MemoryStream.Capacity%2A&gt;</ph> é definido como <ph id="ph2">`count`</ph>.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32)">
          <source>The length of the stream cannot be set to a value greater than the initial length of the specified byte array; however, the stream can be truncated (see <ph id="ph1">&lt;xref:System.IO.MemoryStream.SetLength%2A&gt;</ph>).</source>
          <target state="translated">O comprimento do fluxo não pode ser definido como um valor maior que o tamanho inicial da matriz de bytes especificada; No entanto, o fluxo pode ser truncado (consulte <ph id="ph1">&lt;xref:System.IO.MemoryStream.SetLength%2A&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32)">
          <source>This constructor does not expose the underlying stream.</source>
          <target state="translated">Este construtor não expõe o fluxo subjacente.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.IO.MemoryStream.GetBuffer%2A&gt;</ph> throws <ph id="ph2">&lt;xref:System.UnauthorizedAccessException&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.MemoryStream.GetBuffer%2A&gt;</ph> gera <ph id="ph2">&lt;xref:System.UnauthorizedAccessException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32)">
          <source>However, you can write to the stream.</source>
          <target state="translated">No entanto, você pode gravar no fluxo.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> or <ph id="ph2">&lt;paramref name="count" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> ou <ph id="ph2">&lt;paramref name="count" /&gt;</ph> é menor que zero.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32)">
          <source>The buffer length minus <ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than <ph id="ph2">&lt;paramref name="count" /&gt;</ph>.</source>
          <target state="translated">O tamanho do buffer menos <ph id="ph1">&lt;paramref name="index" /&gt;</ph> é menor que <ph id="ph2">&lt;paramref name="count" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32,System.Boolean)">
          <source>The array of unsigned bytes from which to create this stream.</source>
          <target state="translated">A matriz de bytes sem sinal da qual este fluxo deve ser criado.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32,System.Boolean)">
          <source>The index in <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> at which the stream begins.</source>
          <target state="translated">O índice no <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> no qual o fluxo começa.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32,System.Boolean)">
          <source>The length of the stream in bytes.</source>
          <target state="translated">O comprimento do fluxo em bytes.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32,System.Boolean)">
          <source>The setting of the <ph id="ph1">&lt;see cref="P:System.IO.MemoryStream.CanWrite" /&gt;</ph> property, which determines whether the stream supports writing.</source>
          <target state="translated">A configuração da propriedade <ph id="ph1">&lt;see cref="P:System.IO.MemoryStream.CanWrite" /&gt;</ph>, que determina se o fluxo dá suporte à gravação.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32,System.Boolean)">
          <source>Initializes a new non-resizable instance of the <ph id="ph1">&lt;see cref="T:System.IO.MemoryStream" /&gt;</ph> class based on the specified region of a byte array, with the <ph id="ph2">&lt;see cref="P:System.IO.MemoryStream.CanWrite" /&gt;</ph> property set as specified.</source>
          <target state="translated">Inicializa uma nova instância não redimensionável da classe <ph id="ph1">&lt;see cref="T:System.IO.MemoryStream" /&gt;</ph> com base na região especificada de uma matriz de bytes, com a propriedade <ph id="ph2">&lt;see cref="P:System.IO.MemoryStream.CanWrite" /&gt;</ph> definida conforme especificado.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32,System.Boolean)">
          <source>The <ph id="ph1">&lt;xref:System.IO.MemoryStream.CanRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IO.MemoryStream.CanSeek%2A&gt;</ph> properties are both set to <ph id="ph3">`true`</ph>.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.IO.MemoryStream.CanRead%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.IO.MemoryStream.CanSeek%2A&gt;</ph> propriedades são definidas como <ph id="ph3">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;xref:System.IO.MemoryStream.Capacity%2A&gt;</ph> is set to <ph id="ph2">`count`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.MemoryStream.Capacity%2A&gt;</ph> é definido como <ph id="ph2">`count`</ph>.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32,System.Boolean)">
          <source>The length of the stream cannot be set to a value greater than the initial length of the specified byte array; however, the stream can be truncated (see <ph id="ph1">&lt;xref:System.IO.MemoryStream.SetLength%2A&gt;</ph>).</source>
          <target state="translated">O comprimento do fluxo não pode ser definido como um valor maior que o tamanho inicial da matriz de bytes especificada; No entanto, o fluxo pode ser truncado (consulte <ph id="ph1">&lt;xref:System.IO.MemoryStream.SetLength%2A&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32,System.Boolean)">
          <source>This constructor does not expose the underlying stream.</source>
          <target state="translated">Este construtor não expõe o fluxo subjacente.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;xref:System.IO.MemoryStream.GetBuffer%2A&gt;</ph> throws <ph id="ph2">&lt;xref:System.UnauthorizedAccessException&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.MemoryStream.GetBuffer%2A&gt;</ph> gera <ph id="ph2">&lt;xref:System.UnauthorizedAccessException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32,System.Boolean)">
          <source>However, you can write to the stream if <ph id="ph1">`writable`</ph> is <ph id="ph2">`true`</ph>.</source>
          <target state="translated">No entanto, você pode gravar no fluxo se <ph id="ph1">`writable`</ph> é <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> or <ph id="ph2">&lt;paramref name="count" /&gt;</ph> are negative.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> ou <ph id="ph2">&lt;paramref name="count" /&gt;</ph> é negativo.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32,System.Boolean)">
          <source>The buffer length minus <ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than <ph id="ph2">&lt;paramref name="count" /&gt;</ph>.</source>
          <target state="translated">O tamanho do buffer menos <ph id="ph1">&lt;paramref name="index" /&gt;</ph> é menor que <ph id="ph2">&lt;paramref name="count" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32,System.Boolean,System.Boolean)">
          <source>The array of unsigned bytes from which to create this stream.</source>
          <target state="translated">A matriz de bytes sem sinal da qual este fluxo deve ser criado.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32,System.Boolean,System.Boolean)">
          <source>The index into <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> at which the stream begins.</source>
          <target state="translated">O índice no <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> no qual o fluxo começa.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32,System.Boolean,System.Boolean)">
          <source>The length of the stream in bytes.</source>
          <target state="translated">O comprimento do fluxo em bytes.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32,System.Boolean,System.Boolean)">
          <source>The setting of the <ph id="ph1">&lt;see cref="P:System.IO.MemoryStream.CanWrite" /&gt;</ph> property, which determines whether the stream supports writing.</source>
          <target state="translated">A configuração da propriedade <ph id="ph1">&lt;see cref="P:System.IO.MemoryStream.CanWrite" /&gt;</ph>, que determina se o fluxo dá suporte à gravação.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to enable <ph id="ph2">&lt;see cref="M:System.IO.MemoryStream.GetBuffer" /&gt;</ph>, which returns the unsigned byte array from which the stream was created; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> para habilitar o <ph id="ph2">&lt;see cref="M:System.IO.MemoryStream.GetBuffer" /&gt;</ph>, que retorna a matriz de bytes sem sinal da qual o fluxo foi criado. Caso contrário, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32,System.Boolean,System.Boolean)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.IO.MemoryStream" /&gt;</ph> class based on the specified region of a byte array, with the <ph id="ph2">&lt;see cref="P:System.IO.MemoryStream.CanWrite" /&gt;</ph> property set as specified, and the ability to call <ph id="ph3">&lt;see cref="M:System.IO.MemoryStream.GetBuffer" /&gt;</ph> set as specified.</source>
          <target state="translated">Inicializa uma nova instância da classe <ph id="ph1">&lt;see cref="T:System.IO.MemoryStream" /&gt;</ph> com base na região especificada de uma matriz de bytes, com o conjunto de propriedades <ph id="ph2">&lt;see cref="P:System.IO.MemoryStream.CanWrite" /&gt;</ph> especificado e a capacidade de chamar <ph id="ph3">&lt;see cref="M:System.IO.MemoryStream.GetBuffer" /&gt;</ph> definida de acordo com a especificação.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32,System.Boolean,System.Boolean)">
          <source>The <ph id="ph1">&lt;xref:System.IO.MemoryStream.CanRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IO.MemoryStream.CanSeek%2A&gt;</ph> properties are both set to <ph id="ph3">`true`</ph>.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.IO.MemoryStream.CanRead%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.IO.MemoryStream.CanSeek%2A&gt;</ph> propriedades são definidas como <ph id="ph3">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;xref:System.IO.MemoryStream.Capacity%2A&gt;</ph> is set to <ph id="ph2">`count`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.MemoryStream.Capacity%2A&gt;</ph> é definido como <ph id="ph2">`count`</ph>.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32,System.Boolean,System.Boolean)">
          <source>The new stream instance can be written to, but the <ph id="ph1">&lt;xref:System.IO.MemoryStream.Capacity%2A&gt;</ph> of the underlying byte array cannot be changed.</source>
          <target state="translated">A nova instância de fluxo pode ser gravada, mas o <ph id="ph1">&lt;xref:System.IO.MemoryStream.Capacity%2A&gt;</ph> matriz do byte subjacente não pode ser alterada.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32,System.Boolean,System.Boolean)">
          <source>The length of the stream cannot be set to a value greater than the initial length of the specified byte array; however, the stream can be truncated (see <ph id="ph1">&lt;xref:System.IO.MemoryStream.SetLength%2A&gt;</ph>).</source>
          <target state="translated">O comprimento do fluxo não pode ser definido como um valor maior que o tamanho inicial da matriz de bytes especificada; No entanto, o fluxo pode ser truncado (consulte <ph id="ph1">&lt;xref:System.IO.MemoryStream.SetLength%2A&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> or <ph id="ph2">&lt;paramref name="count" /&gt;</ph> is negative.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> ou <ph id="ph2">&lt;paramref name="count" /&gt;</ph> é negativo.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32,System.Boolean,System.Boolean)">
          <source>The buffer length minus <ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than <ph id="ph2">&lt;paramref name="count" /&gt;</ph>.</source>
          <target state="translated">O tamanho do buffer menos <ph id="ph1">&lt;paramref name="index" /&gt;</ph> é menor que <ph id="ph2">&lt;paramref name="count" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" uid="P:System.IO.MemoryStream.CanRead">
          <source>Gets a value indicating whether the current stream supports reading.</source>
          <target state="translated">Obtém um valor que indica se o fluxo atual dá suporte à leitura.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.MemoryStream.CanRead">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the stream is open.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se o fluxo estiver aberto.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.MemoryStream.CanRead">
          <source>If a class derived from <ph id="ph1">&lt;xref:System.IO.Stream&gt;</ph> does not support reading, calls to the <ph id="ph2">&lt;xref:System.IO.MemoryStream.Read%2A&gt;</ph> and <ph id="ph3">&lt;xref:System.IO.MemoryStream.ReadByte%2A&gt;</ph> methods throw a <ph id="ph4">&lt;xref:System.NotSupportedException&gt;</ph>.</source>
          <target state="translated">Se uma classe derivada de <ph id="ph1">&lt;xref:System.IO.Stream&gt;</ph> não dá suporte para leitura, chamadas para o <ph id="ph2">&lt;xref:System.IO.MemoryStream.Read%2A&gt;</ph> e <ph id="ph3">&lt;xref:System.IO.MemoryStream.ReadByte%2A&gt;</ph> métodos lançam uma <ph id="ph4">&lt;xref:System.NotSupportedException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.MemoryStream.CanRead">
          <source>If the stream is closed, this property returns <ph id="ph1">`false`</ph>.</source>
          <target state="translated">Se o fluxo está fechado, essa propriedade retornará <ph id="ph1">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" uid="P:System.IO.MemoryStream.CanSeek">
          <source>Gets a value indicating whether the current stream supports seeking.</source>
          <target state="translated">Obtém um valor que indica se o fluxo atual dá suporte à busca.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.MemoryStream.CanSeek">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the stream is open.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se o fluxo estiver aberto.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.MemoryStream.CanSeek">
          <source>If a class derived from <ph id="ph1">&lt;xref:System.IO.Stream&gt;</ph> does not support seeking, calls to <ph id="ph2">&lt;xref:System.IO.MemoryStream.Length%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.IO.MemoryStream.SetLength%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.IO.MemoryStream.Position%2A&gt;</ph>, and <ph id="ph5">&lt;xref:System.IO.MemoryStream.Seek%2A&gt;</ph> throw a <ph id="ph6">&lt;xref:System.NotSupportedException&gt;</ph>.</source>
          <target state="translated">Se uma classe derivada de <ph id="ph1">&lt;xref:System.IO.Stream&gt;</ph> não dá suporte para busca, chamadas para <ph id="ph2">&lt;xref:System.IO.MemoryStream.Length%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.IO.MemoryStream.SetLength%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.IO.MemoryStream.Position%2A&gt;</ph>, e <ph id="ph5">&lt;xref:System.IO.MemoryStream.Seek%2A&gt;</ph> lançar um <ph id="ph6">&lt;xref:System.NotSupportedException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.MemoryStream.CanSeek">
          <source>If the stream is closed, this property returns <ph id="ph1">`false`</ph>.</source>
          <target state="translated">Se o fluxo está fechado, essa propriedade retornará <ph id="ph1">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" uid="P:System.IO.MemoryStream.CanWrite">
          <source>Gets a value indicating whether the current stream supports writing.</source>
          <target state="translated">Obtém um valor que indica se o fluxo atual dá suporte à gravação.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.MemoryStream.CanWrite">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the stream supports writing; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se o fluxo der suporte à gravação; caso contrário, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.MemoryStream.CanWrite">
          <source>If a class derived from <ph id="ph1">&lt;xref:System.IO.Stream&gt;</ph> does not support writing, a call to <ph id="ph2">&lt;xref:System.IO.Stream.SetLength%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.IO.Stream.Write%2A&gt;</ph>, or <ph id="ph4">&lt;xref:System.IO.Stream.WriteByte%2A&gt;</ph> throws a <ph id="ph5">&lt;xref:System.NotSupportedException&gt;</ph>.</source>
          <target state="translated">Se uma classe derivada de <ph id="ph1">&lt;xref:System.IO.Stream&gt;</ph> não oferece suporte à gravação, uma chamada para <ph id="ph2">&lt;xref:System.IO.Stream.SetLength%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.IO.Stream.Write%2A&gt;</ph>, ou <ph id="ph4">&lt;xref:System.IO.Stream.WriteByte%2A&gt;</ph> lança um <ph id="ph5">&lt;xref:System.NotSupportedException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.MemoryStream.CanWrite">
          <source>If the stream is closed, this property returns <ph id="ph1">`false`</ph>.</source>
          <target state="translated">Se o fluxo está fechado, essa propriedade retornará <ph id="ph1">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" uid="P:System.IO.MemoryStream.Capacity">
          <source>Gets or sets the number of bytes allocated for this stream.</source>
          <target state="translated">Obtém ou define o número de bytes alocados a este fluxo.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.MemoryStream.Capacity">
          <source>The length of the usable portion of the buffer for the stream.</source>
          <target state="translated">O tamanho da parte utilizável do buffer para o fluxo.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.MemoryStream.Capacity">
          <source><ph id="ph1">`Capacity`</ph> is the buffer length for system-provided byte arrays.</source>
          <target state="translated"><ph id="ph1">`Capacity`</ph> é o comprimento do buffer para matrizes de bytes fornecido pelo sistema.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.MemoryStream.Capacity">
          <source><ph id="ph1">`Capacity`</ph> cannot be set to a value less than the current length of the stream.</source>
          <target state="translated"><ph id="ph1">`Capacity`</ph> não pode ser definido como um valor menor que o tamanho atual do fluxo.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.MemoryStream.Capacity">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.IO.MemoryStream&gt;</ph> class.</source>
          <target state="translated">Este exemplo de código é parte de um exemplo maior fornecido para a <ph id="ph1">&lt;xref:System.IO.MemoryStream&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" uid="P:System.IO.MemoryStream.Capacity">
          <source>A capacity is set that is negative or less than the current length of the stream.</source>
          <target state="translated">Foi definida uma capacidade negativa ou menor que o tamanho atual do fluxo.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" uid="P:System.IO.MemoryStream.Capacity">
          <source>The current stream is closed.</source>
          <target state="translated">O fluxo atual está fechado.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" uid="P:System.IO.MemoryStream.Capacity">
          <source><ph id="ph1">&lt;see langword="set" /&gt;</ph> is invoked on a stream whose capacity cannot be modified.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="set" /&gt;</ph> é invocado em um fluxo cuja capacidade não pode ser modificada.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.CopyToAsync(System.IO.Stream,System.Int32,System.Threading.CancellationToken)">
          <source>The stream to which the contents of the current stream will be copied.</source>
          <target state="translated">O fluxo para o qual o conteúdo do fluxo atual será copiado.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.CopyToAsync(System.IO.Stream,System.Int32,System.Threading.CancellationToken)">
          <source>The size, in bytes, of the buffer.</source>
          <target state="translated">O tamanho do buffer, em bytes.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.CopyToAsync(System.IO.Stream,System.Int32,System.Threading.CancellationToken)">
          <source>This value must be greater than zero.</source>
          <target state="translated">Esse valor deve ser maior que zero.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.CopyToAsync(System.IO.Stream,System.Int32,System.Threading.CancellationToken)">
          <source>The token to monitor for cancellation requests.</source>
          <target state="translated">O token a se monitorar para solicitações de cancelamento.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.CopyToAsync(System.IO.Stream,System.Int32,System.Threading.CancellationToken)">
          <source>Asynchronously reads all the bytes from the current stream and writes them to another stream, using a specified buffer size and cancellation token.</source>
          <target state="translated">Lê de maneira assíncrona todos os bytes do fluxo atual e os grava em outro fluxo usando um tamanho do buffer especificado e um token de cancelamento.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.CopyToAsync(System.IO.Stream,System.Int32,System.Threading.CancellationToken)">
          <source>A task that represents the asynchronous copy operation.</source>
          <target state="translated">Uma tarefa que representa a operação de cópia assíncrona.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.CopyToAsync(System.IO.Stream,System.Int32,System.Threading.CancellationToken)">
          <source><ph id="ph1">&lt;paramref name="destination" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="destination" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.CopyToAsync(System.IO.Stream,System.Int32,System.Threading.CancellationToken)">
          <source><ph id="ph1">&lt;paramref name="buffersize" /&gt;</ph> is negative or zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffersize" /&gt;</ph> é negativo ou zero.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.CopyToAsync(System.IO.Stream,System.Int32,System.Threading.CancellationToken)">
          <source>Either the current stream or the destination stream is disposed.</source>
          <target state="translated">O fluxo atual ou o fluxo de destino é descartado.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.CopyToAsync(System.IO.Stream,System.Int32,System.Threading.CancellationToken)">
          <source>The current stream does not support reading, or the destination stream does not support writing.</source>
          <target state="translated">O fluxo atual não dá suporte à leitura ou o fluxo de destino não dá suporte à gravação.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.Dispose(System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to release both managed and unmanaged resources; <ph id="ph2">&lt;see langword="false" /&gt;</ph> to release only unmanaged resources.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> para liberar recursos gerenciados e não gerenciados; <ph id="ph2">&lt;see langword="false" /&gt;</ph> para liberar apenas recursos não gerenciados.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.Dispose(System.Boolean)">
          <source>Releases the unmanaged resources used by the <ph id="ph1">&lt;see cref="T:System.IO.MemoryStream" /&gt;</ph> class and optionally releases the managed resources.</source>
          <target state="translated">Libera os recursos não gerenciados usados pela classe <ph id="ph1">&lt;see cref="T:System.IO.MemoryStream" /&gt;</ph> e, opcionalmente, libera os recursos gerenciados.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.Dispose(System.Boolean)">
          <source>This method is called by the public <ph id="ph1">&lt;xref:System.ComponentModel.Component.Dispose%2A&gt;</ph> method and the <ph id="ph2">&lt;xref:System.Object.Finalize%2A&gt;</ph> method.</source>
          <target state="translated">Este método é chamado pelo método público <ph id="ph1">&lt;xref:System.ComponentModel.Component.Dispose%2A&gt;</ph> e pelo método <ph id="ph2">&lt;xref:System.Object.Finalize%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.Dispose(System.Boolean)">
          <source><ph id="ph1">&lt;xref:System.ComponentModel.Component.Dispose%2A&gt;</ph> invokes the protected <ph id="ph2">&lt;xref:System.IO.MemoryStream.Dispose%2A&gt;</ph> method with the <ph id="ph3">`disposing`</ph> parameter set to <ph id="ph4">`true`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.ComponentModel.Component.Dispose%2A&gt;</ph> invoca o método <ph id="ph2">&lt;xref:System.IO.MemoryStream.Dispose%2A&gt;</ph> protegido com o parâmetro <ph id="ph3">`disposing`</ph> definido como <ph id="ph4">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.Dispose(System.Boolean)">
          <source><ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> invokes <ph id="ph2">&lt;xref:System.IO.MemoryStream.Dispose%2A&gt;</ph> with <ph id="ph3">`disposing`</ph> set to <ph id="ph4">`false`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> invoca <ph id="ph2">&lt;xref:System.IO.MemoryStream.Dispose%2A&gt;</ph> com <ph id="ph3">`disposing`</ph> definido como <ph id="ph4">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.Dispose(System.Boolean)">
          <source>When the <ph id="ph1">`disposing`</ph> parameter is <ph id="ph2">`true`</ph>, this method releases all resources held by any managed objects that this <ph id="ph3">&lt;xref:System.IO.MemoryStream&gt;</ph> references.</source>
          <target state="translated">Quando o <ph id="ph1">`disposing`</ph> parâmetro é <ph id="ph2">`true`</ph>, esse método libera todos os recursos mantidos por qualquer objeto gerenciado que este <ph id="ph3">&lt;xref:System.IO.MemoryStream&gt;</ph> referências.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.Dispose(System.Boolean)">
          <source>This method invokes the <ph id="ph1">&lt;xref:System.ComponentModel.Component.Dispose%2A&gt;</ph> method of each referenced object.</source>
          <target state="translated">Este método invoca o método <ph id="ph1">&lt;xref:System.ComponentModel.Component.Dispose%2A&gt;</ph> de cada objeto referenciado.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.Dispose(System.Boolean)">
          <source><ph id="ph1">&lt;see cref="M:System.ComponentModel.Component.Dispose" /&gt;</ph> can be called multiple times by other objects.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.ComponentModel.Component.Dispose" /&gt;</ph> pode ser chamado várias vezes por outros objetos.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.Dispose(System.Boolean)">
          <source>When overriding <ph id="ph1">&lt;see cref="M:System.IO.MemoryStream.Dispose(System.Boolean)" /&gt;</ph> be careful not to reference objects that have been previously disposed of in an earlier call to <ph id="ph2">&lt;see cref="M:System.ComponentModel.Component.Dispose" /&gt;</ph>.</source>
          <target state="translated">Ao substituir <ph id="ph1">&lt;see cref="M:System.IO.MemoryStream.Dispose(System.Boolean)" /&gt;</ph> cuidado para não fazer referência a objetos que têm foi descartados anteriormente em uma chamada anterior para <ph id="ph2">&lt;see cref="M:System.ComponentModel.Component.Dispose" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.Dispose(System.Boolean)">
          <source>For more information about how to implement <ph id="ph1">&lt;see cref="M:System.IO.MemoryStream.Dispose(System.Boolean)" /&gt;</ph>, see <bpt id="p1">[</bpt>Implementing a Dispose Method<ept id="p1">](~/docs/standard/garbage-collection/implementing-dispose.md)</ept>.</source>
          <target state="translated">Para obter mais informações sobre como implementar <ph id="ph1">&lt;see cref="M:System.IO.MemoryStream.Dispose(System.Boolean)" /&gt;</ph>, consulte <bpt id="p1">[</bpt>implementar um método Dispose<ept id="p1">](~/docs/standard/garbage-collection/implementing-dispose.md)</ept>.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.Dispose(System.Boolean)">
          <source>For more information about <ph id="ph1">&lt;see cref="M:System.ComponentModel.Component.Dispose" /&gt;</ph> and <ph id="ph2">&lt;see cref="M:System.Object.Finalize" /&gt;</ph>, see <bpt id="p1">[</bpt>Cleaning Up Unmanaged Resources<ept id="p1">](~/docs/standard/garbage-collection/unmanaged.md)</ept>.</source>
          <target state="translated">Para obter mais informações sobre <ph id="ph1">&lt;see cref="M:System.ComponentModel.Component.Dispose" /&gt;</ph> e <ph id="ph2">&lt;see cref="M:System.Object.Finalize" /&gt;</ph>, consulte <bpt id="p1">[</bpt>limpeza de recursos não gerenciados<ept id="p1">](~/docs/standard/garbage-collection/unmanaged.md)</ept>.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.Flush">
          <source>Overrides the <ph id="ph1">&lt;see cref="M:System.IO.Stream.Flush" /&gt;</ph> method so that no action is performed.</source>
          <target state="translated">Substitui o método <ph id="ph1">&lt;see cref="M:System.IO.Stream.Flush" /&gt;</ph> para que nenhuma ação seja executada.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.Flush">
          <source>This method overrides the <ph id="ph1">&lt;xref:System.IO.Stream.Flush%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Esse método substitui o <ph id="ph1">&lt;xref:System.IO.Stream.Flush%2A?displayProperty=nameWithType&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.Flush">
          <source>Because any data written to a <ph id="ph1">&lt;xref:System.IO.MemoryStream&gt;</ph> object is written into RAM, this method is redundant.</source>
          <target state="translated">Porque os dados gravados em um <ph id="ph1">&lt;xref:System.IO.MemoryStream&gt;</ph> objeto é gravado na RAM, esse método é redundante.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.FlushAsync(System.Threading.CancellationToken)">
          <source>The token to monitor for cancellation requests.</source>
          <target state="translated">O token a se monitorar para solicitações de cancelamento.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.FlushAsync(System.Threading.CancellationToken)">
          <source>Asynchronously clears all buffers for this stream, and monitors cancellation requests.</source>
          <target state="translated">Limpa de maneira assíncrona todos os buffers para esse fluxo e monitora solicitações de cancelamento.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.FlushAsync(System.Threading.CancellationToken)">
          <source>A task that represents the asynchronous flush operation.</source>
          <target state="translated">Uma tarefa que representa a operação de liberação assíncrona.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.FlushAsync(System.Threading.CancellationToken)">
          <source>Because any data written to a <ph id="ph1">&lt;xref:System.IO.MemoryStream&gt;</ph> object is written into RAM, this method is redundant.</source>
          <target state="translated">Porque os dados gravados em um <ph id="ph1">&lt;xref:System.IO.MemoryStream&gt;</ph> objeto é gravado na RAM, esse método é redundante.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.FlushAsync(System.Threading.CancellationToken)">
          <source>If the operation is canceled before it completes, the returned task contains the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph> value for the <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Status%2A&gt;</ph> property.</source>
          <target state="translated">Se a operação foi cancelada antes da conclusão, a tarefa retornada contém o <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph> valor para o <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Status%2A&gt;</ph> propriedade.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.FlushAsync(System.Threading.CancellationToken)">
          <source>You can create a cancellation token by creating an instance of the <ph id="ph1">&lt;xref:System.Threading.CancellationTokenSource&gt;</ph> class and passing the <ph id="ph2">&lt;xref:System.Threading.CancellationTokenSource.Token%2A&gt;</ph> property as the <ph id="ph3">`cancellationToken`</ph> parameter.</source>
          <target state="translated">Você pode criar um token de cancelamento, criando uma instância do <ph id="ph1">&lt;xref:System.Threading.CancellationTokenSource&gt;</ph> classe e passando o <ph id="ph2">&lt;xref:System.Threading.CancellationTokenSource.Token%2A&gt;</ph> a propriedade como o <ph id="ph3">`cancellationToken`</ph> parâmetro.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.FlushAsync(System.Threading.CancellationToken)">
          <source>The stream has been disposed.</source>
          <target state="translated">O fluxo foi descartado.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.GetBuffer">
          <source>Returns the array of unsigned bytes from which this stream was created.</source>
          <target state="translated">Retorna a matriz de bytes sem sinal com base na qual este fluxo foi criado.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.GetBuffer">
          <source>The byte array from which this stream was created, or the underlying array if a byte array was not provided to the <ph id="ph1">&lt;see cref="T:System.IO.MemoryStream" /&gt;</ph> constructor during construction of the current instance.</source>
          <target state="translated">A matriz de bytes com base na qual este fluxo foi criado ou a matriz subjacente se uma matriz de bytes não tiver sido fornecida para o construtor <ph id="ph1">&lt;see cref="T:System.IO.MemoryStream" /&gt;</ph> durante a construção da instância atual.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.GetBuffer">
          <source>Note that the buffer contains allocated bytes which might be unused.</source>
          <target state="translated">Observe que o buffer contém bytes alocados que não podem ser usados.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.GetBuffer">
          <source>For example, if the string "test" is written into the <ph id="ph1">&lt;xref:System.IO.MemoryStream&gt;</ph> object, the length of the buffer returned from <ph id="ph2">&lt;xref:System.IO.MemoryStream.GetBuffer%2A&gt;</ph> is 256, not 4, with 252 bytes unused.</source>
          <target state="translated">Por exemplo, se a cadeia de caracteres "test" é gravada para o <ph id="ph1">&lt;xref:System.IO.MemoryStream&gt;</ph> objeto, o comprimento do buffer retornado de <ph id="ph2">&lt;xref:System.IO.MemoryStream.GetBuffer%2A&gt;</ph> é 256, não 4, com 252 bytes não utilizados.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.GetBuffer">
          <source>To obtain only the data in the buffer, use the <ph id="ph1">&lt;xref:System.IO.MemoryStream.ToArray%2A&gt;</ph> method; however, <ph id="ph2">&lt;xref:System.IO.MemoryStream.ToArray%2A&gt;</ph> creates a copy of the data in memory.</source>
          <target state="translated">Para obter apenas os dados no buffer, use o <ph id="ph1">&lt;xref:System.IO.MemoryStream.ToArray%2A&gt;</ph> método; no entanto, <ph id="ph2">&lt;xref:System.IO.MemoryStream.ToArray%2A&gt;</ph> cria uma cópia dos dados na memória.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.GetBuffer">
          <source>The buffer can also be <ph id="ph1">`null`</ph>.</source>
          <target state="translated">O buffer também pode ser <ph id="ph1">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.GetBuffer">
          <source>To create a <ph id="ph1">`MemoryStream`</ph> instance with a publicly visible buffer, use <ph id="ph2">&lt;xref:System.IO.MemoryStream.%23ctor%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.IO.MemoryStream.%23ctor%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph>, or <ph id="ph4">&lt;xref:System.IO.MemoryStream.%23ctor%28System.Int32%29&gt;</ph>.</source>
          <target state="translated">Para criar um <ph id="ph1">`MemoryStream`</ph> instância com um buffer visível publicamente, use <ph id="ph2">&lt;xref:System.IO.MemoryStream.%23ctor%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.IO.MemoryStream.%23ctor%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph>, ou <ph id="ph4">&lt;xref:System.IO.MemoryStream.%23ctor%28System.Int32%29&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.GetBuffer">
          <source>If the current stream is resizable, two calls to this method do not return the same array if the underlying byte array is resized between calls.</source>
          <target state="translated">Se o fluxo atual é redimensionável, duas chamadas a este método não retornam a mesma matriz se a matriz de bytes subjacente é redimensionada entre as chamadas.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.GetBuffer">
          <source>For additional information, see <ph id="ph1">&lt;xref:System.IO.MemoryStream.Capacity%2A&gt;</ph>.</source>
          <target state="translated">Para obter mais informações, consulte: <ph id="ph1">&lt;xref:System.IO.MemoryStream.Capacity%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.GetBuffer">
          <source>This method works when the memory stream is closed.</source>
          <target state="translated">Esse método funciona quando o fluxo de memória está fechado.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.GetBuffer">
          <source>The <ph id="ph1">&lt;see langword="MemoryStream" /&gt;</ph> instance was not created with a publicly visible buffer.</source>
          <target state="translated">A instância de <ph id="ph1">&lt;see langword="MemoryStream" /&gt;</ph> não foi criada com um buffer visível publicamente.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" uid="P:System.IO.MemoryStream.Length">
          <source>Gets the length of the stream in bytes.</source>
          <target state="translated">Obtém o tamanho do fluxo em bytes.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.MemoryStream.Length">
          <source>The length of the stream in bytes.</source>
          <target state="translated">O comprimento do fluxo em bytes.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.MemoryStream.Length">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.IO.MemoryStream&gt;</ph> class.</source>
          <target state="translated">Este exemplo de código é parte de um exemplo maior fornecido para a <ph id="ph1">&lt;xref:System.IO.MemoryStream&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" uid="P:System.IO.MemoryStream.Length">
          <source>The stream is closed.</source>
          <target state="translated">O fluxo está fechado.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" uid="P:System.IO.MemoryStream.Position">
          <source>Gets or sets the current position within the stream.</source>
          <target state="translated">Obtém ou define a posição atual no fluxo.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.MemoryStream.Position">
          <source>The current position within the stream.</source>
          <target state="translated">A posição atual no fluxo.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.MemoryStream.Position">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.IO.MemoryStream&gt;</ph> class.</source>
          <target state="translated">Este exemplo de código é parte de um exemplo maior fornecido para a <ph id="ph1">&lt;xref:System.IO.MemoryStream&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" uid="P:System.IO.MemoryStream.Position">
          <source>The position is set to a negative value or a value greater than <ph id="ph1">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</source>
          <target state="translated">A posição é definida com um valor negativo ou um valor maior que <ph id="ph1">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" uid="P:System.IO.MemoryStream.Position">
          <source>The stream is closed.</source>
          <target state="translated">O fluxo está fechado.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>When this method returns, contains the specified byte array with the values between <bpt id="p1">&lt;c&gt;</bpt>offset<ept id="p1">&lt;/c&gt;</ept> and (<bpt id="p2">&lt;c&gt;</bpt>offset<ept id="p2">&lt;/c&gt;</ept><ph id="ph1"> + </ph><bpt id="p3">&lt;c&gt;</bpt>count<ept id="p3">&lt;/c&gt;</ept> - 1) replaced by the characters read from the current stream.</source>
          <target state="translated">Quando este método retorna, contém a matriz de bytes especificada com os valores entre <bpt id="p1">&lt;c&gt;</bpt>deslocamento<ept id="p1">&lt;/c&gt;</ept> e (<bpt id="p2">&lt;c&gt;</bpt>deslocamento<ept id="p2">&lt;/c&gt;</ept><ph id="ph1"> + </ph><bpt id="p3">&lt;c&gt;</bpt>contagem<ept id="p3">&lt;/c&gt;</ept> – 1) substituídos pelos caracteres lidos do fluxo atual.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>The zero-based byte offset in <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> at which to begin storing data from the current stream.</source>
          <target state="translated">O deslocamento de bytes baseado em zero no <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> no qual começar a armazenar dados no fluxo atual.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>The maximum number of bytes to read.</source>
          <target state="translated">O número máximo de bytes a serem lidos.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>Reads a block of bytes from the current stream and writes the data to a buffer.</source>
          <target state="translated">Lê um bloco de bytes do fluxo atual e grava os dados em um buffer.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>The total number of bytes written into the buffer.</source>
          <target state="translated">O número total de bytes gravados no buffer.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>This can be less than the number of bytes requested if that number of bytes are not currently available, or zero if the end of the stream is reached before any bytes are read.</source>
          <target state="translated">Isso poderá ser menor que o número de bytes solicitado se esse número de bytes não estiver disponível no momento, ou zero se o final do fluxo for atingido antes que os bytes sejam lidos.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>This method overrides <ph id="ph1">&lt;xref:System.IO.Stream.Read%2A&gt;</ph>.</source>
          <target state="translated">Este método substitui <ph id="ph1">&lt;xref:System.IO.Stream.Read%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>The <ph id="ph1">`offset`</ph> parameter gives the offset of the first byte in <ph id="ph2">`buffer`</ph> to which data from the current stream is written.</source>
          <target state="translated">O <ph id="ph1">`offset`</ph> parâmetro fornece o deslocamento do primeiro byte no <ph id="ph2">`buffer`</ph> para os dados do fluxo atual foi criados.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>The <ph id="ph1">`count`</ph> parameter gives the maximum number of bytes to read from the current stream.</source>
          <target state="translated">O <ph id="ph1">`count`</ph> parâmetro retorna o número máximo de bytes a serem lidos do fluxo atual.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>The returned value is the actual number of bytes read, or zero if the end of the stream is reached.</source>
          <target state="translated">O valor retornado é o número real de bytes lidos ou zero se o fim do fluxo for atingido.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>If the read operation is successful, the current position within the stream advances by the number of bytes read.</source>
          <target state="translated">Se a operação de leitura for bem-sucedida, a posição atual dentro do fluxo avança pelo número de bytes lidos.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>If an exception occurs, the current position within the stream remains unchanged.</source>
          <target state="translated">Se ocorrer uma exceção, a posição atual dentro do fluxo permanecerá inalterada.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>The <ph id="ph1">`Read`</ph> method will return zero only if the end of the stream is reached.</source>
          <target state="translated">O <ph id="ph1">`Read`</ph> método retornará zero somente se o fim do fluxo for atingido.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>In all other cases, <ph id="ph1">`Read`</ph> always reads at least one byte from the stream before returning.</source>
          <target state="translated">Em todos os outros casos, <ph id="ph1">`Read`</ph> lê sempre pelo menos um byte do fluxo antes de retornar.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>By definition, if no data is available from the stream upon a call to <ph id="ph1">`Read`</ph>, the <ph id="ph2">`Read`</ph> method returns zero (the end of the stream is reached automatically).</source>
          <target state="translated">Por definição, se não há dados disponíveis do fluxo após uma chamada para <ph id="ph1">`Read`</ph>, o <ph id="ph2">`Read`</ph> método retorna zero (o fim do fluxo for alcançado automaticamente).</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>An implementation is free to return fewer bytes than requested even if the end of the stream has not been reached.</source>
          <target state="translated">Uma implementação está livre para retornar menos bytes que solicitado, mesmo que não foi atingido o fim do fluxo.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>Use <ph id="ph1">&lt;xref:System.IO.BinaryReader&gt;</ph> for reading primitive data types.</source>
          <target state="translated">Use <ph id="ph1">&lt;xref:System.IO.BinaryReader&gt;</ph> para ler tipos de dados primitivos.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>If the byte array specified in the <ph id="ph1">`buffer`</ph> parameter is the underlying buffer returned by the <ph id="ph2">&lt;xref:System.IO.MemoryStream.GetBuffer%2A&gt;</ph> method, the array contents are overwritten, and no exception is thrown.</source>
          <target state="translated">Se a matriz de bytes especificado no <ph id="ph1">`buffer`</ph> parâmetro é o buffer subjacente retornado pelo <ph id="ph2">&lt;xref:System.IO.MemoryStream.GetBuffer%2A&gt;</ph> método, o conteúdo da matriz é substituído e nenhuma exceção é lançada.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.IO.MemoryStream&gt;</ph> class.</source>
          <target state="translated">Este exemplo de código é parte de um exemplo maior fornecido para a <ph id="ph1">&lt;xref:System.IO.MemoryStream&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> or <ph id="ph2">&lt;paramref name="count" /&gt;</ph> is negative.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> ou <ph id="ph2">&lt;paramref name="count" /&gt;</ph> é negativo.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> subtracted from the buffer length is less than <ph id="ph2">&lt;paramref name="count" /&gt;</ph>.</source>
          <target state="translated">O <ph id="ph1">&lt;paramref name="offset" /&gt;</ph> subtraído do tamanho do buffer é menor que <ph id="ph2">&lt;paramref name="count" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>The current stream instance is closed.</source>
          <target state="translated">A instância atual do fluxo está fechada.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The buffer to write the data into.</source>
          <target state="translated">O buffer no qual os dados serão gravados.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The byte offset in <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> at which to begin writing data from the stream.</source>
          <target state="translated">O deslocamento de bytes no <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> em que será iniciada a gravação de dados do fluxo.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The maximum number of bytes to read.</source>
          <target state="translated">O número máximo de bytes a serem lidos.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The token to monitor for cancellation requests.</source>
          <target state="translated">O token a se monitorar para solicitações de cancelamento.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The default value is <ph id="ph1">&lt;see cref="P:System.Threading.CancellationToken.None" /&gt;</ph>.</source>
          <target state="translated">O valor padrão é <ph id="ph1">&lt;see cref="P:System.Threading.CancellationToken.None" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>Asynchronously reads a sequence of bytes from the current stream, advances the position within the stream by the number of bytes read, and monitors cancellation requests.</source>
          <target state="translated">Lê de forma assíncrona uma sequência de bytes do fluxo atual, avança a posição no fluxo até o número de bytes lidos e monitora as solicitações de cancelamento.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>A task that represents the asynchronous read operation.</source>
          <target state="translated">Uma tarefa que representa a operação de leitura assíncrona.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The value of the <ph id="ph1">&lt;paramref name="TResult" /&gt;</ph> parameter contains the total number of bytes read into the buffer.</source>
          <target state="translated">O valor do parâmetro <ph id="ph1">&lt;paramref name="TResult" /&gt;</ph> contém o número total de bytes lidos no buffer.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The result value can be less than the number of bytes requested if the number of bytes currently available is less than the requested number, or it can be 0 (zero) if the end of the stream has been reached.</source>
          <target state="translated">O valor do resultado poderá ser menor que o número de bytes solicitados se o número de bytes disponíveis no momento for menor que o número solicitado ou poderá ser 0 (zero) se o final do fluxo foi atingido.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>If the operation is canceled before it completes, the returned task contains the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph> value for the <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Status%2A&gt;</ph> property.</source>
          <target state="translated">Se a operação foi cancelada antes da conclusão, a tarefa retornada contém o <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph> valor para o <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Status%2A&gt;</ph> propriedade.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>You can create a cancellation token by creating an instance of the <ph id="ph1">&lt;xref:System.Threading.CancellationTokenSource&gt;</ph> class and passing the <ph id="ph2">&lt;xref:System.Threading.CancellationTokenSource.Token%2A&gt;</ph> property as the <ph id="ph3">`cancellationToken`</ph> parameter.</source>
          <target state="translated">Você pode criar um token de cancelamento, criando uma instância do <ph id="ph1">&lt;xref:System.Threading.CancellationTokenSource&gt;</ph> classe e passando o <ph id="ph2">&lt;xref:System.Threading.CancellationTokenSource.Token%2A&gt;</ph> a propriedade como o <ph id="ph3">`cancellationToken`</ph> parâmetro.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> or <ph id="ph2">&lt;paramref name="count" /&gt;</ph> is negative.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> ou <ph id="ph2">&lt;paramref name="count" /&gt;</ph> é negativo.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The sum of <ph id="ph1">&lt;paramref name="offset" /&gt;</ph> and <ph id="ph2">&lt;paramref name="count" /&gt;</ph> is larger than the buffer length.</source>
          <target state="translated">A soma de <ph id="ph1">&lt;paramref name="offset" /&gt;</ph> e <ph id="ph2">&lt;paramref name="count" /&gt;</ph> é maior que o tamanho do buffer.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The stream does not support reading.</source>
          <target state="translated">Não há suporte para leitura no fluxo.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The stream has been disposed.</source>
          <target state="translated">O fluxo foi descartado.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The stream is currently in use by a previous read operation.</source>
          <target state="translated">O fluxo está sendo usado no momento por uma operação de leitura anterior.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.ReadByte">
          <source>Reads a byte from the current stream.</source>
          <target state="translated">Lê um byte do fluxo atual.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.ReadByte">
          <source>The byte cast to a <ph id="ph1">&lt;see cref="T:System.Int32" /&gt;</ph>, or -1 if the end of the stream has been reached.</source>
          <target state="translated">O byte é convertido em um <ph id="ph1">&lt;see cref="T:System.Int32" /&gt;</ph> ou -1, se o fim do fluxo tiver sido atingido.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.ReadByte">
          <source>This method overrides <ph id="ph1">&lt;xref:System.IO.Stream.ReadByte%2A&gt;</ph>.</source>
          <target state="translated">Este método substitui <ph id="ph1">&lt;xref:System.IO.Stream.ReadByte%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.ReadByte">
          <source>If the read operation is successful, the current position within the stream is advanced by one byte.</source>
          <target state="translated">Se a operação de leitura for bem-sucedida, a posição atual dentro do fluxo for avançada por um byte.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.ReadByte">
          <source>If an exception occurs, the current position within the stream is unchanged.</source>
          <target state="translated">Se ocorrer uma exceção, a posição atual dentro do fluxo está inalterada.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.ReadByte">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.IO.MemoryStream&gt;</ph> class.</source>
          <target state="translated">Este exemplo de código é parte de um exemplo maior fornecido para a <ph id="ph1">&lt;xref:System.IO.MemoryStream&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.ReadByte">
          <source>The current stream instance is closed.</source>
          <target state="translated">A instância atual do fluxo está fechada.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.Seek(System.Int64,System.IO.SeekOrigin)">
          <source>The new position within the stream.</source>
          <target state="translated">A nova posição no fluxo.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.Seek(System.Int64,System.IO.SeekOrigin)">
          <source>This is relative to the <bpt id="p1">&lt;c&gt;</bpt>loc<ept id="p1">&lt;/c&gt;</ept> parameter, and can be positive or negative.</source>
          <target state="translated">Isso é relativo ao parâmetro <bpt id="p1">&lt;c&gt;</bpt>loc<ept id="p1">&lt;/c&gt;</ept> e pode ser positivo ou negativo.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.Seek(System.Int64,System.IO.SeekOrigin)">
          <source>A value of type <ph id="ph1">&lt;see cref="T:System.IO.SeekOrigin" /&gt;</ph>, which acts as the seek reference point.</source>
          <target state="translated">Um valor do tipo <ph id="ph1">&lt;see cref="T:System.IO.SeekOrigin" /&gt;</ph>, que atua como o ponto de referência de busca.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.Seek(System.Int64,System.IO.SeekOrigin)">
          <source>Sets the position within the current stream to the specified value.</source>
          <target state="translated">Define a posição no fluxo atual com o valor especificado.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.Seek(System.Int64,System.IO.SeekOrigin)">
          <source>The new position within the stream, calculated by combining the initial reference point and the offset.</source>
          <target state="translated">A nova posição no fluxo, calculada pela combinação do ponto de referência inicial e do deslocamento.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.Seek(System.Int64,System.IO.SeekOrigin)">
          <source>This method overrides <ph id="ph1">&lt;xref:System.IO.Stream.Seek%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Este método substitui <ph id="ph1">&lt;xref:System.IO.Stream.Seek%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.Seek(System.Int64,System.IO.SeekOrigin)">
          <source>Seeking to any location beyond the length of the stream is supported.</source>
          <target state="translated">Há suporte para busca em qualquer local além do comprimento do fluxo.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.Seek(System.Int64,System.IO.SeekOrigin)">
          <source>Do not use the <ph id="ph1">&lt;xref:System.IO.MemoryStream.Seek%2A&gt;</ph> method to determine the new position in the stream if the <ph id="ph2">&lt;xref:System.IO.MemoryStream&gt;</ph> was initialized with a non-zero offset.</source>
          <target state="translated">Não use o <ph id="ph1">&lt;xref:System.IO.MemoryStream.Seek%2A&gt;</ph> método para determinar a nova posição no fluxo se o <ph id="ph2">&lt;xref:System.IO.MemoryStream&gt;</ph> foi inicializada com um deslocamento diferente de zero.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.Seek(System.Int64,System.IO.SeekOrigin)">
          <source>If you do, <ph id="ph1">&lt;xref:System.IO.MemoryStream.Seek%2A&gt;</ph> will return an inaccurate value.</source>
          <target state="translated">Se você fizer isso, <ph id="ph1">&lt;xref:System.IO.MemoryStream.Seek%2A&gt;</ph> retornará um valor.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.Seek(System.Int64,System.IO.SeekOrigin)">
          <source>Instead, use the <ph id="ph1">&lt;xref:System.IO.MemoryStream.Position%2A&gt;</ph> property to get the new position of the stream.</source>
          <target state="translated">Em vez disso, use o <ph id="ph1">&lt;xref:System.IO.MemoryStream.Position%2A&gt;</ph> propriedade para obter a nova posição do fluxo.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.Seek(System.Int64,System.IO.SeekOrigin)">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.IO.MemoryStream&gt;</ph> class.</source>
          <target state="translated">Este exemplo de código é parte de um exemplo maior fornecido para a <ph id="ph1">&lt;xref:System.IO.MemoryStream&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.Seek(System.Int64,System.IO.SeekOrigin)">
          <source>Seeking is attempted before the beginning of the stream.</source>
          <target state="translated">A busca é tentada antes do início do fluxo.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.Seek(System.Int64,System.IO.SeekOrigin)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is greater than <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> é maior que <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.Seek(System.Int64,System.IO.SeekOrigin)">
          <source>There is an invalid <ph id="ph1">&lt;see cref="T:System.IO.SeekOrigin" /&gt;</ph>.</source>
          <target state="translated">Há um <ph id="ph1">&lt;see cref="T:System.IO.SeekOrigin" /&gt;</ph> inválido.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.Seek(System.Int64,System.IO.SeekOrigin)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.Seek(System.Int64,System.IO.SeekOrigin)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> caused an arithmetic overflow.</source>
          <target state="translated">O <ph id="ph1">&lt;paramref name="offset" /&gt;</ph> causou um estouro aritmético.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.Seek(System.Int64,System.IO.SeekOrigin)">
          <source>The current stream instance is closed.</source>
          <target state="translated">A instância atual do fluxo está fechada.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.SetLength(System.Int64)">
          <source>The value at which to set the length.</source>
          <target state="translated">O valor a ser usado para definir o comprimento.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.SetLength(System.Int64)">
          <source>Sets the length of the current stream to the specified value.</source>
          <target state="translated">Define o comprimento do fluxo atual para o valor especificado.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.SetLength(System.Int64)">
          <source>This method overrides <ph id="ph1">&lt;xref:System.IO.Stream.SetLength%2A&gt;</ph>.</source>
          <target state="translated">Este método substitui <ph id="ph1">&lt;xref:System.IO.Stream.SetLength%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.SetLength(System.Int64)">
          <source>If the specified value is less than the current length of the stream, the stream is truncated.</source>
          <target state="translated">Se o valor especificado é menor que o tamanho atual do fluxo, o fluxo é truncado.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.SetLength(System.Int64)">
          <source>If after the truncation the current position within the stream is past the end of the stream, the <ph id="ph1">&lt;xref:System.IO.MemoryStream.ReadByte%2A&gt;</ph> method returns -1, the <ph id="ph2">&lt;xref:System.IO.MemoryStream.Read%2A&gt;</ph> method reads zero bytes into the provided byte array, and <ph id="ph3">&lt;xref:System.IO.MemoryStream.Write%2A&gt;</ph> and <ph id="ph4">&lt;xref:System.IO.MemoryStream.WriteByte%2A&gt;</ph> methods append specified bytes at the end of the stream, increasing its length.</source>
          <target state="translated">Se após o truncamento da posição atual dentro do fluxo for após o fim do fluxo a <ph id="ph1">&lt;xref:System.IO.MemoryStream.ReadByte%2A&gt;</ph> método retornará -1, o <ph id="ph2">&lt;xref:System.IO.MemoryStream.Read%2A&gt;</ph> método lê a zero bytes para a matriz de bytes fornecida, e <ph id="ph3">&lt;xref:System.IO.MemoryStream.Write%2A&gt;</ph> e <ph id="ph4">&lt;xref:System.IO.MemoryStream.WriteByte%2A&gt;</ph> métodos acrescentar os bytes especificados ao final do fluxo, aumentando seu tamanho.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.SetLength(System.Int64)">
          <source>If the specified value is larger than the current capacity and the stream is resizable, the capacity is increased, and the current position within the stream is unchanged.</source>
          <target state="translated">Se o valor especificado é maior do que a capacidade atual e o fluxo é redimensionável, aumenta a capacidade e a posição atual dentro do fluxo não é alterada.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.SetLength(System.Int64)">
          <source>If the length is increased, the contents of the stream between the old and the new length are initialized to zeros.</source>
          <target state="translated">Se o tamanho é aumentado, o conteúdo do fluxo entre o antigo e o novo comprimento é inicializado para zeros.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.SetLength(System.Int64)">
          <source>A <ph id="ph1">&lt;xref:System.IO.MemoryStream&gt;</ph> instance must support writing for this method to work.</source>
          <target state="translated">Um <ph id="ph1">&lt;xref:System.IO.MemoryStream&gt;</ph> instância deve oferecer suporte à gravação para esse método trabalhar.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.SetLength(System.Int64)">
          <source>Use the <ph id="ph1">&lt;xref:System.IO.MemoryStream.CanWrite%2A&gt;</ph> property to determine whether the current instance supports writing.</source>
          <target state="translated">Use o <ph id="ph1">&lt;xref:System.IO.MemoryStream.CanWrite%2A&gt;</ph> propriedade para determinar se a instância atual oferece suporte à gravação.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.SetLength(System.Int64)">
          <source>For additional information, see <ph id="ph1">&lt;xref:System.IO.Stream.CanWrite%2A&gt;</ph>.</source>
          <target state="translated">Para obter mais informações, consulte: <ph id="ph1">&lt;xref:System.IO.Stream.CanWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.SetLength(System.Int64)">
          <source>The current stream is not resizable and <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is larger than the current capacity.</source>
          <target state="translated">O fluxo atual não é redimensionável e <ph id="ph1">&lt;paramref name="value" /&gt;</ph> é maior que a capacidade atual.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.SetLength(System.Int64)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.SetLength(System.Int64)">
          <source>The current stream does not support writing.</source>
          <target state="translated">O fluxo atual não dá suporte para gravação.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.SetLength(System.Int64)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is negative or is greater than the maximum length of the <ph id="ph2">&lt;see cref="T:System.IO.MemoryStream" /&gt;</ph>, where the maximum length is(<ph id="ph3">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph> - origin), and origin is the index into the underlying buffer at which the stream starts.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> é negativo ou maior que o comprimento máximo do <ph id="ph2">&lt;see cref="T:System.IO.MemoryStream" /&gt;</ph>, em que o comprimento máximo é (<ph id="ph3">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph> – origem) e a origem é o índice para o buffer subjacente no qual o fluxo se inicia.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.ToArray">
          <source>Writes the stream contents to a byte array, regardless of the <ph id="ph1">&lt;see cref="P:System.IO.MemoryStream.Position" /&gt;</ph> property.</source>
          <target state="translated">Grava o conteúdo de fluxo em uma matriz de bytes, independentemente da propriedade <ph id="ph1">&lt;see cref="P:System.IO.MemoryStream.Position" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.ToArray">
          <source>A new byte array.</source>
          <target state="translated">Uma nova matriz de bytes.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.ToArray">
          <source>This method omits unused bytes in <ph id="ph1">&lt;xref:System.IO.MemoryStream&gt;</ph> from the array.</source>
          <target state="translated">Esse método omite bytes não utilizados no <ph id="ph1">&lt;xref:System.IO.MemoryStream&gt;</ph> da matriz.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.ToArray">
          <source>To get the entire buffer, use the <ph id="ph1">&lt;xref:System.IO.MemoryStream.GetBuffer%2A&gt;</ph> method.</source>
          <target state="translated">Para obter o buffer inteiro, use o <ph id="ph1">&lt;xref:System.IO.MemoryStream.GetBuffer%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.ToArray">
          <source>This method returns a copy of the contents of the <ph id="ph1">&lt;xref:System.IO.MemoryStream&gt;</ph> as a byte array.</source>
          <target state="translated">Esse método retorna uma cópia do conteúdo do <ph id="ph1">&lt;xref:System.IO.MemoryStream&gt;</ph> como uma matriz de bytes.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.ToArray">
          <source>If the current instance was constructed on a provided byte array, a copy of the section of the array to which this instance has access is returned.</source>
          <target state="translated">Se a instância atual foi construída em uma matriz de bytes fornecida, uma cópia da seção da matriz ao qual esta instância tem acesso será retornada.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.ToArray">
          <source>See the <ph id="ph1">&lt;xref:System.IO.MemoryStream.%23ctor%2A&gt;</ph> constructor for details.</source>
          <target state="translated">Consulte o <ph id="ph1">&lt;xref:System.IO.MemoryStream.%23ctor%2A&gt;</ph> construtor para obter detalhes.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.ToArray">
          <source>This method works when the <ph id="ph1">&lt;xref:System.IO.MemoryStream&gt;</ph> is closed.</source>
          <target state="translated">Esse método funciona quando o <ph id="ph1">&lt;xref:System.IO.MemoryStream&gt;</ph> está fechado.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.TryGetBuffer(System.ArraySegment{System.Byte}@)">
          <source>The byte array segment from which this stream was created.</source>
          <target state="translated">O segmento da matriz de bytes do qual este fluxo foi criado.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.TryGetBuffer(System.ArraySegment{System.Byte}@)">
          <source>Returns the array of unsigned bytes from which this stream was created.</source>
          <target state="translated">Retorna a matriz de bytes sem sinal com base na qual este fluxo foi criado.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.TryGetBuffer(System.ArraySegment{System.Byte}@)">
          <source>The return value indicates whether the conversion succeeded.</source>
          <target state="translated">O valor de retorno indica se a conversão foi bem-sucedida.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.TryGetBuffer(System.ArraySegment{System.Byte}@)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the conversion was successful; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se a conversão tiver sido bem-sucedida; caso contrário, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source>The buffer to write data from.</source>
          <target state="translated">O buffer do qual os dados serão gravados.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source>The zero-based byte offset in <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> at which to begin copying bytes to the current stream.</source>
          <target state="translated">O deslocamento de bytes baseado em zero no <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> no qual será iniciada a cópia de bytes para o fluxo atual.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source>The maximum number of bytes to write.</source>
          <target state="translated">O número máximo de bytes a serem gravados.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source>Writes a block of bytes to the current stream using data read from a buffer.</source>
          <target state="translated">Grava um bloco de bytes no fluxo atual usando os dados lidos de um buffer.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source>This method overrides <ph id="ph1">&lt;xref:System.IO.Stream.Write%2A&gt;</ph>.</source>
          <target state="translated">Este método substitui <ph id="ph1">&lt;xref:System.IO.Stream.Write%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source>The <ph id="ph1">`offset`</ph> parameter gives the offset of the first byte in <ph id="ph2">`buffer`</ph> to write from, and the <ph id="ph3">`count`</ph> parameter gives the number of bytes to write.</source>
          <target state="translated">O <ph id="ph1">`offset`</ph> parâmetro fornece o deslocamento do primeiro byte na <ph id="ph2">`buffer`</ph> para gravação e o <ph id="ph3">`count`</ph> parâmetro retorna o número de bytes a serem gravados.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source>If the write operation is successful, the current position within the stream is advanced by the number of bytes written.</source>
          <target state="translated">Se a operação de gravação for bem-sucedida, a posição atual dentro do fluxo for avançada pelo número de bytes gravados.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source>If an exception occurs, the current position within the stream is unchanged.</source>
          <target state="translated">Se ocorrer uma exceção, a posição atual dentro do fluxo está inalterada.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source>Except for a <ph id="ph1">`MemoryStream`</ph> constructed with a byte[] parameter, write operations at the end of a <ph id="ph2">`MemoryStream`</ph> expand the <ph id="ph3">`MemoryStream`</ph>.</source>
          <target state="translated">Exceto para uma <ph id="ph1">`MemoryStream`</ph> construído com um parâmetro de byte [], gravar operações no final de um <ph id="ph2">`MemoryStream`</ph> expandir o <ph id="ph3">`MemoryStream`</ph>.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.IO.MemoryStream&gt;</ph> class.</source>
          <target state="translated">Este exemplo de código é parte de um exemplo maior fornecido para a <ph id="ph1">&lt;xref:System.IO.MemoryStream&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source>The stream does not support writing.</source>
          <target state="translated">Não há suporte para gravação no fluxo.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source>For additional information see <ph id="ph1">&lt;see cref="P:System.IO.Stream.CanWrite" /&gt;</ph>.</source>
          <target state="translated">Para obter mais informações, consulte <ph id="ph1">&lt;see cref="P:System.IO.Stream.CanWrite" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source>The current position is closer than <ph id="ph1">&lt;paramref name="count" /&gt;</ph> bytes to the end of the stream, and the capacity cannot be modified.</source>
          <target state="translated">A posição atual está mais próxima do que bytes <ph id="ph1">&lt;paramref name="count" /&gt;</ph> até o final do fluxo, e a capacidade não pode ser modificada.</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> subtracted from the buffer length is less than <ph id="ph2">&lt;paramref name="count" /&gt;</ph>.</source>
          <target state="translated">O <ph id="ph1">&lt;paramref name="offset" /&gt;</ph> subtraído do tamanho do buffer é menor que <ph id="ph2">&lt;paramref name="count" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> or <ph id="ph2">&lt;paramref name="count" /&gt;</ph> are negative.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> ou <ph id="ph2">&lt;paramref name="count" /&gt;</ph> é negativo.</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source>An I/O error occurs.</source>
          <target state="translated">Ocorre um erro de E/S.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source>The current stream instance is closed.</source>
          <target state="translated">A instância atual do fluxo está fechada.</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The buffer to write data from.</source>
          <target state="translated">O buffer do qual os dados serão gravados.</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The zero-based byte offset in <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> from which to begin copying bytes to the stream.</source>
          <target state="translated">O deslocamento de bytes baseado em zero no <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> do qual será iniciada a cópia de bytes para o fluxo.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The maximum number of bytes to write.</source>
          <target state="translated">O número máximo de bytes a serem gravados.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The token to monitor for cancellation requests.</source>
          <target state="translated">O token a se monitorar para solicitações de cancelamento.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The default value is <ph id="ph1">&lt;see cref="P:System.Threading.CancellationToken.None" /&gt;</ph>.</source>
          <target state="translated">O valor padrão é <ph id="ph1">&lt;see cref="P:System.Threading.CancellationToken.None" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>Asynchronously writes a sequence of bytes to the current stream, advances the current position within this stream by the number of bytes written, and monitors cancellation requests.</source>
          <target state="translated">Grava uma sequência de bytes no fluxo atual assincronamente, avança a posição atual dentro desse fluxo pelo número de bytes gravados e monitora as solicitações de cancelamento.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>A task that represents the asynchronous write operation.</source>
          <target state="translated">Uma tarefa que representa a operação de gravação assíncrona.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>If the operation is canceled before it completes, the returned task contains the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph> value for the <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Status%2A&gt;</ph> property.</source>
          <target state="translated">Se a operação foi cancelada antes da conclusão, a tarefa retornada contém o <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph> valor para o <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Status%2A&gt;</ph> propriedade.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>You can create a cancellation token by creating an instance of the <ph id="ph1">&lt;xref:System.Threading.CancellationTokenSource&gt;</ph> class and passing the <ph id="ph2">&lt;xref:System.Threading.CancellationTokenSource.Token%2A&gt;</ph> property as the <ph id="ph3">`cancellationToken`</ph> parameter.</source>
          <target state="translated">Você pode criar um token de cancelamento, criando uma instância do <ph id="ph1">&lt;xref:System.Threading.CancellationTokenSource&gt;</ph> classe e passando o <ph id="ph2">&lt;xref:System.Threading.CancellationTokenSource.Token%2A&gt;</ph> a propriedade como o <ph id="ph3">`cancellationToken`</ph> parâmetro.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> or <ph id="ph2">&lt;paramref name="count" /&gt;</ph> is negative.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> ou <ph id="ph2">&lt;paramref name="count" /&gt;</ph> é negativo.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The sum of <ph id="ph1">&lt;paramref name="offset" /&gt;</ph> and <ph id="ph2">&lt;paramref name="count" /&gt;</ph> is larger than the buffer length.</source>
          <target state="translated">A soma de <ph id="ph1">&lt;paramref name="offset" /&gt;</ph> e <ph id="ph2">&lt;paramref name="count" /&gt;</ph> é maior que o tamanho do buffer.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The stream does not support writing.</source>
          <target state="translated">Não há suporte para gravação no fluxo.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The stream has been disposed.</source>
          <target state="translated">O fluxo foi descartado.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The stream is currently in use by a previous write operation.</source>
          <target state="translated">O fluxo está em uso no momento por uma operação de gravação anterior.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.WriteByte(System.Byte)">
          <source>The byte to write.</source>
          <target state="translated">O byte a ser gravado.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.WriteByte(System.Byte)">
          <source>Writes a byte to the current stream at the current position.</source>
          <target state="translated">Grava um byte no fluxo atual na posição atual.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.WriteByte(System.Byte)">
          <source>This method overrides <ph id="ph1">&lt;xref:System.IO.Stream.WriteByte%2A&gt;</ph>.</source>
          <target state="translated">Este método substitui <ph id="ph1">&lt;xref:System.IO.Stream.WriteByte%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.WriteByte(System.Byte)">
          <source>Except for a <ph id="ph1">`MemoryStream`</ph> constructed with a byte[] parameter, write operations at the end of a <ph id="ph2">`MemoryStream`</ph> expand the <ph id="ph3">`MemoryStream`</ph>.</source>
          <target state="translated">Exceto para uma <ph id="ph1">`MemoryStream`</ph> construído com um parâmetro de byte [], gravar operações no final de um <ph id="ph2">`MemoryStream`</ph> expandir o <ph id="ph3">`MemoryStream`</ph>.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.WriteByte(System.Byte)">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.IO.MemoryStream&gt;</ph> class.</source>
          <target state="translated">Este exemplo de código é parte de um exemplo maior fornecido para a <ph id="ph1">&lt;xref:System.IO.MemoryStream&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.WriteByte(System.Byte)">
          <source>The stream does not support writing.</source>
          <target state="translated">Não há suporte para gravação no fluxo.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.WriteByte(System.Byte)">
          <source>For additional information see <ph id="ph1">&lt;see cref="P:System.IO.Stream.CanWrite" /&gt;</ph>.</source>
          <target state="translated">Para obter mais informações, consulte <ph id="ph1">&lt;see cref="P:System.IO.Stream.CanWrite" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.WriteByte(System.Byte)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.WriteByte(System.Byte)">
          <source>The current position is at the end of the stream, and the capacity cannot be modified.</source>
          <target state="translated">A posição atual é no final do fluxo e a capacidade não pode ser modificada.</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.WriteByte(System.Byte)">
          <source>The current stream is closed.</source>
          <target state="translated">O fluxo atual está fechado.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.WriteTo(System.IO.Stream)">
          <source>The stream to write this memory stream to.</source>
          <target state="translated">O fluxo no qual este fluxo de memória será gravado.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.WriteTo(System.IO.Stream)">
          <source>Writes the entire contents of this memory stream to another stream.</source>
          <target state="translated">Grava todo o conteúdo deste fluxo de memória em outro fluxo.</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.WriteTo(System.IO.Stream)">
          <source>When the current stream is open, this method is equivalent to calling <ph id="ph1">&lt;xref:System.IO.Stream.Write%2A?displayProperty=nameWithType&gt;</ph> on the underlying buffer of this stream.</source>
          <target state="translated">Quando o fluxo atual está aberto, esse método é equivalente a chamar <ph id="ph1">&lt;xref:System.IO.Stream.Write%2A?displayProperty=nameWithType&gt;</ph> no buffer deste fluxo subjacente.</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.WriteTo(System.IO.Stream)">
          <source><ph id="ph1">&lt;paramref name="stream" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="stream" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.WriteTo(System.IO.Stream)">
          <source>The current or target stream is closed.</source>
          <target state="translated">O fluxo atual ou de destino está fechado.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>