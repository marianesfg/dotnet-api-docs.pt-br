<Type Name="Path" FullName="System.IO.Path">
  <Metadata><Meta Name="ms.openlocfilehash" Value="7d6e92442757fd51d003d6e8352e0318077814f8" /><Meta Name="ms.sourcegitcommit" Value="a3e01ec36374fac54a55add0dcc1e754e394abeb" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pt-BR" /><Meta Name="ms.lasthandoff" Value="03/30/2019" /><Meta Name="ms.locfileid" Value="58736122" /></Metadata><TypeSignature Language="C#" Value="public static class Path" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed Path extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.IO.Path" />
  <TypeSignature Language="VB.NET" Value="Public Class Path" />
  <TypeSignature Language="C++ CLI" Value="public ref class Path abstract sealed" />
  <TypeSignature Language="F#" Value="type Path = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="7729c-101">Executa operações em instâncias de <see cref="T:System.String" /> que contêm informações de caminho de arquivo ou diretório.</span><span class="sxs-lookup"><span data-stu-id="7729c-101">Performs operations on <see cref="T:System.String" /> instances that contain file or directory path information.</span></span> <span data-ttu-id="7729c-102">Essas operações são executadas de uma maneira em plataforma cruzada.</span><span class="sxs-lookup"><span data-stu-id="7729c-102">These operations are performed in a cross-platform manner.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
 <span data-ttu-id="7729c-103">Um caminho é uma cadeia de caracteres que fornece a localização de um arquivo ou diretório.</span><span class="sxs-lookup"><span data-stu-id="7729c-103">A path is a string that provides the location of a file or directory.</span></span> <span data-ttu-id="7729c-104">Um caminho não necessariamente aponta para um local no disco; Por exemplo, um caminho pode mapear para um local na memória ou em um dispositivo.</span><span class="sxs-lookup"><span data-stu-id="7729c-104">A path does not necessarily point to a location on disk; for example, a path might map to a location in memory or on a device.</span></span> <span data-ttu-id="7729c-105">O formato exato de um caminho é determinado pela plataforma atual.</span><span class="sxs-lookup"><span data-stu-id="7729c-105">The exact format of a path is determined by the current platform.</span></span> <span data-ttu-id="7729c-106">Por exemplo, em alguns sistemas, um caminho pode iniciar com uma letra de unidade ou volume, enquanto esse elemento não estiver presente em outros sistemas.</span><span class="sxs-lookup"><span data-stu-id="7729c-106">For example, on some systems, a path can start with a drive or volume letter, while this element is not present in other systems.</span></span> <span data-ttu-id="7729c-107">Em alguns sistemas, caminhos de arquivo podem conter extensões, que indicam o tipo de informações armazenadas no arquivo.</span><span class="sxs-lookup"><span data-stu-id="7729c-107">On some systems, file paths can contain extensions, which indicate the type of information stored in the file.</span></span> <span data-ttu-id="7729c-108">O formato de uma extensão de nome de arquivo é dependente de plataforma; Por exemplo, alguns sistemas de limitam as extensões para três caracteres e outros não.</span><span class="sxs-lookup"><span data-stu-id="7729c-108">The format of a file name extension is platform-dependent; for example, some systems limit extensions to three characters, and others do not.</span></span> <span data-ttu-id="7729c-109">A plataforma atual também determina o conjunto de caracteres usado para separar os elementos de um caminho e o conjunto de caracteres que não pode ser usado ao especificar caminhos.</span><span class="sxs-lookup"><span data-stu-id="7729c-109">The current platform also determines the set of characters used to separate the elements of a path, and the set of characters that cannot be used when specifying paths.</span></span> <span data-ttu-id="7729c-110">Por causa dessas diferenças, os campos do `Path` , bem como o comportamento exato do alguns membros de classe a `Path` classe dependem da plataforma.</span><span class="sxs-lookup"><span data-stu-id="7729c-110">Because of these differences, the fields of the `Path` class as well as the exact behavior of some members of the `Path` class are platform-dependent.</span></span>  
  
 <span data-ttu-id="7729c-111">Um caminho pode conter informações de local absoluto ou relativo.</span><span class="sxs-lookup"><span data-stu-id="7729c-111">A path can contain absolute or relative location information.</span></span> <span data-ttu-id="7729c-112">Caminhos absolutos totalmente especificam um local: o arquivo ou diretório pode ser identificado exclusivamente, independentemente do local atual.</span><span class="sxs-lookup"><span data-stu-id="7729c-112">Absolute paths fully specify a location: the file or directory can be uniquely identified regardless of the current location.</span></span> <span data-ttu-id="7729c-113">Caminhos relativos especificam uma localização parcial: o local atual é usado como o ponto de partida ao localizar um arquivo especificado com um caminho relativo.</span><span class="sxs-lookup"><span data-stu-id="7729c-113">Relative paths specify a partial location: the current location is used as the starting point when locating a file specified with a relative path.</span></span> <span data-ttu-id="7729c-114">Para determinar o diretório atual, chame <xref:System.IO.Directory.GetCurrentDirectory%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="7729c-114">To determine the current directory, call <xref:System.IO.Directory.GetCurrentDirectory%2A?displayProperty=nameWithType>.</span></span>  

 <span data-ttu-id="7729c-115">.NET core 1.1 e versões posteriores e .NET Framework 4.6.2 e versões posteriores também dão suporte a acesso a objetos de sistema de arquivos que são nomes de dispositivo, como "\\? \C:\".</span><span class="sxs-lookup"><span data-stu-id="7729c-115">.NET Core 1.1 and later versions and .NET Framework 4.6.2 and later versions also support access to file system objects that are device names, such as "\\?\C:\".</span></span>

<span data-ttu-id="7729c-116">Para obter mais informações sobre formatos de caminho de arquivo no Windows, consulte [formatos de caminho de arquivo nos sistemas Windows](~/docs/standard/io/file-path-formats.md).</span><span class="sxs-lookup"><span data-stu-id="7729c-116">For more information on file path formats on Windows, see [File path formats on Windows systems](~/docs/standard/io/file-path-formats.md).</span></span>

 <span data-ttu-id="7729c-117">A maioria dos membros do `Path` não interagem com o sistema de arquivos de classe e não verificar a existência do arquivo especificado por uma cadeia de caracteres de caminho.</span><span class="sxs-lookup"><span data-stu-id="7729c-117">Most members of the `Path` class do not interact with the file system and do not verify the existence of the file specified by a path string.</span></span> <span data-ttu-id="7729c-118">`Path` que modificar uma cadeia de caracteres de caminho, como membros de classe <xref:System.IO.Path.ChangeExtension%2A>, não têm nenhum efeito nos nomes dos arquivos no sistema de arquivos.</span><span class="sxs-lookup"><span data-stu-id="7729c-118">`Path` class members that modify a path string, such as <xref:System.IO.Path.ChangeExtension%2A>, have no effect on names of files in the file system.</span></span> <span data-ttu-id="7729c-119">`Path` membros, no entanto, validar o conteúdo de uma cadeia de caracteres do caminho especificado e lançar uma <xref:System.ArgumentException> exceção se a cadeia de caracteres contém caracteres que não são válidos em cadeias de caracteres de caminho, conforme definido nos caracteres retornados do <xref:System.IO.Path.GetInvalidPathChars%2A> método.</span><span class="sxs-lookup"><span data-stu-id="7729c-119">`Path` members do, however, validate the contents of a specified path string, and throw an <xref:System.ArgumentException> exception if the string contains characters that are not valid in path strings, as defined in the characters returned from the <xref:System.IO.Path.GetInvalidPathChars%2A> method.</span></span> <span data-ttu-id="7729c-120">Por exemplo, em plataformas de área de trabalho baseado em Windows, caracteres de caminho inválidos podem incluir aspas ("), menor que (\<), maior que (>), pipe (&#124;), backspace (\b), nulo (\0) e caracteres de Unicode 16 a 18 e 20 a 25.</span><span class="sxs-lookup"><span data-stu-id="7729c-120">For example, on Windows-based desktop platforms, invalid path characters might include quote ("), less than (\<), greater than (>), pipe (&#124;), backspace (\b), null (\0), and Unicode characters 16 through 18 and 20 through 25.</span></span>  
  
 <span data-ttu-id="7729c-121">Os membros do `Path` classe que você possa facilmente executar operações comuns, como determinar se uma extensão de nome de arquivo é parte de um caminho e combinando duas cadeias de caracteres em nome de um caminho.</span><span class="sxs-lookup"><span data-stu-id="7729c-121">The members of the `Path` class enable you to quickly and easily perform common operations such as determining whether a file name extension is part of a path, and combining two strings into one path name.</span></span>  
  
 <span data-ttu-id="7729c-122">Todos os membros de `Path` classe são estático e, portanto, pode ser chamado sem a necessidade de uma instância de um caminho.</span><span class="sxs-lookup"><span data-stu-id="7729c-122">All members of the `Path` class are static and can therefore be called without having an instance of a path.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="7729c-123">Em membros que aceitam um caminho como uma cadeia de caracteres de entrada, esse caminho deve ser bem formado ou uma exceção será gerada.</span><span class="sxs-lookup"><span data-stu-id="7729c-123">In members that accept a path as an input string, that path must be well-formed or an exception is raised.</span></span> <span data-ttu-id="7729c-124">Por exemplo, se um caminho totalmente qualificado, mas começa com um espaço, o caminho não foi cortado em métodos da classe.</span><span class="sxs-lookup"><span data-stu-id="7729c-124">For example, if a path is fully qualified but begins with a space, the path is not trimmed in methods of the class.</span></span> <span data-ttu-id="7729c-125">Portanto, o caminho está malformado e uma exceção será gerada.</span><span class="sxs-lookup"><span data-stu-id="7729c-125">Therefore, the path is malformed and an exception is raised.</span></span> <span data-ttu-id="7729c-126">Da mesma forma, um caminho ou uma combinação de caminhos não pode ser totalmente qualificada duas vezes.</span><span class="sxs-lookup"><span data-stu-id="7729c-126">Similarly, a path or a combination of paths cannot be fully qualified twice.</span></span> <span data-ttu-id="7729c-127">Por exemplo, "c:\windows c:\temp" também gerará uma exceção na maioria dos casos.</span><span class="sxs-lookup"><span data-stu-id="7729c-127">For example, "c:\temp c:\windows" also raises an exception in most cases.</span></span> <span data-ttu-id="7729c-128">Certifique-se de que seus caminhos são bem formados, ao usar os métodos que aceitam uma cadeia de caracteres de caminho.</span><span class="sxs-lookup"><span data-stu-id="7729c-128">Ensure that your paths are well-formed when using methods that accept a path string.</span></span>  
  
 <span data-ttu-id="7729c-129">Em membros que aceitam um caminho, o caminho pode consultar um arquivo ou apenas um diretório.</span><span class="sxs-lookup"><span data-stu-id="7729c-129">In members that accept a path, the path can refer to a file or just a directory.</span></span> <span data-ttu-id="7729c-130">O caminho especificado também pode se referir a um caminho relativo ou um caminho de convenção de nomenclatura Universal (UNC) para um nome de servidor e compartilhamento.</span><span class="sxs-lookup"><span data-stu-id="7729c-130">The specified path can also refer to a relative path or a Universal Naming Convention (UNC) path for a server and share name.</span></span> <span data-ttu-id="7729c-131">Por exemplo, todos os itens a seguir é caminhos aceitáveis:</span><span class="sxs-lookup"><span data-stu-id="7729c-131">For example, all the following are acceptable paths:</span></span>  
  
-   <span data-ttu-id="7729c-132">"c:\\\MyDir\\\MyFile.txt" em c# ou "c:\MyDir\MyFile.txt" no Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="7729c-132">"c:\\\MyDir\\\MyFile.txt" in C#, or "c:\MyDir\MyFile.txt" in Visual Basic.</span></span>  
  
-   <span data-ttu-id="7729c-133">"c:\\\MyDir" em c# ou "c:\MyDir" no Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="7729c-133">"c:\\\MyDir" in C#, or "c:\MyDir" in Visual Basic.</span></span>  
  
-   <span data-ttu-id="7729c-134">"MyDir\\\MySubdir" em c# ou "MyDir\MySubDir" no Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="7729c-134">"MyDir\\\MySubdir" in C#, or "MyDir\MySubDir" in Visual Basic.</span></span>  
  
-   <span data-ttu-id="7729c-135">"\\\\\\\MyServer\\\MyShare" no c#, ou "\\\MyServer\MyShare" no Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="7729c-135">"\\\\\\\MyServer\\\MyShare" in C#, or "\\\MyServer\MyShare" in Visual Basic.</span></span>  
  
 <span data-ttu-id="7729c-136">Como todas essas operações são executadas em cadeias de caracteres, é impossível de verificar se os resultados são válidos em todos os cenários.</span><span class="sxs-lookup"><span data-stu-id="7729c-136">Because all these operations are performed on strings, it is impossible to verify that the results are valid in all scenarios.</span></span> <span data-ttu-id="7729c-137">Por exemplo, o <xref:System.IO.Path.GetExtension%2A> método analisa uma cadeia de caracteres que você passa para ele e retorna a extensão da cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="7729c-137">For example, the <xref:System.IO.Path.GetExtension%2A> method parses a string that you pass to it and returns the extension from that string.</span></span> <span data-ttu-id="7729c-138">No entanto, isso não significa que um arquivo com a extensão existe no disco.</span><span class="sxs-lookup"><span data-stu-id="7729c-138">However, this does not mean that a file with that extension exists on the disk.</span></span>  
  
 <span data-ttu-id="7729c-139">Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).</span><span class="sxs-lookup"><span data-stu-id="7729c-139">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>   
  
## Examples  
 <span data-ttu-id="7729c-140">O exemplo a seguir demonstra alguns dos principais membros o `Path` classe.</span><span class="sxs-lookup"><span data-stu-id="7729c-140">The following example demonstrates some of the main members of the `Path` class.</span></span>  
  
 [!code-cpp[path class#1](~/samples/snippets/cpp/VS_Snippets_CLR/Path Class/CPP/path class.cpp#1)]
 [!code-csharp[path class#1](~/samples/snippets/csharp/VS_Snippets_CLR/Path Class/CS/path class.cs#1)]
 [!code-vb[path class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Path Class/VB/path class.vb#1)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="7729c-141">E/S de arquivo e de fluxo</span><span class="sxs-lookup"><span data-stu-id="7729c-141">File and Stream I/O</span></span></related>
    <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="7729c-142">Como ler texto de um arquivo</span><span class="sxs-lookup"><span data-stu-id="7729c-142">How to: Read Text from a File</span></span></related>
    <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="7729c-143">Como gravar texto em um arquivo</span><span class="sxs-lookup"><span data-stu-id="7729c-143">How to: Write Text to a File</span></span></related>
    <related type="Article" href="~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md"><span data-ttu-id="7729c-144">Como ler e gravar em um arquivo de dados recém-criado</span><span class="sxs-lookup"><span data-stu-id="7729c-144">How to: Read and Write to a Newly Created Data File</span></span></related>
    <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="7729c-145">Formatos de caminho de arquivo em sistemas Windows</span><span class="sxs-lookup"><span data-stu-id="7729c-145">File path formats on Windows systems</span></span></related>
  </Docs>
  <Members>
    <Member MemberName="AltDirectorySeparatorChar">
      <MemberSignature Language="C#" Value="public static readonly char AltDirectorySeparatorChar;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char AltDirectorySeparatorChar" />
      <MemberSignature Language="DocId" Value="F:System.IO.Path.AltDirectorySeparatorChar" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly AltDirectorySeparatorChar As Char " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly char AltDirectorySeparatorChar;" />
      <MemberSignature Language="F#" Value=" staticval mutable AltDirectorySeparatorChar : char" Usage="System.IO.Path.AltDirectorySeparatorChar" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="7729c-146">Fornece um caractere alternativo específico da plataforma usado para separar os níveis de diretório em uma cadeia de caracteres de caminho que reflete uma organização do sistema de arquivos hierárquico.</span><span class="sxs-lookup"><span data-stu-id="7729c-146">Provides a platform-specific alternate character used to separate directory levels in a path string that reflects a hierarchical file system organization.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 
<span data-ttu-id="7729c-147">Esse campo pode ter o mesmo valor que <xref:System.IO.Path.DirectorySeparatorChar>.</span><span class="sxs-lookup"><span data-stu-id="7729c-147">This field can have the same value as <xref:System.IO.Path.DirectorySeparatorChar>.</span></span> <span data-ttu-id="7729c-148">`AltDirectorySeparatorChar` e <xref:System.IO.Path.DirectorySeparatorChar> são ambos válidos para separar os níveis em uma cadeia de caracteres do caminho do diretório.</span><span class="sxs-lookup"><span data-stu-id="7729c-148">`AltDirectorySeparatorChar` and <xref:System.IO.Path.DirectorySeparatorChar> are both valid for separating directory levels in a path string.</span></span>  
  
<span data-ttu-id="7729c-149">O valor desse campo é uma barra ('/') no Windows e sistemas operacionais baseados em Unix.</span><span class="sxs-lookup"><span data-stu-id="7729c-149">The value of this field is a slash ('/') on both Windows and Unix-based operating systems.</span></span>  
  
## Examples  

<span data-ttu-id="7729c-150">O exemplo a seguir exibe <xref:System.IO.Path> no Windows e em sistemas baseados em Unix de valores de campo.</span><span class="sxs-lookup"><span data-stu-id="7729c-150">The following example displays <xref:System.IO.Path> field values on Windows and on Unix-based systems.</span></span> <span data-ttu-id="7729c-151">Observe que o Windows oferece suporte a barra invertida (que é retornada pela <xref:System.IO.Path.AltDirectorySeparatorChar> campo) ou a barra invertida (que é retornado pelo <xref:System.IO.Path.DirectorySeparatorChar> campo) como caracteres de separador de caminho, enquanto os sistemas baseados em Unix oferece suporte somente a barra.</span><span class="sxs-lookup"><span data-stu-id="7729c-151">Note that Windows supports either the forward slash (which is returned by the <xref:System.IO.Path.AltDirectorySeparatorChar> field) or the backslash (which is returned by the <xref:System.IO.Path.DirectorySeparatorChar> field) as path separator characters, while Unix-based systems support only the forward slash.</span></span>

[!code-csharp[DirectorySeparatorChar](~/samples/snippets/csharp/api/system.io/path/directoryseparatorchar/program.cs)]
[!code-vb[DirectorySeparatorChar](~/samples/snippets/visualbasic/api/system.io/path/directoryseparatorchar/program.vb)]
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="7729c-152">E/S de arquivo e de fluxo</span><span class="sxs-lookup"><span data-stu-id="7729c-152">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="7729c-153">Como ler texto de um arquivo</span><span class="sxs-lookup"><span data-stu-id="7729c-153">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="7729c-154">Como gravar texto em um arquivo</span><span class="sxs-lookup"><span data-stu-id="7729c-154">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ChangeExtension">
      <MemberSignature Language="C#" Value="public static string ChangeExtension (string path, string extension);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ChangeExtension(string path, string extension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.ChangeExtension(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ChangeExtension (path As String, extension As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ ChangeExtension(System::String ^ path, System::String ^ extension);" />
      <MemberSignature Language="F#" Value="static member ChangeExtension : string * string -&gt; string" Usage="System.IO.Path.ChangeExtension (path, extension)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="extension" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="7729c-155">As informações de caminho a serem modificadas.</span><span class="sxs-lookup"><span data-stu-id="7729c-155">The path information to modify.</span></span> <span data-ttu-id="7729c-156">O caminho não pode conter nenhum dos caracteres definidos em <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span><span class="sxs-lookup"><span data-stu-id="7729c-156">The path cannot contain any of the characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></param>
        <param name="extension"><span data-ttu-id="7729c-157">A nova extensão (com ou sem um ponto à esquerda).</span><span class="sxs-lookup"><span data-stu-id="7729c-157">The new extension (with or without a leading period).</span></span> <span data-ttu-id="7729c-158">Especifique <see langword="null" /> para remover uma extensão do <paramref name="path" />.</span><span class="sxs-lookup"><span data-stu-id="7729c-158">Specify <see langword="null" /> to remove an existing extension from <paramref name="path" />.</span></span></param>
        <summary><span data-ttu-id="7729c-159">Altera a extensão de uma cadeia de caracteres do caminho.</span><span class="sxs-lookup"><span data-stu-id="7729c-159">Changes the extension of a path string.</span></span></summary>
        <returns><span data-ttu-id="7729c-160">As informações de caminho modificadas.</span><span class="sxs-lookup"><span data-stu-id="7729c-160">The modified path information.</span></span>  
  
<span data-ttu-id="7729c-161">Em plataformas de área de trabalho baseadas no Windows, se <paramref name="path" /> for <see langword="null" /> ou uma cadeia de caracteres vazia (""), as informações de caminho serão retornadas sem modificações.</span><span class="sxs-lookup"><span data-stu-id="7729c-161">On Windows-based desktop platforms, if <paramref name="path" /> is <see langword="null" /> or an empty string (""), the path information is returned unmodified.</span></span> <span data-ttu-id="7729c-162">Se <paramref name="extension" /> for <see langword="null" />, a cadeia de caracteres retornada conterá o caminho especificado com sua extensão removida.</span><span class="sxs-lookup"><span data-stu-id="7729c-162">If <paramref name="extension" /> is <see langword="null" />, the returned string contains the specified path with its extension removed.</span></span> <span data-ttu-id="7729c-163">Se o <paramref name="path" /> não tiver uma extensão e <paramref name="extension" /> não for <see langword="null" />, a cadeia de caracteres de caminho retornada conterá <paramref name="extension" /> acrescentado ao final de <paramref name="path" />.</span><span class="sxs-lookup"><span data-stu-id="7729c-163">If <paramref name="path" /> has no extension, and <paramref name="extension" /> is not <see langword="null" />, the returned path string contains <paramref name="extension" /> appended to the end of <paramref name="path" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7729c-164">Se nem `path` nem `extension` contém um ponto (.), `ChangeExtension` adiciona o período.</span><span class="sxs-lookup"><span data-stu-id="7729c-164">If neither `path` nor `extension` contains a period (.), `ChangeExtension` adds the period.</span></span>  
  
 <span data-ttu-id="7729c-165">O `extension` parâmetro pode conter vários períodos e quaisquer caracteres de caminho válido e pode ter qualquer comprimento.</span><span class="sxs-lookup"><span data-stu-id="7729c-165">The `extension` parameter can contain multiple periods and any valid path characters, and can be any length.</span></span> <span data-ttu-id="7729c-166">Se `extension` está `null`, a cadeia de caracteres retornada conterá o conteúdo do `path` com o último período e todos os caracteres seguintes removido.</span><span class="sxs-lookup"><span data-stu-id="7729c-166">If `extension` is `null`, the returned string contains the contents of `path` with the last period and all characters following it removed.</span></span>  
  
 <span data-ttu-id="7729c-167">Se `extension` é uma cadeia de caracteres vazia, a cadeia de caracteres de caminho retornada conterá o conteúdo do `path` com todos os caracteres depois do último ponto removido.</span><span class="sxs-lookup"><span data-stu-id="7729c-167">If `extension` is an empty string, the returned path string contains the contents of `path` with any characters following the last period removed.</span></span>  
  
 <span data-ttu-id="7729c-168">Se `path` não tem uma extensão e `extension` não está `null`, a cadeia de caracteres retornada contém `path` seguido por `extension`.</span><span class="sxs-lookup"><span data-stu-id="7729c-168">If `path` does not have an extension and `extension` is not `null`, the returned string contains `path` followed by `extension`.</span></span>  
  
 <span data-ttu-id="7729c-169">Se `extension` não é `null` e não contém um ponto à esquerda, o período é adicionado.</span><span class="sxs-lookup"><span data-stu-id="7729c-169">If `extension` is not `null` and does not contain a leading period, the period is added.</span></span>  
  
 <span data-ttu-id="7729c-170">Se `path` contém várias extensões separadas por vários períodos, a cadeia de caracteres retornada conterá o conteúdo do `path` com o último período e todos os caracteres seguintes substituído por `extension`.</span><span class="sxs-lookup"><span data-stu-id="7729c-170">If `path` contains a multiple extension separated by multiple periods, the returned string contains the contents of `path` with the last period and all characters following it replaced by `extension`.</span></span> <span data-ttu-id="7729c-171">Por exemplo, se `path` é "\Dir1\examples\pathtests.csx.txt" e `extension` é "cs", o caminho modificado é "\Dir1\examples\pathtests.csx.cs".</span><span class="sxs-lookup"><span data-stu-id="7729c-171">For example, if `path` is "\Dir1\examples\pathtests.csx.txt" and `extension` is "cs", the modified path is "\Dir1\examples\pathtests.csx.cs".</span></span>  
  
 <span data-ttu-id="7729c-172">Não é possível verificar se os resultados retornados são válidos em todos os cenários.</span><span class="sxs-lookup"><span data-stu-id="7729c-172">It is not possible to verify that the returned results are valid in all scenarios.</span></span> <span data-ttu-id="7729c-173">Por exemplo, se `path` estiver vazio, `extension` é acrescentado.</span><span class="sxs-lookup"><span data-stu-id="7729c-173">For example, if `path` is empty, `extension` is appended.</span></span>  
  
 <span data-ttu-id="7729c-174">Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).</span><span class="sxs-lookup"><span data-stu-id="7729c-174">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7729c-175">O exemplo a seguir demonstra um uso do `ChangeExtension` método.</span><span class="sxs-lookup"><span data-stu-id="7729c-175">The following example demonstrates a use of the `ChangeExtension` method.</span></span>  
  
 [!code-cpp[System.IO.Path Members#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#1)]
 [!code-csharp[System.IO.Path Members#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#1)]
 [!code-vb[System.IO.Path Members#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="7729c-176"><paramref name="path" /> contém um ou mais caracteres inválidos definidos em <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span><span class="sxs-lookup"><span data-stu-id="7729c-176"><paramref name="path" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="7729c-177">Formatos de caminho de arquivo em sistemas Windows</span><span class="sxs-lookup"><span data-stu-id="7729c-177">File path formats on Windows systems</span></span></related>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="7729c-178">E/S de arquivo e de fluxo</span><span class="sxs-lookup"><span data-stu-id="7729c-178">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="7729c-179">Como ler texto de um arquivo</span><span class="sxs-lookup"><span data-stu-id="7729c-179">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="7729c-180">Como gravar texto em um arquivo</span><span class="sxs-lookup"><span data-stu-id="7729c-180">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Combine">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="7729c-181">Combina as cadeias de caracteres em um caminho.</span><span class="sxs-lookup"><span data-stu-id="7729c-181">Combines strings into a path.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
 
## Remarks  

<span data-ttu-id="7729c-182">Este método destina-se para concatenar cadeias de caracteres individuais em uma única cadeia de caracteres que representa um caminho de arquivo.</span><span class="sxs-lookup"><span data-stu-id="7729c-182">This method is intended to concatenate individual strings into a single string that represents a file path.</span></span> <span data-ttu-id="7729c-183">No entanto, se um argumento que não seja o primeiro contém um caminho com raiz, quaisquer componentes de caminho anteriores são ignorados e a cadeia de caracteres retornada começa com esse componente de caminho com raiz.</span><span class="sxs-lookup"><span data-stu-id="7729c-183">However, if an argument other than the first contains a rooted path, any previous path components are ignored, and the returned string begins with that rooted path component.</span></span> <span data-ttu-id="7729c-184">Como uma alternativa para o `Combine` método, considere usar o <xref:System.IO.Path.Join%2A> ou <xref:System.IO.Path.TryJoin%2A> métodos.</span><span class="sxs-lookup"><span data-stu-id="7729c-184">As an alternative to the `Combine` method, consider using the <xref:System.IO.Path.Join%2A> or <xref:System.IO.Path.TryJoin%2A> methods.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="7729c-185">Este método presume que o primeiro argumento é um caminho absoluto e que o argumento ou argumentos a seguir são caminhos relativos.</span><span class="sxs-lookup"><span data-stu-id="7729c-185">This method assumes that the first argument is an absolute path and that the following argument or arguments are relative paths.</span></span> <span data-ttu-id="7729c-186">Se isso não for o caso, e especialmente se os argumentos subsequentes são cadeias de caracteres inseridas pelo usuário, chame o <xref:System.IO.Path.Join%2A> ou <xref:System.IO.Path.TryJoin%2A> método em vez disso.</span><span class="sxs-lookup"><span data-stu-id="7729c-186">If this is not the case, and particularly if any subsequent arguments are strings input by the user, call the <xref:System.IO.Path.Join%2A> or <xref:System.IO.Path.TryJoin%2A> method instead.</span></span>

 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static string Combine (params string[] paths);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Combine(string[] paths) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Combine(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (ParamArray paths As String()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Combine(... cli::array &lt;System::String ^&gt; ^ paths);" />
      <MemberSignature Language="F#" Value="static member Combine : string[] -&gt; string" Usage="System.IO.Path.Combine paths" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="paths" Type="System.String[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="paths"><span data-ttu-id="7729c-187">Uma matriz de partes do caminho.</span><span class="sxs-lookup"><span data-stu-id="7729c-187">An array of parts of the path.</span></span></param>
        <summary><span data-ttu-id="7729c-188">Combina uma matriz de cadeias de caracteres em um caminho.</span><span class="sxs-lookup"><span data-stu-id="7729c-188">Combines an array of strings into a path.</span></span></summary>
        <returns><span data-ttu-id="7729c-189">Os caminhos combinados.</span><span class="sxs-lookup"><span data-stu-id="7729c-189">The combined paths.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

<span data-ttu-id="7729c-190">`paths` deve ser uma matriz das partes do caminho para combinar.</span><span class="sxs-lookup"><span data-stu-id="7729c-190">`paths` should be an array of the parts of the path to combine.</span></span> <span data-ttu-id="7729c-191">Se um dos caminhos subsequentes é um caminho absoluto, a operação de combinar redefine a partir desse caminho absoluto, descartando todos os caminhos combinados anteriores.</span><span class="sxs-lookup"><span data-stu-id="7729c-191">If the one of the subsequent paths is an absolute path, then the combine operation resets starting with that absolute path, discarding all previous combined paths.</span></span>  

<span data-ttu-id="7729c-192">Se qualquer elemento em `paths` , mas o último deles não é uma unidade e não termina com um a <xref:System.IO.Path.DirectorySeparatorChar> ou o <xref:System.IO.Path.AltDirectorySeparatorChar> caractere, o `Combine` método adiciona um <xref:System.IO.Path.DirectorySeparatorChar> caractere entre esse elemento e a próxima.</span><span class="sxs-lookup"><span data-stu-id="7729c-192">If any element in `paths` but the last one is not a drive and does not end with either the <xref:System.IO.Path.DirectorySeparatorChar> or the <xref:System.IO.Path.AltDirectorySeparatorChar> character, the `Combine` method adds a <xref:System.IO.Path.DirectorySeparatorChar> character between that element and the next one.</span></span> <span data-ttu-id="7729c-193">Observe que, se o elemento termina em um caractere de separador de caminho que não é adequado para a plataforma de destino, o `Combine` método preserva o caractere separador de caminho original e acrescenta compatível.</span><span class="sxs-lookup"><span data-stu-id="7729c-193">Note that, if the element ends in a path separator character that is not appropriate for the target platform, the `Combine` method preserves the original path separator character and appends a supported one.</span></span> <span data-ttu-id="7729c-194">O exemplo a seguir compara o resultado em sistemas baseados em Unix e Windows quando a barra invertida é usada como um caractere de separador de caminho.</span><span class="sxs-lookup"><span data-stu-id="7729c-194">The following example compares the result on Windows and Unix-based systems when the backslash is used as a path separator character.</span></span>

[!code-csharp[Combine and path separator characters](~/samples/snippets/csharp/api/system.io/path/combine/program.cs#1)]
[!code-vb[Combine and path separator characters](~/samples/snippets/visualbasic/api/system.io/path/combine/program.vb#1)]  

 <span data-ttu-id="7729c-195">Cadeias de caracteres de comprimento zero são omitidas do caminho combinado.</span><span class="sxs-lookup"><span data-stu-id="7729c-195">Zero-length strings are omitted from the combined path.</span></span>  
  
 <span data-ttu-id="7729c-196">Os parâmetros não são analisados, se eles têm espaço em branco.</span><span class="sxs-lookup"><span data-stu-id="7729c-196">The parameters are not parsed if they have white space.</span></span>  
  
 <span data-ttu-id="7729c-197">Nem todos os caracteres inválidos para nomes de arquivo e diretório são interpretados como inaceitáveis pelo `Combine` método, porque você pode usar esses caracteres para caracteres curinga de pesquisa.</span><span class="sxs-lookup"><span data-stu-id="7729c-197">Not all invalid characters for directory and file names are interpreted as unacceptable by the `Combine` method, because you can use these characters for search wildcard characters.</span></span> <span data-ttu-id="7729c-198">Por exemplo, embora `Path.Combine("c:\\", "*.txt")` pode ser inválida se você fosse criar um arquivo a partir dele, ele é válido como uma cadeia de caracteres de pesquisa.</span><span class="sxs-lookup"><span data-stu-id="7729c-198">For example, while `Path.Combine("c:\\", "*.txt")` might be invalid if you were to create a file from it, it is valid as a search string.</span></span> <span data-ttu-id="7729c-199">Portanto é interpretado com êxito pelo `Combine` método.</span><span class="sxs-lookup"><span data-stu-id="7729c-199">It is therefore successfully interpreted by the `Combine` method.</span></span>  
  
## Examples  
 <span data-ttu-id="7729c-200">O exemplo a seguir combina uma matriz de cadeias de caracteres em um caminho.</span><span class="sxs-lookup"><span data-stu-id="7729c-200">The following example combines an array of strings into a path.</span></span>  
  
 [!code-csharp[System.IO.Path.Combine#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.path.combine/cs/program.cs#3)]
 [!code-vb[System.IO.Path.Combine#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.path.combine/vb/program.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="7729c-201">Uma das cadeias de caracteres na matriz contém um ou mais caracteres inválidos definidos em <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span><span class="sxs-lookup"><span data-stu-id="7729c-201">One of the strings in the array contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7729c-202">Uma das cadeias de caracteres na matriz é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="7729c-202">One of the strings in the array is <see langword="null" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="7729c-203">Formatos de caminho de arquivo em sistemas Windows</span><span class="sxs-lookup"><span data-stu-id="7729c-203">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static string Combine (string path1, string path2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Combine(string path1, string path2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Combine(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (path1 As String, path2 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Combine(System::String ^ path1, System::String ^ path2);" />
      <MemberSignature Language="F#" Value="static member Combine : string * string -&gt; string" Usage="System.IO.Path.Combine (path1, path2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="path2" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path1"><span data-ttu-id="7729c-204">O primeiro caminho a ser combinado.</span><span class="sxs-lookup"><span data-stu-id="7729c-204">The first path to combine.</span></span></param>
        <param name="path2"><span data-ttu-id="7729c-205">O segundo caminho a ser combinado.</span><span class="sxs-lookup"><span data-stu-id="7729c-205">The second path to combine.</span></span></param>
        <summary><span data-ttu-id="7729c-206">Combina duas cadeias de caracteres em um caminho.</span><span class="sxs-lookup"><span data-stu-id="7729c-206">Combines two strings into a path.</span></span></summary>
        <returns><span data-ttu-id="7729c-207">Os caminhos combinados.</span><span class="sxs-lookup"><span data-stu-id="7729c-207">The combined paths.</span></span> <span data-ttu-id="7729c-208">Se um dos caminhos especificados for uma cadeia de comprimento zero, esse método retornará o outro caminho.</span><span class="sxs-lookup"><span data-stu-id="7729c-208">If one of the specified paths is a zero-length string, this method returns the other path.</span></span> <span data-ttu-id="7729c-209">Se <paramref name="path2" /> contiver um caminho absoluto, esse método retornará <paramref name="path2" />.</span><span class="sxs-lookup"><span data-stu-id="7729c-209">If <paramref name="path2" /> contains an absolute path, this method returns <paramref name="path2" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7729c-210">Se `path1` não é uma referência de unidade (ou seja, "C:" ou "D:") e não termina com um caractere separador válido conforme definido na <xref:System.IO.Path.DirectorySeparatorChar>, <xref:System.IO.Path.AltDirectorySeparatorChar>, ou <xref:System.IO.Path.VolumeSeparatorChar>, <xref:System.IO.Path.DirectorySeparatorChar> é acrescentado ao `path1` antes da concatenação.</span><span class="sxs-lookup"><span data-stu-id="7729c-210">If `path1` is not a drive reference (that is, "C:" or "D:") and does not end with a valid separator character as defined in <xref:System.IO.Path.DirectorySeparatorChar>, <xref:System.IO.Path.AltDirectorySeparatorChar>, or <xref:System.IO.Path.VolumeSeparatorChar>, <xref:System.IO.Path.DirectorySeparatorChar> is appended to `path1` before concatenation.</span></span> <span data-ttu-id="7729c-211">Observe que, se `path1` termina em um caractere de separador de caminho que não é adequado para a plataforma de destino, o `Combine` método preserva o caractere separador de caminho original e acrescenta compatível.</span><span class="sxs-lookup"><span data-stu-id="7729c-211">Note that if `path1` ends in a path separator character that is not appropriate for the target platform, the `Combine` method preserves the original path separator character and appends a supported one.</span></span> <span data-ttu-id="7729c-212">O exemplo a seguir compara o resultado em sistemas baseados em Unix e Windows quando a barra invertida é usada como um caractere de separador de caminho.</span><span class="sxs-lookup"><span data-stu-id="7729c-212">The following example compares the result on Windows and Unix-based systems when the backslash is used as a path separator character.</span></span>  
  
[!code-csharp[Combine and path separator characters](~/samples/snippets/csharp/api/system.io/path/combine/program.cs#2)]
[!code-vb[Combine and path separator characters](~/samples/snippets/visualbasic/api/system.io/path/combine/program.vb#2)]  

 <span data-ttu-id="7729c-213">Se `path2` não inclui uma raiz (por exemplo, se `path2` não começa com um caractere separador ou uma especificação de unidade), o resultado é uma concatenação de dois caminhos, com um caractere separador de intermediários.</span><span class="sxs-lookup"><span data-stu-id="7729c-213">If `path2` does not include a root (for example, if `path2` does not start with a separator character or a drive specification), the result is a concatenation of the two paths, with an intervening separator character.</span></span> <span data-ttu-id="7729c-214">Se `path2` inclui uma raiz `path2` é retornado.</span><span class="sxs-lookup"><span data-stu-id="7729c-214">If `path2` includes a root, `path2` is returned.</span></span>  
  
 <span data-ttu-id="7729c-215">Os parâmetros não são analisados, se eles têm espaço em branco.</span><span class="sxs-lookup"><span data-stu-id="7729c-215">The parameters are not parsed if they have white space.</span></span> <span data-ttu-id="7729c-216">Portanto, se `path2` inclui o espaço em branco (por exemplo, "\file.txt"), o <xref:System.IO.Path.Combine%2A> método acrescenta `path2` à `path1` em vez de retornar apenas `path2`.</span><span class="sxs-lookup"><span data-stu-id="7729c-216">Therefore, if `path2` includes white space (for example, " \file.txt "), the <xref:System.IO.Path.Combine%2A> method appends `path2` to `path1` instead of returning only `path2`.</span></span>  
  
 <span data-ttu-id="7729c-217">Nem todos os caracteres inválidos para nomes de arquivo e diretório são interpretados como inaceitáveis pelo `Combine` método, porque você pode usar esses caracteres para caracteres curinga de pesquisa.</span><span class="sxs-lookup"><span data-stu-id="7729c-217">Not all invalid characters for directory and file names are interpreted as unacceptable by the `Combine` method, because you can use these characters for search wildcard characters.</span></span> <span data-ttu-id="7729c-218">Por exemplo, embora `Path.Combine("c:\\", "*.txt")` pode ser inválida se você fosse criar um arquivo a partir dele, ele é válido como uma cadeia de caracteres de pesquisa.</span><span class="sxs-lookup"><span data-stu-id="7729c-218">For example, while `Path.Combine("c:\\", "*.txt")` might be invalid if you were to create a file from it, it is valid as a search string.</span></span> <span data-ttu-id="7729c-219">Portanto é interpretado com êxito pelo `Combine` método.</span><span class="sxs-lookup"><span data-stu-id="7729c-219">It is therefore successfully interpreted by the `Combine` method.</span></span>  
  
 <span data-ttu-id="7729c-220">Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).</span><span class="sxs-lookup"><span data-stu-id="7729c-220">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7729c-221">O exemplo a seguir demonstra como usar o `Combine` método em uma plataforma de desktop baseada em Windows.</span><span class="sxs-lookup"><span data-stu-id="7729c-221">The following example demonstrates using the `Combine` method on a Windows-based desktop platform.</span></span>  
  
 [!code-cpp[pathcombine#1](~/samples/snippets/cpp/VS_Snippets_CLR/pathcombine/CPP/pathcombine.cpp#1)]
 [!code-csharp[pathcombine#1](~/samples/snippets/csharp/VS_Snippets_CLR/pathcombine/CS/pathcombine.cs#1)]
 [!code-vb[pathcombine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/pathcombine/VB/pathcombine.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="7729c-222"><paramref name="path1" /> ou <paramref name="path2" /> contém um ou mais caracteres inválidos definidos em <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span><span class="sxs-lookup"><span data-stu-id="7729c-222"><paramref name="path1" /> or <paramref name="path2" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7729c-223"><paramref name="path1" /> ou <paramref name="path2" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="7729c-223"><paramref name="path1" /> or <paramref name="path2" /> is <see langword="null" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="7729c-224">Formatos de caminho de arquivo em sistemas Windows</span><span class="sxs-lookup"><span data-stu-id="7729c-224">File path formats on Windows systems</span></span></related>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="7729c-225">E/S de arquivo e de fluxo</span><span class="sxs-lookup"><span data-stu-id="7729c-225">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="7729c-226">Como ler texto de um arquivo</span><span class="sxs-lookup"><span data-stu-id="7729c-226">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="7729c-227">Como gravar texto em um arquivo</span><span class="sxs-lookup"><span data-stu-id="7729c-227">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static string Combine (string path1, string path2, string path3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Combine(string path1, string path2, string path3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Combine(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (path1 As String, path2 As String, path3 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Combine(System::String ^ path1, System::String ^ path2, System::String ^ path3);" />
      <MemberSignature Language="F#" Value="static member Combine : string * string * string -&gt; string" Usage="System.IO.Path.Combine (path1, path2, path3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="path2" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="path3" Type="System.String" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path1"><span data-ttu-id="7729c-228">O primeiro caminho a ser combinado.</span><span class="sxs-lookup"><span data-stu-id="7729c-228">The first path to combine.</span></span></param>
        <param name="path2"><span data-ttu-id="7729c-229">O segundo caminho a ser combinado.</span><span class="sxs-lookup"><span data-stu-id="7729c-229">The second path to combine.</span></span></param>
        <param name="path3"><span data-ttu-id="7729c-230">O terceiro caminho a ser combinado.</span><span class="sxs-lookup"><span data-stu-id="7729c-230">The third path to combine.</span></span></param>
        <summary><span data-ttu-id="7729c-231">Combina três cadeias de caracteres em um caminho.</span><span class="sxs-lookup"><span data-stu-id="7729c-231">Combines three strings into a path.</span></span></summary>
        <returns><span data-ttu-id="7729c-232">Os caminhos combinados.</span><span class="sxs-lookup"><span data-stu-id="7729c-232">The combined paths.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7729c-233">`path1` deve ser um caminho absoluto (por exemplo, "d:\archives" ou "\\\archives\public").</span><span class="sxs-lookup"><span data-stu-id="7729c-233">`path1` should be an absolute path (for example, "d:\archives" or "\\\archives\public").</span></span> <span data-ttu-id="7729c-234">Se `path2` ou `path3` também é um caminho absoluto, os caminhos de descartes tudo anteriormente combinados de operação de combinar e a redefine para o caminho absoluto.</span><span class="sxs-lookup"><span data-stu-id="7729c-234">If `path2` or `path3` is also an absolute path, the combine operation discards all previously combined paths and resets to that absolute path.</span></span>  
  
 <span data-ttu-id="7729c-235">Cadeias de caracteres de comprimento zero são omitidas do caminho combinado.</span><span class="sxs-lookup"><span data-stu-id="7729c-235">Zero-length strings are omitted from the combined path.</span></span>  
  
 <span data-ttu-id="7729c-236">Se `path1` ou `path2` não é uma referência de unidade (ou seja, "C:" ou "D:") e não termina com um caractere separador válido conforme definido na <xref:System.IO.Path.DirectorySeparatorChar>, <xref:System.IO.Path.AltDirectorySeparatorChar>, ou <xref:System.IO.Path.VolumeSeparatorChar>, <xref:System.IO.Path.DirectorySeparatorChar> é acrescentado ao `path1` ou `path2` antes da concatenação.</span><span class="sxs-lookup"><span data-stu-id="7729c-236">If `path1` or `path2` is not a drive reference (that is, "C:" or "D:") and does not end with a valid separator character as defined in <xref:System.IO.Path.DirectorySeparatorChar>, <xref:System.IO.Path.AltDirectorySeparatorChar>, or <xref:System.IO.Path.VolumeSeparatorChar>, <xref:System.IO.Path.DirectorySeparatorChar> is appended to `path1` or `path2` before concatenation.</span></span> <span data-ttu-id="7729c-237">Observe que, se `path1` ou `path2` termina em um caractere de separador de caminho que não é adequado para a plataforma de destino, o `Combine` método preserva o caractere separador de caminho original e acrescenta compatível.</span><span class="sxs-lookup"><span data-stu-id="7729c-237">Note that if `path1` or `path2` ends in a path separator character that is not appropriate for the target platform, the `Combine` method preserves the original path separator character and appends a supported one.</span></span> <span data-ttu-id="7729c-238">O exemplo a seguir compara o resultado em sistemas baseados em Unix e Windows quando a barra invertida é usada como um caractere de separador de caminho.</span><span class="sxs-lookup"><span data-stu-id="7729c-238">The following example compares the result on Windows and Unix-based systems when the backslash is used as a path separator character.</span></span> 

[!code-csharp[Combine and path separator characters](~/samples/snippets/csharp/api/system.io/path/combine/program.cs#3)]
[!code-vb[Combine and path separator characters](~/samples/snippets/visualbasic/api/system.io/path/combine/program.vb#3)]  

 <span data-ttu-id="7729c-239">Se `path2` não inclui uma raiz (por exemplo, se `path2` não começa com um caractere separador ou uma especificação de unidade), o resultado é uma concatenação de dois caminhos, com um caractere separador de intermediários.</span><span class="sxs-lookup"><span data-stu-id="7729c-239">If `path2` does not include a root (for example, if `path2` does not start with a separator character or a drive specification), the result is a concatenation of the two paths, with an intervening separator character.</span></span> <span data-ttu-id="7729c-240">Se `path2` inclui uma raiz `path2` é retornado.</span><span class="sxs-lookup"><span data-stu-id="7729c-240">If `path2` includes a root, `path2` is returned.</span></span>  
  
 <span data-ttu-id="7729c-241">Os parâmetros não são analisados, se eles têm espaço em branco.</span><span class="sxs-lookup"><span data-stu-id="7729c-241">The parameters are not parsed if they have white space.</span></span> <span data-ttu-id="7729c-242">Portanto, se `path2` inclui o espaço em branco (por exemplo, "\file.txt"), o <xref:System.IO.Path.Combine%2A> método acrescenta `path2` para `path1`.</span><span class="sxs-lookup"><span data-stu-id="7729c-242">Therefore, if `path2` includes white space (for example, " \file.txt "), the <xref:System.IO.Path.Combine%2A> method appends `path2` to `path1`.</span></span>  
  
 <span data-ttu-id="7729c-243">Nem todos os caracteres inválidos para nomes de arquivo e diretório são interpretados como inaceitáveis pelo `Combine` método, porque você pode usar esses caracteres para caracteres curinga de pesquisa.</span><span class="sxs-lookup"><span data-stu-id="7729c-243">Not all invalid characters for directory and file names are interpreted as unacceptable by the `Combine` method, because you can use these characters for search wildcard characters.</span></span> <span data-ttu-id="7729c-244">Por exemplo, embora `Path.Combine("c:\\", "*.txt")` pode ser inválida se você fosse criar um arquivo a partir dele, ele é válido como uma cadeia de caracteres de pesquisa.</span><span class="sxs-lookup"><span data-stu-id="7729c-244">For example, while `Path.Combine("c:\\", "*.txt")` might be invalid if you were to create a file from it, it is valid as a search string.</span></span> <span data-ttu-id="7729c-245">Portanto é interpretado com êxito pelo `Combine` método.</span><span class="sxs-lookup"><span data-stu-id="7729c-245">It is therefore successfully interpreted by the `Combine` method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7729c-246">O exemplo a seguir combina três caminhos.</span><span class="sxs-lookup"><span data-stu-id="7729c-246">The following example combines three paths.</span></span>  
  
 [!code-csharp[System.IO.Path.Combine#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.path.combine/cs/program.cs#1)]
 [!code-vb[System.IO.Path.Combine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.path.combine/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="7729c-247"><paramref name="path1" />, <paramref name="path2" /> ou <paramref name="path3" /> contém um ou mais caracteres inválidos definidos em <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span><span class="sxs-lookup"><span data-stu-id="7729c-247"><paramref name="path1" />, <paramref name="path2" />, or <paramref name="path3" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7729c-248"><paramref name="path1" />, <paramref name="path2" /> ou <paramref name="path3" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="7729c-248"><paramref name="path1" />, <paramref name="path2" />, or <paramref name="path3" /> is <see langword="null" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="7729c-249">Formatos de caminho de arquivo em sistemas Windows</span><span class="sxs-lookup"><span data-stu-id="7729c-249">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static string Combine (string path1, string path2, string path3, string path4);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Combine(string path1, string path2, string path3, string path4) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Combine(System.String,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (path1 As String, path2 As String, path3 As String, path4 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Combine(System::String ^ path1, System::String ^ path2, System::String ^ path3, System::String ^ path4);" />
      <MemberSignature Language="F#" Value="static member Combine : string * string * string * string -&gt; string" Usage="System.IO.Path.Combine (path1, path2, path3, path4)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="path2" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="path3" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="path4" Type="System.String" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path1"><span data-ttu-id="7729c-250">O primeiro caminho a ser combinado.</span><span class="sxs-lookup"><span data-stu-id="7729c-250">The first path to combine.</span></span></param>
        <param name="path2"><span data-ttu-id="7729c-251">O segundo caminho a ser combinado.</span><span class="sxs-lookup"><span data-stu-id="7729c-251">The second path to combine.</span></span></param>
        <param name="path3"><span data-ttu-id="7729c-252">O terceiro caminho a ser combinado.</span><span class="sxs-lookup"><span data-stu-id="7729c-252">The third path to combine.</span></span></param>
        <param name="path4"><span data-ttu-id="7729c-253">O quarto caminho a ser combinado.</span><span class="sxs-lookup"><span data-stu-id="7729c-253">The fourth path to combine.</span></span></param>
        <summary><span data-ttu-id="7729c-254">Combina quatro cadeias de caracteres em um caminho.</span><span class="sxs-lookup"><span data-stu-id="7729c-254">Combines four strings into a path.</span></span></summary>
        <returns><span data-ttu-id="7729c-255">Os caminhos combinados.</span><span class="sxs-lookup"><span data-stu-id="7729c-255">The combined paths.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7729c-256">`path1` deve ser um caminho absoluto (por exemplo, "d:\archives" ou "\\\archives\public"). Se um dos caminhos subsequentes também é um caminho absoluto, a operação de combinar descarta todos os caminhos combinados anteriormente e redefine para o caminho absoluto.</span><span class="sxs-lookup"><span data-stu-id="7729c-256">`path1` should be an absolute path (for example, "d:\archives" or "\\\archives\public").If one of the subsequent paths is also an absolute path, the combine operation discards all previously combined paths and resets to that absolute path.</span></span>  
  
 <span data-ttu-id="7729c-257">Cadeias de caracteres de comprimento zero são omitidas do caminho combinado.</span><span class="sxs-lookup"><span data-stu-id="7729c-257">Zero-length strings are omitted from the combined path.</span></span>  
  
 <span data-ttu-id="7729c-258">Se `path1`, `path2`, ou `path3` não é uma referência de unidade (ou seja, "C:" ou "D:") e não termina com um caractere separador válido conforme definido na <xref:System.IO.Path.DirectorySeparatorChar>, <xref:System.IO.Path.AltDirectorySeparatorChar>, ou <xref:System.IO.Path.VolumeSeparatorChar>, <xref:System.IO.Path.DirectorySeparatorChar> é acrescentado a ele antes da concatenação.</span><span class="sxs-lookup"><span data-stu-id="7729c-258">If `path1`, `path2`, or `path3` is not a drive reference (that is, "C:" or "D:") and does not end with a valid separator character as defined in <xref:System.IO.Path.DirectorySeparatorChar>, <xref:System.IO.Path.AltDirectorySeparatorChar>, or <xref:System.IO.Path.VolumeSeparatorChar>, <xref:System.IO.Path.DirectorySeparatorChar> is appended to it before concatenation.</span></span> <span data-ttu-id="7729c-259">Observe que, se `path1`, `path2`, ou `path3` termina em um caractere de separador de caminho que não é adequado para a plataforma de destino, o `Combine` método preserva o caractere separador de caminho original e acrescenta compatível.</span><span class="sxs-lookup"><span data-stu-id="7729c-259">Note that if `path1`, `path2`, or `path3` ends in a path separator character that is not appropriate for the target platform, the `Combine` method preserves the original path separator character and appends a supported one.</span></span> <span data-ttu-id="7729c-260">O exemplo a seguir compara o resultado em sistemas baseados em Unix e Windows quando a barra invertida é usada como um caractere de separador de caminho.</span><span class="sxs-lookup"><span data-stu-id="7729c-260">The following example compares the result on Windows and Unix-based systems when the backslash is used as a path separator character.</span></span> 

[!code-csharp[Combine and path separator characters](~/samples/snippets/csharp/api/system.io/path/combine/program.cs#4)]
[!code-vb[Combine and path separator characters](~/samples/snippets/visualbasic/api/system.io/path/combine/program.vb#4)]   
  
 <span data-ttu-id="7729c-261">Se `path2` não inclui uma raiz (por exemplo, se `path2` não começa com um caractere separador ou uma especificação de unidade), o resultado é uma concatenação de dois caminhos, com um caractere separador de intermediários.</span><span class="sxs-lookup"><span data-stu-id="7729c-261">If `path2` does not include a root (for example, if `path2` does not start with a separator character or a drive specification), the result is a concatenation of the two paths, with an intervening separator character.</span></span> <span data-ttu-id="7729c-262">Se `path2` inclui uma raiz `path2` é retornado.</span><span class="sxs-lookup"><span data-stu-id="7729c-262">If `path2` includes a root, `path2` is returned.</span></span>  
  
 <span data-ttu-id="7729c-263">Os parâmetros não são analisados, se eles têm espaço em branco.</span><span class="sxs-lookup"><span data-stu-id="7729c-263">The parameters are not parsed if they have white space.</span></span> <span data-ttu-id="7729c-264">Portanto, se `path2` inclui o espaço em branco (por exemplo, "\file.txt"), o <xref:System.IO.Path.Combine%2A> método acrescenta `path2` para `path1`.</span><span class="sxs-lookup"><span data-stu-id="7729c-264">Therefore, if `path2` includes white space (for example, " \file.txt "), the <xref:System.IO.Path.Combine%2A> method appends `path2` to `path1`.</span></span>  
  
 <span data-ttu-id="7729c-265">Nem todos os caracteres inválidos para nomes de arquivo e diretório são interpretados como inaceitáveis pelo `Combine` método, porque você pode usar esses caracteres para caracteres curinga de pesquisa.</span><span class="sxs-lookup"><span data-stu-id="7729c-265">Not all invalid characters for directory and file names are interpreted as unacceptable by the `Combine` method, because you can use these characters for search wildcard characters.</span></span> <span data-ttu-id="7729c-266">Por exemplo, embora `Path.Combine("c:\\", "*.txt")` pode ser inválida se você fosse criar um arquivo a partir dele, ele é válido como uma cadeia de caracteres de pesquisa.</span><span class="sxs-lookup"><span data-stu-id="7729c-266">For example, while `Path.Combine("c:\\", "*.txt")` might be invalid if you were to create a file from it, it is valid as a search string.</span></span> <span data-ttu-id="7729c-267">Portanto é interpretado com êxito pelo `Combine` método.</span><span class="sxs-lookup"><span data-stu-id="7729c-267">It is therefore successfully interpreted by the `Combine` method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7729c-268">O exemplo a seguir combina quatro caminhos.</span><span class="sxs-lookup"><span data-stu-id="7729c-268">The following example combines four paths.</span></span>  
  
 [!code-csharp[System.IO.Path.Combine#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.path.combine/cs/program.cs#2)]
 [!code-vb[System.IO.Path.Combine#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.path.combine/vb/program.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="7729c-269"><paramref name="path1" />, <paramref name="path2" />, <paramref name="path3" /> ou <paramref name="path4" /> contém um ou mais caracteres inválidos definidos em <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span><span class="sxs-lookup"><span data-stu-id="7729c-269"><paramref name="path1" />, <paramref name="path2" />, <paramref name="path3" />, or <paramref name="path4" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7729c-270"><paramref name="path1" />, <paramref name="path2" />, <paramref name="path3" /> ou <paramref name="path4" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="7729c-270"><paramref name="path1" />, <paramref name="path2" />, <paramref name="path3" />, or <paramref name="path4" /> is <see langword="null" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="7729c-271">Formatos de caminho de arquivo em sistemas Windows</span><span class="sxs-lookup"><span data-stu-id="7729c-271">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="DirectorySeparatorChar">
      <MemberSignature Language="C#" Value="public static readonly char DirectorySeparatorChar;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char DirectorySeparatorChar" />
      <MemberSignature Language="DocId" Value="F:System.IO.Path.DirectorySeparatorChar" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DirectorySeparatorChar As Char " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly char DirectorySeparatorChar;" />
      <MemberSignature Language="F#" Value=" staticval mutable DirectorySeparatorChar : char" Usage="System.IO.Path.DirectorySeparatorChar" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="7729c-272">Fornece um caractere específico da plataforma usado para separar os níveis de diretório em uma cadeia de caracteres de caminho que reflete uma organização do sistema de arquivos hierárquico.</span><span class="sxs-lookup"><span data-stu-id="7729c-272">Provides a platform-specific character used to separate directory levels in a path string that reflects a hierarchical file system organization.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

<span data-ttu-id="7729c-273"><xref:System.IO.Path.AltDirectorySeparatorChar> e `DirectorySeparatorChar` são ambos válidos para separar os níveis em uma cadeia de caracteres do caminho do diretório.</span><span class="sxs-lookup"><span data-stu-id="7729c-273"><xref:System.IO.Path.AltDirectorySeparatorChar> and `DirectorySeparatorChar` are both valid for separating directory levels in a path string.</span></span>  
  
<span data-ttu-id="7729c-274">Quando você estiver usando o .NET Core para desenvolver aplicativos que são executados em várias plataformas:</span><span class="sxs-lookup"><span data-stu-id="7729c-274">When you are using .NET Core to develop applications that run on multiple platforms:</span></span>

- <span data-ttu-id="7729c-275">Se você preferir codificar o caractere separador de diretório, você deve usar a barra invertida (`/`) caracteres.</span><span class="sxs-lookup"><span data-stu-id="7729c-275">If you prefer to hard-code the directory separator character, you should use the forward slash (`/`) character.</span></span> <span data-ttu-id="7729c-276">É o caractere separador de diretório reconhecidos apenas em sistemas Unix, como a saída do exemplo mostra e é o <xref:System.IO.Path.AltDirectorySeparatorChar> no Windows.</span><span class="sxs-lookup"><span data-stu-id="7729c-276">It is the only recognized directory separator character on Unix systems, as the output from the example shows, and is the <xref:System.IO.Path.AltDirectorySeparatorChar> on Windows.</span></span>

- <span data-ttu-id="7729c-277">Use a concatenação de cadeia de caracteres para recuperar o caractere separador de caminho em tempo de execução dinamicamente e incorporá-la em caminhos do sistema de arquivos.</span><span class="sxs-lookup"><span data-stu-id="7729c-277">Use string concatenation to dynamically retrieve the path separator character at runtime and incorporate it into file system paths.</span></span> <span data-ttu-id="7729c-278">Por exemplo,</span><span class="sxs-lookup"><span data-stu-id="7729c-278">For example,</span></span> 

   ```csharp
   separator = Path.DirectorySeparatorChar;
   path = $"{separator}users{separator}user1{separator}";
   ```
   ```vb
   separator = Path.DirectorySeparatorChar;
   path = $"{separator}users{separator}user1{separator}";
   ``` 
   <span data-ttu-id="7729c-279">Você também pode recuperar o valor da <xref:System.IO.Path.AltDirectorySeparatorChar> propriedade, uma vez que é o mesmo no Windows e sistemas baseados em Unx.</span><span class="sxs-lookup"><span data-stu-id="7729c-279">You can also retrieve the value from the <xref:System.IO.Path.AltDirectorySeparatorChar> property, since it is the same on both Windows and Unx-based systems.</span></span>

- <span data-ttu-id="7729c-280">Recuperar o <xref:System.IO.Path.AltDirectorySeparatorChar> propriedade</span><span class="sxs-lookup"><span data-stu-id="7729c-280">Retrieve the <xref:System.IO.Path.AltDirectorySeparatorChar> property</span></span>

<span data-ttu-id="7729c-281">Se seu aplicativo não é multiplataforma, você pode usar o separador apropriado para seu sistema.</span><span class="sxs-lookup"><span data-stu-id="7729c-281">If your application is not cross-platform, you can use the separator appropriate for your system.</span></span>

## Examples  

<span data-ttu-id="7729c-282">O exemplo a seguir exibe <xref:System.IO.Path> no Windows e em sistemas baseados em Unix de valores de campo.</span><span class="sxs-lookup"><span data-stu-id="7729c-282">The following example displays <xref:System.IO.Path> field values on Windows and on Unix-based systems.</span></span> <span data-ttu-id="7729c-283">Observe que o Windows oferece suporte a barra invertida (que é retornada pela <xref:System.IO.Path.AltDirectorySeparatorChar> campo) ou a barra invertida (que é retornado pelo <xref:System.IO.Path.DirectorySeparatorChar> campo) como caracteres de separador de caminho, enquanto os sistemas baseados em Unix oferece suporte somente a barra.</span><span class="sxs-lookup"><span data-stu-id="7729c-283">Note that Windows supports either the forward slash (which is returned by the <xref:System.IO.Path.AltDirectorySeparatorChar> field) or the backslash (which is returned by the <xref:System.IO.Path.DirectorySeparatorChar> field) as path separator characters, while Unix-based systems support only the forward slash.</span></span>  

[!code-csharp[DirectorySeparatorChar](~/samples/snippets/csharp/api/system.io/path/directoryseparatorchar/program.cs)]
[!code-vb[DirectorySeparatorChar](~/samples/snippets/visualbasic/api/system.io/path/directoryseparatorchar/program.vb)]
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="7729c-284">E/S de arquivo e de fluxo</span><span class="sxs-lookup"><span data-stu-id="7729c-284">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="7729c-285">Formatos de caminho de arquivo em sistemas Windows</span><span class="sxs-lookup"><span data-stu-id="7729c-285">File path formats on Windows systems</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="7729c-286">Como ler texto de um arquivo</span><span class="sxs-lookup"><span data-stu-id="7729c-286">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="7729c-287">Como gravar texto em um arquivo</span><span class="sxs-lookup"><span data-stu-id="7729c-287">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetDirectoryName">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; GetDirectoryName (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; GetDirectoryName(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetDirectoryName(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDirectoryName (path As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ReadOnlySpan&lt;char&gt; GetDirectoryName(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member GetDirectoryName : ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.IO.Path.GetDirectoryName path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <summary><span data-ttu-id="7729c-288">Retorna as informações de diretório para o caminho especificado representado por um intervalo de caracteres.</span><span class="sxs-lookup"><span data-stu-id="7729c-288">Returns the directory information for the specified path represented by a character span.</span></span></summary>
        <returns><span data-ttu-id="7729c-289">Informações de diretório <paramref name="path" /> ou um intervalo vazio se <paramref name="path" /> é <see langword="null" />, um intervalo vazio ou uma raiz (como \, C: ou \\servidor\compartilhamento).</span><span class="sxs-lookup"><span data-stu-id="7729c-289">Directory information for <paramref name="path" />, or an empty span if <paramref name="path" /> is <see langword="null" />, an empty span, or a root (such as \, C:, or \\server\share).</span></span></returns>
        <remarks>To be added.</remarks>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="7729c-290">Formatos de caminho de arquivo em sistemas Windows</span><span class="sxs-lookup"><span data-stu-id="7729c-290">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetDirectoryName">
      <MemberSignature Language="C#" Value="public static string GetDirectoryName (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetDirectoryName(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetDirectoryName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDirectoryName (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetDirectoryName(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetDirectoryName : string -&gt; string" Usage="System.IO.Path.GetDirectoryName path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="7729c-291">O caminho de um arquivo ou diretório.</span><span class="sxs-lookup"><span data-stu-id="7729c-291">The path of a file or directory.</span></span></param>
        <summary><span data-ttu-id="7729c-292">Retorna as informações de diretório para a cadeia de caracteres do caminho especificado.</span><span class="sxs-lookup"><span data-stu-id="7729c-292">Returns the directory information for the specified path string.</span></span></summary>
        <returns><span data-ttu-id="7729c-293">Informações de diretório para <paramref name="path" /> ou <see langword="null" />, se <paramref name="path" /> denotar um diretório raiz ou for nulo.</span><span class="sxs-lookup"><span data-stu-id="7729c-293">Directory information for <paramref name="path" />, or <see langword="null" /> if <paramref name="path" /> denotes a root directory or is null.</span></span> <span data-ttu-id="7729c-294">Retornará <see cref="F:System.String.Empty" /> se <paramref name="path" /> não contiver informações de diretório.</span><span class="sxs-lookup"><span data-stu-id="7729c-294">Returns <see cref="F:System.String.Empty" /> if <paramref name="path" /> does not contain directory information.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7729c-295">Na maioria dos casos, a cadeia de caracteres retornada por esse método consiste em todos os caracteres no caminho de backup, mas não incluindo a última <xref:System.IO.Path.DirectorySeparatorChar> ou <xref:System.IO.Path.AltDirectorySeparatorChar>.</span><span class="sxs-lookup"><span data-stu-id="7729c-295">In most cases, the string returned by this method consists of all characters in the path up to but not including the last <xref:System.IO.Path.DirectorySeparatorChar> or <xref:System.IO.Path.AltDirectorySeparatorChar>.</span></span> <span data-ttu-id="7729c-296">Se o caminho consiste em um diretório raiz, como "c:\\", null será retornado.</span><span class="sxs-lookup"><span data-stu-id="7729c-296">If the path consists of a root directory, such as "c:\\", null is returned.</span></span> <span data-ttu-id="7729c-297">Observe que esse método não dá suporte a caminhos usando "arquivo:".</span><span class="sxs-lookup"><span data-stu-id="7729c-297">Note that this method does not support paths using "file:".</span></span> <span data-ttu-id="7729c-298">Porque o caminho retornado não inclui o <xref:System.IO.Path.DirectorySeparatorChar> ou <xref:System.IO.Path.AltDirectorySeparatorChar>, passando o caminho retornado de volta para o <xref:System.IO.Path.GetDirectoryName%2A> método resultará em truncamento de um nível de pasta por uma chamada subsequente na cadeia de caracteres resultante.</span><span class="sxs-lookup"><span data-stu-id="7729c-298">Because the returned path does not include the <xref:System.IO.Path.DirectorySeparatorChar> or <xref:System.IO.Path.AltDirectorySeparatorChar>, passing the returned path back into the <xref:System.IO.Path.GetDirectoryName%2A> method will result in the truncation of one folder level per subsequent call on the result string.</span></span> <span data-ttu-id="7729c-299">Por exemplo, passando o caminho "C:\Directory\SubDirectory\test.txt" para o <xref:System.IO.Path.GetDirectoryName%2A> método retornará "C:\Directory\SubDirectory".</span><span class="sxs-lookup"><span data-stu-id="7729c-299">For example, passing the path "C:\Directory\SubDirectory\test.txt" into the <xref:System.IO.Path.GetDirectoryName%2A> method will return "C:\Directory\SubDirectory".</span></span> <span data-ttu-id="7729c-300">Passar essa cadeia de caracteres "C:\Directory\SubDirectory", em <xref:System.IO.Path.GetDirectoryName%2A> resultará em "C:\Directory".</span><span class="sxs-lookup"><span data-stu-id="7729c-300">Passing that string, "C:\Directory\SubDirectory", into <xref:System.IO.Path.GetDirectoryName%2A> will result in "C:\Directory".</span></span>  
  
 <span data-ttu-id="7729c-301">Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).</span><span class="sxs-lookup"><span data-stu-id="7729c-301">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7729c-302">O exemplo a seguir demonstra como usar o `GetDirectoryName` método em uma plataforma de desktop baseada em Windows.</span><span class="sxs-lookup"><span data-stu-id="7729c-302">The following example demonstrates using the `GetDirectoryName` method on a Windows-based desktop platform.</span></span>  
  
 [!code-cpp[System.IO.Path Members#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#3)]
 [!code-csharp[System.IO.Path Members#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#3)]
 [!code-vb[System.IO.Path Members#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="7729c-303">O parâmetro <paramref name="path" /> contém caracteres inválidos, está vazio ou contém apenas espaços em branco.</span><span class="sxs-lookup"><span data-stu-id="7729c-303">The <paramref name="path" /> parameter contains invalid characters, is empty, or contains only white spaces.</span></span></exception>
        <exception cref="T:System.IO.PathTooLongException"><block subset="none" type="note">
            <para>  
 <span data-ttu-id="7729c-304">Em vez disso, no <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET para aplicativos da Windows Store</see> ou na <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Biblioteca de Classes Portátil</see>, capture a exceção de classe base, <see cref="T:System.IO.IOException" />.</span><span class="sxs-lookup"><span data-stu-id="7729c-304">In the <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> or the <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, catch the base class exception, <see cref="T:System.IO.IOException" />, instead.</span></span>  
  
</para>
          </block>  
  
 <span data-ttu-id="7729c-305">O parâmetro <paramref name="path" /> é maior que o comprimento máximo definido pelo sistema.</span><span class="sxs-lookup"><span data-stu-id="7729c-305">The <paramref name="path" /> parameter is longer than the system-defined maximum length.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="7729c-306">Formatos de caminho de arquivo em sistemas Windows</span><span class="sxs-lookup"><span data-stu-id="7729c-306">File path formats on Windows systems</span></span></related>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="7729c-307">E/S de arquivo e de fluxo</span><span class="sxs-lookup"><span data-stu-id="7729c-307">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="7729c-308">Como ler texto de um arquivo</span><span class="sxs-lookup"><span data-stu-id="7729c-308">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="7729c-309">Como gravar texto em um arquivo</span><span class="sxs-lookup"><span data-stu-id="7729c-309">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetExtension">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; GetExtension (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; GetExtension(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetExtension(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetExtension (path As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ReadOnlySpan&lt;char&gt; GetExtension(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member GetExtension : ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.IO.Path.GetExtension path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="7729c-310">O caminho de arquivo do qual obter a extensão.</span><span class="sxs-lookup"><span data-stu-id="7729c-310">The file path from which to get the extension.</span></span></param>
        <summary><span data-ttu-id="7729c-311">Retorna a extensão de um caminho de arquivo que é representado por um intervalo de caracteres somente leitura.</span><span class="sxs-lookup"><span data-stu-id="7729c-311">Returns the extension of a file path that is represented by a read-only character span.</span></span></summary>
        <returns><span data-ttu-id="7729c-312">A extensão do caminho especificado (incluindo o ponto, ".") ou <see cref="P:System.ReadOnlySpan`1.Empty" /> se <paramref name="path" /> não tem informações de intervalo.</span><span class="sxs-lookup"><span data-stu-id="7729c-312">The extension of the specified path (including the period, "."), or <see cref="P:System.ReadOnlySpan`1.Empty" /> if <paramref name="path" /> does not have extension information.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

<span data-ttu-id="7729c-313">Esse método obtém a extensão dos `path` pesquisando `path` por um período ("."), desde o último caractere na extensão de somente leitura e continuando até o primeiro caractere.</span><span class="sxs-lookup"><span data-stu-id="7729c-313">This method obtains the extension of `path` by searching `path` for a period ("."), starting from the last character in the read-only span and continuing toward its first character.</span></span> <span data-ttu-id="7729c-314">Se algum for encontrado antes de uma <xref:System.IO.Path.DirectorySeparatorChar> ou <xref:System.IO.Path.AltDirectorySeparatorChar> caractere, o alcance de somente leitura retornado contém o período e os caracteres depois; caso contrário, <xref:System.ReadOnlySpan%601.Empty?displayProperty=nameWithType> será retornado.</span><span class="sxs-lookup"><span data-stu-id="7729c-314">If a period is found before a <xref:System.IO.Path.DirectorySeparatorChar> or <xref:System.IO.Path.AltDirectorySeparatorChar> character, the returned read-only span contains the period and the characters after it; otherwise, <xref:System.ReadOnlySpan%601.Empty?displayProperty=nameWithType> is returned.</span></span>  

         ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="7729c-315">Formatos de caminho de arquivo em sistemas Windows</span><span class="sxs-lookup"><span data-stu-id="7729c-315">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetExtension">
      <MemberSignature Language="C#" Value="public static string GetExtension (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetExtension(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetExtension(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetExtension (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetExtension(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetExtension : string -&gt; string" Usage="System.IO.Path.GetExtension path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="7729c-316">A cadeia de caracteres do caminho do qual obter a extensão.</span><span class="sxs-lookup"><span data-stu-id="7729c-316">The path string from which to get the extension.</span></span></param>
        <summary><span data-ttu-id="7729c-317">Retorna a extensão da cadeia de caracteres do caminho especificado.</span><span class="sxs-lookup"><span data-stu-id="7729c-317">Returns the extension of the specified path string.</span></span></summary>
        <returns><span data-ttu-id="7729c-318">A extensão do caminho especificado (incluindo o ponto ".") ou <see langword="null" /> ou <see cref="F:System.String.Empty" />.</span><span class="sxs-lookup"><span data-stu-id="7729c-318">The extension of the specified path (including the period "."), or <see langword="null" />, or <see cref="F:System.String.Empty" />.</span></span> <span data-ttu-id="7729c-319">Se <paramref name="path" /> for <see langword="null" />, <see cref="M:System.IO.Path.GetExtension(System.String)" /> retornará <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="7729c-319">If <paramref name="path" /> is <see langword="null" />, <see cref="M:System.IO.Path.GetExtension(System.String)" /> returns <see langword="null" />.</span></span> <span data-ttu-id="7729c-320">Se <paramref name="path" /> não tiver informações de extensão, <see cref="M:System.IO.Path.GetExtension(System.String)" /> retornará <see cref="F:System.String.Empty" />.</span><span class="sxs-lookup"><span data-stu-id="7729c-320">If <paramref name="path" /> does not have extension information, <see cref="M:System.IO.Path.GetExtension(System.String)" /> returns <see cref="F:System.String.Empty" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

<span data-ttu-id="7729c-321">Esse método obtém a extensão dos `path` pesquisando `path` para um ponto (.), começando com o último caractere no `path` e continuando até o primeiro caractere.</span><span class="sxs-lookup"><span data-stu-id="7729c-321">This method obtains the extension of `path` by searching `path` for a period (.), starting with the last character in `path` and continuing toward the first character.</span></span> <span data-ttu-id="7729c-322">Se algum for encontrado antes de uma <xref:System.IO.Path.DirectorySeparatorChar> ou <xref:System.IO.Path.AltDirectorySeparatorChar> caracteres, cadeia de caracteres retornada contém o período e os caracteres depois; caso contrário, <xref:System.String.Empty?displayProperty=nameWithType> será retornado.</span><span class="sxs-lookup"><span data-stu-id="7729c-322">If a period is found before a <xref:System.IO.Path.DirectorySeparatorChar> or <xref:System.IO.Path.AltDirectorySeparatorChar> character, the returned string contains the period and the characters after it; otherwise, <xref:System.String.Empty?displayProperty=nameWithType> is returned.</span></span>  
  
 <span data-ttu-id="7729c-323">Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).</span><span class="sxs-lookup"><span data-stu-id="7729c-323">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>
 
## Examples  
 <span data-ttu-id="7729c-324">O exemplo a seguir demonstra como usar o `GetExtension` método em uma plataforma de desktop baseada em Windows.</span><span class="sxs-lookup"><span data-stu-id="7729c-324">The following example demonstrates using the `GetExtension` method on a Windows-based desktop platform.</span></span>  
  
 [!code-cpp[System.IO.Path Members#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#4)]
 [!code-csharp[System.IO.Path Members#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#4)]
 [!code-vb[System.IO.Path Members#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="7729c-325"><paramref name="path" /> contém um ou mais caracteres inválidos definidos em <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span><span class="sxs-lookup"><span data-stu-id="7729c-325"><paramref name="path" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="7729c-326">Formatos de caminho de arquivo em sistemas Windows</span><span class="sxs-lookup"><span data-stu-id="7729c-326">File path formats on Windows systems</span></span></related>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="7729c-327">E/S de arquivo e de fluxo</span><span class="sxs-lookup"><span data-stu-id="7729c-327">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="7729c-328">Como ler texto de um arquivo</span><span class="sxs-lookup"><span data-stu-id="7729c-328">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="7729c-329">Como gravar texto em um arquivo</span><span class="sxs-lookup"><span data-stu-id="7729c-329">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetFileName">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; GetFileName (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; GetFileName(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFileName(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFileName (path As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ReadOnlySpan&lt;char&gt; GetFileName(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member GetFileName : ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.IO.Path.GetFileName path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="7729c-330">Um intervalo somente leitura que contém o caminho do qual obter o nome de arquivo e a extensão.</span><span class="sxs-lookup"><span data-stu-id="7729c-330">A read-only span that contains the path from which to obtain the file name and extension.</span></span></param>
        <summary><span data-ttu-id="7729c-331">Retorna o nome de arquivo e a extensão de um caminho de arquivo que é representado por um intervalo de caracteres somente leitura.</span><span class="sxs-lookup"><span data-stu-id="7729c-331">Returns the file name and extension of a file path that is represented by a read-only character span.</span></span></summary>
        <returns><span data-ttu-id="7729c-332">Os caracteres após o último caractere separador de diretório em <paramref name="path" />.</span><span class="sxs-lookup"><span data-stu-id="7729c-332">The characters after the last directory separator character in <paramref name="path" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

<span data-ttu-id="7729c-333">O alcance de somente leitura retornado contém os caracteres do caminho que siga o último separador em `path`.</span><span class="sxs-lookup"><span data-stu-id="7729c-333">The returned read-only span contains the characters of the path that follow the last separator in `path`.</span></span> <span data-ttu-id="7729c-334">Se o último caractere em `path` é um caractere de separador de diretório ou volume, o método retorna <xref:System.ReadOnlySpan%601.Empty?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="7729c-334">If the last character in `path` is a volume or directory separator character, the method returns <xref:System.ReadOnlySpan%601.Empty?displayProperty=nameWithType>.</span></span> <span data-ttu-id="7729c-335">Se `path` não contém nenhum caractere separador, retorna o método `path`.</span><span class="sxs-lookup"><span data-stu-id="7729c-335">If `path` contains no separator character, the method returns `path`.</span></span>

         ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="7729c-336">Formatos de caminho de arquivo em sistemas Windows</span><span class="sxs-lookup"><span data-stu-id="7729c-336">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetFileName">
      <MemberSignature Language="C#" Value="public static string GetFileName (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFileName(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFileName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFileName (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetFileName(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetFileName : string -&gt; string" Usage="System.IO.Path.GetFileName path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="7729c-337">A cadeia de caracteres do caminho do qual o nome do arquivo e a extensão serão obtidos.</span><span class="sxs-lookup"><span data-stu-id="7729c-337">The path string from which to obtain the file name and extension.</span></span></param>
        <summary><span data-ttu-id="7729c-338">Retorna o nome de arquivo e a extensão da cadeia de caracteres do caminho especificado.</span><span class="sxs-lookup"><span data-stu-id="7729c-338">Returns the file name and extension of the specified path string.</span></span></summary>
        <returns><span data-ttu-id="7729c-339">Os caracteres após o último caractere separador de diretório em <paramref name="path" />.</span><span class="sxs-lookup"><span data-stu-id="7729c-339">The characters after the last directory separator character in <paramref name="path" />.</span></span> <span data-ttu-id="7729c-340">Se o último caractere de <paramref name="path" /> for um caractere de separador de diretório ou volume, esse método retornará <see cref="F:System.String.Empty" />.</span><span class="sxs-lookup"><span data-stu-id="7729c-340">If the last character of <paramref name="path" /> is a directory or volume separator character, this method returns <see cref="F:System.String.Empty" />.</span></span> <span data-ttu-id="7729c-341">Se <paramref name="path" /> for <see langword="null" />, esse método retornará <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="7729c-341">If <paramref name="path" /> is <see langword="null" />, this method returns <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

<span data-ttu-id="7729c-342">O valor retornado é `null` se o caminho do arquivo é `null`.</span><span class="sxs-lookup"><span data-stu-id="7729c-342">The returned value is `null` if the file path is `null`.</span></span>  
  
<span data-ttu-id="7729c-343">Os caracteres de separador usados para determinar o início do nome do arquivo são <xref:System.IO.Path.DirectorySeparatorChar> e <xref:System.IO.Path.AltDirectorySeparatorChar>.</span><span class="sxs-lookup"><span data-stu-id="7729c-343">The separator characters used to determine the start of the file name are <xref:System.IO.Path.DirectorySeparatorChar> and <xref:System.IO.Path.AltDirectorySeparatorChar>.</span></span>  

<span data-ttu-id="7729c-344">Porque *\\* é um nome de arquivo legal em Unix, `GetFileName` em execução em plataformas Unix-based corretamente não pode retornar o nome do arquivo de um Windows = caminho com base como *c:\\mydir\\myfile.ext*, mas `GetFileName` em execução em plataformas baseadas em Windows corretamente pode retornar o nome do arquivo de um caminho com base em Unix, como */tmp/myfile.ext*; portanto, o comportamento do `GetFileName` método não é estritamente o mesmo em plataformas Unix e Windows.</span><span class="sxs-lookup"><span data-stu-id="7729c-344">Because *\\* is a legal file name on Unix, `GetFileName` running under Unix-based platforms cannot correctly return the file name from a Windows=based path like *C:\\mydir\\myfile.ext*, but `GetFileName` running under Windows-based platforms can correctly return the file name from a Unix-based path like */tmp/myfile.ext*, so the behavior of the `GetFileName` method is not strictly the same on Unix-based and Windows-based platforms.</span></span>

<span data-ttu-id="7729c-345">Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).</span><span class="sxs-lookup"><span data-stu-id="7729c-345">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7729c-346">O exemplo a seguir demonstra o comportamento do `GetFileName` método em uma plataforma de desktop baseada em Windows.</span><span class="sxs-lookup"><span data-stu-id="7729c-346">The following example demonstrates the behavior of the `GetFileName` method on a Windows-based desktop platform.</span></span>  
  
 [!code-cpp[System.IO.Path Members#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#5)]
 [!code-csharp[System.IO.Path Members#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#5)]
 [!code-vb[System.IO.Path Members#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="7729c-347"><paramref name="path" /> contém um ou mais caracteres inválidos definidos em <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span><span class="sxs-lookup"><span data-stu-id="7729c-347"><paramref name="path" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="7729c-348">Formatos de caminho de arquivo em sistemas Windows</span><span class="sxs-lookup"><span data-stu-id="7729c-348">File path formats on Windows systems</span></span></related>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="7729c-349">E/S de arquivo e de fluxo</span><span class="sxs-lookup"><span data-stu-id="7729c-349">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="7729c-350">Como ler texto de um arquivo</span><span class="sxs-lookup"><span data-stu-id="7729c-350">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="7729c-351">Como gravar texto em um arquivo</span><span class="sxs-lookup"><span data-stu-id="7729c-351">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetFileNameWithoutExtension">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; GetFileNameWithoutExtension (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; GetFileNameWithoutExtension(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFileNameWithoutExtension(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFileNameWithoutExtension (path As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ReadOnlySpan&lt;char&gt; GetFileNameWithoutExtension(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member GetFileNameWithoutExtension : ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.IO.Path.GetFileNameWithoutExtension path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="7729c-352">Um intervalo somente leitura que contém o caminho do qual obter o nome de arquivo sem a extensão.</span><span class="sxs-lookup"><span data-stu-id="7729c-352">A read-only span that contains the path from which to obtain the file name without the extension.</span></span></param>
        <summary><span data-ttu-id="7729c-353">Retorna o nome de arquivo sem a extensão de um caminho de arquivo que é representado por um intervalo de caracteres somente leitura.</span><span class="sxs-lookup"><span data-stu-id="7729c-353">Returns the file name without the extension of a file path that is represented by a read-only character span.</span></span></summary>
        <returns><span data-ttu-id="7729c-354">Os caracteres no intervalo somente leitura retornados por <see cref="M:System.IO.Path.GetFileName(System.ReadOnlySpan{System.Char})" />, menos o último ponto (.) e todos os caracteres depois dele.</span><span class="sxs-lookup"><span data-stu-id="7729c-354">The characters in the read-only span returned by <see cref="M:System.IO.Path.GetFileName(System.ReadOnlySpan{System.Char})" />, minus the last period (.) and all characters following it.</span></span></returns>
        <remarks>To be added.</remarks>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="7729c-355">Formatos de caminho de arquivo em sistemas Windows</span><span class="sxs-lookup"><span data-stu-id="7729c-355">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetFileNameWithoutExtension">
      <MemberSignature Language="C#" Value="public static string GetFileNameWithoutExtension (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFileNameWithoutExtension(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFileNameWithoutExtension(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFileNameWithoutExtension (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetFileNameWithoutExtension(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetFileNameWithoutExtension : string -&gt; string" Usage="System.IO.Path.GetFileNameWithoutExtension path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="7729c-356">O caminho do arquivo.</span><span class="sxs-lookup"><span data-stu-id="7729c-356">The path of the file.</span></span></param>
        <summary><span data-ttu-id="7729c-357">Retorna o nome de arquivo da cadeia de caracteres do caminho especificado sem a extensão.</span><span class="sxs-lookup"><span data-stu-id="7729c-357">Returns the file name of the specified path string without the extension.</span></span></summary>
        <returns><span data-ttu-id="7729c-358">A cadeia de caracteres retornada por <see cref="M:System.IO.Path.GetFileName(System.ReadOnlySpan{System.Char})" />, menos o último ponto (.) e todos os caracteres seguintes.</span><span class="sxs-lookup"><span data-stu-id="7729c-358">The string returned by <see cref="M:System.IO.Path.GetFileName(System.ReadOnlySpan{System.Char})" />, minus the last period (.) and all characters following it.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7729c-359">Esse método não verifica se o nome de caminho ou arquivo existe.</span><span class="sxs-lookup"><span data-stu-id="7729c-359">This method does not verify that the path or file name exists.</span></span>  
  
 <span data-ttu-id="7729c-360">Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).</span><span class="sxs-lookup"><span data-stu-id="7729c-360">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7729c-361">O exemplo a seguir demonstra um uso do `GetFileNameWithoutExtension` método.</span><span class="sxs-lookup"><span data-stu-id="7729c-361">The following example demonstrates a use of the `GetFileNameWithoutExtension` method.</span></span>  
  
 [!code-cpp[System.IO.Path Members#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#6)]
 [!code-csharp[System.IO.Path Members#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#6)]
 [!code-vb[System.IO.Path Members#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="7729c-362"><paramref name="path" /> contém um ou mais caracteres inválidos definidos em <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span><span class="sxs-lookup"><span data-stu-id="7729c-362"><paramref name="path" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="7729c-363">Formatos de caminho de arquivo em sistemas Windows</span><span class="sxs-lookup"><span data-stu-id="7729c-363">File path formats on Windows systems</span></span></related>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="7729c-364">E/S de arquivo e de fluxo</span><span class="sxs-lookup"><span data-stu-id="7729c-364">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="7729c-365">Como ler texto de um arquivo</span><span class="sxs-lookup"><span data-stu-id="7729c-365">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="7729c-366">Como gravar texto em um arquivo</span><span class="sxs-lookup"><span data-stu-id="7729c-366">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetFullPath">
      <MemberSignature Language="C#" Value="public static string GetFullPath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFullPath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFullPath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFullPath (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetFullPath(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetFullPath : string -&gt; string" Usage="System.IO.Path.GetFullPath path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="7729c-367">O arquivo ou diretório para o qual as informações de caminho absoluto serão obtidas.</span><span class="sxs-lookup"><span data-stu-id="7729c-367">The file or directory for which to obtain absolute path information.</span></span></param>
        <summary><span data-ttu-id="7729c-368">Retorna o caminho absoluto para a cadeia de caracteres do caminho especificado.</span><span class="sxs-lookup"><span data-stu-id="7729c-368">Returns the absolute path for the specified path string.</span></span></summary>
        <returns><span data-ttu-id="7729c-369">O local totalmente qualificado de <paramref name="path" />, como "C:\MyFile.txt".</span><span class="sxs-lookup"><span data-stu-id="7729c-369">The fully qualified location of <paramref name="path" />, such as "C:\MyFile.txt".</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
 <span data-ttu-id="7729c-370">O caminho absoluto inclui todas as informações necessárias para localizar um arquivo ou diretório em um sistema.</span><span class="sxs-lookup"><span data-stu-id="7729c-370">The absolute path includes all information required to locate a file or directory on a system.</span></span>  
  
 <span data-ttu-id="7729c-371">O arquivo ou diretório especificado por `path` não precisa existir.</span><span class="sxs-lookup"><span data-stu-id="7729c-371">The file or directory specified by `path` is not required to exist.</span></span> <span data-ttu-id="7729c-372">Por exemplo, se *c:\temp\newdir* é o diretório atual, chamar `GetFullPath` em um nome de arquivo, como *Test. txt* retorna *c:\temp\newdir\test.txt*.</span><span class="sxs-lookup"><span data-stu-id="7729c-372">For example, if *c:\temp\newdir* is the current directory, calling `GetFullPath` on a file name such as *test.txt* returns *c:\temp\newdir\test.txt*.</span></span> <span data-ttu-id="7729c-373">O arquivo não precisa existir.</span><span class="sxs-lookup"><span data-stu-id="7729c-373">The file need not exist.</span></span>  

> [!IMPORTANT]
> <span data-ttu-id="7729c-374">Se `path` é um caminho relativo, essa sobrecarga retorna um caminho totalmente qualificado que pode ser baseado em unidade atual e do diretório atual.</span><span class="sxs-lookup"><span data-stu-id="7729c-374">If `path` is a relative path, this overload returns a fully qualified path that can be based on the current drive and current directory.</span></span> <span data-ttu-id="7729c-375">Podem alterar a unidade atual e o diretório atual a qualquer momento durante a execução de um aplicativo.</span><span class="sxs-lookup"><span data-stu-id="7729c-375">The current drive and current directory can change at any time as an application executes.</span></span> <span data-ttu-id="7729c-376">Como resultado, o caminho retornado por essa sobrecarga não pode ser determinado com antecedência.</span><span class="sxs-lookup"><span data-stu-id="7729c-376">As a result, the path returned by this overload cannot be determined in advance.</span></span> <span data-ttu-id="7729c-377">Para retornar um caminho determinístico, chame o <xref:System.IO.Path.GetFullPath(System.String,System.String)> de sobrecarga.</span><span class="sxs-lookup"><span data-stu-id="7729c-377">To return a deterministic path, call the <xref:System.IO.Path.GetFullPath(System.String,System.String)> overload.</span></span> <span data-ttu-id="7729c-378">Você também pode chamar o <xref:System.IO.Path.IsPathFullyQualified%2A> método para determinar se um caminho totalmente qualificado ou relativo e, portanto, se uma chamada para `GetFullPath` é necessário.</span><span class="sxs-lookup"><span data-stu-id="7729c-378">You can also call the <xref:System.IO.Path.IsPathFullyQualified%2A> method to determine whether a path is fully qualified or relative and therefore whether a call to `GetFullPath` is necessary.</span></span>

 <span data-ttu-id="7729c-379">No entanto, se `path` existir, o chamador deve ter permissão para obter informações de caminho para `path`.</span><span class="sxs-lookup"><span data-stu-id="7729c-379">However, if `path` does exist, the caller must have permission to obtain path information for `path`.</span></span> <span data-ttu-id="7729c-380">Observe que, ao contrário da maioria dos membros do <xref:System.IO.Path> classe, esse método acessa o sistema de arquivos.</span><span class="sxs-lookup"><span data-stu-id="7729c-380">Note that unlike most members of the <xref:System.IO.Path> class, this method accesses the file system.</span></span>  
  
 <span data-ttu-id="7729c-381">Esse método usa o diretório atual e informações de volume atual para qualificar totalmente `path`.</span><span class="sxs-lookup"><span data-stu-id="7729c-381">This method uses the current directory and current volume information to fully qualify `path`.</span></span> <span data-ttu-id="7729c-382">Se você especificar um arquivo de nome apenas no `path`, `GetFullPath` retorna o caminho totalmente qualificado do diretório atual.</span><span class="sxs-lookup"><span data-stu-id="7729c-382">If you specify a file name only in `path`, `GetFullPath` returns the fully qualified path of the current directory.</span></span>  
  
 <span data-ttu-id="7729c-383">Se você passar um nome de arquivo curto, ele é expandido para um nome de arquivo longos.</span><span class="sxs-lookup"><span data-stu-id="7729c-383">If you pass in a short file name, it is expanded to a long file name.</span></span>  
  
 <span data-ttu-id="7729c-384">Se um caminho contém caracteres não significativos, não é válido, a menos que ele contém um ou mais "." caracteres seguidos por qualquer número de espaços; em seguida, ele será analisado como um "."ou"..".</span><span class="sxs-lookup"><span data-stu-id="7729c-384">If a path contains no significant characters, it is invalid unless it contains one or more "." characters followed by any number of spaces; then it will be parsed as either "." or "..".</span></span>  

<span data-ttu-id="7729c-385">.NET core 1.1 e versões posteriores e .NET Framework 4.6.2 e versões posteriores também dão suporte a caminhos que incluem nomes de dispositivo, como "\\? \C:\".</span><span class="sxs-lookup"><span data-stu-id="7729c-385">.NET Core 1.1 and later versions and .NET Framework 4.6.2 and later versions also support paths that include device names, such as "\\?\C:\".</span></span>

<span data-ttu-id="7729c-386">Para obter mais informações sobre formatos de caminho de arquivo no Windows, consulte [formatos de caminho de arquivo nos sistemas Windows](~/docs/standard/io/file-path-formats.md).</span><span class="sxs-lookup"><span data-stu-id="7729c-386">For more information on file path formats on Windows, see [File path formats on Windows systems](~/docs/standard/io/file-path-formats.md).</span></span> <span data-ttu-id="7729c-387">Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).</span><span class="sxs-lookup"><span data-stu-id="7729c-387">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>
  
## Examples  
 <span data-ttu-id="7729c-388">O exemplo a seguir demonstra o `GetFullPath` método em uma plataforma de desktop baseada em Windows.</span><span class="sxs-lookup"><span data-stu-id="7729c-388">The following example demonstrates the `GetFullPath` method on a Windows-based desktop platform.</span></span>  
  
 [!code-cpp[System.IO.Path Members#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#7)]
 [!code-csharp[System.IO.Path Members#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#7)]
 [!code-vb[System.IO.Path Members#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="7729c-389"><paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou contém um ou mais dos caracteres inválidos definidos em <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span><span class="sxs-lookup"><span data-stu-id="7729c-389"><paramref name="path" /> is a zero-length string, contains only white space, or contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span>  
  
<span data-ttu-id="7729c-390">- ou -</span><span class="sxs-lookup"><span data-stu-id="7729c-390">-or-</span></span> 
<span data-ttu-id="7729c-391">O sistema não pôde recuperar o caminho absoluto.</span><span class="sxs-lookup"><span data-stu-id="7729c-391">The system could not retrieve the absolute path.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="7729c-392">O chamador não tem as permissões necessárias.</span><span class="sxs-lookup"><span data-stu-id="7729c-392">The caller does not have the required permissions.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7729c-393"><paramref name="path" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="7729c-393"><paramref name="path" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="7729c-394"><paramref name="path" /> contém dois pontos (":") que não fazem parte de um identificador de volume (por exemplo, "c:\\").</span><span class="sxs-lookup"><span data-stu-id="7729c-394"><paramref name="path" /> contains a colon (":") that is not part of a volume identifier (for example, "c:\\").</span></span></exception>
        <exception cref="T:System.IO.PathTooLongException"><span data-ttu-id="7729c-395">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema.</span><span class="sxs-lookup"><span data-stu-id="7729c-395">The specified path, file name, or both exceed the system-defined maximum length.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="7729c-396">para acesso ao caminho.</span><span class="sxs-lookup"><span data-stu-id="7729c-396">for access to the path.</span></span></permission>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="7729c-397">Formatos de caminho de arquivo em sistemas Windows</span><span class="sxs-lookup"><span data-stu-id="7729c-397">File path formats on Windows systems</span></span></related>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="7729c-398">E/S de arquivo e de fluxo</span><span class="sxs-lookup"><span data-stu-id="7729c-398">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="7729c-399">Como ler texto de um arquivo</span><span class="sxs-lookup"><span data-stu-id="7729c-399">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="7729c-400">Como gravar texto em um arquivo</span><span class="sxs-lookup"><span data-stu-id="7729c-400">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetFullPath">
      <MemberSignature Language="C#" Value="public static string GetFullPath (string path, string basePath);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFullPath(string path, string basePath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFullPath(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFullPath (path As String, basePath As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetFullPath(System::String ^ path, System::String ^ basePath);" />
      <MemberSignature Language="F#" Value="static member GetFullPath : string * string -&gt; string" Usage="System.IO.Path.GetFullPath (path, basePath)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="basePath" Type="System.String" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="7729c-401">Um caminho relativo a ser concatenado com <paramref name="basePath" />.</span><span class="sxs-lookup"><span data-stu-id="7729c-401">A relative path to concatenate to <paramref name="basePath" />.</span></span></param>
        <param name="basePath"><span data-ttu-id="7729c-402">O início de um caminho totalmente qualificado.</span><span class="sxs-lookup"><span data-stu-id="7729c-402">The beginning of a fully qualified path.</span></span></param>
        <summary><span data-ttu-id="7729c-403">Retorna um caminho absoluto de um caminho base totalmente qualificado e um caminho relativo.</span><span class="sxs-lookup"><span data-stu-id="7729c-403">Returns an absolute path from a fully qualified base path and a relative path.</span></span></summary>
        <returns><span data-ttu-id="7729c-404">O caminho absoluto.</span><span class="sxs-lookup"><span data-stu-id="7729c-404">The absolute path.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

<span data-ttu-id="7729c-405">Se `path` é um caminho vazio, o método retorna `basePath`.</span><span class="sxs-lookup"><span data-stu-id="7729c-405">If `path` is an empty path, the method returns `basePath`.</span></span> <span data-ttu-id="7729c-406">Se `path` é um caminho totalmente qualificado, o método passa `path` para o <xref:System.IO.Path.GetFullPath(System.String)> método e retorna o resultado.</span><span class="sxs-lookup"><span data-stu-id="7729c-406">If `path` is a fully qualified path, the method passes `path` to the <xref:System.IO.Path.GetFullPath(System.String)> method and returns the result.</span></span>

<span data-ttu-id="7729c-407">Use esse método para retornar um caminho determinístico com base em um volume especificado e com raiz diretório quando você estiver usando caminhos relativos.</span><span class="sxs-lookup"><span data-stu-id="7729c-407">Use this method to return a deterministic path based on a specified volume and rooted directory when you're using relative paths.</span></span> <span data-ttu-id="7729c-408">Usando um modelo predefinido `basePath` em vez de uma baseada nas proteções de diretório de unidade atual em relação a caminhos de arquivos indesejados causados por alterações inesperadas na unidade atual e o directory.</span><span class="sxs-lookup"><span data-stu-id="7729c-408">Using a predefined `basePath` rather than one based on the current drive directory guards against unwanted file paths caused by unexpected changes in the current drive and directory.</span></span> 

## <a name="example"></a><span data-ttu-id="7729c-409">Exemplo</span><span class="sxs-lookup"><span data-stu-id="7729c-409">Example</span></span>

<span data-ttu-id="7729c-410">O exemplo a seguir define uma variável, `basePath`, para representar o diretório atual de um aplicativo.</span><span class="sxs-lookup"><span data-stu-id="7729c-410">The following example defines a variable, `basePath`, to represent an application's current directory.</span></span> <span data-ttu-id="7729c-411">Em seguida, passá-lo para o `GetFullPath` método para obter um caminho totalmente qualificado para o diretório de dados do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="7729c-411">It then passes it to the `GetFullPath` method to get a fully qualified path to the application's data directory.</span></span>

[!code-csharp[Path.GetFullPath(String,String)](~/samples/snippets/csharp/api/system.io/path/getfullpath/program.cs)] 
[!code-vb[Path.GetFullPath(String,String)](~/samples/snippets/visualbasic/api/system.io/path/getfullpath/program.vb)] 

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7729c-412"><paramref name="path" /> ou <paramref name="basePath" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="7729c-412"><paramref name="path" /> or <paramref name="basePath" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="7729c-413"><paramref name="basePath" /> não é um caminho totalmente qualificado.</span><span class="sxs-lookup"><span data-stu-id="7729c-413"><paramref name="basePath" /> is not a fully qualified path.</span></span>

<span data-ttu-id="7729c-414">- ou -</span><span class="sxs-lookup"><span data-stu-id="7729c-414">-or-</span></span>

<span data-ttu-id="7729c-415"><paramref name="path" /> ou <paramref name="basePath" /> contém caracteres de caminho inválidos, como U+0000.</span><span class="sxs-lookup"><span data-stu-id="7729c-415"><paramref name="path" /> or <paramref name="basePath" /> contains invalid path characters, such as U+0000.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetInvalidFileNameChars">
      <MemberSignature Language="C#" Value="public static char[] GetInvalidFileNameChars ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig char[] GetInvalidFileNameChars() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetInvalidFileNameChars" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetInvalidFileNameChars () As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;char&gt; ^ GetInvalidFileNameChars();" />
      <MemberSignature Language="F#" Value="static member GetInvalidFileNameChars : unit -&gt; char[]" Usage="System.IO.Path.GetInvalidFileNameChars " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="7729c-416">Obtém uma matriz que contém os caracteres que não são permitidos em nomes de arquivo.</span><span class="sxs-lookup"><span data-stu-id="7729c-416">Gets an array containing the characters that are not allowed in file names.</span></span></summary>
        <returns><span data-ttu-id="7729c-417">Uma matriz que contém os caracteres que não são permitidos em nomes de arquivo.</span><span class="sxs-lookup"><span data-stu-id="7729c-417">An array containing the characters that are not allowed in file names.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7729c-418">A matriz retornada por esse método não é garantida para conter o conjunto completo de caracteres que são inválidos em nomes de arquivo e diretório.</span><span class="sxs-lookup"><span data-stu-id="7729c-418">The array returned from this method is not guaranteed to contain the complete set of characters that are invalid in file and directory names.</span></span> <span data-ttu-id="7729c-419">O conjunto completo de caracteres inválidos pode variar por sistema de arquivos.</span><span class="sxs-lookup"><span data-stu-id="7729c-419">The full set of invalid characters can vary by file system.</span></span> <span data-ttu-id="7729c-420">Por exemplo, em plataformas de área de trabalho baseado em Windows, caracteres de caminho inválido podem incluir caracteres ASCII/Unicode de 1 a 31, bem como colocar entre aspas ("), menor que (\<), maior que (>), pipe (&#124;), backspace (\b), nulo (\0) e tabulação (\t).</span><span class="sxs-lookup"><span data-stu-id="7729c-420">For example, on Windows-based desktop platforms, invalid path characters might include ASCII/Unicode characters 1 through 31, as well as quote ("), less than (\<), greater than (>), pipe (&#124;), backspace (\b), null (\0) and tab (\t).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7729c-421">O exemplo a seguir demonstra a <xref:System.IO.Path.GetInvalidFileNameChars%2A> método e o <xref:System.IO.Path.GetInvalidPathChars%2A> método para recuperar caracteres inválidos.</span><span class="sxs-lookup"><span data-stu-id="7729c-421">The following example demonstrates the <xref:System.IO.Path.GetInvalidFileNameChars%2A> method and the <xref:System.IO.Path.GetInvalidPathChars%2A> method to retrieve invalid characters.</span></span>  
  
 [!code-cpp[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/cpp/example.cpp#1)]
 [!code-csharp[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/CS/example.cs#1)]
 [!code-vb[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetInvalidPathChars">
      <MemberSignature Language="C#" Value="public static char[] GetInvalidPathChars ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig char[] GetInvalidPathChars() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetInvalidPathChars" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetInvalidPathChars () As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;char&gt; ^ GetInvalidPathChars();" />
      <MemberSignature Language="F#" Value="static member GetInvalidPathChars : unit -&gt; char[]" Usage="System.IO.Path.GetInvalidPathChars " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="7729c-422">Obtém uma matriz que contém os caracteres que não são permitidos em nomes de caminho.</span><span class="sxs-lookup"><span data-stu-id="7729c-422">Gets an array containing the characters that are not allowed in path names.</span></span></summary>
        <returns><span data-ttu-id="7729c-423">Uma matriz que contém os caracteres que não são permitidos em nomes de caminho.</span><span class="sxs-lookup"><span data-stu-id="7729c-423">An array containing the characters that are not allowed in path names.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7729c-424">A matriz retornada por esse método não é garantida para conter o conjunto completo de caracteres que são inválidos em nomes de arquivo e diretório.</span><span class="sxs-lookup"><span data-stu-id="7729c-424">The array returned from this method is not guaranteed to contain the complete set of characters that are invalid in file and directory names.</span></span> <span data-ttu-id="7729c-425">O conjunto completo de caracteres inválidos pode variar por sistema de arquivos.</span><span class="sxs-lookup"><span data-stu-id="7729c-425">The full set of invalid characters can vary by file system.</span></span> <span data-ttu-id="7729c-426">Por exemplo, em plataformas de área de trabalho baseado em Windows, caracteres de caminho inválido podem incluir caracteres ASCII/Unicode de 1 a 31, bem como colocar entre aspas ("), menor que (\<), maior que (>), pipe (&#124;), backspace (\b), nulo (\0) e tabulação (\t).</span><span class="sxs-lookup"><span data-stu-id="7729c-426">For example, on Windows-based desktop platforms, invalid path characters might include ASCII/Unicode characters 1 through 31, as well as quote ("), less than (\<), greater than (>), pipe (&#124;), backspace (\b), null (\0) and tab (\t).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7729c-427">O exemplo a seguir demonstra a <xref:System.IO.Path.GetInvalidFileNameChars%2A> método e o <xref:System.IO.Path.GetInvalidPathChars%2A> método para recuperar caracteres inválidos.</span><span class="sxs-lookup"><span data-stu-id="7729c-427">The following example demonstrates the <xref:System.IO.Path.GetInvalidFileNameChars%2A> method and the <xref:System.IO.Path.GetInvalidPathChars%2A> method to retrieve invalid characters.</span></span>  
  
 [!code-cpp[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/cpp/example.cpp#1)]
 [!code-csharp[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/CS/example.cs#1)]
 [!code-vb[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPathRoot">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; GetPathRoot (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; GetPathRoot(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetPathRoot(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPathRoot (path As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ReadOnlySpan&lt;char&gt; GetPathRoot(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member GetPathRoot : ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.IO.Path.GetPathRoot path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="7729c-428">O caminho do qual as informações do diretório raiz serão obtidas.</span><span class="sxs-lookup"><span data-stu-id="7729c-428">The path from which to obtain root directory information.</span></span></param>
        <summary><span data-ttu-id="7729c-429">Obtém as informações do diretório raiz do caminho contido no intervalo de caracteres especificado.</span><span class="sxs-lookup"><span data-stu-id="7729c-429">Gets the root directory information from the path contained in the specified character span.</span></span></summary>
        <returns><span data-ttu-id="7729c-430">Um intervalo de caracteres que contém o diretório raiz do `path`.</span><span class="sxs-lookup"><span data-stu-id="7729c-430">A character span containing the root directory of `path`.</span></span></returns>
        <remarks>To be added.</remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="7729c-431">Formatos de caminho de arquivo em sistemas Windows</span><span class="sxs-lookup"><span data-stu-id="7729c-431">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetPathRoot">
      <MemberSignature Language="C#" Value="public static string GetPathRoot (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetPathRoot(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetPathRoot(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPathRoot (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetPathRoot(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetPathRoot : string -&gt; string" Usage="System.IO.Path.GetPathRoot path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="7729c-432">O caminho do qual as informações do diretório raiz serão obtidas.</span><span class="sxs-lookup"><span data-stu-id="7729c-432">The path from which to obtain root directory information.</span></span></param>
        <summary><span data-ttu-id="7729c-433">Obtém as informações do diretório raiz do caminho especificado.</span><span class="sxs-lookup"><span data-stu-id="7729c-433">Gets the root directory information of the specified path.</span></span></summary>
        <returns><span data-ttu-id="7729c-434">O diretório raiz de <paramref name="path" /> ou <see langword="null" /> se <paramref name="path" /> for <see langword="null" /> ou uma cadeia de caracteres vazia se <paramref name="path" /> não contiver informações do diretório raiz.</span><span class="sxs-lookup"><span data-stu-id="7729c-434">The root directory of <paramref name="path" />, or <see langword="null" /> if <paramref name="path" /> is <see langword="null" />, or an empty string if <paramref name="path" /> does not contain root directory information.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7729c-435">Esse método não verifica se o nome de caminho ou arquivo existe.</span><span class="sxs-lookup"><span data-stu-id="7729c-435">This method does not verify that the path or file name exists.</span></span>  
  
 <span data-ttu-id="7729c-436">Padrões possíveis para a cadeia de caracteres retornada por esse método são da seguinte maneira:</span><span class="sxs-lookup"><span data-stu-id="7729c-436">Possible patterns for the string returned by this method are as follows:</span></span>  
  
- <span data-ttu-id="7729c-437">Uma cadeia de caracteres vazia (`path` especificado um caminho relativo da unidade atual ou do volume).</span><span class="sxs-lookup"><span data-stu-id="7729c-437">An empty string (`path` specified a relative path on the current drive or volume).</span></span>  
  
- <span data-ttu-id="7729c-438">"\" (`path` especificado um caminho absoluto na unidade atual).</span><span class="sxs-lookup"><span data-stu-id="7729c-438">"\" (`path` specified an absolute path on the current drive).</span></span>  
  
- <span data-ttu-id="7729c-439">"X" (`path` especificado um caminho relativo em uma unidade, em que X representa uma letra de unidade ou volume).</span><span class="sxs-lookup"><span data-stu-id="7729c-439">"X:" (`path` specified a relative path on a drive, where X represents a drive or volume letter).</span></span>  
  
- <span data-ttu-id="7729c-440">"X:\" (`path` especificado um caminho absoluto em uma determinada unidade).</span><span class="sxs-lookup"><span data-stu-id="7729c-440">"X:\" (`path` specified an absolute path on a given drive).</span></span>  
  
- <span data-ttu-id="7729c-441">"\\\ComputerName\SharedFolder" (um caminho UNC).</span><span class="sxs-lookup"><span data-stu-id="7729c-441">"\\\ComputerName\SharedFolder" (a UNC path).</span></span>  
  
- <span data-ttu-id="7729c-442">"\\? \C:" (DOS caminho de dispositivo, com suporte no .NET Core 1.1 e versões posteriores e no .NET Framework 4.6.2 e versões posteriores)</span><span class="sxs-lookup"><span data-stu-id="7729c-442">"\\?\C:" (a DOS device path, supported in .NET Core 1.1 and later versions and in .NET Framework 4.6.2 and later versions)</span></span>
   
 <span data-ttu-id="7729c-443">Para obter mais informações sobre caminhos de arquivo no Windows, consulte [formatos de caminho de arquivo nos sistemas Windows](~/docs/standard/io/file-path-formats.md).</span><span class="sxs-lookup"><span data-stu-id="7729c-443">For more information on file paths on Windows, see [File path formats on Windows systems](~/docs/standard/io/file-path-formats.md).</span></span> <span data-ttu-id="7729c-444">Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).</span><span class="sxs-lookup"><span data-stu-id="7729c-444">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
## Examples  
 <span data-ttu-id="7729c-445">O exemplo a seguir demonstra um uso do `GetPathRoot` método.</span><span class="sxs-lookup"><span data-stu-id="7729c-445">The following example demonstrates a use of the `GetPathRoot` method.</span></span>  
  
 [!code-cpp[System.IO.Path Members#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#8)]
 [!code-csharp[System.IO.Path Members#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#8)]
 [!code-vb[System.IO.Path Members#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="7729c-446"><paramref name="path" /> contém um ou mais caracteres inválidos definidos em <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span><span class="sxs-lookup"><span data-stu-id="7729c-446"><paramref name="path" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span>  
  
<span data-ttu-id="7729c-447">- ou -</span><span class="sxs-lookup"><span data-stu-id="7729c-447">-or-</span></span> 
 <span data-ttu-id="7729c-448"><see cref="F:System.String.Empty" /> foi passado para <paramref name="path" />.</span><span class="sxs-lookup"><span data-stu-id="7729c-448"><see cref="F:System.String.Empty" /> was passed to <paramref name="path" />.</span></span></exception>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="7729c-449">Formatos de caminho de arquivo em sistemas Windows</span><span class="sxs-lookup"><span data-stu-id="7729c-449">File path formats on Windows systems</span></span></related>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="7729c-450">E/S de arquivo e de fluxo</span><span class="sxs-lookup"><span data-stu-id="7729c-450">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="7729c-451">Como ler texto de um arquivo</span><span class="sxs-lookup"><span data-stu-id="7729c-451">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="7729c-452">Como gravar texto em um arquivo</span><span class="sxs-lookup"><span data-stu-id="7729c-452">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetRandomFileName">
      <MemberSignature Language="C#" Value="public static string GetRandomFileName ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetRandomFileName() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetRandomFileName" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetRandomFileName () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetRandomFileName();" />
      <MemberSignature Language="F#" Value="static member GetRandomFileName : unit -&gt; string" Usage="System.IO.Path.GetRandomFileName " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="7729c-453">Retorna um nome de pasta ou nome de arquivo aleatório.</span><span class="sxs-lookup"><span data-stu-id="7729c-453">Returns a random folder name or file name.</span></span></summary>
        <returns><span data-ttu-id="7729c-454">Um nome de pasta aleatório ou um nome de arquivo.</span><span class="sxs-lookup"><span data-stu-id="7729c-454">A random folder name or file name.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7729c-455">O <xref:System.IO.Path.GetRandomFileName%2A> método retorna uma cadeia de caracteres aleatória, criptograficamente forte que pode ser usada como um nome de pasta ou um nome de arquivo.</span><span class="sxs-lookup"><span data-stu-id="7729c-455">The <xref:System.IO.Path.GetRandomFileName%2A> method returns a cryptographically strong, random string that can be used as either a folder name or a file name.</span></span> <span data-ttu-id="7729c-456">Diferentemente <xref:System.IO.Path.GetTempFileName%2A>, <xref:System.IO.Path.GetRandomFileName%2A> não cria um arquivo.</span><span class="sxs-lookup"><span data-stu-id="7729c-456">Unlike <xref:System.IO.Path.GetTempFileName%2A>, <xref:System.IO.Path.GetRandomFileName%2A> does not create a file.</span></span> <span data-ttu-id="7729c-457">Quando a segurança do seu sistema de arquivos é fundamental, esse método deve ser usado em vez de <xref:System.IO.Path.GetTempFileName%2A>.</span><span class="sxs-lookup"><span data-stu-id="7729c-457">When the security of your file system is paramount, this method should be used instead of <xref:System.IO.Path.GetTempFileName%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7729c-458">O exemplo a seguir mostram a saída do <xref:System.IO.Path.GetRandomFileName%2A> método.</span><span class="sxs-lookup"><span data-stu-id="7729c-458">The following example show output from the <xref:System.IO.Path.GetRandomFileName%2A> method.</span></span>  
  
 [!code-csharp[System.IO.Path Members#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers20.cs#20)]
 [!code-vb[System.IO.Path Members#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers20.vb#20)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetRelativePath">
      <MemberSignature Language="C#" Value="public static string GetRelativePath (string relativeTo, string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetRelativePath(string relativeTo, string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetRelativePath(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetRelativePath (relativeTo As String, path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetRelativePath(System::String ^ relativeTo, System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetRelativePath : string * string -&gt; string" Usage="System.IO.Path.GetRelativePath (relativeTo, path)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="relativeTo" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="path" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="relativeTo"><span data-ttu-id="7729c-459">O caminho de origem ao qual o resultado deve ser relativo.</span><span class="sxs-lookup"><span data-stu-id="7729c-459">The source path the result should be relative to.</span></span> <span data-ttu-id="7729c-460">Esse caminho é sempre considerado um diretório.</span><span class="sxs-lookup"><span data-stu-id="7729c-460">This path is always considered to be a directory.</span></span></param>
        <param name="path"><span data-ttu-id="7729c-461">O caminho de destino.</span><span class="sxs-lookup"><span data-stu-id="7729c-461">The destination path.</span></span></param>
        <summary><span data-ttu-id="7729c-462">Retorna um caminho relativo de um caminho para outro.</span><span class="sxs-lookup"><span data-stu-id="7729c-462">Returns a relative path from one path to another.</span></span></summary>
        <returns><span data-ttu-id="7729c-463">O caminho relativo ou <paramref name="path" /> se os caminhos não compartilham a mesma raiz.</span><span class="sxs-lookup"><span data-stu-id="7729c-463">The relative path, or <paramref name="path" /> if the paths don't share the same root.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

<span data-ttu-id="7729c-464">Caminhos são resolvidos por meio da chamada a <xref:System.IO.Path.GetFullPath%2A> método antes de calcular a diferença.</span><span class="sxs-lookup"><span data-stu-id="7729c-464">Paths are resolved by calling the <xref:System.IO.Path.GetFullPath%2A> method before calculating the difference.</span></span> <span data-ttu-id="7729c-465">O método usa a comparação de caminho de arquivo padrão para a plataforma atual (<xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> para Windows e MacOs, <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> para Linux.</span><span class="sxs-lookup"><span data-stu-id="7729c-465">The method uses the default file path comparison for the current platform (<xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> for Windows and MacOs, <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> for Linux.</span></span> 

         ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7729c-466"><paramref name="relativeTo" /> ou <paramref name="path" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="7729c-466"><paramref name="relativeTo" /> or <paramref name="path" /> is <see langword="null" />.</span></span></exception>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="7729c-467">Formatos de caminho de arquivo em sistemas Windows</span><span class="sxs-lookup"><span data-stu-id="7729c-467">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetTempFileName">
      <MemberSignature Language="C#" Value="public static string GetTempFileName ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetTempFileName() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetTempFileName" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTempFileName () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetTempFileName();" />
      <MemberSignature Language="F#" Value="static member GetTempFileName : unit -&gt; string" Usage="System.IO.Path.GetTempFileName " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="7729c-468">Cria um arquivo temporário de zero byte nomeado exclusivamente no disco e retorna o caminho completo do arquivo.</span><span class="sxs-lookup"><span data-stu-id="7729c-468">Creates a uniquely named, zero-byte temporary file on disk and returns the full path of that file.</span></span></summary>
        <returns><span data-ttu-id="7729c-469">O caminho completo do arquivo temporário.</span><span class="sxs-lookup"><span data-stu-id="7729c-469">The full path of the temporary file.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7729c-470">Esse método cria um arquivo temporário com um. Extensão de arquivo TMP.</span><span class="sxs-lookup"><span data-stu-id="7729c-470">This method creates a temporary file with a .TMP file extension.</span></span> <span data-ttu-id="7729c-471">O arquivo temporário é criado na pasta temporária do usuário, que é o caminho retornado pelo <xref:System.IO.Path.GetTempPath%2A> método.</span><span class="sxs-lookup"><span data-stu-id="7729c-471">The temporary file is created within the user's temporary folder, which is the path returned by the <xref:System.IO.Path.GetTempPath%2A> method.</span></span>  
  
 <span data-ttu-id="7729c-472">O <xref:System.IO.Path.GetTempFileName%2A> método irá gerar um <xref:System.IO.IOException> se ele é usado para criar arquivos de mais de 65.535 sem excluir os arquivos temporários anteriores.</span><span class="sxs-lookup"><span data-stu-id="7729c-472">The <xref:System.IO.Path.GetTempFileName%2A> method will raise an <xref:System.IO.IOException> if it is used to create more than 65535 files without deleting previous temporary files.</span></span>  
  
 <span data-ttu-id="7729c-473">O <xref:System.IO.Path.GetTempFileName%2A> método irá gerar um <xref:System.IO.IOException> se nenhum nome de arquivo temporário exclusivo está disponível.</span><span class="sxs-lookup"><span data-stu-id="7729c-473">The <xref:System.IO.Path.GetTempFileName%2A> method will raise an <xref:System.IO.IOException> if no unique temporary file name is available.</span></span> <span data-ttu-id="7729c-474">Para resolver esse erro, exclua todos os arquivos temporários desnecessários.</span><span class="sxs-lookup"><span data-stu-id="7729c-474">To resolve this error, delete all unneeded temporary files.</span></span>  
  
 <span data-ttu-id="7729c-475">Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).</span><span class="sxs-lookup"><span data-stu-id="7729c-475">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="7729c-476">Ocorre um erro de E/S; por exemplo, não há um nome de arquivo temporário exclusivo disponível.</span><span class="sxs-lookup"><span data-stu-id="7729c-476">An I/O error occurs, such as no unique temporary file name is available.</span></span>  
  
<span data-ttu-id="7729c-477">- ou -</span><span class="sxs-lookup"><span data-stu-id="7729c-477">-or-</span></span> 
<span data-ttu-id="7729c-478">Não foi possível criar um arquivo temporário com este método.</span><span class="sxs-lookup"><span data-stu-id="7729c-478">This method was unable to create a temporary file.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="7729c-479">para gravar no diretório temporário.</span><span class="sxs-lookup"><span data-stu-id="7729c-479">for writing to the temporary directory.</span></span> <span data-ttu-id="7729c-480">Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></span><span class="sxs-lookup"><span data-stu-id="7729c-480">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></span></span></permission>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="7729c-481">E/S de arquivo e de fluxo</span><span class="sxs-lookup"><span data-stu-id="7729c-481">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="7729c-482">Como ler texto de um arquivo</span><span class="sxs-lookup"><span data-stu-id="7729c-482">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="7729c-483">Como gravar texto em um arquivo</span><span class="sxs-lookup"><span data-stu-id="7729c-483">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetTempPath">
      <MemberSignature Language="C#" Value="public static string GetTempPath ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetTempPath() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetTempPath" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTempPath () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetTempPath();" />
      <MemberSignature Language="F#" Value="static member GetTempPath : unit -&gt; string" Usage="System.IO.Path.GetTempPath " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="7729c-484">Retorna o caminho da pasta temporária do usuário atual.</span><span class="sxs-lookup"><span data-stu-id="7729c-484">Returns the path of the current user's temporary folder.</span></span></summary>
        <returns><span data-ttu-id="7729c-485">O caminho para a pasta temporária, terminando com uma barra invertida.</span><span class="sxs-lookup"><span data-stu-id="7729c-485">The path to the temporary folder, ending with a backslash.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7729c-486">Esse método verifica a existência de variáveis de ambiente na seguinte ordem e usa o primeiro caminho encontrado:</span><span class="sxs-lookup"><span data-stu-id="7729c-486">This method checks for the existence of environment variables in the following order and uses the first path found:</span></span>  
  
1.  <span data-ttu-id="7729c-487">O caminho especificado pela variável de ambiente TMP.</span><span class="sxs-lookup"><span data-stu-id="7729c-487">The path specified by the TMP environment variable.</span></span>  
  
2.  <span data-ttu-id="7729c-488">O caminho especificado pela variável de ambiente TEMP.</span><span class="sxs-lookup"><span data-stu-id="7729c-488">The path specified by the TEMP environment variable.</span></span>  
  
3.  <span data-ttu-id="7729c-489">O caminho especificado pela variável de ambiente USERPROFILE.</span><span class="sxs-lookup"><span data-stu-id="7729c-489">The path specified by the USERPROFILE environment variable.</span></span>  
  
4.  <span data-ttu-id="7729c-490">O diretório do Windows.</span><span class="sxs-lookup"><span data-stu-id="7729c-490">The Windows directory.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7729c-491">O código a seguir mostra como chamar o <xref:System.IO.Path.GetTempPath%2A> método.</span><span class="sxs-lookup"><span data-stu-id="7729c-491">The following code shows how to call the <xref:System.IO.Path.GetTempPath%2A> method.</span></span>  
  
```vb  
result As String = Path.GetTempPath()  
Console.WriteLine(result)  
```  
  
```csharp  
string result = Path.GetTempPath();  
Console.WriteLine(result);  
```  
  
 <span data-ttu-id="7729c-492">Este exemplo produz uma saída semelhante à seguinte.</span><span class="sxs-lookup"><span data-stu-id="7729c-492">This example produces output similar to the following.</span></span>  
  
```  
C:\Users\UserName\AppData\Local\Temp\  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="7729c-493">O chamador não tem as permissões necessárias.</span><span class="sxs-lookup"><span data-stu-id="7729c-493">The caller does not have the required permissions.</span></span></exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission"><span data-ttu-id="7729c-494">Para obter acesso irrestrito a variáveis de ambiente.</span><span class="sxs-lookup"><span data-stu-id="7729c-494">for unrestricted access to environment variables.</span></span> <span data-ttu-id="7729c-495">Enumeração associada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></span><span class="sxs-lookup"><span data-stu-id="7729c-495">Associated enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></span></span></permission>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="7729c-496">E/S de arquivo e de fluxo</span><span class="sxs-lookup"><span data-stu-id="7729c-496">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="7729c-497">Como ler texto de um arquivo</span><span class="sxs-lookup"><span data-stu-id="7729c-497">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="7729c-498">Como gravar texto em um arquivo</span><span class="sxs-lookup"><span data-stu-id="7729c-498">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="HasExtension">
      <MemberSignature Language="C#" Value="public static bool HasExtension (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool HasExtension(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.HasExtension(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function HasExtension (path As ReadOnlySpan(Of Char)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool HasExtension(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member HasExtension : ReadOnlySpan&lt;char&gt; -&gt; bool" Usage="System.IO.Path.HasExtension path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="7729c-499">O caminho para pesquisar uma extensão.</span><span class="sxs-lookup"><span data-stu-id="7729c-499">The path to search for an extension.</span></span></param>
        <summary><span data-ttu-id="7729c-500">Determina se o caminho representado pelo intervalo de caracteres especificado inclui uma extensão de nome de arquivo.</span><span class="sxs-lookup"><span data-stu-id="7729c-500">Determines whether the path represented by the specified character span includes a file name extension.</span></span></summary>
        <returns><span data-ttu-id="7729c-501"><see langword="true" /> se o caractere após o último caractere separador de diretório ou separador de volume no caminho inclui um ponto (".") seguido por um ou mais caracteres; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="7729c-501"><see langword="true" /> if the characters that follow the last directory separator character or volume separator in the path include a period (".") followed by one or more characters; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

<span data-ttu-id="7729c-502">Um ponto à direita em `path` não é considerado uma extensão.</span><span class="sxs-lookup"><span data-stu-id="7729c-502">A trailing period in `path` is not considered an extension.</span></span>

         ]]></format>
        </remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="7729c-503">Formatos de caminho de arquivo em sistemas Windows</span><span class="sxs-lookup"><span data-stu-id="7729c-503">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="HasExtension">
      <MemberSignature Language="C#" Value="public static bool HasExtension (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool HasExtension(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.HasExtension(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function HasExtension (path As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool HasExtension(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member HasExtension : string -&gt; bool" Usage="System.IO.Path.HasExtension path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="7729c-504">O caminho para pesquisar uma extensão.</span><span class="sxs-lookup"><span data-stu-id="7729c-504">The path to search for an extension.</span></span></param>
        <summary><span data-ttu-id="7729c-505">Determina se um caminho inclui uma extensão de nome de arquivo.</span><span class="sxs-lookup"><span data-stu-id="7729c-505">Determines whether a path includes a file name extension.</span></span></summary>
        <returns><span data-ttu-id="7729c-506"><see langword="true" /> se o caractere que segue o último separador de diretório (\\\ ou /) ou o separador de volume (:) no caminho incluir um ponto (.) seguido por um ou mais caracteres; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="7729c-506"><see langword="true" /> if the characters that follow the last directory separator (\\\ or /) or volume separator (:) in the path include a period (.) followed by one or more characters; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7729c-507">A partir do final do `path`, esse método pesquisará um ponto (.) seguido pelo menos um caractere.</span><span class="sxs-lookup"><span data-stu-id="7729c-507">Starting from the end of `path`, this method searches for a period (.) followed by at least one character.</span></span> <span data-ttu-id="7729c-508">Se esse padrão for encontrado antes de uma <xref:System.IO.Path.DirectorySeparatorChar>, <xref:System.IO.Path.AltDirectorySeparatorChar>, ou <xref:System.IO.Path.VolumeSeparatorChar> caractere for encontrado, esse método retornará `true`.</span><span class="sxs-lookup"><span data-stu-id="7729c-508">If this pattern is found before a <xref:System.IO.Path.DirectorySeparatorChar>, <xref:System.IO.Path.AltDirectorySeparatorChar>, or <xref:System.IO.Path.VolumeSeparatorChar> character is encountered, this method returns `true`.</span></span>  
  
 <span data-ttu-id="7729c-509">Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).</span><span class="sxs-lookup"><span data-stu-id="7729c-509">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7729c-510">O exemplo a seguir demonstra o uso do método `HasExtension`.</span><span class="sxs-lookup"><span data-stu-id="7729c-510">The following example demonstrates the use of the `HasExtension` method.</span></span>  
  
 [!code-cpp[System.IO.Path Members#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#11)]
 [!code-csharp[System.IO.Path Members#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#11)]
 [!code-vb[System.IO.Path Members#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="7729c-511"><paramref name="path" /> contém um ou mais caracteres inválidos definidos em <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span><span class="sxs-lookup"><span data-stu-id="7729c-511"><paramref name="path" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></exception>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="7729c-512">Formatos de caminho de arquivo em sistemas Windows</span><span class="sxs-lookup"><span data-stu-id="7729c-512">File path formats on Windows systems</span></span></related>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="7729c-513">E/S de arquivo e de fluxo</span><span class="sxs-lookup"><span data-stu-id="7729c-513">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="7729c-514">Como ler texto de um arquivo</span><span class="sxs-lookup"><span data-stu-id="7729c-514">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="7729c-515">Como gravar texto em um arquivo</span><span class="sxs-lookup"><span data-stu-id="7729c-515">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="InvalidPathChars">
      <MemberSignature Language="C#" Value="public static readonly char[] InvalidPathChars;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char[] InvalidPathChars" />
      <MemberSignature Language="DocId" Value="F:System.IO.Path.InvalidPathChars" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InvalidPathChars As Char() " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly cli::array &lt;char&gt; ^ InvalidPathChars;" />
      <MemberSignature Language="F#" Value=" staticval mutable InvalidPathChars : char[]" Usage="System.IO.Path.InvalidPathChars" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("see GetInvalidPathChars and GetInvalidFileNameChars methods.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("Please use GetInvalidPathChars or GetInvalidFileNameChars instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="7729c-516">Fornece uma matriz de caracteres específica da plataforma que não pode ser especificada nos argumentos de cadeia de caracteres de caminho passados para membros da classe <see cref="T:System.IO.Path" />.</span><span class="sxs-lookup"><span data-stu-id="7729c-516">Provides a platform-specific array of characters that cannot be specified in path string arguments passed to members of the <see cref="T:System.IO.Path" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7729c-517">A matriz retornada por esse método não é garantida para conter o conjunto completo de caracteres que são inválidos em nomes de arquivo e diretório.</span><span class="sxs-lookup"><span data-stu-id="7729c-517">The array returned from this method is not guaranteed to contain the complete set of characters that are invalid in file and directory names.</span></span> <span data-ttu-id="7729c-518">O conjunto completo de caracteres inválidos pode variar por sistema de arquivos.</span><span class="sxs-lookup"><span data-stu-id="7729c-518">The full set of invalid characters can vary by file system.</span></span> <span data-ttu-id="7729c-519">Por exemplo, em plataformas de área de trabalho baseado em Windows, caracteres de caminho inválido podem incluir caracteres ASCII/Unicode de 1 a 31, bem como colocar entre aspas ("), menor que (\<), maior que (>), pipe (&#124;), backspace (\b), nulo (\0) e tabulação (\t).</span><span class="sxs-lookup"><span data-stu-id="7729c-519">For example, on Windows-based desktop platforms, invalid path characters might include ASCII/Unicode characters 1 through 31, as well as quote ("), less than (\<), greater than (>), pipe (&#124;), backspace (\b), null (\0) and tab (\t).</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="7729c-520">Não use <xref:System.IO.Path.InvalidPathChars> se você achar que seu código pode ser executado no mesmo domínio de aplicativo do código não confiável.</span><span class="sxs-lookup"><span data-stu-id="7729c-520">Do not use <xref:System.IO.Path.InvalidPathChars> if you think your code might execute in the same application domain as untrusted code.</span></span> <span data-ttu-id="7729c-521"><xref:System.IO.Path.InvalidPathChars> é uma matriz, portanto, seus elementos podem ser substituídos.</span><span class="sxs-lookup"><span data-stu-id="7729c-521"><xref:System.IO.Path.InvalidPathChars> is an array, so its elements can be overwritten.</span></span> <span data-ttu-id="7729c-522">Se o código não confiável substitui os elementos de <xref:System.IO.Path.InvalidPathChars>, ele pode fazer com que seu código funcione incorretamente de maneiras que podem ser exploradas.</span><span class="sxs-lookup"><span data-stu-id="7729c-522">If untrusted code overwrites elements of <xref:System.IO.Path.InvalidPathChars>, it might cause your code to malfunction in ways that could be exploited.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7729c-523">O exemplo a seguir demonstra o uso do `InvalidPathChars` propriedade.</span><span class="sxs-lookup"><span data-stu-id="7729c-523">The following example demonstrates the use of the `InvalidPathChars` property.</span></span>  
  
 [!code-cpp[System.IO.Path Members#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#13)]
 [!code-csharp[System.IO.Path Members#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#13)]
 [!code-vb[System.IO.Path Members#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#13)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="7729c-524">E/S de arquivo e de fluxo</span><span class="sxs-lookup"><span data-stu-id="7729c-524">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="7729c-525">Como ler texto de um arquivo</span><span class="sxs-lookup"><span data-stu-id="7729c-525">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="7729c-526">Como gravar texto em um arquivo</span><span class="sxs-lookup"><span data-stu-id="7729c-526">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsPathFullyQualified">
      <Docs>
        <summary><span data-ttu-id="7729c-527">Retorna um valor que indica se um caminho de arquivo é totalmente qualificado.</span><span class="sxs-lookup"><span data-stu-id="7729c-527">Returns a value that indicates whether a file path is fully qualified.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
 
## Remarks  

<span data-ttu-id="7729c-528">As sobrecargas do `IsPathFullyQualified` caminhos de identificador de método que usam o <xref:System.IO.Path.DirectorySeparatorChar> e o <xref:System.IO.Path.AltDirectorySeparatorChar> caracteres.</span><span class="sxs-lookup"><span data-stu-id="7729c-528">The overloads of the `IsPathFullyQualified` method handle paths that use both the <xref:System.IO.Path.DirectorySeparatorChar> and the <xref:System.IO.Path.AltDirectorySeparatorChar> characters.</span></span> <span data-ttu-id="7729c-529">Ele não executa nenhuma validação no caminho que é passado para ele como um argumento.</span><span class="sxs-lookup"><span data-stu-id="7729c-529">It does not perform any validation on the path that is passed to it as an argument.</span></span> <span data-ttu-id="7729c-530">Como resultado, os URIs são interpretados como caminhos relativos e retornar `false`.</span><span class="sxs-lookup"><span data-stu-id="7729c-530">As a result, URIs are interpreted as relative paths and return `false`.</span></span> 

<span data-ttu-id="7729c-531">Há uma diferença entre um caminho totalmente qualificado (conforme indicado pelo `IsPathFullyQualified` método) e um caminho com raiz (conforme indicado pelo <xref:System.IO.Path.IsPathRooted%2A> método).</span><span class="sxs-lookup"><span data-stu-id="7729c-531">There is a difference between a fully qualified path (as indicated by the `IsPathFullyQualified` method) and a rooted path (as indicated by the <xref:System.IO.Path.IsPathRooted%2A> method).</span></span> <span data-ttu-id="7729c-532">Um *caminho totalmente qualificado* ou *caminho absoluto* sempre define um caminho exato de uma determinada unidade ou dispositivo para um arquivo de destino ou diretório e não depende da unidade atual ou o diretório atual.</span><span class="sxs-lookup"><span data-stu-id="7729c-532">A *fully qualified path* or *absolute path* always defines an exact path from a particular drive or device to a target file or directory, and does not depend on the current drive or current directory.</span></span> <span data-ttu-id="7729c-533">Por exemplo, em sistemas Windows, *C:/users/user1/documents/reports/2019/january/highlights.pdf* define um caminho absoluto da raiz da unidade c para o arquivo de destino *highlights.pdf*.</span><span class="sxs-lookup"><span data-stu-id="7729c-533">For example, on Windows systems, *C:/users/user1/documents/reports/2019/january/highlights.pdf* defines an absolute path from the root of the C: drive to the target file, *highlights.pdf*.</span></span> <span data-ttu-id="7729c-534">Um *caminho com raiz* Especifica uma unidade inicial ou o diretório raiz, mas depende do diretório atual (se ele está na raiz por uma unidade especificada) ou a unidade atual (se ele está com o diretório raiz para a raiz).</span><span class="sxs-lookup"><span data-stu-id="7729c-534">A *rooted path* specifies either a starting drive or root directory, but depends on either the current directory (if it is rooted by a specified drive) or the current drive (if it is rooted by the root directory).</span></span> <span data-ttu-id="7729c-535">O exemplo a seguir ilustra a diferença entre os caminhos totalmente qualificados e caminhos com raiz.</span><span class="sxs-lookup"><span data-stu-id="7729c-535">The following example illustrates the difference between fully qualified paths and rooted paths.</span></span>

[!code-csharp[IsPathRooted](~/samples/snippets/csharp/api/system.IO/Path/IsPathRooted/program.cs)]
[!code-vb[IsPathRooted](~/samples/snippets/visualbasic/api/system.IO/Path/IsPathRooted/program.vb)]

         ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsPathFullyQualified">
      <MemberSignature Language="C#" Value="public static bool IsPathFullyQualified (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPathFullyQualified(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.IsPathFullyQualified(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPathFullyQualified (path As ReadOnlySpan(Of Char)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPathFullyQualified(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member IsPathFullyQualified : ReadOnlySpan&lt;char&gt; -&gt; bool" Usage="System.IO.Path.IsPathFullyQualified path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="7729c-536">Um caminho de arquivo.</span><span class="sxs-lookup"><span data-stu-id="7729c-536">A file path.</span></span></param>
        <summary><span data-ttu-id="7729c-537">Retorna um valor que indica se o caminho de arquivo representado pelo intervalo de caracteres especificado está fixo em uma unidade ou um caminho UNC específico.</span><span class="sxs-lookup"><span data-stu-id="7729c-537">Returns a value that indicates whether the file path represented by the specified character span is fixed to a specific drive or UNC path.</span></span></summary>
        <returns><span data-ttu-id="7729c-538"><see langword="true" /> se o caminho está fixo em uma unidade ou um caminho UNC específico; <see langword="false" /> se o caminho é relativo à unidade ou ao diretório de trabalho atual.</span><span class="sxs-lookup"><span data-stu-id="7729c-538"><see langword="true" /> if the path is fixed to a specific drive or UNC path; <see langword="false" /> if the path is relative to the current drive or working directory.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  


         ]]></format>
        </remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="7729c-539">Formatos de caminho de arquivo em sistemas Windows</span><span class="sxs-lookup"><span data-stu-id="7729c-539">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsPathFullyQualified">
      <MemberSignature Language="C#" Value="public static bool IsPathFullyQualified (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPathFullyQualified(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.IsPathFullyQualified(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPathFullyQualified (path As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPathFullyQualified(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member IsPathFullyQualified : string -&gt; bool" Usage="System.IO.Path.IsPathFullyQualified path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="7729c-540">Um caminho de arquivo.</span><span class="sxs-lookup"><span data-stu-id="7729c-540">A file path.</span></span></param>
        <summary><span data-ttu-id="7729c-541">Retorna um valor que indica se o caminho de arquivo especificado está fixo em uma unidade ou um caminho UNC específico.</span><span class="sxs-lookup"><span data-stu-id="7729c-541">Returns a value that indicates whether the specified file path is fixed to a specific drive or UNC path.</span></span></summary>
        <returns><span data-ttu-id="7729c-542"><see langword="true" /> se o caminho está fixo em uma unidade ou um caminho UNC específico; <see langword="false" /> se o caminho é relativo à unidade ou ao diretório de trabalho atual.</span><span class="sxs-lookup"><span data-stu-id="7729c-542"><see langword="true" /> if the path is fixed to a specific drive or UNC path; <see langword="false" /> if the path is relative to the current drive or working directory.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7729c-543"><paramref name="path" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="7729c-543"><paramref name="path" /> is <see langword="null" />.</span></span></exception>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="7729c-544">Formatos de caminho de arquivo em sistemas Windows</span><span class="sxs-lookup"><span data-stu-id="7729c-544">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsPathRooted">
      <Docs>
        <summary><span data-ttu-id="7729c-545">Retorna um valor que indica se um caminho de arquivo contém uma raiz.</span><span class="sxs-lookup"><span data-stu-id="7729c-545">Returns a value that indicates whether a file path contains a root.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
 
## Remarks  

<span data-ttu-id="7729c-546">Um **caminho com raiz** é o caminho do arquivo que é fixo para uma unidade específica ou um caminho de UNIX; ela contrasta com um caminho relativo a unidade atual ou o diretório de trabalho.</span><span class="sxs-lookup"><span data-stu-id="7729c-546">A **rooted path** is file path that is fixed to a specific drive or UNIC path; it contrasts with a path that is relative to the current drive or working directory.</span></span> <span data-ttu-id="7729c-547">Por exemplo, em sistemas Windows, um caminho com raiz começa com uma barra invertida (por exemplo, "\Documents") ou uma letra de unidade e dois-pontos (por exemplo, "C:Documents").</span><span class="sxs-lookup"><span data-stu-id="7729c-547">For example, on Windows systems, a rooted path begins with a backslash (for example, "\Documents") or a drive letter and colon (for example, "C:Documents").</span></span> 

<span data-ttu-id="7729c-548">Observe que os caminhos com raiz podem ser absoluto (isto é, totalmente qualificado) ou relativo.</span><span class="sxs-lookup"><span data-stu-id="7729c-548">Note that rooted paths can be either absolute (that is, fully qualified) or relative.</span></span> <span data-ttu-id="7729c-549">Um caminho com raiz absoluto é um caminho totalmente qualificado da raiz de uma unidade para um diretório específico.</span><span class="sxs-lookup"><span data-stu-id="7729c-549">An absolute rooted path is a fully qualified path from the root of a drive to a specific directory.</span></span> <span data-ttu-id="7729c-550">Um caminho com raiz relativo Especifica uma unidade, mas o caminho totalmente qualificado é resolvido em relação ao diretório atual.</span><span class="sxs-lookup"><span data-stu-id="7729c-550">A relative rooted path specifies a drive, but its fully qualified path is resolved against the current directory.</span></span> <span data-ttu-id="7729c-551">O exemplo a seguir ilustra a diferença.</span><span class="sxs-lookup"><span data-stu-id="7729c-551">The following example illustrates the difference.</span></span>

[!code-csharp[IsPathRooted](~/samples/snippets/csharp/api/system.IO/Path/IsPathRooted/program.cs)]
[!code-vb[IsPathRooted](~/samples/snippets/visualbasic/api/system.IO/Path/IsPathRooted/program.vb)]

         ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsPathRooted">
      <MemberSignature Language="C#" Value="public static bool IsPathRooted (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPathRooted(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.IsPathRooted(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPathRooted (path As ReadOnlySpan(Of Char)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPathRooted(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member IsPathRooted : ReadOnlySpan&lt;char&gt; -&gt; bool" Usage="System.IO.Path.IsPathRooted path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="7729c-552">O caminho a ser testado.</span><span class="sxs-lookup"><span data-stu-id="7729c-552">The path to test.</span></span></param>
        <summary><span data-ttu-id="7729c-553">Retorna um valor que indica se o intervalo de caracteres especificado que representa um caminho de arquivo contém uma raiz.</span><span class="sxs-lookup"><span data-stu-id="7729c-553">Returns a value that indicates whether the specified character span that represents a file path contains a root.</span></span></summary>
        <returns><span data-ttu-id="7729c-554"><see langword="true" /> se <paramref name="path" /> contém uma raiz; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="7729c-554"><see langword="true" /> if <paramref name="path" /> contains a root; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="7729c-555">Formatos de caminho de arquivo em sistemas Windows</span><span class="sxs-lookup"><span data-stu-id="7729c-555">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsPathRooted">
      <MemberSignature Language="C#" Value="public static bool IsPathRooted (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPathRooted(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.IsPathRooted(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPathRooted (path As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPathRooted(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member IsPathRooted : string -&gt; bool" Usage="System.IO.Path.IsPathRooted path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="7729c-556">O caminho a ser testado.</span><span class="sxs-lookup"><span data-stu-id="7729c-556">The path to test.</span></span></param>
        <summary><span data-ttu-id="7729c-557">Retorna um valor que indica se a cadeia de caracteres do caminho especificado contém uma raiz.</span><span class="sxs-lookup"><span data-stu-id="7729c-557">Returns a value indicating whether the specified path string contains a root.</span></span></summary>
        <returns><span data-ttu-id="7729c-558"><see langword="true" /> se <paramref name="path" /> contém uma raiz; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="7729c-558"><see langword="true" /> if <paramref name="path" /> contains a root; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7729c-559">O <xref:System.IO.Path.IsPathRooted%2A> retorn `true` se o primeiro caractere é um caractere separador de diretório, como "\\", ou se o caminho começa com uma letra de unidade e dois-pontos (:).</span><span class="sxs-lookup"><span data-stu-id="7729c-559">The <xref:System.IO.Path.IsPathRooted%2A> method returns `true` if the first character is a directory separator character such as "\\", or if the path starts with a drive letter and colon (:).</span></span> <span data-ttu-id="7729c-560">Por exemplo, ele retorna `true` para `path` cadeias de caracteres como "\\\MyDir\\\MyFile.txt", "c:\\\MyDir", ou "C:MyDir".</span><span class="sxs-lookup"><span data-stu-id="7729c-560">For example, it returns `true` for `path` strings such as "\\\MyDir\\\MyFile.txt", "C:\\\MyDir", or "C:MyDir".</span></span> <span data-ttu-id="7729c-561">Ele retorna `false` para `path` cadeias de caracteres como "MyDir".</span><span class="sxs-lookup"><span data-stu-id="7729c-561">It returns `false` for `path` strings such as "MyDir".</span></span>  
  
 <span data-ttu-id="7729c-562">Esse método não verifica se o nome de caminho ou arquivo existe.</span><span class="sxs-lookup"><span data-stu-id="7729c-562">This method does not verify that the path or file name exists.</span></span>  
  
 <span data-ttu-id="7729c-563">Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).</span><span class="sxs-lookup"><span data-stu-id="7729c-563">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  

## Examples  
 <span data-ttu-id="7729c-564">O exemplo a seguir demonstra como o `IsPathRooted` método pode ser usado para testar as três cadeias de caracteres.</span><span class="sxs-lookup"><span data-stu-id="7729c-564">The following example demonstrates how the `IsPathRooted` method can be used to test three strings.</span></span>  
  
 [!code-cpp[System.IO.Path Members#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#12)]
 [!code-csharp[System.IO.Path Members#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#12)]
 [!code-vb[System.IO.Path Members#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="7729c-565"><paramref name="path" /> contém um ou mais caracteres inválidos definidos em <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span><span class="sxs-lookup"><span data-stu-id="7729c-565"><paramref name="path" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></exception>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="7729c-566">Formatos de caminho de arquivo em sistemas Windows</span><span class="sxs-lookup"><span data-stu-id="7729c-566">File path formats on Windows systems</span></span></related>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="7729c-567">E/S de arquivo e de fluxo</span><span class="sxs-lookup"><span data-stu-id="7729c-567">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="7729c-568">Como ler texto de um arquivo</span><span class="sxs-lookup"><span data-stu-id="7729c-568">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="7729c-569">Como gravar texto em um arquivo</span><span class="sxs-lookup"><span data-stu-id="7729c-569">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(valuetype System.ReadOnlySpan`1&lt;char&gt; path1, valuetype System.ReadOnlySpan`1&lt;char&gt; path2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Join(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (path1 As ReadOnlySpan(Of Char), path2 As ReadOnlySpan(Of Char)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2);" />
      <MemberSignature Language="F#" Value="static member Join : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; -&gt; string" Usage="System.IO.Path.Join (path1, path2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="path2" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path1"><span data-ttu-id="7729c-570">Um intervalo de caracteres que contém o primeiro caminho a ser unido.</span><span class="sxs-lookup"><span data-stu-id="7729c-570">A character span that contains the first path to join.</span></span></param>
        <param name="path2"><span data-ttu-id="7729c-571">Um intervalo de caracteres que contém o segundo caminho a ser unido.</span><span class="sxs-lookup"><span data-stu-id="7729c-571">A character span that contains the second path to join.</span></span></param>
        <summary><span data-ttu-id="7729c-572">Concatena componentes de dois caminhos em um único caminho.</span><span class="sxs-lookup"><span data-stu-id="7729c-572">Concatenates two path components into a single path.</span></span></summary>
        <returns><span data-ttu-id="7729c-573">Os caminhos combinados.</span><span class="sxs-lookup"><span data-stu-id="7729c-573">The combined paths.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 
<span data-ttu-id="7729c-574">Esse método simplesmente concatena `path` e `path2` e adiciona um caractere de separador de diretório entre os componentes do caminho de dois, se um já não estiver presente no final da `path1` ou o início da `path2`.</span><span class="sxs-lookup"><span data-stu-id="7729c-574">This method simply concatenates `path` and `path2` and adds a directory separator character between the two path components if one is not already present at the end of `path1` or the beginning of `path2`.</span></span> <span data-ttu-id="7729c-575">Se o <xref:System.ReadOnlySpan%601.Length> deles `path1` ou `path2` for zero, o método retornará o outro caminho.</span><span class="sxs-lookup"><span data-stu-id="7729c-575">If the <xref:System.ReadOnlySpan%601.Length> of either `path1` or `path2` is zero, the method returns the other path.</span></span> <span data-ttu-id="7729c-576">Se o <xref:System.ReadOnlySpan%601.Length> de ambos `path1` e `path2` for zero, o método retorna <xref:System.String.Empty?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="7729c-576">If the <xref:System.ReadOnlySpan%601.Length> of both `path1` and `path2` is zero, the method returns <xref:System.String.Empty?displayProperty=nameWithType>.</span></span> 

<span data-ttu-id="7729c-577">Se `path1` termina em um caractere de separador de caminho que não é adequado para a plataforma de destino, o `Join` método preserva o caractere separador de caminho original e acrescenta tem suporte.</span><span class="sxs-lookup"><span data-stu-id="7729c-577">If `path1` ends in a path separator character that is not appropriate for the target platform, the `Join` method preserves the original path separator character and appends the supported one.</span></span> <span data-ttu-id="7729c-578">Esse problema surge em caminhos embutidos que usam Windows barra invertida ("\") caractere, que não é reconhecido como um separador de caminho em sistemas baseados em Unix.</span><span class="sxs-lookup"><span data-stu-id="7729c-578">This issue arises in hard-coded paths that use the Windows backslash ("\") character, which is not recognized as a path separator on Unix-based systems.</span></span> <span data-ttu-id="7729c-579">Para contornar esse problema, você pode:</span><span class="sxs-lookup"><span data-stu-id="7729c-579">To work around this issue, you can:</span></span>

- <span data-ttu-id="7729c-580">Recuperar o valor da <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> propriedade em vez de embutir um caractere separador de diretório.</span><span class="sxs-lookup"><span data-stu-id="7729c-580">Retrieve the value of the <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> property rather than hard-coding a directory separator character.</span></span>

- <span data-ttu-id="7729c-581">Use uma barra invertida ("/") como o caractere separador de diretório.</span><span class="sxs-lookup"><span data-stu-id="7729c-581">Use a forward slash ("/") as the directory separator character.</span></span> <span data-ttu-id="7729c-582">Esse caractere é retornado pelo <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> propriedade em sistemas baseados em Unix e pelo <xref:System.IO.Path.AltDirectorySeparatorChar?displayProperty=nameWithType> propriedade nos sistemas Windows.</span><span class="sxs-lookup"><span data-stu-id="7729c-582">This character is returned by the <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> property on Unix-based systems and by the <xref:System.IO.Path.AltDirectorySeparatorChar?displayProperty=nameWithType> property on Windows systems.</span></span> 

<span data-ttu-id="7729c-583">Ao contrário do <xref:System.IO.Path.Combine%2A> método, o <xref:System.IO.Path.Join%2A> método não tenta o caminho retornado da raiz.</span><span class="sxs-lookup"><span data-stu-id="7729c-583">Unlike the <xref:System.IO.Path.Combine%2A> method, the <xref:System.IO.Path.Join%2A> method does not attempt to root the returned path.</span></span> <span data-ttu-id="7729c-584">(Ou seja, se `path2` é um caminho absoluto, o `Join` método não descarta `path1` e retornar `path2` como o <xref:System.IO.Path.Combine%2A> que o método.) O exemplo a seguir ilustra a diferença nos caminhos retornados por dois métodos.</span><span class="sxs-lookup"><span data-stu-id="7729c-584">(That is, if `path2` is an absolute path, the `Join` method does not discard `path1` and return `path2` as the <xref:System.IO.Path.Combine%2A> method does.) The following example illustrates the difference in the paths returned by the two methods.</span></span> <span data-ttu-id="7729c-585">Se a origem do `path2` é a entrada do usuário, o <xref:System.IO.Path.Combine%2A> método torna possível para um usuário acessar um recurso do sistema de arquivos (como *c: /usuários/User1/documentos/Finanças/* no caso do exemplo) que o aplicativo fez não pretendemos tornar acessível.</span><span class="sxs-lookup"><span data-stu-id="7729c-585">If the source of `path2` is user input, the <xref:System.IO.Path.Combine%2A> method makes it possible for a user to access a file system resource (such as *C:/Users/User1/Documents/Financial/* in the case of the example) that the application did not intend to make accessible.</span></span>  

<span data-ttu-id="7729c-586">Nem todos os caracteres inválidos para nomes de arquivo e diretório são interpretados como inaceitáveis pelo `Join` método, porque você pode usar esses caracteres para caracteres curinga de pesquisa.</span><span class="sxs-lookup"><span data-stu-id="7729c-586">Not all invalid characters for directory and file names are interpreted as unacceptable by the `Join` method, because you can use these characters for search wildcard characters.</span></span> <span data-ttu-id="7729c-587">Por exemplo, embora `Path.Join("c:\\", "*.txt")` pode ser inválido quando criar um arquivo, ele é válido como uma cadeia de caracteres de pesquisa.</span><span class="sxs-lookup"><span data-stu-id="7729c-587">For example, while `Path.Join("c:\\", "*.txt")` might be invalid when creating a file, it is valid as a search string.</span></span> <span data-ttu-id="7729c-588">O `Join` método, portanto, com êxito interpretará.</span><span class="sxs-lookup"><span data-stu-id="7729c-588">The `Join` method therefore successfully interprets it.</span></span> 

## <a name="example"></a><span data-ttu-id="7729c-589">Exemplo</span><span class="sxs-lookup"><span data-stu-id="7729c-589">Example</span></span>

<span data-ttu-id="7729c-590">O exemplo a seguir ilustra a diferença nos caminhos retornados pela <xref:System.IO.Path.Join(System.ReadOnlySpan%7BSystem.Char%7D,System.ReadOnlySpan%7BSystem.Char%7D)?displayProperty=nameWithType> e <xref:System.IO.Path.Combine(System.String,System.String)?displayProperty=nameWithType> métodos.</span><span class="sxs-lookup"><span data-stu-id="7729c-590">The following example illustrates the difference in the paths returned by the <xref:System.IO.Path.Join(System.ReadOnlySpan%7BSystem.Char%7D,System.ReadOnlySpan%7BSystem.Char%7D)?displayProperty=nameWithType> and <xref:System.IO.Path.Combine(System.String,System.String)?displayProperty=nameWithType> methods.</span></span> <span data-ttu-id="7729c-591">Quando a primeira cadeia de caracteres é um caminho totalmente qualificado que inclui um unidade e o diretório raiz e o segundo é um caminho relativo do primeiro caminho, os dois métodos produzem resultados idênticos.</span><span class="sxs-lookup"><span data-stu-id="7729c-591">When the first string is an fully qualified path that includes a drive and root directory and the second is a relative path from the first path, the two methods produce identical results.</span></span> <span data-ttu-id="7729c-592">Na segunda e terceira chamadas para o `ShowPathInformation` divergem do método, as cadeias de caracteres retornadas pelos dois métodos.</span><span class="sxs-lookup"><span data-stu-id="7729c-592">In the second and third calls to the `ShowPathInformation` method, the strings returned by the two methods diverge.</span></span> <span data-ttu-id="7729c-593">Na segunda chamada do método, a cadeia de caracteres do primeiro argumento é uma unidade, enquanto o segundo é um diretório raiz.</span><span class="sxs-lookup"><span data-stu-id="7729c-593">In the second method call, the first string argument is a drive, while the second is a rooted directory.</span></span> <span data-ttu-id="7729c-594">O `Join` método concatena duas cadeias de caracteres e preserva duplicar separadores de caminho.</span><span class="sxs-lookup"><span data-stu-id="7729c-594">The `Join` method concatenates the two strings and preserves duplicate path separators.</span></span> <span data-ttu-id="7729c-595">O `Combine` método abandona a unidade e retorna um diretório raiz da unidade atual.</span><span class="sxs-lookup"><span data-stu-id="7729c-595">The `Combine` method abandons the drive and returns a rooted directory on the current drive.</span></span> <span data-ttu-id="7729c-596">Se o aplicativo atual da unidade é C:\ e a cadeia de caracteres é usada para acessar um arquivo ou arquivos no diretório, ele teria acesso c: em vez de d:.</span><span class="sxs-lookup"><span data-stu-id="7729c-596">If the application's current drive is C:\ and the string is used to access a file or files in the directory, it would access C: instead of D:.</span></span> <span data-ttu-id="7729c-597">Por fim, porque ambos os argumentos na terceira chamada para `ShowPathInformation` estão vinculados, o `Join` método simplesmente acrescenta-os para criar um caminho de arquivo não fizer sentido, enquanto o `Combine` método descarta a primeira cadeia de caracteres e retorna o segundo.</span><span class="sxs-lookup"><span data-stu-id="7729c-597">Finally, because both arguments in the third call to `ShowPathInformation` are rooted, the `Join` method simply appends them to create a nonsensical file path, while the `Combine` method discards the first string and returns the second.</span></span> <span data-ttu-id="7729c-598">Usando essa cadeia de caracteres para o acesso a arquivos poderia dar ao aplicativo acesso involuntário a arquivos confidenciais.</span><span class="sxs-lookup"><span data-stu-id="7729c-598">Using this string for file access could give the application unintended access to sensitive files.</span></span>  

[!code-csharp[Path.Join(String,String)](~/samples/snippets/csharp/api/system.io/path/combine2/program.cs)]
[!code-csharp[Path.Join(String,String)](~/samples/snippets/visualbasic/api/system.io/path/combine2/program.vb)]


       ]]></format>
        </remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="7729c-599">Formatos de caminho de arquivo em sistemas Windows</span><span class="sxs-lookup"><span data-stu-id="7729c-599">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string path1, string path2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string path1, string path2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Join(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (path1 As String, path2 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ path1, System::String ^ path2);" />
      <MemberSignature Language="F#" Value="static member Join : string * string -&gt; string" Usage="System.IO.Path.Join (path1, path2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="path2" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="path1">To be added.</param>
        <param name="path2">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, ReadOnlySpan&lt;char&gt; path3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(valuetype System.ReadOnlySpan`1&lt;char&gt; path1, valuetype System.ReadOnlySpan`1&lt;char&gt; path2, valuetype System.ReadOnlySpan`1&lt;char&gt; path3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Join(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (path1 As ReadOnlySpan(Of Char), path2 As ReadOnlySpan(Of Char), path3 As ReadOnlySpan(Of Char)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, ReadOnlySpan&lt;char&gt; path3);" />
      <MemberSignature Language="F#" Value="static member Join : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; -&gt; string" Usage="System.IO.Path.Join (path1, path2, path3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="path2" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="path3" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path1"><span data-ttu-id="7729c-600">Um intervalo de caracteres que contém o primeiro caminho a ser unido.</span><span class="sxs-lookup"><span data-stu-id="7729c-600">A character span that contains the first path to join.</span></span></param>
        <param name="path2"><span data-ttu-id="7729c-601">Um intervalo de caracteres que contém o segundo caminho a ser unido.</span><span class="sxs-lookup"><span data-stu-id="7729c-601">A character span that contains the second path to join.</span></span></param>
        <param name="path3"><span data-ttu-id="7729c-602">Um intervalo de caracteres que contém o terceiro caminho a ser unido.</span><span class="sxs-lookup"><span data-stu-id="7729c-602">A character span that contains the third path to join.</span></span></param>
        <summary><span data-ttu-id="7729c-603">Concatena componentes de três caminhos em um único caminho.</span><span class="sxs-lookup"><span data-stu-id="7729c-603">Concatenates three path components into a single path.</span></span></summary>
        <returns>To be added.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 
<span data-ttu-id="7729c-604">Esse método simplesmente concatena `path`, `path2`, e `path3` e adiciona um caractere de separador de diretório entre qualquer um dos componentes de caminho, se ele ainda não está presente.</span><span class="sxs-lookup"><span data-stu-id="7729c-604">This method simply concatenates `path`, `path2`, and `path3` and adds a directory separator character between any of the path components if one is not already present.</span></span> <span data-ttu-id="7729c-605">Se o <xref:System.ReadOnlySpan%601.Length> de qualquer uma das `path1`, `path2`, ou `path3` argumento for zero, o método concatena os argumentos restantes.</span><span class="sxs-lookup"><span data-stu-id="7729c-605">If the <xref:System.ReadOnlySpan%601.Length> of any of `path1`, `path2`, or `path3` argument is zero, the method concatenates the remaining arguments.</span></span> <span data-ttu-id="7729c-606">Se o <xref:System.ReadOnlySpan%601.Length?displayProperty=nameWithType> de todos os componentes é zero, o método retorna <xref:System.String.Empty?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="7729c-606">If the <xref:System.ReadOnlySpan%601.Length?displayProperty=nameWithType> of all components is zero, the method returns <xref:System.String.Empty?displayProperty=nameWithType>.</span></span>    

<span data-ttu-id="7729c-607">Se `path1` ou `path2` termina em um caractere de separador de caminho que não é adequado para a plataforma de destino, o `Join` método preserva o caractere separador de caminho original e acrescenta tem suporte.</span><span class="sxs-lookup"><span data-stu-id="7729c-607">If `path1` or `path2` ends in a path separator character that is not appropriate for the target platform, the `Join` method preserves the original path separator character and appends the supported one.</span></span> <span data-ttu-id="7729c-608">Esse problema surge em caminhos embutidos que usam Windows barra invertida ("\") caractere, que não é reconhecido como um separador de caminho em sistemas baseados em Unix.</span><span class="sxs-lookup"><span data-stu-id="7729c-608">This issue arises in hard-coded paths that use the Windows backslash ("\") character, which is not recognized as a path separator on Unix-based systems.</span></span> <span data-ttu-id="7729c-609">Para contornar esse problema, você pode:</span><span class="sxs-lookup"><span data-stu-id="7729c-609">To work around this issue, you can:</span></span>

- <span data-ttu-id="7729c-610">Recuperar o valor da <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> propriedade em vez de embutir um caractere separador de diretório.</span><span class="sxs-lookup"><span data-stu-id="7729c-610">Retrieve the value of the <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> property rather than hard-coding a directory separator character.</span></span>

- <span data-ttu-id="7729c-611">Use uma barra invertida ("/") como o caractere separador de diretório.</span><span class="sxs-lookup"><span data-stu-id="7729c-611">Use a forward slash ("/") as the directory separator character.</span></span> <span data-ttu-id="7729c-612">Esse caractere é retornado pelo <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> propriedade em sistemas baseados em Unix e pelo <xref:System.IO.Path.AltDirectorySeparatorChar?displayProperty=nameWithType> propriedade nos sistemas Windows.</span><span class="sxs-lookup"><span data-stu-id="7729c-612">This character is returned by the <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> property on Unix-based systems and by the <xref:System.IO.Path.AltDirectorySeparatorChar?displayProperty=nameWithType> property on Windows systems.</span></span> 

<span data-ttu-id="7729c-613">Ao contrário do <xref:System.IO.Path.Combine%2A> método, o <xref:System.IO.Path.Join%2A> método não tenta o caminho retornado da raiz.</span><span class="sxs-lookup"><span data-stu-id="7729c-613">Unlike the <xref:System.IO.Path.Combine%2A> method, the <xref:System.IO.Path.Join%2A> method does not attempt to root the returned path.</span></span> <span data-ttu-id="7729c-614">(Ou seja, se `path2` ou `path2` é um caminho absoluto, o `Join` método não descarta os caminhos anteriores como o <xref:System.IO.Path.Combine%2A> método faz.</span><span class="sxs-lookup"><span data-stu-id="7729c-614">(That is, if `path2` or `path2` is an absolute path, the `Join` method does not discard the previous paths as the <xref:System.IO.Path.Combine%2A> method does.</span></span>  
  
<span data-ttu-id="7729c-615">Nem todos os caracteres inválidos para nomes de arquivo e diretório são interpretados como inaceitáveis pelo `Join` método, porque você pode usar esses caracteres para caracteres curinga de pesquisa.</span><span class="sxs-lookup"><span data-stu-id="7729c-615">Not all invalid characters for directory and file names are interpreted as unacceptable by the `Join` method, because you can use these characters for search wildcard characters.</span></span> <span data-ttu-id="7729c-616">Por exemplo, embora `Path.Join("c:\\", "temp", "*.txt")` pode ser inválido quando criar um arquivo, ele é válido como uma cadeia de caracteres de pesquisa.</span><span class="sxs-lookup"><span data-stu-id="7729c-616">For example, while `Path.Join("c:\\", "temp", "*.txt")` might be invalid when creating a file, it is valid as a search string.</span></span> <span data-ttu-id="7729c-617">O `Join` método, portanto, com êxito interpretará.</span><span class="sxs-lookup"><span data-stu-id="7729c-617">The `Join` method therefore successfully interprets it.</span></span> 

## <a name="example"></a><span data-ttu-id="7729c-618">Exemplo</span><span class="sxs-lookup"><span data-stu-id="7729c-618">Example</span></span>

<span data-ttu-id="7729c-619">O exemplo a seguir ilustra a diferença nos caminhos retornados pela <xref:System.IO.Path.Join(System.ReadOnlySpan%7BSystem.Char%7D,System.ReadOnlySpan%7BSystem.Char%7D,System.ReadOnlySpan%7BSystem.Char%7D)?displayProperty=nameWithType> e <xref:System.IO.Path.Combine(System.String,System.String,System.String)?displayProperty=nameWithType> métodos.</span><span class="sxs-lookup"><span data-stu-id="7729c-619">The following example illustrates the difference in the paths returned by the <xref:System.IO.Path.Join(System.ReadOnlySpan%7BSystem.Char%7D,System.ReadOnlySpan%7BSystem.Char%7D,System.ReadOnlySpan%7BSystem.Char%7D)?displayProperty=nameWithType> and <xref:System.IO.Path.Combine(System.String,System.String,System.String)?displayProperty=nameWithType> methods.</span></span> <span data-ttu-id="7729c-620">Quando a primeira cadeia de caracteres é um caminho totalmente qualificado que inclui um unidade e o diretório raiz e o segundo é um caminho relativo do primeiro caminho, os dois métodos produzem resultados idênticos.</span><span class="sxs-lookup"><span data-stu-id="7729c-620">When the first string is an fully qualified path that includes a drive and root directory and the second is a relative path from the first path, the two methods produce identical results.</span></span> <span data-ttu-id="7729c-621">Na segunda e terceira chamadas para o `ShowPathInformation` divergem do método, as cadeias de caracteres retornadas pelos dois métodos.</span><span class="sxs-lookup"><span data-stu-id="7729c-621">In the second and third calls to the `ShowPathInformation` method, the strings returned by the two methods diverge.</span></span> <span data-ttu-id="7729c-622">Na segunda chamada do método, a cadeia de caracteres do primeiro argumento é uma unidade, enquanto o segundo é um diretório raiz.</span><span class="sxs-lookup"><span data-stu-id="7729c-622">In the second method call, the first string argument is a drive, while the second is a rooted directory.</span></span> <span data-ttu-id="7729c-623">O `Join` método concatena duas cadeias de caracteres e preserva duplicar separadores de caminho.</span><span class="sxs-lookup"><span data-stu-id="7729c-623">The `Join` method concatenates the two strings and preserves duplicate path separators.</span></span> <span data-ttu-id="7729c-624">Uma chamada para o <xref:System.IO.Path.GetFullPath%2A> método seria eliminar a duplicação.</span><span class="sxs-lookup"><span data-stu-id="7729c-624">A call to the <xref:System.IO.Path.GetFullPath%2A> method would eliminate the duplication.</span></span> <span data-ttu-id="7729c-625">O `Combine` método abandona a unidade e retorna um diretório raiz da unidade atual.</span><span class="sxs-lookup"><span data-stu-id="7729c-625">The `Combine` method abandons the drive and returns a rooted directory on the current drive.</span></span> <span data-ttu-id="7729c-626">Se o aplicativo atual da unidade é C:\ e a cadeia de caracteres é usada para acessar um arquivo ou arquivos no diretório, ele teria acesso c: em vez de d:.</span><span class="sxs-lookup"><span data-stu-id="7729c-626">If the application's current drive is C:\ and the string is used to access a file or files in the directory, it would access C: instead of D:.</span></span> <span data-ttu-id="7729c-627">Por fim, porque o argumento final na terceira chamada para `ShowPathInformation` estão vinculados, o `Join` método acrescenta simplesmente para os dois primeiros argumentos para criar um caminho de arquivo não fizer sentido, enquanto o `Combine` método descarta as primeiras duas cadeias de caracteres e retorna o terceiro.</span><span class="sxs-lookup"><span data-stu-id="7729c-627">Finally, because the final argument in the third call to `ShowPathInformation` are rooted, the `Join` method simply appends it to the first two arguments to create a nonsensical file path, while the `Combine` method discards the first two strings and returns the third.</span></span> <span data-ttu-id="7729c-628">Usando essa cadeia de caracteres para o acesso a arquivos poderia dar ao aplicativo acesso involuntário a arquivos confidenciais.</span><span class="sxs-lookup"><span data-stu-id="7729c-628">Using this string for file access could give the application unintended access to sensitive files.</span></span>  

[!code-csharp[Path.Join(String,String,String)](~/samples/snippets/csharp/api/system.io/path/combine3/program.cs)] 
[!code-csharp[Path.Join(String,String,String)](~/samples/snippets/visualbasic/api/system.io/path/combine3/program.vb)] 

       ]]></format>
        </remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="7729c-629">Formatos de caminho de arquivo em sistemas Windows</span><span class="sxs-lookup"><span data-stu-id="7729c-629">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string path1, string path2, string path3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string path1, string path2, string path3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Join(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (path1 As String, path2 As String, path3 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ path1, System::String ^ path2, System::String ^ path3);" />
      <MemberSignature Language="F#" Value="static member Join : string * string * string -&gt; string" Usage="System.IO.Path.Join (path1, path2, path3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="path2" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="path3" Type="System.String" Index="2" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="path1">To be added.</param>
        <param name="path2">To be added.</param>
        <param name="path3">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PathSeparator">
      <MemberSignature Language="C#" Value="public static readonly char PathSeparator;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char PathSeparator" />
      <MemberSignature Language="DocId" Value="F:System.IO.Path.PathSeparator" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PathSeparator As Char " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly char PathSeparator;" />
      <MemberSignature Language="F#" Value=" staticval mutable PathSeparator : char" Usage="System.IO.Path.PathSeparator" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="7729c-630">Um caractere separador específico da plataforma usado para separar cadeias de caracteres de caminho em variáveis de ambiente.</span><span class="sxs-lookup"><span data-stu-id="7729c-630">A platform-specific separator character used to separate path strings in environment variables.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7729c-631">Em plataformas de área de trabalho baseado em Windows, o valor desse campo é o ponto e vírgula (;) por padrão, mas podem variar em outras plataformas.</span><span class="sxs-lookup"><span data-stu-id="7729c-631">On Windows-based desktop platforms, the value of this field is the semicolon (;) by default, but might vary on other platforms.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7729c-632">O exemplo a seguir demonstra o uso do `PathSeparator` campo.</span><span class="sxs-lookup"><span data-stu-id="7729c-632">The following example demonstrates the use of the `PathSeparator` field.</span></span>  
  
 [!code-cpp[System.IO.Path Members#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#13)]
 [!code-csharp[System.IO.Path Members#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#13)]
 [!code-vb[System.IO.Path Members#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#13)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="7729c-633">E/S de arquivo e de fluxo</span><span class="sxs-lookup"><span data-stu-id="7729c-633">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="7729c-634">Como ler texto de um arquivo</span><span class="sxs-lookup"><span data-stu-id="7729c-634">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="7729c-635">Como gravar texto em um arquivo</span><span class="sxs-lookup"><span data-stu-id="7729c-635">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryJoin">
      <Docs>
        <summary><span data-ttu-id="7729c-636">Tenta concatenar componentes de um caminho individual em um intervalo de caracteres pré-alocado e retorna um valor que indica se a operação foi bem-sucedida.</span><span class="sxs-lookup"><span data-stu-id="7729c-636">Attempts to concatenate individual path components to a preallocated character span, and returns a value that indicates whether the operation succeeded.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
 
## Remarks  

<span data-ttu-id="7729c-637">O intervalo de caracteres de destino deve ser grande o suficiente para conter o caminho concatenado.</span><span class="sxs-lookup"><span data-stu-id="7729c-637">The destination character span must be large enough to hold the concatenated path.</span></span> <span data-ttu-id="7729c-638">Você pode então recuperar o caminho concatenado chamando o <xref:System.Span%601.Slice%2A?displayProperty=nameWithType> método, como o exemplo a seguir ilustra.</span><span class="sxs-lookup"><span data-stu-id="7729c-638">You can then retrieve the concatenated path by calling the <xref:System.Span%601.Slice%2A?displayProperty=nameWithType> method, as the following example illustrates.</span></span>

[!code-csharp[IsPathRooted](~/samples/snippets/csharp/api/system.IO/Path/TryJoin/program.cs)]

         ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryJoin">
      <MemberSignature Language="C#" Value="public static bool TryJoin (ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, Span&lt;char&gt; destination, out int charsWritten);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryJoin(valuetype System.ReadOnlySpan`1&lt;char&gt; path1, valuetype System.ReadOnlySpan`1&lt;char&gt; path2, valuetype System.Span`1&lt;char&gt; destination, [out] int32&amp; charsWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.TryJoin(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.Span{System.Char},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryJoin (path1 As ReadOnlySpan(Of Char), path2 As ReadOnlySpan(Of Char), destination As Span(Of Char), ByRef charsWritten As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryJoin(ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, Span&lt;char&gt; destination, [Runtime::InteropServices::Out] int % charsWritten);" />
      <MemberSignature Language="F#" Value="static member TryJoin : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * Span&lt;char&gt; *  -&gt; bool" Usage="System.IO.Path.TryJoin (path1, path2, destination, charsWritten)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="path2" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="charsWritten" Type="System.Int32" RefType="out" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path1"><span data-ttu-id="7729c-639">Um intervalo de caracteres que contém o primeiro caminho a ser unido.</span><span class="sxs-lookup"><span data-stu-id="7729c-639">A character span that contains the first path to join.</span></span></param>
        <param name="path2"><span data-ttu-id="7729c-640">Um intervalo de caracteres que contém o segundo caminho a ser unido.</span><span class="sxs-lookup"><span data-stu-id="7729c-640">A character span that contains the second path to join.</span></span></param>
        <param name="destination"><span data-ttu-id="7729c-641">Um intervalo de caracteres que conterá o caminho concatenado.</span><span class="sxs-lookup"><span data-stu-id="7729c-641">A character span to hold the concatenated path.</span></span></param>
        <param name="charsWritten"><span data-ttu-id="7729c-642">Quando o método é retornado, um valor que indica o número de caracteres gravados no <paramref name="destination" />.</span><span class="sxs-lookup"><span data-stu-id="7729c-642">When the method returns, a value that indicates the number of characters written to the <paramref name="destination" />.</span></span></param>
        <summary><span data-ttu-id="7729c-643">Tenta concatenar componentes de dois caminhos em um único intervalo de caracteres pré-alocado e retorna um valor que indica se a operação foi bem-sucedida.</span><span class="sxs-lookup"><span data-stu-id="7729c-643">Attempts to concatenate two path components to a single preallocated character span, and returns a value that indicates whether the operation succeeded.</span></span></summary>
        <returns><span data-ttu-id="7729c-644"><see langword="true" /> se a operação de concatenação for bem-sucedida; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="7729c-644"><see langword="true" /> if the concatenation operation is successful; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Remarks

<span data-ttu-id="7729c-645">`destination` deve ser grande o suficiente para conter o caminho concatenado.</span><span class="sxs-lookup"><span data-stu-id="7729c-645">`destination` must be large enough to hold the concatenated path.</span></span> <span data-ttu-id="7729c-646">Você pode então recuperar o caminho concatenado chamando o <xref:System.Span%601.Slice%2A?displayProperty=nameWithType> método, como mostra o exemplo.</span><span class="sxs-lookup"><span data-stu-id="7729c-646">You can then retrieve the concatenated path by calling the <xref:System.Span%601.Slice%2A?displayProperty=nameWithType> method, as the example illustrates.</span></span>

         ]]></format>
        </remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="7729c-647">Formatos de caminho de arquivo em sistemas Windows</span><span class="sxs-lookup"><span data-stu-id="7729c-647">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="TryJoin">
      <MemberSignature Language="C#" Value="public static bool TryJoin (ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, ReadOnlySpan&lt;char&gt; path3, Span&lt;char&gt; destination, out int charsWritten);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryJoin(valuetype System.ReadOnlySpan`1&lt;char&gt; path1, valuetype System.ReadOnlySpan`1&lt;char&gt; path2, valuetype System.ReadOnlySpan`1&lt;char&gt; path3, valuetype System.Span`1&lt;char&gt; destination, [out] int32&amp; charsWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.TryJoin(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.Span{System.Char},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryJoin (path1 As ReadOnlySpan(Of Char), path2 As ReadOnlySpan(Of Char), path3 As ReadOnlySpan(Of Char), destination As Span(Of Char), ByRef charsWritten As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryJoin(ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, ReadOnlySpan&lt;char&gt; path3, Span&lt;char&gt; destination, [Runtime::InteropServices::Out] int % charsWritten);" />
      <MemberSignature Language="F#" Value="static member TryJoin : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * Span&lt;char&gt; *  -&gt; bool" Usage="System.IO.Path.TryJoin (path1, path2, path3, destination, charsWritten)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="path2" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="path3" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="charsWritten" Type="System.Int32" RefType="out" Index="4" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path1"><span data-ttu-id="7729c-648">Um intervalo de caracteres que contém o primeiro caminho a ser unido.</span><span class="sxs-lookup"><span data-stu-id="7729c-648">A character span that contains the first path to join.</span></span></param>
        <param name="path2"><span data-ttu-id="7729c-649">Um intervalo de caracteres que contém o segundo caminho a ser unido.</span><span class="sxs-lookup"><span data-stu-id="7729c-649">A character span that contains the second path to join.</span></span></param>
        <param name="path3"><span data-ttu-id="7729c-650">Um intervalo de caracteres que contém o terceiro caminho a ser unido.</span><span class="sxs-lookup"><span data-stu-id="7729c-650">A character span that contains the third path to join.</span></span></param>
        <param name="destination"><span data-ttu-id="7729c-651">Um intervalo de caracteres que conterá o caminho concatenado.</span><span class="sxs-lookup"><span data-stu-id="7729c-651">A character span to hold the concatenated path.</span></span></param>
        <param name="charsWritten"><span data-ttu-id="7729c-652">Quando o método é retornado, um valor que indica o número de caracteres gravados no <paramref name="destination" />.</span><span class="sxs-lookup"><span data-stu-id="7729c-652">When the method returns, a value that indicates the number of characters written to the <paramref name="destination" />.</span></span></param>
        <summary><span data-ttu-id="7729c-653">Tenta concatenar componentes de dois caminhos em um único intervalo de caracteres pré-alocado e retorna um valor que indica se a operação foi bem-sucedida.</span><span class="sxs-lookup"><span data-stu-id="7729c-653">Attempts to concatenate two path components to a single preallocated character span, and returns a value that indicates whether the operation succeeded.</span></span></summary>
        <returns><span data-ttu-id="7729c-654"><see langword="true" /> se a operação de concatenação for bem-sucedida; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="7729c-654"><see langword="true" /> if the concatenation operation is successful; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Remarks

<span data-ttu-id="7729c-655">`destination` deve ser grande o suficiente para conter o caminho concatenado.</span><span class="sxs-lookup"><span data-stu-id="7729c-655">`destination` must be large enough to hold the concatenated path.</span></span> <span data-ttu-id="7729c-656">Você pode então recuperar o caminho concatenado chamando o <xref:System.Span%601.Slice%2A?displayProperty=nameWithType> método, como mostra o exemplo.</span><span class="sxs-lookup"><span data-stu-id="7729c-656">You can then retrieve the concatenated path by calling the <xref:System.Span%601.Slice%2A?displayProperty=nameWithType> method, as the example illustrates.</span></span>

         ]]></format>
        </remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="7729c-657">Formatos de caminho de arquivo em sistemas Windows</span><span class="sxs-lookup"><span data-stu-id="7729c-657">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="VolumeSeparatorChar">
      <MemberSignature Language="C#" Value="public static readonly char VolumeSeparatorChar;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char VolumeSeparatorChar" />
      <MemberSignature Language="DocId" Value="F:System.IO.Path.VolumeSeparatorChar" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly VolumeSeparatorChar As Char " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly char VolumeSeparatorChar;" />
      <MemberSignature Language="F#" Value=" staticval mutable VolumeSeparatorChar : char" Usage="System.IO.Path.VolumeSeparatorChar" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="7729c-658">Fornece um caractere separador de volume específico à plataforma.</span><span class="sxs-lookup"><span data-stu-id="7729c-658">Provides a platform-specific volume separator character.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7729c-659">O valor desse campo é um dois-pontos (:) no Windows e no Macintosh e uma barra (/) em sistemas operacionais UNIX.</span><span class="sxs-lookup"><span data-stu-id="7729c-659">The value of this field is a colon (:) on Windows and Macintosh, and a slash (/) on UNIX operating systems.</span></span> <span data-ttu-id="7729c-660">Isso é mais útil para analisar os caminhos como "c:\windows" ou "Pasta MacVolume:System".</span><span class="sxs-lookup"><span data-stu-id="7729c-660">This is most useful for parsing paths such as "c:\windows" or "MacVolume:System Folder".</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7729c-661">O exemplo a seguir demonstra o uso do `VolumeSeparatorChar` campo.</span><span class="sxs-lookup"><span data-stu-id="7729c-661">The following example demonstrates the use of the `VolumeSeparatorChar` field.</span></span>  
  
 [!code-cpp[System.IO.Path Members#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#13)]
 [!code-csharp[System.IO.Path Members#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#13)]
 [!code-vb[System.IO.Path Members#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#13)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="7729c-662">E/S de arquivo e de fluxo</span><span class="sxs-lookup"><span data-stu-id="7729c-662">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="7729c-663">Como ler texto de um arquivo</span><span class="sxs-lookup"><span data-stu-id="7729c-663">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="7729c-664">Como gravar texto em um arquivo</span><span class="sxs-lookup"><span data-stu-id="7729c-664">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
  </Members>
</Type>
