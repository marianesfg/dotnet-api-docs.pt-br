<Type Name="File" FullName="System.IO.File">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="543f4dd9e168f2437fdf302f9e44eb009b9b1fcd" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="pt-BR" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37653315" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class File" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit File extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.IO.File" />
  <TypeSignature Language="VB.NET" Value="Public Class File" />
  <TypeSignature Language="C++ CLI" Value="public ref class File abstract sealed" />
  <TypeSignature Language="F#" Value="type File = class" />
  <AssemblyInfo>
    <AssemblyName>System.IO.FileSystem</AssemblyName>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Fornece métodos estáticos para a criação, cópia, exclusão, deslocamento e abertura de um arquivo, além de ajudar na criação de objetos <see cref="T:System.IO.FileStream" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use o <xref:System.IO.File> classe para operações comuns, como copiar, mover, renomear, criando, abrindo, excluindo e anexando a um único arquivo por vez. Você também pode usar o <xref:System.IO.File> classe para obter e definir atributos de arquivo ou <xref:System.DateTime> informações relacionadas à criação, acessar e gravação de um arquivo. Se você quiser executar operações em vários arquivos, consulte <xref:System.IO.Directory.GetFiles%2A?displayProperty=nameWithType> ou <xref:System.IO.DirectoryInfo.GetFiles%2A?displayProperty=nameWithType>.  
  
 Muitas do <xref:System.IO.File> métodos retornam outros tipos de e/s ao criar ou abrir arquivos. Você pode usar esses outros tipos para manipular mais de um arquivo. Para obter mais informações, consulte específico <xref:System.IO.File> membros, como <xref:System.IO.File.OpenText%2A>, <xref:System.IO.File.CreateText%2A>, ou <xref:System.IO.File.Create%2A>.  
  
 Porque todos os <xref:System.IO.File> métodos são estáticos, talvez seja mais eficiente usar um <xref:System.IO.File> método em vez de um correspondente <xref:System.IO.FileInfo> método de instância, se você quiser executar apenas uma ação. Todos os <xref:System.IO.File> métodos requerem o caminho para o arquivo que você está manipulando.  
  
 Os métodos estáticos do <xref:System.IO.File> classe executar verificações de segurança em todos os métodos. Se você for reutilizar um objeto várias vezes, considere usar o método de instância correspondente do <xref:System.IO.FileInfo> em vez disso, porque a verificação de segurança do será nem sempre seja necessário.  
  
 Por padrão, o acesso de leitura/gravação completa para novos arquivos é concedido a todos os usuários.  
  
 A tabela a seguir descreve as enumerações que são usadas para personalizar o comportamento de vários <xref:System.IO.File> métodos.  
  
|Enumeração|Descrição|  
|-----------------|-----------------|  
|<xref:System.IO.FileAccess>|Especifica o acesso de leitura e gravação em um arquivo.|  
|<xref:System.IO.FileShare>|Especifica o nível de acesso permitido para um arquivo que já está em uso.|  
|<xref:System.IO.FileMode>|Especifica se o conteúdo de um arquivo existente é preservado ou substituído, e se as solicitações para criar um arquivo existente causam uma exceção.|  
  
> [!NOTE]
>  Em membros que aceitam um caminho como uma cadeia de caracteres de entrada, esse caminho deve ser bem formado ou uma exceção será gerada. Por exemplo, se um caminho totalmente qualificado, mas começa com um espaço, o caminho não foi cortado em métodos da classe. Portanto, o caminho está malformado e uma exceção será gerada. Da mesma forma, um caminho ou uma combinação de caminhos não pode ser totalmente qualificada duas vezes. Por exemplo, "c:\windows c:\temp" também gerará uma exceção na maioria dos casos. Certifique-se de que seus caminhos são bem formados, ao usar os métodos que aceitam uma cadeia de caracteres de caminho.  
  
 Em membros que aceitam um caminho, o caminho pode consultar um arquivo ou apenas um diretório. O caminho especificado também pode se referir a um caminho relativo ou um caminho de convenção de nomenclatura Universal (UNC) para um nome de servidor e compartilhamento. Por exemplo, todos os itens a seguir é caminhos aceitáveis:  
  
-   "c:\\\MyDir\\\MyFile.txt" em c# ou "c:\MyDir\MyFile.txt" no Visual Basic.  
  
-   "c:\\\MyDir" em c# ou "c:\MyDir" no Visual Basic.  
  
-   "MyDir\\\MySubdir" em c# ou "MyDir\MySubDir" no Visual Basic.  
  
-   "\\\\\\\MyServer\\\MyShare" no c#, ou "\\\MyServer\MyShare" no Visual Basic.  
  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 O exemplo a seguir demonstra como usar o <xref:System.IO.File> classe para verificar se existe um arquivo e, dependendo do resultado, qualquer um criar um novo arquivo e gravar nele, ou abra o arquivo existente e lê-lo. Antes de executar o código, crie um `c:\temp` pasta.  
  
 [!code-cpp[File Class Example#1](~/samples/snippets/cpp/VS_Snippets_CLR/File Class Example/CPP/file class example.cpp#1)]
 [!code-csharp[File Class Example#1](~/samples/snippets/csharp/VS_Snippets_CLR/File Class Example/CS/file class example.cs#1)]
 [!code-vb[File Class Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File Class Example/VB/file class example.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.IO.DriveInfo" />
    <altmember cref="T:System.IO.FileSystemWatcher" />
  </Docs>
  <Members>
    <MemberGroup MemberName="AppendAllLines">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Acrescenta linhas a um arquivo e fecha o arquivo.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AppendAllLines">
      <MemberSignature Language="C#" Value="public static void AppendAllLines (string path, System.Collections.Generic.IEnumerable&lt;string&gt; contents);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AppendAllLines(string path, class System.Collections.Generic.IEnumerable`1&lt;string&gt; contents) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.AppendAllLines(System.String,System.Collections.Generic.IEnumerable{System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AppendAllLines (path As String, contents As IEnumerable(Of String))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AppendAllLines(System::String ^ path, System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ contents);" />
      <MemberSignature Language="F#" Value="static member AppendAllLines : string * seq&lt;string&gt; -&gt; unit" Usage="System.IO.File.AppendAllLines (path, contents)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="path">O arquivo ao qual serão acrescentadas as linhas. Se ainda não existir, o arquivo será criado.</param>
        <param name="contents">As linhas a serem acrescentadas ao arquivo.</param>
        <summary>Acrescenta linhas a um arquivo e fecha o arquivo. Se o arquivo especificado não existir, esse método criará um arquivo, gravará as linhas especificadas no arquivo e fechará o arquivo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O método cria o arquivo se ele não existir, mas não criar novos diretórios. Portanto, o valor da `path` parâmetro deve conter diretórios existentes.  
  
   
  
## Examples  
 O exemplo a seguir grava linhas selecionadas de um arquivo de dados de exemplo em um arquivo e, em seguida, acrescenta mais linhas. O diretório chamado `temp` na unidade C deve existir para o exemplo concluído com êxito.  
  
 [!code-csharp[System.IO.File.WriteAllAppendAll#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.file.writeallappendall/cs/program.cs#1)]
 [!code-vb[System.IO.File.WriteAllAppendAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.file.writeallappendall/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou contém um ou mais caracteres inválidos definidos pelo método <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">O <paramref name="path" /> ou <paramref name="contents" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <paramref name="path" /> é inválido (por exemplo, o diretório não existe ou está em uma unidade não mapeada).</exception>
        <exception cref="T:System.IO.FileNotFoundException">O arquivo especificado por <paramref name="path" /> não foi encontrado.</exception>
        <exception cref="T:System.IO.IOException">Um erro de E/S ocorreu ao abrir o arquivo.</exception>
        <exception cref="T:System.IO.PathTooLongException">
          <paramref name="path" /> excede o tamanho máximo definido pelo sistema.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> está em um formato inválido.</exception>
        <exception cref="T:System.Security.SecurityException">O chamador não tem permissão para gravar no arquivo.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> especifica um arquivo somente leitura.  -ou-  Essa operação não é compatível com a plataforma atual.  -ou-  <paramref name="path" /> é um diretório.</exception>
      </Docs>
    </Member>
    <Member MemberName="AppendAllLines">
      <MemberSignature Language="C#" Value="public static void AppendAllLines (string path, System.Collections.Generic.IEnumerable&lt;string&gt; contents, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AppendAllLines(string path, class System.Collections.Generic.IEnumerable`1&lt;string&gt; contents, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.AppendAllLines(System.String,System.Collections.Generic.IEnumerable{System.String},System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AppendAllLines(System::String ^ path, System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ contents, System::Text::Encoding ^ encoding);" />
      <MemberSignature Language="F#" Value="static member AppendAllLines : string * seq&lt;string&gt; * System.Text.Encoding -&gt; unit" Usage="System.IO.File.AppendAllLines (path, contents, encoding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="path">O arquivo ao qual serão acrescentadas as linhas. Se ainda não existir, o arquivo será criado.</param>
        <param name="contents">As linhas a serem acrescentadas ao arquivo.</param>
        <param name="encoding">A codificação de caracteres a ser usada.</param>
        <summary>Acrescenta linhas em um arquivo usando uma codificação especificada e, em seguida, fecha o arquivo. Se o arquivo especificado não existir, esse método criará um arquivo, gravará as linhas especificadas no arquivo e fechará o arquivo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O método cria o arquivo se ele não existir, mas não criar novos diretórios. Portanto, o valor da `path` parâmetro deve conter diretórios existentes.  
  
 Você pode usar esse método para criar um arquivo que contém o seguinte:  
  
-   Os resultados de uma [LINQ to Objects](http://msdn.microsoft.com/library/73cafe73-37cf-46e7-bfa7-97c7eea7ced9) consultar as linhas de um arquivo, como obtida usando o <xref:System.IO.File.ReadLines%2A> método.  
  
-   O conteúdo de uma coleção que implementa um <xref:System.Collections.Generic.IEnumerable%601> de cadeias de caracteres.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou contém um ou mais caracteres inválidos definidos pelo método <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" />, <paramref name="contents" /> ou <paramref name="encoding" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <paramref name="path" /> é inválido (por exemplo, o diretório não existe ou está em uma unidade não mapeada).</exception>
        <exception cref="T:System.IO.FileNotFoundException">O arquivo especificado por <paramref name="path" /> não foi encontrado.</exception>
        <exception cref="T:System.IO.IOException">Um erro de E/S ocorreu ao abrir o arquivo.</exception>
        <exception cref="T:System.IO.PathTooLongException">
          <paramref name="path" /> excede o tamanho máximo definido pelo sistema.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> está em um formato inválido.</exception>
        <exception cref="T:System.Security.SecurityException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> especifica um arquivo somente leitura.  -ou-  Essa operação não é compatível com a plataforma atual.  -ou- <paramref name="path" /> é um diretório.  -ou-  O chamador não tem a permissão necessária.</exception>
      </Docs>
    </Member>
    <Member MemberName="AppendAllLinesAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task AppendAllLinesAsync (string path, System.Collections.Generic.IEnumerable&lt;string&gt; contents, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task AppendAllLinesAsync(string path, class System.Collections.Generic.IEnumerable`1&lt;string&gt; contents, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.AppendAllLinesAsync(System.String,System.Collections.Generic.IEnumerable{System.String},System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="static member AppendAllLinesAsync : string * seq&lt;string&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="System.IO.File.AppendAllLinesAsync (path, contents, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="contents">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendAllLinesAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task AppendAllLinesAsync (string path, System.Collections.Generic.IEnumerable&lt;string&gt; contents, System.Text.Encoding encoding, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task AppendAllLinesAsync(string path, class System.Collections.Generic.IEnumerable`1&lt;string&gt; contents, class System.Text.Encoding encoding, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.AppendAllLinesAsync(System.String,System.Collections.Generic.IEnumerable{System.String},System.Text.Encoding,System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="static member AppendAllLinesAsync : string * seq&lt;string&gt; * System.Text.Encoding * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="System.IO.File.AppendAllLinesAsync (path, contents, encoding, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="contents">To be added.</param>
        <param name="encoding">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AppendAllText">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Acrescenta a cadeia de caracteres especificada ao arquivo, criando-o, caso ele ainda não exista.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AppendAllText">
      <MemberSignature Language="C#" Value="public static void AppendAllText (string path, string contents);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AppendAllText(string path, string contents) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.AppendAllText(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AppendAllText (path As String, contents As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AppendAllText(System::String ^ path, System::String ^ contents);" />
      <MemberSignature Language="F#" Value="static member AppendAllText : string * string -&gt; unit" Usage="System.IO.File.AppendAllText (path, contents)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">O arquivo no qual a cadeia de caracteres especificada será anexada.</param>
        <param name="contents">A cadeia de caracteres a ser anexada ao arquivo.</param>
        <summary>Abre um arquivo, acrescenta a cadeia de caracteres especificada no arquivo e fecha o arquivo. Se o arquivo não existir, esse método criará um arquivo, gravará a cadeia de caracteres especificada no arquivo e fechará o arquivo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dada uma cadeia de caracteres e um caminho de arquivo, este método abre o arquivo especificado, acrescenta a cadeia de caracteres ao final do arquivo e, em seguida, fecha o arquivo. O identificador de arquivo é garantido para ser fechada por esse método, mesmo se as exceções são geradas.  
  
 O método cria o arquivo se ele não existir, mas não criar novos diretórios. Portanto, o valor da `path` parâmetro deve conter diretórios existentes.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso do <xref:System.IO.File.AppendAllText%2A> método para adicionar texto extra ao final de um arquivo. Neste exemplo, um arquivo é criado se ele ainda não existir, e o texto é adicionado a ele. No entanto, o diretório denominado `temp` na unidade C deve existir para o exemplo concluído com êxito.  
  
 [!code-csharp[System.IO.File.AllText#00](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.File.AllText/cs/AllText.cs#00)]
 [!code-vb[System.IO.File.AllText#00](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.File.AllText/vb/AllText.vb#00)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou um ou mais caracteres inválidos, conforme definido por <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">O caminho especificado é inválido (por exemplo, o diretório não existe ou está em uma unidade não mapeada).</exception>
        <exception cref="T:System.IO.IOException">Um erro de E/S ocorreu ao abrir o arquivo.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> especificou um arquivo somente leitura.  -ou-  Essa operação não é compatível com a plataforma atual.  -ou-  <paramref name="path" /> especificou um diretório.  -ou-  O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> está em um formato inválido.</exception>
        <exception cref="T:System.Security.SecurityException">O chamador não tem a permissão necessária.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para acesso de gravação para um arquivo ou diretório. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" /></permission>
      </Docs>
    </Member>
    <Member MemberName="AppendAllText">
      <MemberSignature Language="C#" Value="public static void AppendAllText (string path, string contents, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AppendAllText(string path, string contents, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.AppendAllText(System.String,System.String,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AppendAllText(System::String ^ path, System::String ^ contents, System::Text::Encoding ^ encoding);" />
      <MemberSignature Language="F#" Value="static member AppendAllText : string * string * System.Text.Encoding -&gt; unit" Usage="System.IO.File.AppendAllText (path, contents, encoding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.String" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="path">O arquivo no qual a cadeia de caracteres especificada será anexada.</param>
        <param name="contents">A cadeia de caracteres a ser anexada ao arquivo.</param>
        <param name="encoding">A codificação de caracteres a ser usada.</param>
        <summary>Acrescenta a cadeia de caracteres especificada ao arquivo, criando-o, caso ele ainda não exista.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dada uma cadeia de caracteres e um caminho de arquivo, este método abre o arquivo especificado, acrescenta a cadeia de caracteres ao final do arquivo usando a codificação especificada e, em seguida, fecha o arquivo. O identificador de arquivo é garantido para ser fechada por esse método, mesmo se as exceções são geradas.  
  
 O método cria o arquivo se ele não existir, mas não criar novos diretórios. Portanto, o valor da `path` parâmetro deve conter diretórios existentes.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso do <xref:System.IO.File.AppendAllText%2A> método para adicionar texto extra ao final de um arquivo. Neste exemplo, um arquivo é criado se ele ainda não existir, e o texto é adicionado a ele. No entanto, o diretório denominado `temp` na unidade C deve existir para o exemplo concluído com êxito.  
  
 [!code-csharp[System.IO.File.AllText_Encoding#00](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.File.AllText_Encoding/cs/AllText.cs#00)]
 [!code-vb[System.IO.File.AllText_Encoding#00](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.File.AllText_Encoding/vb/AllText.vb#00)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou um ou mais caracteres inválidos, conforme definido por <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">O caminho especificado é inválido (por exemplo, o diretório não existe ou está em uma unidade não mapeada).</exception>
        <exception cref="T:System.IO.IOException">Um erro de E/S ocorreu ao abrir o arquivo.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> especificou um arquivo somente leitura.  -ou-  Essa operação não é compatível com a plataforma atual.  -ou-  <paramref name="path" /> especificou um diretório.  -ou-  O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> está em um formato inválido.</exception>
        <exception cref="T:System.Security.SecurityException">O chamador não tem a permissão necessária.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para acesso de gravação para um arquivo ou diretório. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" /></permission>
      </Docs>
    </Member>
    <Member MemberName="AppendAllTextAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task AppendAllTextAsync (string path, string contents, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task AppendAllTextAsync(string path, string contents, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.AppendAllTextAsync(System.String,System.String,System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="static member AppendAllTextAsync : string * string * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="System.IO.File.AppendAllTextAsync (path, contents, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.String" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="contents">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendAllTextAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task AppendAllTextAsync (string path, string contents, System.Text.Encoding encoding, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task AppendAllTextAsync(string path, string contents, class System.Text.Encoding encoding, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.AppendAllTextAsync(System.String,System.String,System.Text.Encoding,System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="static member AppendAllTextAsync : string * string * System.Text.Encoding * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="System.IO.File.AppendAllTextAsync (path, contents, encoding, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.String" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="contents">To be added.</param>
        <param name="encoding">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendText">
      <MemberSignature Language="C#" Value="public static System.IO.StreamWriter AppendText (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.StreamWriter AppendText(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.AppendText(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AppendText (path As String) As StreamWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::StreamWriter ^ AppendText(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member AppendText : string -&gt; System.IO.StreamWriter" Usage="System.IO.File.AppendText path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.StreamWriter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">O caminho para o arquivo a ser anexado.</param>
        <summary>Cria um <see cref="T:System.IO.StreamWriter" /> que acrescenta um texto codificado para UTF-8 a um arquivo existente ou a um novo arquivo, se o arquivo especificado não existe.</summary>
        <returns>Um gravador de fluxo que acrescenta texto codificado para UTF-8 ao arquivo especificado ou a um novo arquivo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é equivalente a <xref:System.IO.StreamWriter.%23ctor%28System.String%2CSystem.Boolean%29> sobrecarga de construtor. Se o arquivo especificado por `path` não existir, ele é criado. Se o arquivo existir, as operações de gravação a <xref:System.IO.StreamWriter> acrescentar texto ao arquivo. Threads adicionais têm permissão para ler o arquivo enquanto ele está aberto.  
  
 O `path` parâmetro tem permissão para especificar informações de caminho relativo ou absoluto. As informações do caminho relativo são interpretadas como relativas ao diretório de trabalho atual. Para obter o diretório de trabalho atual, consulte <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 O `path` parâmetro não diferencia maiusculas de minúsculas.  
  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 O exemplo a seguir acrescenta o texto em um arquivo. O método cria um novo arquivo se o arquivo não existe. No entanto, o diretório denominado `temp` na unidade C deve existir para o exemplo concluído com êxito.  
  
 [!code-cpp[File_AppendText#1](~/samples/snippets/cpp/VS_Snippets_CLR/File_AppendText/CPP/file_appendtext.cpp#1)]
 [!code-csharp[File_AppendText#1](~/samples/snippets/csharp/VS_Snippets_CLR/File_AppendText/CS/file_appendtext.cs#1)]
 [!code-vb[File_AppendText#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File_AppendText/VB/file_appendtext.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou um ou mais caracteres inválidos, conforme definido por <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">O caminho especificado é inválido (por exemplo, o diretório não existe ou está em uma unidade não mapeada).</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> está em um formato inválido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Para acrescentar ao arquivo especificado. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" /></permission>
        <altmember cref="T:System.IO.StreamWriter" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Copy">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Copia um arquivo existente para um novo arquivo.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (string sourceFileName, string destFileName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(string sourceFileName, string destFileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Copy(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (sourceFileName As String, destFileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(System::String ^ sourceFileName, System::String ^ destFileName);" />
      <MemberSignature Language="F#" Value="static member Copy : string * string -&gt; unit" Usage="System.IO.File.Copy (sourceFileName, destFileName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destFileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">O arquivo a ser copiado.</param>
        <param name="destFileName">O nome do arquivo de destino. Não pode ser um diretório ou um arquivo existente.</param>
        <summary>Copia um arquivo existente para um novo arquivo. Não é permitida a substituição de um arquivo de mesmo nome.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é equivalente à <xref:System.IO.File.Copy%28System.String%2CSystem.String%2CSystem.Boolean%29> sobrecarga de método com o `overwrite` parâmetro definido como `false`.  
  
 O `sourceFileName` e `destFileName` parâmetros podem especificar informações de caminho relativo ou absoluto. As informações do caminho relativo são interpretadas como relativas ao diretório de trabalho atual. Para obter o diretório de trabalho atual, consulte o <xref:System.IO.Directory.GetCurrentDirectory%2A?displayProperty=nameWithType> método. Esse método não dá suporte a caracteres curinga nos parâmetros.  
  
 Os atributos do arquivo original são mantidos no arquivo copiado.  
  
   
  
## Examples  
 O exemplo a seguir copia arquivos para a pasta de backup C:\archives\2008. Ele usa as duas sobrecargas do <xref:System.IO.File.Copy%2A> método da seguinte maneira:  
  
-   Primeiro, ele usa o <xref:System.IO.File.Copy%28System.String%2CSystem.String%29?displayProperty=nameWithType> sobrecarga de método para copiar os arquivos de texto (. txt). O código demonstra que essa sobrecarga não permitir a substituição de arquivos que já foram copiados.  
  
-   Ele usa o <xref:System.IO.File.Copy%28System.String%2CSystem.String%2CSystem.Boolean%29?displayProperty=nameWithType> sobrecarga de método para copiar imagens (arquivos. jpg). O código demonstra que essa sobrecarga de permitir a substituição de arquivos que já foram copiados.  
  
 [!code-csharp[FileCopyDelete#1](~/samples/snippets/csharp/VS_Snippets_CLR/filecopydelete/cs/program.cs#1)]
 [!code-vb[FileCopyDelete#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/filecopydelete/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="sourceFileName" /> ou <paramref name="destFileName" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou contém um ou mais caracteres inválidos, conforme definido por <see cref="F:System.IO.Path.InvalidPathChars" />.  -ou- <paramref name="sourceFileName" /> ou <paramref name="destFileName" /> especifica um diretório.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sourceFileName" /> ou <paramref name="destFileName" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">O caminho especificado em <paramref name="sourceFileName" /> ou <paramref name="destFileName" /> é inválido (por exemplo, está em uma unidade não mapeada).</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="sourceFileName" /> não foi encontrado.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="destFileName" /> existe.  -ou- Erro de E/S.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="sourceFileName" /> ou <paramref name="destFileName" /> está em um formato inválido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para leitura do <paramref name="sourceFileName" /> e gravar em <paramref name="destFileName" />. Enumerações associadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="M:System.IO.Directory.Move(System.String,System.String)" />
        <altmember cref="M:System.IO.File.Move(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (string sourceFileName, string destFileName, bool overwrite);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(string sourceFileName, string destFileName, bool overwrite) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Copy(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (sourceFileName As String, destFileName As String, overwrite As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(System::String ^ sourceFileName, System::String ^ destFileName, bool overwrite);" />
      <MemberSignature Language="F#" Value="static member Copy : string * string * bool -&gt; unit" Usage="System.IO.File.Copy (sourceFileName, destFileName, overwrite)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destFileName" Type="System.String" />
        <Parameter Name="overwrite" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">O arquivo a ser copiado.</param>
        <param name="destFileName">O nome do arquivo de destino. Ele não pode ser um diretório.</param>
        <param name="overwrite">
          <see langword="true" /> se o arquivo de destino puder ser substituído; caso contrário, <see langword="false" />.</param>
        <summary>Copia um arquivo existente para um novo arquivo. É permitido substituir um arquivo de mesmo nome.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `sourceFileName` e `destFileName` parâmetros podem especificar informações de caminho relativo ou absoluto. As informações do caminho relativo são interpretadas como relativas ao diretório de trabalho atual. Esse método não dá suporte a caracteres curinga nos parâmetros.  
  
 Os atributos do arquivo original são mantidos no arquivo copiado.  
  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 O exemplo a seguir copia arquivos para a pasta de backup C:\archives\2008. Ele usa as duas sobrecargas do <xref:System.IO.File.Copy%2A> método da seguinte maneira:  
  
-   Primeiro, ele usa o <xref:System.IO.File.Copy%28System.String%2CSystem.String%29?displayProperty=nameWithType> sobrecarga de método para copiar os arquivos de texto (. txt). O código demonstra que essa sobrecarga não permitir a substituição de arquivos que já foram copiados.  
  
 Ele usa o <xref:System.IO.File.Copy%28System.String%2CSystem.String%2CSystem.Boolean%29?displayProperty=nameWithType> sobrecarga de método para copiar imagens (arquivos. jpg). O código demonstra que essa sobrecarga de permitir a substituição de arquivos que já foram copiados.  
  
 [!code-csharp[FileCopyDelete#1](~/samples/snippets/csharp/VS_Snippets_CLR/filecopydelete/cs/program.cs#1)]
 [!code-vb[FileCopyDelete#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/filecopydelete/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">O chamador não tem a permissão necessária.  -ou- <paramref name="destFileName" /> é somente leitura.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="sourceFileName" /> ou <paramref name="destFileName" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou contém um ou mais caracteres inválidos, conforme definido por <see cref="F:System.IO.Path.InvalidPathChars" />.  -ou- <paramref name="sourceFileName" /> ou <paramref name="destFileName" /> especifica um diretório.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sourceFileName" /> ou <paramref name="destFileName" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">O caminho especificado em <paramref name="sourceFileName" /> ou <paramref name="destFileName" /> é inválido (por exemplo, está em uma unidade não mapeada).</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="sourceFileName" /> não foi encontrado.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="destFileName" /> existe e <paramref name="overwrite" /> é <see langword="false" />.  -ou- Erro de E/S.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="sourceFileName" /> ou <paramref name="destFileName" /> está em um formato inválido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para leitura do <paramref name="sourceFileName" /> e gravar em <paramref name="destFileName" />. Enumerações associadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="M:System.IO.Directory.Move(System.String,System.String)" />
        <altmember cref="M:System.IO.File.Move(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Create">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Cria um arquivo no caminho especificado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.IO.FileStream Create (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.FileStream Create(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Create(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (path As String) As FileStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::FileStream ^ Create(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member Create : string -&gt; System.IO.FileStream" Usage="System.IO.File.Create path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">O caminho e o nome do arquivo a ser criado.</param>
        <summary>Cria ou substitui um arquivo no caminho especificado.</summary>
        <returns>Um <see cref="T:System.IO.FileStream" /> que fornece acesso de leitura/gravação para o arquivo especificado em <paramref name="path" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.IO.FileStream> objeto criado por esse método tem um padrão <xref:System.IO.FileShare> valor <xref:System.IO.FileShare.None>; nenhum outro processo ou código pode acessar o arquivo criado até que o identificador de arquivo original seja fechado.  
  
 Esse método é equivalente a <xref:System.IO.File.Create%28System.String%2CSystem.Int32%29> sobrecarga do método usando o tamanho do buffer padrão.  
  
 O `path` parâmetro tem permissão para especificar informações de caminho relativo ou absoluto. As informações do caminho relativo são interpretadas como relativas ao diretório de trabalho atual. Para obter o diretório de trabalho atual, consulte <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Se o arquivo especificado não existir, ele será criado; Se ele existe e não é somente leitura, o conteúdo será substituído.  
  
 Por padrão, o acesso de leitura/gravação completa para novos arquivos é concedido a todos os usuários. O arquivo é aberto com acesso de leitura/gravação e deve ser fechado antes que ele pode ser aberto por outro aplicativo.  
  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 O exemplo a seguir cria um arquivo no caminho especificado, grava algumas informações no arquivo e lê do arquivo.  
  
 [!code-cpp[File Create1#1](~/samples/snippets/cpp/VS_Snippets_CLR/File Create1/CPP/file create1.cpp#1)]
 [!code-csharp[File Create1#1](~/samples/snippets/csharp/VS_Snippets_CLR/File Create1/CS/file create1.cs#1)]
 [!code-vb[File Create1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File Create1/VB/file create1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">O chamador não tem a permissão necessária.  -ou- <paramref name="path" /> especificou um arquivo somente leitura.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou um ou mais caracteres inválidos, conforme definido por <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">O caminho especificado é inválido (por exemplo, ele está em uma unidade não mapeada).</exception>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S ao criar o arquivo.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> está em um formato inválido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">permissão Ler e gravar o arquivo descrito pelo <paramref name="path" /> parâmetro. Ação de segurança: <see cref="F:System.Security.Permissions.SecurityAction.Demand" /> . Enumerações associadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.IO.FileStream Create (string path, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.FileStream Create(string path, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Create(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (path As String, bufferSize As Integer) As FileStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::FileStream ^ Create(System::String ^ path, int bufferSize);" />
      <MemberSignature Language="F#" Value="static member Create : string * int -&gt; System.IO.FileStream" Usage="System.IO.File.Create (path, bufferSize)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="path">O nome do arquivo.</param>
        <param name="bufferSize">O número de bytes armazenados em buffer para leituras e gravações no arquivo.</param>
        <summary>Cria ou substitui o arquivo especificado.</summary>
        <returns>Um <see cref="T:System.IO.FileStream" /> com o tamanho do buffer especificado que fornece acesso de leitura/gravação para o arquivo especificado em <paramref name="path" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.IO.FileStream> objeto criado por esse método tem um padrão <xref:System.IO.FileShare> valor <xref:System.IO.FileShare.None>; nenhum outro processo ou código pode acessar o arquivo criado até que o identificador de arquivo original seja fechado.  
  
 O `path` parâmetro tem permissão para especificar informações de caminho relativo ou absoluto. As informações do caminho relativo são interpretadas como relativas ao diretório de trabalho atual. Para obter o diretório de trabalho atual, consulte <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Esse método é equivalente a <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%29> sobrecarga de construtor. Se o arquivo especificado não existir, ele será criado; Se ele existe e não é somente leitura, o conteúdo será substituído.  
  
 Por padrão, o acesso de leitura/gravação completa para novos arquivos é concedido a todos os usuários. O arquivo é aberto com acesso de leitura/gravação e deve ser fechado antes que ele pode ser aberto por outro aplicativo.  
  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 O exemplo a seguir cria um arquivo com o tamanho do buffer especificado.  
  
 [!code-cpp[File Create2#1](~/samples/snippets/cpp/VS_Snippets_CLR/File Create2/CPP/file create2.cpp#1)]
 [!code-csharp[File Create2#1](~/samples/snippets/csharp/VS_Snippets_CLR/File Create2/CS/file create2.cs#1)]
 [!code-vb[File Create2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File Create2/VB/file create2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">O chamador não tem a permissão necessária.  -ou- <paramref name="path" /> especificou um arquivo somente leitura.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou um ou mais caracteres inválidos, conforme definido por <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">O caminho especificado é inválido (por exemplo, ele está em uma unidade não mapeada).</exception>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S ao criar o arquivo.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> está em um formato inválido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">permissão Ler e gravar o arquivo descrito pelo <paramref name="path" /> parâmetro. Ação de segurança: por demanda. Enumerações associadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.IO.FileStream Create (string path, int bufferSize, System.IO.FileOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.FileStream Create(string path, int32 bufferSize, valuetype System.IO.FileOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Create(System.String,System.Int32,System.IO.FileOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (path As String, bufferSize As Integer, options As FileOptions) As FileStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::FileStream ^ Create(System::String ^ path, int bufferSize, System::IO::FileOptions options);" />
      <MemberSignature Language="F#" Value="static member Create : string * int * System.IO.FileOptions -&gt; System.IO.FileStream" Usage="System.IO.File.Create (path, bufferSize, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="options" Type="System.IO.FileOptions" />
      </Parameters>
      <Docs>
        <param name="path">O nome do arquivo.</param>
        <param name="bufferSize">O número de bytes armazenados em buffer para leituras e gravações no arquivo.</param>
        <param name="options">Um dos valores de <see cref="T:System.IO.FileOptions" /> que descreve como criar ou substituir o arquivo.</param>
        <summary>Cria ou substitui o arquivo especificado, especificando um tamanho do buffer e um valor <see cref="T:System.IO.FileOptions" /> que descreve como criar ou substituir o arquivo.</summary>
        <returns>Um novo arquivo com o tamanho do buffer especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `path` parâmetro tem permissão para especificar informações de caminho relativo ou absoluto. As informações do caminho relativo são interpretadas como relativas ao diretório de trabalho atual. Para obter o diretório de trabalho atual, consulte <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Esse método é equivalente a <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%29> sobrecarga de construtor. Se o arquivo especificado não existir, ele será criado; Se ele existe e não é somente leitura, o conteúdo será substituído.  
  
 Por padrão, o acesso de leitura/gravação completa para novos arquivos é concedido a todos os usuários. O arquivo é aberto com acesso de leitura/gravação e deve ser fechado antes que ele pode ser aberto por outro aplicativo.  
  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">O chamador não tem a permissão necessária.  -ou- <paramref name="path" /> especificou um arquivo somente leitura.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou um ou mais caracteres inválidos, conforme definido por <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">O caminho especificado é inválido (por exemplo, ele está em uma unidade não mapeada).</exception>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S ao criar o arquivo.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> está em um formato inválido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">permissão Ler e gravar o arquivo descrito pelo <paramref name="path" /> parâmetro. Ação de segurança: por demanda. Enumerações associadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.IO.FileStream Create (string path, int bufferSize, System.IO.FileOptions options, System.Security.AccessControl.FileSecurity fileSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.FileStream Create(string path, int32 bufferSize, valuetype System.IO.FileOptions options, class System.Security.AccessControl.FileSecurity fileSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Create(System.String,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::FileStream ^ Create(System::String ^ path, int bufferSize, System::IO::FileOptions options, System::Security::AccessControl::FileSecurity ^ fileSecurity);" />
      <MemberSignature Language="F#" Value="static member Create : string * int * System.IO.FileOptions * System.Security.AccessControl.FileSecurity -&gt; System.IO.FileStream" Usage="System.IO.File.Create (path, bufferSize, options, fileSecurity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="options" Type="System.IO.FileOptions" />
        <Parameter Name="fileSecurity" Type="System.Security.AccessControl.FileSecurity" />
      </Parameters>
      <Docs>
        <param name="path">O nome do arquivo.</param>
        <param name="bufferSize">O número de bytes armazenados em buffer para leituras e gravações no arquivo.</param>
        <param name="options">Um dos valores de <see cref="T:System.IO.FileOptions" /> que descreve como criar ou substituir o arquivo.</param>
        <param name="fileSecurity">Um dos valores de <see cref="T:System.Security.AccessControl.FileSecurity" /> que determina o controle de acesso e a segurança de auditoria para o arquivo.</param>
        <summary>Cria ou substitui no arquivo especificado o tamanho do buffer, as opções de arquivo e a segurança de arquivo especificados.</summary>
        <returns>Um novo arquivo com o tamanho do buffer, as opções de arquivo e a segurança de arquivo especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `path` parâmetro tem permissão para especificar informações de caminho relativo ou absoluto. As informações do caminho relativo são interpretadas como relativas ao diretório de trabalho atual. Para obter o diretório de trabalho atual, consulte <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Esse método é equivalente a <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%29> sobrecarga de construtor. Se o arquivo especificado não existir, ele será criado; Se ele existe e não é somente leitura, o conteúdo será substituído.  
  
 Por padrão, o acesso de leitura/gravação completa para novos arquivos é concedido a todos os usuários. O arquivo é aberto com acesso de leitura/gravação e deve ser fechado antes que ele pode ser aberto por outro aplicativo.  
  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">O chamador não tem a permissão necessária.  -ou- <paramref name="path" /> especificou um arquivo somente leitura.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou um ou mais caracteres inválidos, conforme definido por <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">O caminho especificado é inválido (por exemplo, ele está em uma unidade não mapeada).</exception>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S ao criar o arquivo.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> está em um formato inválido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">permissão Ler e gravar o arquivo descrito pelo <paramref name="path" /> parâmetro. Ação de segurança: por demanda. Enumerações associadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateText">
      <MemberSignature Language="C#" Value="public static System.IO.StreamWriter CreateText (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.StreamWriter CreateText(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.CreateText(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateText (path As String) As StreamWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::StreamWriter ^ CreateText(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member CreateText : string -&gt; System.IO.StreamWriter" Usage="System.IO.File.CreateText path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.StreamWriter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">O arquivo a ser aberto para gravação.</param>
        <summary>Cria ou abre um arquivo para gravar texto codificado em UTF-8. Se o arquivo já existir, o conteúdo dele será substituído.</summary>
        <returns>Um <see cref="T:System.IO.StreamWriter" /> que grava no arquivo especificado usando a codificação UTF-8.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é equivalente à <xref:System.IO.StreamWriter.%23ctor%28System.String%2CSystem.Boolean%29> sobrecarga de construtor com o `append` parâmetro definido como `false`. Se o arquivo especificado por `path` não existir, ele é criado. Se o arquivo existir, seu conteúdo será substituído. Threads adicionais têm permissão para ler o arquivo enquanto ele está aberto.  
  
 O `path` parâmetro tem permissão para especificar informações de caminho relativo ou absoluto. As informações do caminho relativo são interpretadas como relativas ao diretório de trabalho atual. Para obter o diretório de trabalho atual, consulte <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 O exemplo a seguir cria um arquivo para gravação e leitura de texto.  
  
 [!code-cpp[File CreateText#1](~/samples/snippets/cpp/VS_Snippets_CLR/File CreateText/CPP/file createtext.cpp#1)]
 [!code-csharp[File CreateText#1](~/samples/snippets/csharp/VS_Snippets_CLR/File CreateText/CS/file createtext.cs#1)]
 [!code-vb[File CreateText#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File CreateText/VB/file createtext.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou um ou mais caracteres inválidos, conforme definido por <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">O caminho especificado é inválido (por exemplo, ele está em uma unidade não mapeada).</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> está em um formato inválido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para gravar no arquivo especificado. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Decrypt">
      <MemberSignature Language="C#" Value="public static void Decrypt (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Decrypt(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Decrypt(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Decrypt (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Decrypt(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member Decrypt : string -&gt; unit" Usage="System.IO.File.Decrypt path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Um caminho que descreve um arquivo a ser descriptografado.</param>
        <summary>Descriptografa um arquivo que foi criptografado pela conta atual usando o método <see cref="M:System.IO.File.Encrypt(System.String)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.IO.File.Decrypt%2A> método permite que você descriptografar um arquivo que foi criptografado usando o <xref:System.IO.File.Encrypt%2A> método.  O <xref:System.IO.File.Decrypt%2A> método pode descriptografar somente os arquivos que foram criptografados usando a conta de usuário atual.  
  
 O <xref:System.IO.File.Decrypt%2A> método requer acesso exclusivo para o arquivo que está sendo descriptografado e gerará uma exceção se outro processo está usando o arquivo. Se o arquivo não é criptografado, <xref:System.IO.File.Decrypt%2A> retornará um valor diferente de zero, o que indica êxito.  
  
 Os dois os <xref:System.IO.File.Encrypt%2A> método e o <xref:System.IO.File.Decrypt%2A> método usa o provedor de serviços de criptografia (CSP) instalado no computador e as chaves de criptografia de arquivo do processo de chamada do método.  
  
 O sistema de arquivos atual deve ser formatada como NTFS e o sistema operacional atual deve ser o Windows NT ou posterior.  
  
   
  
## Examples  
 O seguinte exemplo de código usa o <xref:System.IO.File.Encrypt%2A> método e o <xref:System.IO.File.Decrypt%2A> método para criptografar e descriptografar um arquivo. O arquivo deve existir para o exemplo funcione.  
  
 [!code-cpp[IO.File.Encrypt-Decrypt#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.File.Encrypt-Decrypt/cpp/sample.cpp#1)]
 [!code-csharp[IO.File.Encrypt-Decrypt#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.File.Encrypt-Decrypt/CS/sample.cs#1)]
 [!code-vb[IO.File.Encrypt-Decrypt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.File.Encrypt-Decrypt/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O parâmetro <paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou um ou mais caracteres inválidos, conforme definido por <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.DriveNotFoundException">Uma unidade inválida foi especificada.</exception>
        <exception cref="T:System.IO.FileNotFoundException">O arquivo descrito pelo parâmetro <paramref name="path" /> não pôde ser encontrado.</exception>
        <exception cref="T:System.IO.IOException">Um erro de E/S ocorreu ao abrir o arquivo. Por exemplo, o arquivo criptografado já está aberto.  -ou-  Essa operação não é compatível com a plataforma atual.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema.</exception>
        <exception cref="T:System.PlatformNotSupportedException">O sistema operacional atual não é o Windows NT ou posterior.</exception>
        <exception cref="T:System.NotSupportedException">O sistema de arquivos não é NTFS.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O parâmetro <paramref name="path" /> especificou um arquivo somente leitura.  -ou-  Essa operação não é compatível com a plataforma atual.  -ou-  O parâmetro <paramref name="path" /> especificou um diretório.  -ou-  O chamador não tem a permissão necessária.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">permissão Ler e gravar o arquivo descrito pelo <paramref name="path" /> parâmetro. Ação de segurança: por demanda. Enumerações associadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static void Delete (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Delete(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Delete(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Delete (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Delete(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member Delete : string -&gt; unit" Usage="System.IO.File.Delete path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">O nome do arquivo a ser excluído. Não há suporte para caracteres curinga.</param>
        <summary>Exclui o arquivo especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Especifique um nome de arquivo com qualquer informação de caminho relativo ou absoluto para o `path` parâmetro. Caracteres curinga não podem ser incluídos. As informações do caminho relativo são interpretadas como relativas ao diretório de trabalho atual. Para obter o diretório de trabalho atual, consulte <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Se o arquivo a ser excluído não existir, nenhuma exceção é lançada.  
  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 O exemplo a seguir copia os grupos de arquivos para a pasta de backup C:\archives\2008 e, em seguida, exclui-los da pasta de origem.  
  
 [!code-csharp[FileCopyDelete#1](~/samples/snippets/csharp/VS_Snippets_CLR/filecopydelete/cs/program.cs#1)]
 [!code-vb[FileCopyDelete#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/filecopydelete/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou um ou mais caracteres inválidos, conforme definido por <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">O caminho especificado é inválido (por exemplo, ele está em uma unidade não mapeada).</exception>
        <exception cref="T:System.IO.IOException">O arquivo especificado está sendo usado.  -ou-  Há um identificador aberto no arquivo, e o sistema operacional é o Windows XP ou uma versão anterior. Esse identificador aberto pode resultar da enumeração de diretórios e arquivos. Para obter mais informações, confira [Como enumerar diretórios e arquivos](~/docs/standard/io/how-to-enumerate-directories-and-files.md).</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> está em um formato inválido.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O chamador não tem a permissão necessária.  -ou- O arquivo é um arquivo executável que está em uso.  -ou- <paramref name="path" /> é um diretório.  -ou- <paramref name="path" /> especificou um arquivo somente leitura.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Para excluir o arquivo especificado. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Encrypt">
      <MemberSignature Language="C#" Value="public static void Encrypt (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Encrypt(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Encrypt(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Encrypt (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Encrypt(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member Encrypt : string -&gt; unit" Usage="System.IO.File.Encrypt path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Um caminho que descreve um arquivo a ser criptografado.</param>
        <summary>Criptografa um arquivo para que somente a conta usada para criptografar o arquivo possa descriptografá-lo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.IO.File.Encrypt%2A> método permite que você criptografar um arquivo para que somente a conta usada para chamar esse método pode descriptografá-la. Use o <xref:System.IO.File.Decrypt%2A> método para descriptografar um arquivo criptografado pelo <xref:System.IO.File.Encrypt%2A> método.  
  
 O <xref:System.IO.File.Encrypt%2A> método requer acesso exclusivo para o arquivo que está sendo criptografado e falharão se outro processo está usando o arquivo.  
  
 Os dois os <xref:System.IO.File.Encrypt%2A> método e o <xref:System.IO.File.Decrypt%2A> método usa o provedor de serviços de criptografia (CSP) instalado no computador e as chaves de criptografia de arquivo do processo de chamada do método.  
  
 Esse método não está disponível em todas as versões do Windows. Por exemplo, ele não está disponível nas edições Home.  
  
 O sistema de arquivos atual deve ser formatado como NTFS.  
  
   
  
## Examples  
 O seguinte exemplo de código usa o <xref:System.IO.File.Encrypt%2A> método e o <xref:System.IO.File.Decrypt%2A> método para criptografar e descriptografar um arquivo. O arquivo deve existir para o exemplo funcione.  
  
 [!code-cpp[IO.File.Encrypt-Decrypt#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.File.Encrypt-Decrypt/cpp/sample.cpp#1)]
 [!code-csharp[IO.File.Encrypt-Decrypt#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.File.Encrypt-Decrypt/CS/sample.cs#1)]
 [!code-vb[IO.File.Encrypt-Decrypt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.File.Encrypt-Decrypt/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O parâmetro <paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou um ou mais caracteres inválidos, conforme definido por <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.DriveNotFoundException">Uma unidade inválida foi especificada.</exception>
        <exception cref="T:System.IO.FileNotFoundException">O arquivo descrito pelo parâmetro <paramref name="path" /> não pôde ser encontrado.</exception>
        <exception cref="T:System.IO.IOException">Um erro de E/S ocorreu ao abrir o arquivo.  -ou-  Essa operação não é compatível com a plataforma atual.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema.</exception>
        <exception cref="T:System.PlatformNotSupportedException">O sistema operacional atual não é o Windows NT ou posterior.</exception>
        <exception cref="T:System.NotSupportedException">O sistema de arquivos não é NTFS.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O parâmetro <paramref name="path" /> especificou um arquivo somente leitura.  -ou-  Essa operação não é compatível com a plataforma atual.  -ou-  O parâmetro <paramref name="path" /> especificou um diretório.  -ou-  O chamador não tem a permissão necessária.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">permissão Ler e gravar o arquivo descrito pelo <paramref name="path" /> parâmetro. Ação de segurança: por demanda. Enumerações associadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public static bool Exists (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Exists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exists (path As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Exists(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member Exists : string -&gt; bool" Usage="System.IO.File.Exists path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">O arquivo a ser verificado.</param>
        <summary>Determina se o arquivo especificado existe.</summary>
        <returns>
          <see langword="true" /> se o chamador tiver as permissões necessárias e <paramref name="path" /> contiver o nome de um arquivo existente; caso contrário, <see langword="false" />. Esse método também retornará <see langword="false" /> se <paramref name="path" /> for <see langword="null" />, um caminho inválido ou uma cadeia de comprimento zero. Se o chamador não tiver permissões suficientes para ler o arquivo especificado, nenhuma exceção será lançada e o método retornará <see langword="false" /> independentemente da existência de <paramref name="path" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.IO.File.Exists%2A> método não deve ser usado para validação de caminho, este método simplesmente verifica se o arquivo especificado em `path` existe. Passando um caminho inválido para <xref:System.IO.File.Exists%2A> retorna `false`. Para verificar se o caminho contém caracteres inválidos, você pode chamar o <xref:System.IO.Path.GetInvalidPathChars%2A> método para recuperar os caracteres que são inválidos para o sistema de arquivos. Você também pode criar uma expressão regular para testar se o caminho é válido para o seu ambiente. Para obter exemplos de caminhos aceitáveis, consulte <xref:System.IO.File>.  
  
 Para verificar se existe um diretório, consulte <xref:System.IO.Directory.Exists%2A?displayProperty=nameWithType>.  
  
 Lembre-se de que outro processo potencialmente pode fazer algo com o arquivo entre a hora em que você chamar o <xref:System.IO.File.Exists%2A> método e executar outra operação no arquivo, como <xref:System.IO.File.Delete%2A>.  
  
 O `path` parâmetro tem permissão para especificar informações de caminho relativo ou absoluto. As informações do caminho relativo são interpretadas como relativas ao diretório de trabalho atual. Para obter o diretório de trabalho atual, consulte <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Se `path` descreve um diretório, esse método retornará `false`. Espaços à direita são removidos do `path` parâmetro antes de determinar se o arquivo existe.  
  
 O <xref:System.IO.File.Exists%2A> método retorna `false` se ocorrer algum erro ao tentar determinar se o arquivo especificado existe. Isso pode ocorrer em situações que geram exceções, como passar um nome de arquivo com caracteres inválidos ou número excessivo de caracteres, um disco com falha ou ausente, ou se o chamador não tem permissão para ler o arquivo.  
  
   
  
## Examples  
 O exemplo a seguir determina se existe um arquivo.  
  
 [!code-csharp[File Exists#1](~/samples/snippets/csharp/VS_Snippets_CLR/File Exists/CS/program.cs#1)]
 [!code-vb[File Exists#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File Exists/VB/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para a leitura do arquivo especificado. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="M:System.IO.Directory.Exists(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetAccessControl">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtém um objeto <see cref="T:System.Security.AccessControl.FileSecurity" /> que encapsula as entradas de ACL (lista de controle de acesso) para um arquivo especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use o <xref:System.IO.FileInfo.GetAccessControl%2A> entradas ACL (lista) para um arquivo especificado do controle de métodos para recuperar o acesso.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public static System.Security.AccessControl.FileSecurity GetAccessControl (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.AccessControl.FileSecurity GetAccessControl(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.GetAccessControl(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetAccessControl (path As String) As FileSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::AccessControl::FileSecurity ^ GetAccessControl(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetAccessControl : string -&gt; System.Security.AccessControl.FileSecurity" Usage="System.IO.File.GetAccessControl path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.FileSecurity</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">O caminho para um arquivo que contém um objeto <see cref="T:System.Security.AccessControl.FileSecurity" /> que descreve as informações de ACL (lista de controle de acesso) do arquivo.</param>
        <summary>Obtém um objeto <see cref="T:System.Security.AccessControl.FileSecurity" /> que encapsula as entradas de ACL (lista de controle de acesso) para um arquivo especificado.</summary>
        <returns>Um objeto <see cref="T:System.Security.AccessControl.FileSecurity" /> que encapsula as regras de controle de acesso para o arquivo descrito pelo parâmetro <paramref name="path" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use o <xref:System.IO.File.GetAccessControl%2A> método para recuperar as entradas ACL (lista) de controle de acesso para um arquivo.  
  
 Uma ACL descreve indivíduos e/ou grupos que têm ou não tem direitos para ações específicas no arquivo em questão. Para saber mais, confira [Como adicionar ou remover entradas da lista de controle de acesso](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md).  
  
 Em ambientes de NTFS <xref:System.Security.AccessControl.FileSystemRights.ReadAttributes> e <xref:System.Security.AccessControl.FileSystemRights.ReadExtendedAttributes> são concedidas ao usuário se o usuário tiver <xref:System.Security.AccessControl.FileSystemRights.ListDirectory> direitos na pasta pai. Negar <xref:System.Security.AccessControl.FileSystemRights.ReadAttributes> e <xref:System.Security.AccessControl.FileSystemRights.ReadExtendedAttributes>, negar <xref:System.Security.AccessControl.FileSystemRights.ListDirectory> no diretório pai.  
  
   
  
## Examples  
 O seguinte exemplo de código usa o <xref:System.IO.File.GetAccessControl%2A> e o <xref:System.IO.File.SetAccessControl%2A> métodos para adicionar e, em seguida, remover o acesso de um controlam de entrada ACL (lista) de um arquivo.  Você deve fornecer uma conta de grupo ou de usuário válida para executar este exemplo.  
  
 [!code-cpp[IO.File.GetAccessControl-SetAccessControl#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.File.GetAccessControl-SetAccessControl/cpp/sample.cpp#1)]
 [!code-csharp[IO.File.GetAccessControl-SetAccessControl#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.File.GetAccessControl-SetAccessControl/CS/sample.cs#1)]
 [!code-vb[IO.File.GetAccessControl-SetAccessControl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.File.GetAccessControl-SetAccessControl/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Um erro de E/S ocorreu ao abrir o arquivo.</exception>
        <exception cref="T:System.Runtime.InteropServices.SEHException">O parâmetro <paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.SystemException">Não foi possível encontrar o arquivo.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O parâmetro <paramref name="path" /> especificou um arquivo somente leitura.  -ou-  Essa operação não é compatível com a plataforma atual.  -ou-  O parâmetro <paramref name="path" /> especificou um diretório.  -ou-  O chamador não tem a permissão necessária.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">permissão Ler a lista de controle de acesso. Ação de segurança: por demanda. Enumerações associadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.NoAccess" />, <see cref="F:System.Security.AccessControl.AccessControlActions.View" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public static System.Security.AccessControl.FileSecurity GetAccessControl (string path, System.Security.AccessControl.AccessControlSections includeSections);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.AccessControl.FileSecurity GetAccessControl(string path, valuetype System.Security.AccessControl.AccessControlSections includeSections) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.GetAccessControl(System.String,System.Security.AccessControl.AccessControlSections)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetAccessControl (path As String, includeSections As AccessControlSections) As FileSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::AccessControl::FileSecurity ^ GetAccessControl(System::String ^ path, System::Security::AccessControl::AccessControlSections includeSections);" />
      <MemberSignature Language="F#" Value="static member GetAccessControl : string * System.Security.AccessControl.AccessControlSections -&gt; System.Security.AccessControl.FileSecurity" Usage="System.IO.File.GetAccessControl (path, includeSections)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.FileSecurity</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="includeSections" Type="System.Security.AccessControl.AccessControlSections" />
      </Parameters>
      <Docs>
        <param name="path">O caminho para um arquivo que contém um objeto <see cref="T:System.Security.AccessControl.FileSecurity" /> que descreve as informações de ACL (lista de controle de acesso) do arquivo.</param>
        <param name="includeSections">Um dos valores <see cref="T:System.Security.AccessControl.AccessControlSections" /> que especifica o tipo de informações de ACL (lista de controle de acesso) a serem recebidas.</param>
        <summary>Obtém um objeto de <see cref="T:System.Security.AccessControl.FileSecurity" /> que encapsula o tipo especificado de entradas de ACL (lista de controle de acesso) de um arquivo específico.</summary>
        <returns>Um objeto <see cref="T:System.Security.AccessControl.FileSecurity" /> que encapsula as regras de controle de acesso para o arquivo descrito pelo parâmetro <paramref name="path" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use o <xref:System.IO.File.GetAccessControl%2A> método para recuperar as entradas ACL (lista) de controle de acesso para um arquivo.  
  
 Uma ACL descreve indivíduos e/ou grupos que têm ou não tem direitos para ações específicas no arquivo em questão. Para saber mais, confira [Como adicionar ou remover entradas da lista de controle de acesso](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md).  
  
 Em ambientes de NTFS <xref:System.Security.AccessControl.FileSystemRights.ReadAttributes> e <xref:System.Security.AccessControl.FileSystemRights.ReadExtendedAttributes> são concedidas ao usuário se o usuário tiver <xref:System.Security.AccessControl.FileSystemRights.ListDirectory> direitos na pasta pai. Negar <xref:System.Security.AccessControl.FileSystemRights.ReadAttributes> e <xref:System.Security.AccessControl.FileSystemRights.ReadExtendedAttributes>, negar <xref:System.Security.AccessControl.FileSystemRights.ListDirectory> no diretório pai.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Um erro de E/S ocorreu ao abrir o arquivo.</exception>
        <exception cref="T:System.Runtime.InteropServices.SEHException">O parâmetro <paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.SystemException">Não foi possível encontrar o arquivo.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O parâmetro <paramref name="path" /> especificou um arquivo somente leitura.  -ou-  Essa operação não é compatível com a plataforma atual.  -ou-  O parâmetro <paramref name="path" /> especificou um diretório.  -ou-  O chamador não tem a permissão necessária.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">permissão Ler a lista de controle de acesso. Ação de segurança: por demanda. Enumerações associadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.NoAccess" />, <see cref="F:System.Security.AccessControl.AccessControlActions.View" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetAttributes">
      <MemberSignature Language="C#" Value="public static System.IO.FileAttributes GetAttributes (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.IO.FileAttributes GetAttributes(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.GetAttributes(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetAttributes (path As String) As FileAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::FileAttributes GetAttributes(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetAttributes : string -&gt; System.IO.FileAttributes" Usage="System.IO.File.GetAttributes path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileAttributes</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">O caminho para o arquivo.</param>
        <summary>Obtém o <see cref="T:System.IO.FileAttributes" /> do arquivo no caminho.</summary>
        <returns>O <see cref="T:System.IO.FileAttributes" /> do arquivo no caminho.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `path` parâmetro tem permissão para especificar informações de caminho relativo ou absoluto. As informações do caminho relativo são interpretadas como relativas ao diretório de trabalho atual. Para obter o diretório de trabalho atual, consulte <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 O exemplo a seguir demonstra a `GetAttributes` e `SetAttributes` métodos aplicando o `Archive` e `Hidden` atributos para um arquivo.  
  
 [!code-cpp[File GetAttributes#1](~/samples/snippets/cpp/VS_Snippets_CLR/File GetAttributes/CPP/file getattributes.cpp#1)]
 [!code-csharp[File GetAttributes#1](~/samples/snippets/csharp/VS_Snippets_CLR/File GetAttributes/CS/file getattributes.cs#1)]
 [!code-vb[File GetAttributes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File GetAttributes/VB/file getattributes.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> está vazio, contém somente espaços em branco ou contém caracteres inválidos.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> está em um formato inválido.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="path" /> representa um arquivo e é inválido (por exemplo, está em uma unidade não mapeada) ou o arquivo não pode ser encontrado.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <paramref name="path" /> representa um diretório e é inválido (por exemplo, está em uma unidade não mapeada) ou o diretório não pode ser encontrado.</exception>
        <exception cref="T:System.IO.IOException">O arquivo está sendo usado por outro processo.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O chamador não tem a permissão necessária.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para ler arquivos. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetCreationTime">
      <MemberSignature Language="C#" Value="public static DateTime GetCreationTime (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime GetCreationTime(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.GetCreationTime(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCreationTime (path As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime GetCreationTime(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetCreationTime : string -&gt; DateTime" Usage="System.IO.File.GetCreationTime path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">O arquivo ou diretório para o qual obter informações de data e hora de criação.</param>
        <summary>Retorna a data e a hora de criação do arquivo ou diretório especificado.</summary>
        <returns>Uma estrutura <see cref="T:System.DateTime" /> definida como a data e a hora de criação para o arquivo ou diretório especificado. Esse valor é expresso no horário local.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Esse método pode retornar um valor incorreto, pois ela usa as funções nativas cujos valores não podem ser atualizados continuamente pelo sistema operacional.  
  
 O `path` parâmetro tem permissão para especificar informações de caminho relativo ou absoluto. As informações do caminho relativo são interpretadas como relativas ao diretório de trabalho atual. Para obter o diretório de trabalho atual, consulte <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Se o arquivo descrito no `path` parâmetro não existe, este método retorna meia-noite, 1º de janeiro de 1601 D.C. (C.E.) Tempo Universal Coordenado (UTC), ajustado para o horário local.  
  
 Unidades formatadas como NTFS podem armazenar em cache informações sobre um arquivo, como a hora de criação do arquivo, por um curto período de tempo. Como resultado, pode ser necessário definir explicitamente a hora de criação de um arquivo, se você estiver substituindo ou substituindo um arquivo existente.  
  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 O exemplo a seguir demonstra `GetCreationTime`.  
  
 [!code-vb[System.IO.File.GetCreationTime#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.file.getcreationtime/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou um ou mais caracteres inválidos, conforme definido por <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> está em um formato inválido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para a leitura do arquivo especificado. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="GetCreationTimeUtc">
      <MemberSignature Language="C#" Value="public static DateTime GetCreationTimeUtc (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime GetCreationTimeUtc(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.GetCreationTimeUtc(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCreationTimeUtc (path As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime GetCreationTimeUtc(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetCreationTimeUtc : string -&gt; DateTime" Usage="System.IO.File.GetCreationTimeUtc path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">O arquivo ou diretório para o qual obter informações de data e hora de criação.</param>
        <summary>Retorna a data e a hora de criação, em UTC (tempo universal coordenado) do arquivo ou do diretório especificado.</summary>
        <returns>Uma estrutura <see cref="T:System.DateTime" /> definida como a data e a hora de criação para o arquivo ou diretório especificado. Esse valor é expresso em horário UTC.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Esse método pode retornar um valor incorreto, pois ela usa as funções nativas cujos valores não podem ser atualizados continuamente pelo sistema operacional.  
  
 Se o arquivo descrito no `path` parâmetro não existe, este método retorna meia-noite, 1º de janeiro de 1601 D.C. (C.E.) Tempo Universal Coordenado (UTC).  
  
 Unidades formatadas como NTFS podem armazenar em cache informações sobre um arquivo, como a hora de criação do arquivo, por um curto período de tempo. Como resultado, pode ser necessário definir explicitamente a hora de criação de um arquivo, se você estiver substituindo ou substituindo um arquivo existente.  
  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.IO.File.GetCreationTimeUtc%2A> método.  
  
 [!code-vb[System.IO.File.GetCreationTime#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.file.getcreationtime/vb/module2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou um ou mais caracteres inválidos, conforme definido por <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> está em um formato inválido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para a leitura do arquivo especificado. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="GetLastAccessTime">
      <MemberSignature Language="C#" Value="public static DateTime GetLastAccessTime (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime GetLastAccessTime(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.GetLastAccessTime(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLastAccessTime (path As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime GetLastAccessTime(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetLastAccessTime : string -&gt; DateTime" Usage="System.IO.File.GetLastAccessTime path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">O arquivo ou diretório para o qual as informações de data e hora de acesso serão obtidas.</param>
        <summary>Retorna a data e hora em que o arquivo ou o diretório foi acessado pela última vez.</summary>
        <returns>Uma estrutura de <see cref="T:System.DateTime" /> definida como a data e hora em que o arquivo ou diretório especificado foi acessado pela última vez. Esse valor é expresso no horário local.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Esse método pode retornar um valor incorreto, pois ela usa as funções nativas cujos valores não podem ser atualizados continuamente pelo sistema operacional.  
  
 Se o arquivo descrito no `path` parâmetro não existe, este método retorna meia-noite, 1º de janeiro de 1601 D.C. (C.E.) Tempo Universal Coordenado (UTC), ajustado para o horário local.  
  
 O `path` parâmetro tem permissão para especificar informações de caminho relativo ou absoluto. As informações do caminho relativo são interpretadas como relativas ao diretório de trabalho atual. Para obter o diretório de trabalho atual, consulte <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 O exemplo a seguir demonstra `GetLastAccessTime`.  
  
 [!code-cpp[File GetLastAccess#1](~/samples/snippets/cpp/VS_Snippets_CLR/File GetLastAccess/CPP/file getlastaccess.cpp#1)]
 [!code-csharp[File GetLastAccess#1](~/samples/snippets/csharp/VS_Snippets_CLR/File GetLastAccess/CS/file getlastaccess.cs#1)]
 [!code-vb[File GetLastAccess#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File GetLastAccess/VB/file getlastaccess.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou um ou mais caracteres inválidos, conforme definido por <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> está em um formato inválido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para a leitura do arquivo especificado. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="GetLastAccessTimeUtc">
      <MemberSignature Language="C#" Value="public static DateTime GetLastAccessTimeUtc (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime GetLastAccessTimeUtc(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.GetLastAccessTimeUtc(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLastAccessTimeUtc (path As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime GetLastAccessTimeUtc(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetLastAccessTimeUtc : string -&gt; DateTime" Usage="System.IO.File.GetLastAccessTimeUtc path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">O arquivo ou diretório para o qual as informações de data e hora de acesso serão obtidas.</param>
        <summary>Retorna a data e hora, em UTC (Tempo Universal Coordenado), em que o arquivo ou diretório especificado foi acessado pela última vez.</summary>
        <returns>Uma estrutura de <see cref="T:System.DateTime" /> definida como a data e hora em que o arquivo ou diretório especificado foi acessado pela última vez. Esse valor é expresso em horário UTC.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Esse método pode retornar um valor incorreto, pois ela usa as funções nativas cujos valores não podem ser atualizados continuamente pelo sistema operacional.  
  
 Se o arquivo descrito no `path` parâmetro não existe, este método retorna meia-noite, 1º de janeiro de 1601 D.C. (C.E.) Tempo Universal Coordenado (UTC).  
  
 O `path` parâmetro tem permissão para especificar informações de caminho relativo ou absoluto. As informações do caminho relativo são interpretadas como relativas ao diretório de trabalho atual. Para obter o diretório de trabalho atual, consulte <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou um ou mais caracteres inválidos, conforme definido por <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> está em um formato inválido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para a leitura do arquivo especificado. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="GetLastWriteTime">
      <MemberSignature Language="C#" Value="public static DateTime GetLastWriteTime (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime GetLastWriteTime(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.GetLastWriteTime(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLastWriteTime (path As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime GetLastWriteTime(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetLastWriteTime : string -&gt; DateTime" Usage="System.IO.File.GetLastWriteTime path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">O arquivo ou diretório para o qual as informações de data e hora de gravação serão obtidas.</param>
        <summary>Retorna a data e hora em que o arquivo ou diretório especificado foi usado para gravação pela última vez.</summary>
        <returns>Uma estrutura <see cref="T:System.DateTime" /> definida com a data e hora em que o arquivo ou diretório especificado foi gravado pela última vez. Esse valor é expresso no horário local.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Esse método pode retornar um valor incorreto, pois ela usa as funções nativas cujos valores não podem ser atualizados continuamente pelo sistema operacional. Cada sistema operacional gerencia a última hora de gravação acordo com suas próprias regras. Para melhorar o desempenho, um sistema operacional não pode definir o último valor de tempo de gravação para a hora exata da última operação de gravação, mas pode defini-lo como uma aproximação em vez disso.  
  
 Se o arquivo descrito no `path` parâmetro não existe, este método retorna meia-noite, 1º de janeiro de 1601 D.C. (C.E.) Tempo Universal Coordenado (UTC), ajustado para o horário local.  
  
 O `path` parâmetro tem permissão para especificar informações de caminho relativo ou absoluto. As informações do caminho relativo são interpretadas como relativas ao diretório de trabalho atual. Para obter o diretório de trabalho atual, consulte <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 O exemplo a seguir demonstra `GetLastWriteTime`.  
  
 [!code-cpp[File GetLastWrite#1](~/samples/snippets/cpp/VS_Snippets_CLR/File GetLastWrite/CPP/file getlastwrite.cpp#1)]
 [!code-csharp[File GetLastWrite#1](~/samples/snippets/csharp/VS_Snippets_CLR/File GetLastWrite/CS/file getlastwrite.cs#1)]
 [!code-vb[File GetLastWrite#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File GetLastWrite/VB/file getlastwrite.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou um ou mais caracteres inválidos, conforme definido por <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> está em um formato inválido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para a leitura do arquivo especificado. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="GetLastWriteTimeUtc">
      <MemberSignature Language="C#" Value="public static DateTime GetLastWriteTimeUtc (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime GetLastWriteTimeUtc(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.GetLastWriteTimeUtc(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLastWriteTimeUtc (path As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime GetLastWriteTimeUtc(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetLastWriteTimeUtc : string -&gt; DateTime" Usage="System.IO.File.GetLastWriteTimeUtc path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">O arquivo ou diretório para o qual as informações de data e hora de gravação serão obtidas.</param>
        <summary>Retorna a data e hora, em UTC( horário universal coordenado), em que o arquivo ou diretório especificado foi gravado pela última vez.</summary>
        <returns>Uma estrutura <see cref="T:System.DateTime" /> definida com a data e hora em que o arquivo ou diretório especificado foi gravado pela última vez. Esse valor é expresso em horário UTC.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Esse método pode retornar um valor incorreto, pois ela usa as funções nativas cujos valores não podem ser atualizados continuamente pelo sistema operacional. Cada sistema operacional gerencia a última hora de gravação acordo com suas próprias regras. Para melhorar o desempenho, um sistema operacional não pode definir o último valor de tempo de gravação para a hora exata da última operação de gravação, mas pode defini-lo como uma aproximação em vez disso.  
  
 Se o arquivo descrito no `path` parâmetro não existe, este método retorna meia-noite, 1º de janeiro de 1601 D.C. (C.E.) Tempo Universal Coordenado (UTC).  
  
 O `path` parâmetro tem permissão para especificar informações de caminho relativo ou absoluto. As informações do caminho relativo são interpretadas como relativas ao diretório de trabalho atual. Para obter o diretório de trabalho atual, consulte <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou um ou mais caracteres inválidos, conforme definido por <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> está em um formato inválido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para a leitura do arquivo especificado. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="Move">
      <MemberSignature Language="C#" Value="public static void Move (string sourceFileName, string destFileName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Move(string sourceFileName, string destFileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Move(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Move (sourceFileName As String, destFileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Move(System::String ^ sourceFileName, System::String ^ destFileName);" />
      <MemberSignature Language="F#" Value="static member Move : string * string -&gt; unit" Usage="System.IO.File.Move (sourceFileName, destFileName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destFileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">O nome do arquivo a ser movido. Pode incluir um caminho relativo ou absoluto.</param>
        <param name="destFileName">O novo caminho e nome do arquivo.</param>
        <summary>Move um arquivo especificado para um novo local, oferecendo a opção de especificar um novo nome de arquivo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método funciona em volumes de disco, e ele não gera uma exceção se a origem e destino são os mesmos. Observe que, se você tentar substituir um arquivo movendo um arquivo de mesmo nome no diretório, você obterá um <xref:System.IO.IOException>. Você não pode usar o método Move para substituir um arquivo existente.  
  
 O `sourceFileName` e `destFileName` argumentos podem incluir informações de caminho relativo ou absoluto. As informações do caminho relativo são interpretadas como relativas ao diretório de trabalho atual. Para obter o diretório de trabalho atual, consulte <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Se você tentar mover um arquivo em volumes de disco e que arquivo está em uso, o arquivo é copiado para o destino, mas ele não é excluído da fonte.  
  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 O exemplo a seguir move um arquivo.  
  
 [!code-cpp[File Move#1](~/samples/snippets/cpp/VS_Snippets_CLR/File Move/CPP/file move.cpp#1)]
 [!code-csharp[File Move#1](~/samples/snippets/csharp/VS_Snippets_CLR/File Move/CS/file move.cs#1)]
 [!code-vb[File Move#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File Move/VB/file move.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">O arquivo de destino já existe.  -ou- <paramref name="sourceFileName" /> não foi encontrado.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sourceFileName" /> ou <paramref name="destFileName" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="sourceFileName" /> ou <paramref name="destFileName" /> é uma cadeia de caracteres de comprimento zero, contém somente espaços em branco ou caracteres inválidos, conforme definido em <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">O caminho especificado em <paramref name="sourceFileName" /> ou <paramref name="destFileName" /> é inválido (por exemplo, ele está em uma unidade não mapeada).</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="sourceFileName" /> ou <paramref name="destFileName" /> está em um formato inválido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para leitura do <paramref name="sourceFileName" /> e gravar em <paramref name="destFileName" />. Enumerações associadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Open">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Abre um <see cref="T:System.IO.FileStream" /> no caminho especificado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.FileStream Open (string path, System.IO.FileMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.FileStream Open(string path, valuetype System.IO.FileMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Open(System.String,System.IO.FileMode)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Open (path As String, mode As FileMode) As FileStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::FileStream ^ Open(System::String ^ path, System::IO::FileMode mode);" />
      <MemberSignature Language="F#" Value="static member Open : string * System.IO.FileMode -&gt; System.IO.FileStream" Usage="System.IO.File.Open (path, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
      </Parameters>
      <Docs>
        <param name="path">O arquivo a ser aberto.</param>
        <param name="mode">Um valor <see cref="T:System.IO.FileMode" /> que especifica se um arquivo deve ser criado caso não haja um e determina se o conteúdo dos arquivos existentes é mantido ou substituído.</param>
        <summary>Abre um <see cref="T:System.IO.FileStream" /> no caminho especificado com acesso de leitura/gravação sem compartilhamento.</summary>
        <returns>Um <see cref="T:System.IO.FileStream" /> aberto no modo e caminho especificado, com acesso de leitura/gravação e não compartilhado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `path` parâmetro tem permissão para especificar informações de caminho relativo ou absoluto. As informações do caminho relativo são interpretadas como relativas ao diretório de trabalho atual. Para obter o diretório de trabalho atual, consulte <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 O exemplo de código a seguir cria um arquivo temporário e escreve algum texto a ele. O exemplo, em seguida, abre o arquivo usando T:System.IO.FileMode.Open; ou seja, se o arquivo ainda não existia, ela seria não criada.  
  
 [!code-cpp[File Open1#1](~/samples/snippets/cpp/VS_Snippets_CLR/File Open1/CPP/file open1.cpp#1)]
 [!code-csharp[File Open1#1](~/samples/snippets/csharp/VS_Snippets_CLR/File Open1/CS/file open1.cs#1)]
 [!code-vb[File Open1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File Open1/VB/file open1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou um ou mais caracteres inválidos, conforme definido por <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">O caminho especificado é inválido (por exemplo, ele está em uma unidade não mapeada).</exception>
        <exception cref="T:System.IO.IOException">Um erro de E/S ocorreu ao abrir o arquivo.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> especificou um arquivo somente leitura.  -ou-  Essa operação não é compatível com a plataforma atual.  -ou-  <paramref name="path" /> especificou um diretório.  -ou- O chamador não tem a permissão necessária.  -ou- <paramref name="mode" /> é <see cref="F:System.IO.FileMode.Create" /> e o arquivo especificado é um arquivo oculto.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="mode" /> especificou um valor inválido.</exception>
        <exception cref="T:System.IO.FileNotFoundException">O arquivo especificado em <paramref name="path" /> não foi encontrado.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> está em um formato inválido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para ler e gravar no arquivo especificado. Enumerações associadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.FileStream Open (string path, System.IO.FileMode mode, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.FileStream Open(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Open(System.String,System.IO.FileMode,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Open (path As String, mode As FileMode, access As FileAccess) As FileStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::FileStream ^ Open(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access);" />
      <MemberSignature Language="F#" Value="static member Open : string * System.IO.FileMode * System.IO.FileAccess -&gt; System.IO.FileStream" Usage="System.IO.File.Open (path, mode, access)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="path">O arquivo a ser aberto.</param>
        <param name="mode">Um valor <see cref="T:System.IO.FileMode" /> que especifica se um arquivo deve ser criado caso não haja um e determina se o conteúdo dos arquivos existentes é mantido ou substituído.</param>
        <param name="access">Um valor <see cref="T:System.IO.FileAccess" /> que especifica as operações que podem ser executadas no arquivo.</param>
        <summary>Abre um <see cref="T:System.IO.FileStream" /> no caminho especificado, com o modo e o acesso especificados sem compartilhamento.</summary>
        <returns>Um <see cref="T:System.IO.FileStream" /> com compartilhamento cancelado que fornece acesso ao arquivo especificado, com o modo e o acesso especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `path` parâmetro tem permissão para especificar informações de caminho relativo ou absoluto. As informações do caminho relativo são interpretadas como relativas ao diretório de trabalho atual. Para obter o diretório de trabalho atual, consulte <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
   
  
## Examples  
 O exemplo a seguir abre um arquivo com acesso somente leitura.  
  
 [!code-cpp[file open2#1](~/samples/snippets/cpp/VS_Snippets_CLR/File Open2/CPP/file open2.cpp#1)]
 [!code-csharp[file open2#1](~/samples/snippets/csharp/VS_Snippets_CLR/File Open2/CS/file open2.cs#1)]
 [!code-vb[file open2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File Open2/VB/file open2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou um ou mais caracteres inválidos, conforme definido por <see cref="F:System.IO.Path.InvalidPathChars" />.  -ou- <paramref name="access" /> especificou <see langword="Read" /> e <paramref name="mode" /> especificou <see langword="Create" />, <see langword="CreateNew" />, <see langword="Truncate" /> ou <see langword="Append" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">O caminho especificado é inválido (por exemplo, ele está em uma unidade não mapeada).</exception>
        <exception cref="T:System.IO.IOException">Um erro de E/S ocorreu ao abrir o arquivo.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> especificou um arquivo somente leitura e <paramref name="access" /> não é <see langword="Read" />.  -ou-  <paramref name="path" /> especificou um diretório.  -ou- O chamador não tem a permissão necessária.  -ou- <paramref name="mode" /> é <see cref="F:System.IO.FileMode.Create" /> e o arquivo especificado é um arquivo oculto.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="mode" /> ou <paramref name="access" /> especificou um valor inválido.</exception>
        <exception cref="T:System.IO.FileNotFoundException">O arquivo especificado em <paramref name="path" /> não foi encontrado.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> está em um formato inválido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para ler e gravar no arquivo especificado. Enumerações associadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.FileStream Open (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.FileStream Open(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Open(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Open (path As String, mode As FileMode, access As FileAccess, share As FileShare) As FileStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::FileStream ^ Open(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share);" />
      <MemberSignature Language="F#" Value="static member Open : string * System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare -&gt; System.IO.FileStream" Usage="System.IO.File.Open (path, mode, access, share)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
      </Parameters>
      <Docs>
        <param name="path">O arquivo a ser aberto.</param>
        <param name="mode">Um valor <see cref="T:System.IO.FileMode" /> que especifica se um arquivo deve ser criado caso não haja um e determina se o conteúdo dos arquivos existentes é mantido ou substituído.</param>
        <param name="access">Um valor <see cref="T:System.IO.FileAccess" /> que especifica as operações que podem ser executadas no arquivo.</param>
        <param name="share">Um valor <see cref="T:System.IO.FileShare" /> que especifica o tipo de acesso que outros threads têm ao arquivo.</param>
        <summary>Abre um <see cref="T:System.IO.FileStream" /> no caminho especificado, tendo o modo especificado com acesso de leitura, gravação ou leitura/gravação e a opção de compartilhamento especificada.</summary>
        <returns>Um <see cref="T:System.IO.FileStream" /> no caminho especificado, tendo o modo especificado com acesso de leitura, gravação ou leitura/gravação e a opção de compartilhamento especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `path` parâmetro tem permissão para especificar informações de caminho relativo ou absoluto. As informações do caminho relativo são interpretadas como relativas ao diretório de trabalho atual. Para obter o diretório de trabalho atual, consulte <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 O exemplo a seguir abre um arquivo com acesso somente leitura e com o compartilhamento de arquivo não permitida.  
  
 [!code-cpp[file open3#1](~/samples/snippets/cpp/VS_Snippets_CLR/File Open3/CPP/file open3.cpp#1)]
 [!code-csharp[file open3#1](~/samples/snippets/csharp/VS_Snippets_CLR/File Open3/CS/file open3.cs#1)]
 [!code-vb[file open3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File Open3/VB/file open3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou um ou mais caracteres inválidos, conforme definido por <see cref="F:System.IO.Path.InvalidPathChars" />.  -ou- <paramref name="access" /> especificou <see langword="Read" /> e <paramref name="mode" /> especificou <see langword="Create" />, <see langword="CreateNew" />, <see langword="Truncate" /> ou <see langword="Append" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">O caminho especificado é inválido (por exemplo, ele está em uma unidade não mapeada).</exception>
        <exception cref="T:System.IO.IOException">Um erro de E/S ocorreu ao abrir o arquivo.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> especificou um arquivo somente leitura e <paramref name="access" /> não é <see langword="Read" />.  -ou-  <paramref name="path" /> especificou um diretório.  -ou- O chamador não tem a permissão necessária.  -ou- <paramref name="mode" /> é <see cref="F:System.IO.FileMode.Create" /> e o arquivo especificado é um arquivo oculto.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="mode" />, <paramref name="access" /> ou <paramref name="share" /> especificou um valor inválido.</exception>
        <exception cref="T:System.IO.FileNotFoundException">O arquivo especificado em <paramref name="path" /> não foi encontrado.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> está em um formato inválido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para ler e gravar no arquivo especificado. Enumerações associadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="OpenRead">
      <MemberSignature Language="C#" Value="public static System.IO.FileStream OpenRead (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.FileStream OpenRead(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.OpenRead(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenRead (path As String) As FileStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::FileStream ^ OpenRead(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member OpenRead : string -&gt; System.IO.FileStream" Usage="System.IO.File.OpenRead path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">O arquivo a ser aberto para leitura.</param>
        <summary>Abre um arquivo existente para leitura.</summary>
        <returns>Um <see cref="T:System.IO.FileStream" /> somente leitura no caminho especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é equivalente à <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%29> sobrecarga de construtor com um <xref:System.IO.FileMode> valor de <xref:System.IO.FileMode.Open>, uma <xref:System.IO.FileAccess> valor de <xref:System.IO.FileAccess.Read> e uma <xref:System.IO.FileShare> valor de <xref:System.IO.FileShare.Read>.  
  
 O `path` parâmetro tem permissão para especificar informações de caminho relativo ou absoluto. As informações do caminho relativo são interpretadas como relativas ao diretório de trabalho atual. Para obter o diretório de trabalho atual, consulte <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 O exemplo a seguir abre um arquivo para leitura.  
  
 [!code-cpp[file openread#1](~/samples/snippets/cpp/VS_Snippets_CLR/File OpenRead/CPP/file openread.cpp#1)]
 [!code-csharp[file openread#1](~/samples/snippets/csharp/VS_Snippets_CLR/File OpenRead/CS/file openread.cs#1)]
 [!code-vb[file openread#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File OpenRead/VB/file openread.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou um ou mais caracteres inválidos, conforme definido por <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">O caminho especificado é inválido (por exemplo, ele está em uma unidade não mapeada).</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> especificou um diretório.  -ou-  O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.IO.FileNotFoundException">O arquivo especificado em <paramref name="path" /> não foi encontrado.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> está em um formato inválido.</exception>
        <exception cref="T:System.IO.IOException">Um erro de E/S ocorreu ao abrir o arquivo.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para a leitura do arquivo especificado. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="OpenText">
      <MemberSignature Language="C#" Value="public static System.IO.StreamReader OpenText (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.StreamReader OpenText(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.OpenText(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenText (path As String) As StreamReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::StreamReader ^ OpenText(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member OpenText : string -&gt; System.IO.StreamReader" Usage="System.IO.File.OpenText path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.StreamReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">O arquivo a ser aberto para leitura.</param>
        <summary>Abre um arquivo de texto com codificação UTF-8 existente para leitura.</summary>
        <returns>Um <see cref="T:System.IO.StreamReader" /> no caminho especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é equivalente a <xref:System.IO.StreamReader.%23ctor%28System.String%29> sobrecarga de construtor.  
  
 O `path` parâmetro tem permissão para especificar informações de caminho relativo ou absoluto. As informações do caminho relativo são interpretadas como relativas ao diretório de trabalho atual. Para obter o diretório de trabalho atual, consulte <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 O exemplo a seguir abre um arquivo de texto para leitura.  
  
 [!code-cpp[file opentext#1](~/samples/snippets/cpp/VS_Snippets_CLR/File OpenText/CPP/file opentext.cpp#1)]
 [!code-csharp[file opentext#1](~/samples/snippets/csharp/VS_Snippets_CLR/File OpenText/CS/file opentext.cs#1)]
 [!code-vb[file opentext#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File OpenText/VB/file opentext.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou um ou mais caracteres inválidos, conforme definido por <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">O caminho especificado é inválido (por exemplo, ele está em uma unidade não mapeada).</exception>
        <exception cref="T:System.IO.FileNotFoundException">O arquivo especificado em <paramref name="path" /> não foi encontrado.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> está em um formato inválido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para a leitura do arquivo especificado. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="OpenWrite">
      <MemberSignature Language="C#" Value="public static System.IO.FileStream OpenWrite (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.FileStream OpenWrite(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.OpenWrite(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenWrite (path As String) As FileStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::FileStream ^ OpenWrite(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member OpenWrite : string -&gt; System.IO.FileStream" Usage="System.IO.File.OpenWrite path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">O arquivo a ser aberto para gravação.</param>
        <summary>Abre um arquivo existente ou cria um novo arquivo para gravação.</summary>
        <returns>Um objeto <see cref="T:System.IO.FileStream" /> não compartilhado no caminho especificado com acesso <see cref="F:System.IO.FileAccess.Write" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é equivalente à <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%29> sobrecarga de construtor com o modo de arquivo definido como <xref:System.IO.FileMode.OpenOrCreate>, o acesso definido como <xref:System.IO.FileAccess.Write>e o modo de compartilhamento definido como <xref:System.IO.FileShare.None>.  
  
 O <xref:System.IO.File.OpenWrite%2A> método abre um arquivo, se um já existe para o caminho do arquivo ou cria um novo arquivo, se ainda não existir. Para um arquivo existente, ele não anexa o novo texto ao texto existente. Em vez disso, ele substitui os caracteres existentes com os novos caracteres. Se você substituir uma cadeia de caracteres mais longa (como "Este é um teste do método OpenWrite") com uma cadeia de caracteres mais curta (por exemplo, "segunda execução"), o arquivo conterá uma combinação das cadeias de caracteres ("segundo runtest do método OpenWrite").  
  
 O `path` parâmetro pode especificar informações de caminho relativo ou absoluto. As informações do caminho relativo são interpretadas como relativas ao diretório de trabalho atual. Para obter o diretório de trabalho atual, use o <xref:System.IO.Directory.GetCurrentDirectory%2A> método.  
  
 Retornado <xref:System.IO.FileStream> não dá suporte à leitura. Para abrir um arquivo para leitura e gravação, use <xref:System.IO.File.Open%2A>.

 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 O exemplo a seguir abre um arquivo para leitura e gravação.  
  
 [!code-cpp[file openwrite#1](~/samples/snippets/cpp/VS_Snippets_CLR/File OpenWrite/CPP/file openwrite.cpp#1)]
 [!code-csharp[file openwrite#1](~/samples/snippets/csharp/VS_Snippets_CLR/File OpenWrite/CS/file openwrite.cs#1)]
 [!code-vb[file openwrite#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File OpenWrite/VB/file openwrite.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">O chamador não tem a permissão necessária.  -ou- <paramref name="path" /> especificou um arquivo ou um diretório somente leitura.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou um ou mais caracteres inválidos, conforme definido por <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">O caminho especificado é inválido (por exemplo, ele está em uma unidade não mapeada).</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> está em um formato inválido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para gravar no arquivo especificado. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ReadAllBytes">
      <MemberSignature Language="C#" Value="public static byte[] ReadAllBytes (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8[] ReadAllBytes(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.ReadAllBytes(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadAllBytes (path As String) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Byte&gt; ^ ReadAllBytes(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member ReadAllBytes : string -&gt; byte[]" Usage="System.IO.File.ReadAllBytes path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">O arquivo a ser aberto para leitura.</param>
        <summary>Abre um arquivo binário, lê o conteúdo do arquivo em uma matriz de bytes e, em seguida, fecha o arquivo.</summary>
        <returns>Uma matriz de bytes que contém o conteúdo do arquivo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dado um caminho de arquivo, este método abre o arquivo, lê o conteúdo do arquivo em uma matriz de bytes e, em seguida, fecha o arquivo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou um ou mais caracteres inválidos, conforme definido por <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">O caminho especificado é inválido (por exemplo, ele está em uma unidade não mapeada).</exception>
        <exception cref="T:System.IO.IOException">Um erro de E/S ocorreu ao abrir o arquivo.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Não há suporte para essa operação na plataforma atual.  -ou-  <paramref name="path" /> especificou um diretório.  -ou-  O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.IO.FileNotFoundException">O arquivo especificado em <paramref name="path" /> não foi encontrado.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> está em um formato inválido.</exception>
        <exception cref="T:System.Security.SecurityException">O chamador não tem a permissão necessária.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para acesso de leitura de um arquivo ou diretório. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ReadAllBytesAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;byte[]&gt; ReadAllBytesAsync (string path, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;unsigned int8[]&gt; ReadAllBytesAsync(string path, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.ReadAllBytesAsync(System.String,System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="static member ReadAllBytesAsync : string * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;byte[]&gt;" Usage="System.IO.File.ReadAllBytesAsync (path, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Byte[]&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadAllLines">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Abre um arquivo de texto, lê todas as linhas do arquivo em uma matriz de cadeia de caracteres e o fecha.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadAllLines">
      <MemberSignature Language="C#" Value="public static string[] ReadAllLines (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] ReadAllLines(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.ReadAllLines(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadAllLines (path As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ ReadAllLines(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member ReadAllLines : string -&gt; string[]" Usage="System.IO.File.ReadAllLines path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">O arquivo a ser aberto para leitura.</param>
        <summary>Abre um arquivo de texto, lê todas as linhas dele e o fecha.</summary>
        <returns>Uma matriz de cadeia de caracteres que contém todas as linhas do arquivo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método abre um arquivo, lê cada linha do arquivo e, em seguida, adiciona cada linha como um elemento de uma matriz de cadeia de caracteres. Ele fecha o arquivo. Uma é definida como uma sequência de caracteres seguidos por um retorno de carro ('\r'), uma alimentação de linha ('\n') ou um retorno de carro seguido imediatamente por uma linha de alimentação de linha. A cadeia de caracteres resultante não contém a terminação retorno de carro e/ou alimentação de linha.  
  
 Esse método tenta automaticamente detectar a codificação de um arquivo com base na presença de marcas de ordem de byte. Formatos de codificação UTF-8 e UTF-32 (big-endian e little endian) pode ser detectados.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso do <xref:System.IO.File.ReadAllLines%2A> método para exibir o conteúdo de um arquivo. Neste exemplo um arquivo é criado, se ele ainda não existir, e o texto é adicionado a ele.  
  
 [!code-csharp[System.IO.File.AllLines#00](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.File.AllLines/cs/AllText.cs#00)]
 [!code-vb[System.IO.File.AllLines#00](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.File.AllLines/vb/AllText.vb#00)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou um ou mais caracteres inválidos, conforme definido por <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">O caminho especificado é inválido (por exemplo, ele está em uma unidade não mapeada).</exception>
        <exception cref="T:System.IO.IOException">Um erro de E/S ocorreu ao abrir o arquivo.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> especificou um arquivo somente leitura.  -ou-  Essa operação não é compatível com a plataforma atual.  -ou-  <paramref name="path" /> especificou um diretório.  -ou-  O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.IO.FileNotFoundException">O arquivo especificado em <paramref name="path" /> não foi encontrado.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> está em um formato inválido.</exception>
        <exception cref="T:System.Security.SecurityException">O chamador não tem a permissão necessária.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para acesso de leitura de um arquivo ou diretório. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ReadAllLines">
      <MemberSignature Language="C#" Value="public static string[] ReadAllLines (string path, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] ReadAllLines(string path, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.ReadAllLines(System.String,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ ReadAllLines(System::String ^ path, System::Text::Encoding ^ encoding);" />
      <MemberSignature Language="F#" Value="static member ReadAllLines : string * System.Text.Encoding -&gt; string[]" Usage="System.IO.File.ReadAllLines (path, encoding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="path">O arquivo a ser aberto para leitura.</param>
        <param name="encoding">A codificação aplicada ao conteúdo do arquivo.</param>
        <summary>Abre um arquivo, lê todas as linhas do arquivo com a codificação especificada e fecha o arquivo.</summary>
        <returns>Uma matriz de cadeia de caracteres que contém todas as linhas do arquivo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método abre um arquivo, lê cada linha do arquivo e, em seguida, adiciona cada linha como um elemento de uma matriz de cadeia de caracteres. Ele fecha o arquivo. Uma é definida como uma sequência de caracteres seguidos por um retorno de carro ('\r'), uma alimentação de linha ('\n') ou um retorno de carro seguido imediatamente por uma linha de alimentação de linha. A cadeia de caracteres resultante não contém a terminação retorno de carro e/ou alimentação de linha.  
  
 Esse método tenta automaticamente detectar a codificação de um arquivo com base na presença de marcas de ordem de byte. Formatos de codificação UTF-8 e UTF-32 (big-endian e little endian) pode ser detectados.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso do <xref:System.IO.File.ReadAllLines%2A> método para exibir o conteúdo de um arquivo. Neste exemplo um arquivo é criado, se ele ainda não existir, e o texto é adicionado a ele.  
  
 [!code-csharp[System.IO.File.AllLines_Encoding#00](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.File.AllLines_Encoding/cs/AllText_Encoding.cs#00)]
 [!code-vb[System.IO.File.AllLines_Encoding#00](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.File.AllLines_Encoding/vb/AllText_Encoding.vb#00)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou um ou mais caracteres inválidos, conforme definido por <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">O caminho especificado é inválido (por exemplo, ele está em uma unidade não mapeada).</exception>
        <exception cref="T:System.IO.IOException">Um erro de E/S ocorreu ao abrir o arquivo.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> especificou um arquivo somente leitura.  -ou-  Essa operação não é compatível com a plataforma atual.  -ou-  <paramref name="path" /> especificou um diretório.  -ou-  O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.IO.FileNotFoundException">O arquivo especificado em <paramref name="path" /> não foi encontrado.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> está em um formato inválido.</exception>
        <exception cref="T:System.Security.SecurityException">O chamador não tem a permissão necessária.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para acesso de leitura de um arquivo ou diretório. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ReadAllLinesAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;string[]&gt; ReadAllLinesAsync (string path, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;string[]&gt; ReadAllLinesAsync(string path, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.ReadAllLinesAsync(System.String,System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="static member ReadAllLinesAsync : string * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;string[]&gt;" Usage="System.IO.File.ReadAllLinesAsync (path, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.String[]&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadAllLinesAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;string[]&gt; ReadAllLinesAsync (string path, System.Text.Encoding encoding, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;string[]&gt; ReadAllLinesAsync(string path, class System.Text.Encoding encoding, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.ReadAllLinesAsync(System.String,System.Text.Encoding,System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="static member ReadAllLinesAsync : string * System.Text.Encoding * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;string[]&gt;" Usage="System.IO.File.ReadAllLinesAsync (path, encoding, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.String[]&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="encoding">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadAllText">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Abre um arquivo de texto, lê todas as linhas dele em uma cadeia de caracteres e o fecha.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadAllText">
      <MemberSignature Language="C#" Value="public static string ReadAllText (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ReadAllText(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.ReadAllText(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadAllText (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ ReadAllText(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member ReadAllText : string -&gt; string" Usage="System.IO.File.ReadAllText path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">O arquivo a ser aberto para leitura.</param>
        <summary>Abre um arquivo de texto, lê todas as linhas dele e o fecha.</summary>
        <returns>Uma cadeia de caracteres que contém todas as linhas do arquivo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método abre um arquivo, lê cada linha do arquivo e, em seguida, adiciona cada linha como um elemento de uma cadeia de caracteres. Ele fecha o arquivo. Uma é definida como uma sequência de caracteres seguidos por um retorno de carro ('\r'), uma alimentação de linha ('\n') ou um retorno de carro seguido imediatamente por uma linha de alimentação de linha. A cadeia de caracteres resultante não contém a terminação retorno de carro e/ou alimentação de linha.  
  
 Esse método tenta automaticamente detectar a codificação de um arquivo com base na presença de marcas de ordem de byte. Formatos de codificação UTF-8 e UTF-32 (big-endian e little endian) pode ser detectados.  
  
 Use o <xref:System.IO.File.ReadAllText%28System.String%2CSystem.Text.Encoding%29> sobrecarga do método quando a leitura de arquivos que podem conter texto importado, pois não reconhecida caracteres não poderão ser lidos corretamente.  
  
 O identificador de arquivo é garantido para ser fechada por esse método, mesmo se as exceções são geradas.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso do <xref:System.IO.File.ReadAllText%2A> método para exibir o conteúdo de um arquivo. Neste exemplo um arquivo é criado, se ele ainda não existir, e o texto é adicionado a ele.  
  
 [!code-csharp[System.IO.File.AllText#00](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.File.AllText/cs/AllText.cs#00)]
 [!code-vb[System.IO.File.AllText#00](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.File.AllText/vb/AllText.vb#00)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou um ou mais caracteres inválidos, conforme definido por <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">O caminho especificado é inválido (por exemplo, ele está em uma unidade não mapeada).</exception>
        <exception cref="T:System.IO.IOException">Um erro de E/S ocorreu ao abrir o arquivo.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> especificou um arquivo somente leitura.  -ou-  Essa operação não é compatível com a plataforma atual.  -ou-  <paramref name="path" /> especificou um diretório.  -ou-  O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.IO.FileNotFoundException">O arquivo especificado em <paramref name="path" /> não foi encontrado.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> está em um formato inválido.</exception>
        <exception cref="T:System.Security.SecurityException">O chamador não tem a permissão necessária.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para acesso de leitura de um arquivo ou diretório. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ReadAllText">
      <MemberSignature Language="C#" Value="public static string ReadAllText (string path, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ReadAllText(string path, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.ReadAllText(System.String,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ ReadAllText(System::String ^ path, System::Text::Encoding ^ encoding);" />
      <MemberSignature Language="F#" Value="static member ReadAllText : string * System.Text.Encoding -&gt; string" Usage="System.IO.File.ReadAllText (path, encoding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="path">O arquivo a ser aberto para leitura.</param>
        <param name="encoding">A codificação aplicada ao conteúdo do arquivo.</param>
        <summary>Abre um arquivo, lê todas as linhas do arquivo com a codificação especificada e fecha o arquivo.</summary>
        <returns>Uma cadeia de caracteres que contém todas as linhas do arquivo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método abre um arquivo, lê cada linha do arquivo e, em seguida, adiciona cada linha como um elemento de uma cadeia de caracteres. Ele fecha o arquivo. Uma é definida como uma sequência de caracteres seguidos por um retorno de carro ('\r'), uma alimentação de linha ('\n') ou um retorno de carro seguido imediatamente por uma linha de alimentação de linha. A cadeia de caracteres resultante não contém a terminação retorno de carro e/ou alimentação de linha.  
  
 Esse método tenta automaticamente detectar a codificação de um arquivo com base na presença de marcas de ordem de byte. Formatos de codificação UTF-8 e UTF-32 (big-endian e little endian) pode ser detectados.  
  
 O identificador de arquivo é garantido para ser fechada por esse método, mesmo se as exceções são geradas.  
  
 Para usar as configurações de codificação conforme configurado para seu sistema operacional, especifique o <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType> propriedade para o `encoding` parâmetro.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso do <xref:System.IO.File.ReadAllText%2A> método para exibir o conteúdo de um arquivo. Neste exemplo um arquivo é criado, se ele ainda não existir, e o texto é adicionado a ele.  
  
 [!code-csharp[System.IO.File.AllText_Encoding#00](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.File.AllText_Encoding/cs/AllText.cs#00)]
 [!code-vb[System.IO.File.AllText_Encoding#00](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.File.AllText_Encoding/vb/AllText.vb#00)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou um ou mais caracteres inválidos, conforme definido por <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">O caminho especificado é inválido (por exemplo, ele está em uma unidade não mapeada).</exception>
        <exception cref="T:System.IO.IOException">Um erro de E/S ocorreu ao abrir o arquivo.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> especificou um arquivo somente leitura.  -ou-  Essa operação não é compatível com a plataforma atual.  -ou-  <paramref name="path" /> especificou um diretório.  -ou-  O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.IO.FileNotFoundException">O arquivo especificado em <paramref name="path" /> não foi encontrado.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> está em um formato inválido.</exception>
        <exception cref="T:System.Security.SecurityException">O chamador não tem a permissão necessária.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para acesso de leitura de um arquivo ou diretório. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ReadAllTextAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;string&gt; ReadAllTextAsync (string path, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;string&gt; ReadAllTextAsync(string path, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.ReadAllTextAsync(System.String,System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="static member ReadAllTextAsync : string * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;string&gt;" Usage="System.IO.File.ReadAllTextAsync (path, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadAllTextAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;string&gt; ReadAllTextAsync (string path, System.Text.Encoding encoding, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;string&gt; ReadAllTextAsync(string path, class System.Text.Encoding encoding, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.ReadAllTextAsync(System.String,System.Text.Encoding,System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="static member ReadAllTextAsync : string * System.Text.Encoding * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;string&gt;" Usage="System.IO.File.ReadAllTextAsync (path, encoding, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="encoding">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadLines">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Lê as linhas de um arquivo.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadLines">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; ReadLines (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; ReadLines(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.ReadLines(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadLines (path As String) As IEnumerable(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ ReadLines(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member ReadLines : string -&gt; seq&lt;string&gt;" Usage="System.IO.File.ReadLines path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">O arquivo a ser lido.</param>
        <summary>Lê as linhas de um arquivo.</summary>
        <returns>Todas as linhas do arquivo, ou as linhas que são resultado de uma consulta.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.IO.File.ReadLines%2A> e <xref:System.IO.File.ReadAllLines%2A> métodos diferem da seguinte maneira: quando você usa <xref:System.IO.File.ReadLines%2A>, você pode começar a enumeração da coleção de cadeias de caracteres antes da coleção inteira é retornada; quando você usa <xref:System.IO.File.ReadAllLines%2A>, você deve esperar para ser de toda a matriz de cadeias de caracteres retornado antes de poder acessar a matriz. Portanto, quando você estiver trabalhando com arquivos muito grandes, <xref:System.IO.File.ReadLines%2A> pode ser mais eficiente.  
  
 Você pode usar o <xref:System.IO.File.ReadLines%2A> método para fazer o seguinte:  
  
-   Realizar [LINQ to Objects](http://msdn.microsoft.com/library/73cafe73-37cf-46e7-bfa7-97c7eea7ced9) consultas em um arquivo para obter um conjunto filtrado de suas linhas.  
  
-   Gravar a coleção retornada de linhas em um arquivo com o <xref:System.IO.File.WriteAllLines%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29?displayProperty=nameWithType> método, ou acrescentá-los a um arquivo existente com o <xref:System.IO.File.AppendAllLines%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29?displayProperty=nameWithType> método.  
  
-   Criar uma instância imediatamente preenchida de uma coleção que usa um <xref:System.Collections.Generic.IEnumerable%601> coleção de cadeias de caracteres para seu construtor, tal como uma <xref:System.Collections.Generic.IList%601> ou um <xref:System.Collections.Generic.Queue%601>.  
  
 Esse método usa <xref:System.Text.Encoding.UTF8%2A> para o valor de codificação.  
  
   
  
## Examples  
 O exemplo a seguir lê as linhas de um arquivo para localizar linhas que contêm cadeias de caracteres especificadas.  
  
 [!code-csharp[System.IO.File.ReadLines#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.file.readlines/cs/program.cs#1)]
 [!code-vb[System.IO.File.ReadLines#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.file.readlines/vb/program.vb#1)]  
  
 O exemplo a seguir usa o <xref:System.IO.File.ReadLines%2A> método em uma consulta LINQ que enumera todos os diretórios para arquivos que têm uma extensão. txt, lê cada linha do arquivo e exibe a linha se ela contém a cadeia de caracteres "Microsoft".  
  
 [!code-csharp[System.IO.Directory.EnumerateFiles#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.directory.enumeratefiles/cs/program.cs#1)]
 [!code-vb[System.IO.Directory.EnumerateFiles#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.directory.enumeratefiles/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou contém um ou mais caracteres inválidos definidos pelo método <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <paramref name="path" /> é inválido (por exemplo, está em uma unidade não mapeada).</exception>
        <exception cref="T:System.IO.FileNotFoundException">O arquivo especificado por <paramref name="path" /> não foi encontrado.</exception>
        <exception cref="T:System.IO.IOException">Um erro de E/S ocorreu ao abrir o arquivo.</exception>
        <exception cref="T:System.IO.PathTooLongException">
          <paramref name="path" /> excede o tamanho máximo definido pelo sistema.</exception>
        <exception cref="T:System.Security.SecurityException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> especifica um arquivo somente leitura.  -ou-  Essa operação não é compatível com a plataforma atual.  -ou- <paramref name="path" /> é um diretório.  -ou-  O chamador não tem a permissão necessária.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadLines">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; ReadLines (string path, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; ReadLines(string path, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.ReadLines(System.String,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ ReadLines(System::String ^ path, System::Text::Encoding ^ encoding);" />
      <MemberSignature Language="F#" Value="static member ReadLines : string * System.Text.Encoding -&gt; seq&lt;string&gt;" Usage="System.IO.File.ReadLines (path, encoding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="path">O arquivo a ser lido.</param>
        <param name="encoding">A codificação aplicada ao conteúdo do arquivo.</param>
        <summary>Leia as linhas de um arquivo que tem uma codificação especificada.</summary>
        <returns>Todas as linhas do arquivo, ou as linhas que são resultado de uma consulta.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use esse método para especificar uma codificação para usar a ler o arquivo.  
  
 O <xref:System.IO.File.ReadLines%2A> e <xref:System.IO.File.ReadAllLines%2A> métodos diferem da seguinte maneira: quando você usa <xref:System.IO.File.ReadLines%2A>, você pode começar a enumeração da coleção de cadeias de caracteres antes que a coleção inteira é retornada. Quando você usa <xref:System.IO.File.ReadAllLines%2A>, você deve esperar por toda a matriz de cadeias de caracteres retornados antes de você pode acessar a matriz. Portanto, quando você estiver trabalhando com arquivos muito grandes, <xref:System.IO.File.ReadLines%2A> pode ser mais eficiente.  
  
 Você pode usar o <xref:System.IO.File.ReadLines%2A> método para fazer o seguinte:  
  
-   Realizar [LINQ to Objects](http://msdn.microsoft.com/library/73cafe73-37cf-46e7-bfa7-97c7eea7ced9) consultas em um arquivo para obter um conjunto filtrado de suas linhas.  
  
-   Gravar a coleção retornada de linhas em um arquivo com o <xref:System.IO.File.WriteAllLines%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%2CSystem.Text.Encoding%29?displayProperty=nameWithType> método, ou acrescentá-los a um arquivo existente com o <xref:System.IO.File.AppendAllLines%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%2CSystem.Text.Encoding%29?displayProperty=nameWithType> método.  
  
-   Criar uma instância imediatamente preenchida de uma coleção que usa um <xref:System.Collections.Generic.IEnumerable%601> coleção de cadeias de caracteres para seu construtor, tal como uma <xref:System.Collections.Generic.IList%601> ou um <xref:System.Collections.Generic.Queue%601>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> é uma cadeia de tamanho zero, contém somente espaços em branco ou contém um ou mais caracteres inválidos definidos pelo método <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <paramref name="path" /> é inválido (por exemplo, está em uma unidade não mapeada).</exception>
        <exception cref="T:System.IO.FileNotFoundException">O arquivo especificado por <paramref name="path" /> não foi encontrado.</exception>
        <exception cref="T:System.IO.IOException">Um erro de E/S ocorreu ao abrir o arquivo.</exception>
        <exception cref="T:System.IO.PathTooLongException">
          <paramref name="path" /> excede o tamanho máximo definido pelo sistema.</exception>
        <exception cref="T:System.Security.SecurityException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> especifica um arquivo somente leitura.  -ou-  Essa operação não é compatível com a plataforma atual.  -ou- <paramref name="path" /> é um diretório.  -ou-  O chamador não tem a permissão necessária.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Replace">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Substitui o conteúdo de um arquivo especificado pelo conteúdo de outro arquivo, excluindo o arquivo original e criando um backup do arquivo substituído.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.IO.File.Replace%2A> métodos substituem o conteúdo de um arquivo especificado com o conteúdo de outro arquivo.  Eles também pode criar um backup do arquivo que foi substituído.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static void Replace (string sourceFileName, string destinationFileName, string destinationBackupFileName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Replace(string sourceFileName, string destinationFileName, string destinationBackupFileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Replace(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Replace (sourceFileName As String, destinationFileName As String, destinationBackupFileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Replace(System::String ^ sourceFileName, System::String ^ destinationFileName, System::String ^ destinationBackupFileName);" />
      <MemberSignature Language="F#" Value="static member Replace : string * string * string -&gt; unit" Usage="System.IO.File.Replace (sourceFileName, destinationFileName, destinationBackupFileName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destinationFileName" Type="System.String" />
        <Parameter Name="destinationBackupFileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">O nome de um arquivo que substitui o arquivo especificado por <c>destinationFileName</c>.</param>
        <param name="destinationFileName">O nome do arquivo que está sendo substituído.</param>
        <param name="destinationBackupFileName">O nome do arquivo de backup.</param>
        <summary>Substitui o conteúdo de um arquivo especificado pelo conteúdo de outro arquivo, excluindo o arquivo original e criando um backup do arquivo substituído.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.IO.File.Replace%2A> método substitui o conteúdo de um arquivo especificado com o conteúdo de outro arquivo.  Ele também cria um backup do arquivo que foi substituído.  
  
 Se o `sourceFileName` e `destinationFileName` estão em diferentes volumes, esse método gerará uma exceção. Se o `destinationBackupFileName` está em um volume diferente do arquivo de origem, o arquivo de backup será excluído.  
  
 Passar `null` para o `destinationBackupFileName` parâmetro se você não quiser criar um backup do arquivo que está sendo substituído.  

 Se o `destinationBackupFileName` já existe será substituído pelo conteúdo do `destinationFileName` arquivo.
  
   
  
## Examples  
 O seguinte exemplo de código usa o <xref:System.IO.File.Replace%2A> método para substituir um arquivo com outro arquivo e criar um backup do arquivo substituído.  
  
 [!code-cpp[IO.File.Replace#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.File.Replace/cpp/sample.cpp#1)]
 [!code-csharp[IO.File.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.File.Replace/CS/sample.cs#1)]
 [!code-vb[IO.File.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.File.Replace/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O caminho descrito pelo parâmetro <paramref name="destinationFileName" /> tinha um formato inválido.  -ou-  O caminho descrito pelo parâmetro <paramref name="destinationBackupFileName" /> não tinha um formato válido.</exception>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="destinationFileName" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.DriveNotFoundException">Uma unidade inválida foi especificada.</exception>
        <exception cref="T:System.IO.FileNotFoundException">O arquivo descrito pelo objeto <see cref="T:System.IO.FileInfo" /> atual não pôde ser encontrado.  -ou-  O arquivo descrito pelo parâmetro <paramref name="destinationBackupFileName" /> não pôde ser encontrado.</exception>
        <exception cref="T:System.IO.IOException">Um erro de E/S ocorreu ao abrir o arquivo.  \- ou - Os parâmetros <paramref name="sourceFileName" /> e <paramref name="destinationFileName" /> especificam o mesmo arquivo.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema.</exception>
        <exception cref="T:System.PlatformNotSupportedException">O sistema operacional é Windows 98 Second Edition ou anterior e o sistema de arquivos não é NTFS.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O parâmetro <paramref name="sourceFileName" /> ou <paramref name="destinationFileName" /> especifica um arquivo somente leitura.  -ou-  Essa operação não é compatível com a plataforma atual.  -ou- Os parâmetros de origem ou de destino especificam um diretório em vez de um arquivo.  -ou-  O chamador não tem a permissão necessária.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para a permissão de gravação ao arquivo descrito pelo <paramref name="destinationBackupFileName" /> parâmetro se um for especificado. Ação de segurança: por demanda. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static void Replace (string sourceFileName, string destinationFileName, string destinationBackupFileName, bool ignoreMetadataErrors);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Replace(string sourceFileName, string destinationFileName, string destinationBackupFileName, bool ignoreMetadataErrors) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Replace(System.String,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Replace (sourceFileName As String, destinationFileName As String, destinationBackupFileName As String, ignoreMetadataErrors As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Replace(System::String ^ sourceFileName, System::String ^ destinationFileName, System::String ^ destinationBackupFileName, bool ignoreMetadataErrors);" />
      <MemberSignature Language="F#" Value="static member Replace : string * string * string * bool -&gt; unit" Usage="System.IO.File.Replace (sourceFileName, destinationFileName, destinationBackupFileName, ignoreMetadataErrors)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destinationFileName" Type="System.String" />
        <Parameter Name="destinationBackupFileName" Type="System.String" />
        <Parameter Name="ignoreMetadataErrors" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">O nome de um arquivo que substitui o arquivo especificado por <c>destinationFileName</c>.</param>
        <param name="destinationFileName">O nome do arquivo que está sendo substituído.</param>
        <param name="destinationBackupFileName">O nome do arquivo de backup.</param>
        <param name="ignoreMetadataErrors">
          <see langword="true" /> para ignorar erros de mesclagem (como atributos e listas de controle de acesso (ACLs)) do arquivo substituído para o arquivo de substituição; caso contrário, <see langword="false" />.</param>
        <summary>Substitui o conteúdo de um arquivo especificado pelo conteúdo de outro arquivo, excluindo o arquivo original, criando um backup do arquivo substituído e, opcionalmente, ignora erros de mesclagem.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.IO.File.Replace%2A> método substitui o conteúdo de um arquivo especificado com o conteúdo de outro arquivo.  Ele também cria um backup do arquivo que foi substituído.  
  
 Se o `sourceFileName` e `destinationFileName` estão em diferentes volumes, esse método gerará uma exceção. Se o `destinationBackupFileName` está em um volume diferente do arquivo de origem, o arquivo de backup será excluído.  
  
 Passar `null` para o `destinationBackupFileName` parâmetro se você não quiser criar um backup do arquivo que está sendo substituído.  

 Se o `destinationBackupFileName` já existe será substituído pelo conteúdo do `destinationFileName` arquivo.
  
   
  
## Examples  
 O seguinte exemplo de código usa o <xref:System.IO.File.Replace%2A> método para substituir um arquivo com outro arquivo e criar um backup do arquivo substituído.  
  
 [!code-cpp[IO.File.Replace#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.File.Replace/cpp/sample.cpp#1)]
 [!code-csharp[IO.File.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.File.Replace/CS/sample.cs#1)]
 [!code-vb[IO.File.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.File.Replace/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O caminho descrito pelo parâmetro <paramref name="destinationFileName" /> tinha um formato inválido.  -ou-  O caminho descrito pelo parâmetro <paramref name="destinationBackupFileName" /> não tinha um formato válido.</exception>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="destinationFileName" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.DriveNotFoundException">Uma unidade inválida foi especificada.</exception>
        <exception cref="T:System.IO.FileNotFoundException">O arquivo descrito pelo objeto <see cref="T:System.IO.FileInfo" /> atual não pôde ser encontrado.  -ou-  O arquivo descrito pelo parâmetro <paramref name="destinationBackupFileName" /> não pôde ser encontrado.</exception>
        <exception cref="T:System.IO.IOException">Um erro de E/S ocorreu ao abrir o arquivo.  \- ou - Os parâmetros <paramref name="sourceFileName" /> e <paramref name="destinationFileName" /> especificam o mesmo arquivo.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema.</exception>
        <exception cref="T:System.PlatformNotSupportedException">O sistema operacional é Windows 98 Second Edition ou anterior e o sistema de arquivos não é NTFS.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O parâmetro <paramref name="sourceFileName" /> ou <paramref name="destinationFileName" /> especifica um arquivo somente leitura.  -ou-  Essa operação não é compatível com a plataforma atual.  -ou- Os parâmetros de origem ou de destino especificam um diretório em vez de um arquivo.  -ou-  O chamador não tem a permissão necessária.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para a permissão de gravação ao arquivo descrito pelo <paramref name="destinationBackupFileName" /> parâmetro se um for especificado. Ação de segurança: por demanda. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public static void SetAccessControl (string path, System.Security.AccessControl.FileSecurity fileSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetAccessControl(string path, class System.Security.AccessControl.FileSecurity fileSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.SetAccessControl(System.String,System.Security.AccessControl.FileSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetAccessControl(System::String ^ path, System::Security::AccessControl::FileSecurity ^ fileSecurity);" />
      <MemberSignature Language="F#" Value="static member SetAccessControl : string * System.Security.AccessControl.FileSecurity -&gt; unit" Usage="System.IO.File.SetAccessControl (path, fileSecurity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="fileSecurity" Type="System.Security.AccessControl.FileSecurity" />
      </Parameters>
      <Docs>
        <param name="path">Um arquivo ao qual adicionar ou remover entradas de ACL (lista de controle de acesso).</param>
        <param name="fileSecurity">Um objeto <see cref="T:System.Security.AccessControl.FileSecurity" /> que descreve uma entrada de ACL para aplicar ao arquivo descrito pelo parâmetro <c>path</c>.</param>
        <summary>Aplica entradas de ACL (lista de controle de acesso) descritas por um objeto <see cref="T:System.Security.AccessControl.FileSecurity" /> ao arquivo especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.IO.File.SetAccessControl%2A> método se aplica a entradas ACL (lista) de controle de acesso a um arquivo que representa a lista ACL noninherited.  
  
> [!CAUTION]
>  A ACL é especificado para o `fileSecurity` parâmetro substitui a ACL existente para o arquivo. Para adicionar permissões para um novo usuário, use o <xref:System.IO.File.GetAccessControl%2A> método para obter a ACL existente, modificá-lo e, em seguida, usar <xref:System.IO.File.SetAccessControl%2A> para aplicá-la de volta para o arquivo.  
  
 Uma ACL descreve indivíduos e/ou grupos que têm ou não tem direitos para ações específicas no arquivo em questão. Para saber mais, confira [Como adicionar ou remover entradas da lista de controle de acesso](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md).  
  
 O <xref:System.IO.File.SetAccessControl%2A> método persiste somente <xref:System.Security.AccessControl.FileSecurity> objetos que foram modificados após a criação do objeto.  Se um <xref:System.Security.AccessControl.FileSecurity> objeto não tiver sido modificado, ele não será persistente em um arquivo.  Portanto, não é possível recuperar um <xref:System.Security.AccessControl.FileSecurity> do objeto de um arquivo e reaplicar o mesmo objeto para outro arquivo.  
  
 Para copiar informações de ACL de um arquivo para outro:  
  
1.  Use o <xref:System.IO.File.GetAccessControl%2A> método para recuperar o <xref:System.Security.AccessControl.FileSecurity> objeto do arquivo de origem.  
  
2.  Criar um novo <xref:System.Security.AccessControl.FileSecurity> objeto para o arquivo de destino.  
  
3.  Use o <xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorBinaryForm%2A> ou <xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorSddlForm%2A> método da fonte de <xref:System.Security.AccessControl.FileSecurity> objeto para recuperar as informações de ACL.  
  
4.  Use o <xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorBinaryForm%2A> ou <xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorSddlForm%2A> método para copiar as informações recuperadas na etapa 3 para o destino <xref:System.Security.AccessControl.FileSecurity> objeto.  
  
5.  Definir o destino <xref:System.Security.AccessControl.FileSecurity> objeto para o arquivo de destino usando o <xref:System.IO.File.SetAccessControl%2A> método.  
  
 Em ambientes de NTFS <xref:System.Security.AccessControl.FileSystemRights.ReadAttributes> e <xref:System.Security.AccessControl.FileSystemRights.ReadExtendedAttributes> são concedidas ao usuário se o usuário tiver <xref:System.Security.AccessControl.FileSystemRights.ListDirectory> direitos na pasta pai. Negar <xref:System.Security.AccessControl.FileSystemRights.ReadAttributes> e <xref:System.Security.AccessControl.FileSystemRights.ReadExtendedAttributes>, negar <xref:System.Security.AccessControl.FileSystemRights.ListDirectory> no diretório pai.  
  
   
  
## Examples  
 O seguinte exemplo de código usa o <xref:System.IO.File.GetAccessControl%2A> e <xref:System.IO.File.SetAccessControl%2A> métodos para adicionar e, em seguida, remover o acesso de um controlam de entrada ACL (lista) de um arquivo.  Você deve fornecer uma conta de grupo ou de usuário válida para executar este exemplo.  
  
 [!code-cpp[IO.File.GetAccessControl-SetAccessControl#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.File.GetAccessControl-SetAccessControl/cpp/sample.cpp#1)]
 [!code-csharp[IO.File.GetAccessControl-SetAccessControl#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.File.GetAccessControl-SetAccessControl/CS/sample.cs#1)]
 [!code-vb[IO.File.GetAccessControl-SetAccessControl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.File.GetAccessControl-SetAccessControl/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Um erro de E/S ocorreu ao abrir o arquivo.</exception>
        <exception cref="T:System.Runtime.InteropServices.SEHException">O parâmetro <paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.SystemException">Não foi possível encontrar o arquivo.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O parâmetro <paramref name="path" /> especificou um arquivo somente leitura.  -ou-  Essa operação não é compatível com a plataforma atual.  -ou-  O parâmetro <paramref name="path" /> especificou um diretório.  -ou-  O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="fileSecurity" /> é <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">permissão acessar o arquivo. Ação de segurança: por demanda. Enumerações associadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.NoAccess" />, <see cref="F:System.Security.AccessControl.AccessControlActions.Change" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="SetAttributes">
      <MemberSignature Language="C#" Value="public static void SetAttributes (string path, System.IO.FileAttributes fileAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetAttributes(string path, valuetype System.IO.FileAttributes fileAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.SetAttributes(System.String,System.IO.FileAttributes)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetAttributes(System::String ^ path, System::IO::FileAttributes fileAttributes);" />
      <MemberSignature Language="F#" Value="static member SetAttributes : string * System.IO.FileAttributes -&gt; unit" Usage="System.IO.File.SetAttributes (path, fileAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="fileAttributes" Type="System.IO.FileAttributes" />
      </Parameters>
      <Docs>
        <param name="path">O caminho para o arquivo.</param>
        <param name="fileAttributes">Um combinação bit a bit dos valores de enumeração.</param>
        <summary>Define o <see cref="T:System.IO.FileAttributes" /> especificado do arquivo no caminho especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `path` parâmetro tem permissão para especificar informações de caminho relativo ou absoluto. As informações do caminho relativo são interpretadas como relativas ao diretório de trabalho atual. Para obter o diretório de trabalho atual, consulte <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Atributos, determinados arquivos, como <xref:System.IO.FileAttributes.Hidden> e <xref:System.IO.FileAttributes.ReadOnly>, podem ser combinados. Outros atributos, como <xref:System.IO.FileAttributes.Normal>, deve ser usado sozinho.  
  
 Não é possível alterar o status de compactação de um <xref:System.IO.File> do objeto usando o <xref:System.IO.File.SetAttributes%2A> método.  
  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 O exemplo a seguir demonstra a `GetAttributes` e `SetAttributes` métodos aplicando o `Archive` e `Hidden` atributos para um arquivo.  
  
 [!code-cpp[File GetAttributes#1](~/samples/snippets/cpp/VS_Snippets_CLR/File GetAttributes/CPP/file getattributes.cpp#1)]
 [!code-csharp[File GetAttributes#1](~/samples/snippets/csharp/VS_Snippets_CLR/File GetAttributes/CS/file getattributes.cs#1)]
 [!code-vb[File GetAttributes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File GetAttributes/VB/file getattributes.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> está vazio, contém somente espaços em branco, contém caracteres inválidos ou o atributo de arquivo é inválido.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> está em um formato inválido.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">O caminho especificado é inválido (por exemplo, ele está em uma unidade não mapeada).</exception>
        <exception cref="T:System.IO.FileNotFoundException">O arquivo não pode ser encontrado.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> especificou um arquivo somente leitura.  -ou-  Essa operação não é compatível com a plataforma atual.  -ou-  <paramref name="path" /> especificou um diretório.  -ou-  O chamador não tem a permissão necessária.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para ler e gravar arquivos. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="SetCreationTime">
      <MemberSignature Language="C#" Value="public static void SetCreationTime (string path, DateTime creationTime);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetCreationTime(string path, valuetype System.DateTime creationTime) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.SetCreationTime(System.String,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetCreationTime (path As String, creationTime As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetCreationTime(System::String ^ path, DateTime creationTime);" />
      <MemberSignature Language="F#" Value="static member SetCreationTime : string * DateTime -&gt; unit" Usage="System.IO.File.SetCreationTime (path, creationTime)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="creationTime" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">O arquivo para o qual obter as informações de data e hora de criação.</param>
        <param name="creationTime">Um <see cref="T:System.DateTime" /> que contém o valor a ser definido para a data de criação e a hora de <c>path</c>. Esse valor é expresso no horário local.</param>
        <summary>Define a data e a hora em que o arquivo foi criado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `path` parâmetro tem permissão para especificar informações de caminho relativo ou absoluto. As informações do caminho relativo são interpretadas como relativas ao diretório de trabalho atual. Para obter o diretório de trabalho atual, consulte <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Unidades formatadas como NTFS podem armazenar em cache meta-informações do arquivo, como o tempo de criação do arquivo, por um curto período de tempo. Como resultado, pode ser necessário definir explicitamente a hora de criação de um arquivo, se você estiver substituindo ou substituindo um arquivo existente.  
  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">O caminho especificado não foi encontrado.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou um ou mais caracteres inválidos, conforme definido por <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema.</exception>
        <exception cref="T:System.IO.IOException">Um erro de E/S ocorreu ao realizar a operação.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="creationTime" /> especifica um valor fora do intervalo de datas, horas ou ambos permitidos para esta operação.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> está em um formato inválido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para gravar no arquivo especificado. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="SetCreationTimeUtc">
      <MemberSignature Language="C#" Value="public static void SetCreationTimeUtc (string path, DateTime creationTimeUtc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetCreationTimeUtc(string path, valuetype System.DateTime creationTimeUtc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.SetCreationTimeUtc(System.String,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetCreationTimeUtc (path As String, creationTimeUtc As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetCreationTimeUtc(System::String ^ path, DateTime creationTimeUtc);" />
      <MemberSignature Language="F#" Value="static member SetCreationTimeUtc : string * DateTime -&gt; unit" Usage="System.IO.File.SetCreationTimeUtc (path, creationTimeUtc)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="creationTimeUtc" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">O arquivo para o qual obter as informações de data e hora de criação.</param>
        <param name="creationTimeUtc">Um <see cref="T:System.DateTime" /> que contém o valor a ser definido para a data de criação e a hora de <c>path</c>. Esse valor é expresso em horário UTC.</param>
        <summary>Define a data e hora, em UTC (Tempo Universal Coordenado), em que o arquivo foi criado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `path` parâmetro tem permissão para especificar informações de caminho relativo ou absoluto. As informações do caminho relativo são interpretadas como relativas ao diretório de trabalho atual. Para obter o diretório de trabalho atual, consulte <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Unidades formatadas como NTFS podem armazenar em cache meta-informações do arquivo, como o tempo de criação do arquivo, por um curto período de tempo. Como resultado, pode ser necessário definir explicitamente a hora de criação de um arquivo, se você estiver substituindo ou substituindo um arquivo existente.  
  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">O caminho especificado não foi encontrado.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou um ou mais caracteres inválidos, conforme definido por <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema.</exception>
        <exception cref="T:System.IO.IOException">Um erro de E/S ocorreu ao realizar a operação.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="creationTime" /> especifica um valor fora do intervalo de datas, horas ou ambos permitidos para esta operação.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> está em um formato inválido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para gravar no arquivo especificado. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="SetLastAccessTime">
      <MemberSignature Language="C#" Value="public static void SetLastAccessTime (string path, DateTime lastAccessTime);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetLastAccessTime(string path, valuetype System.DateTime lastAccessTime) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.SetLastAccessTime(System.String,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetLastAccessTime (path As String, lastAccessTime As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetLastAccessTime(System::String ^ path, DateTime lastAccessTime);" />
      <MemberSignature Language="F#" Value="static member SetLastAccessTime : string * DateTime -&gt; unit" Usage="System.IO.File.SetLastAccessTime (path, lastAccessTime)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="lastAccessTime" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">O arquivo cujas informações de data e hora serão definidas.</param>
        <param name="lastAccessTime">Um <see cref="T:System.DateTime" /> que contém o valor a ser definido para a data e hora do último acesso de <c>path</c>. Esse valor é expresso no horário local.</param>
        <summary>Define a data e hora em que o arquivo especificado foi acessado pela última vez.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `path` parâmetro tem permissão para especificar informações de caminho relativo ou absoluto. As informações do caminho relativo são interpretadas como relativas ao diretório de trabalho atual. Para obter o diretório de trabalho atual, consulte <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 O exemplo a seguir verifica o sistema de arquivos para o arquivo especificado, criá-lo se necessário e, em seguida, define e obtém a hora do último acesso.  
  
 [!code-cpp[file setlastaccess#1](~/samples/snippets/cpp/VS_Snippets_CLR/File SetLastAccess/CPP/file setlastaccess.cpp#1)]
 [!code-csharp[file setlastaccess#1](~/samples/snippets/csharp/VS_Snippets_CLR/File SetLastAccess/CS/file setlastaccess.cs#1)]
 [!code-vb[file setlastaccess#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File SetLastAccess/VB/file setlastaccess.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou um ou mais caracteres inválidos, conforme definido por <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema.</exception>
        <exception cref="T:System.IO.FileNotFoundException">O caminho especificado não foi encontrado.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> está em um formato inválido.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="lastAccessTime" /> especifica um valor fora do intervalo de datas, horas permitido para esta operação.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para gravar no arquivo especificado. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="SetLastAccessTimeUtc">
      <MemberSignature Language="C#" Value="public static void SetLastAccessTimeUtc (string path, DateTime lastAccessTimeUtc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetLastAccessTimeUtc(string path, valuetype System.DateTime lastAccessTimeUtc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.SetLastAccessTimeUtc(System.String,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetLastAccessTimeUtc (path As String, lastAccessTimeUtc As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetLastAccessTimeUtc(System::String ^ path, DateTime lastAccessTimeUtc);" />
      <MemberSignature Language="F#" Value="static member SetLastAccessTimeUtc : string * DateTime -&gt; unit" Usage="System.IO.File.SetLastAccessTimeUtc (path, lastAccessTimeUtc)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="lastAccessTimeUtc" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">O arquivo cujas informações de data e hora serão definidas.</param>
        <param name="lastAccessTimeUtc">Um <see cref="T:System.DateTime" /> que contém o valor a ser definido para a data e hora do último acesso de <c>path</c>. Esse valor é expresso em horário UTC.</param>
        <summary>Define a data e hora, em UTC (Tempo Universal Coordenado), em que o arquivo especificado foi acessado pela última vez.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `path` parâmetro tem permissão para especificar informações de caminho relativo ou absoluto. As informações do caminho relativo são interpretadas como relativas ao diretório de trabalho atual. Para obter o diretório de trabalho atual, consulte <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou um ou mais caracteres inválidos, conforme definido por <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema.</exception>
        <exception cref="T:System.IO.FileNotFoundException">O caminho especificado não foi encontrado.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> está em um formato inválido.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="lastAccessTimeUtc" /> especifica um valor fora do intervalo de datas, horas permitido para esta operação.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para gravar no arquivo especificado. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="SetLastWriteTime">
      <MemberSignature Language="C#" Value="public static void SetLastWriteTime (string path, DateTime lastWriteTime);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetLastWriteTime(string path, valuetype System.DateTime lastWriteTime) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.SetLastWriteTime(System.String,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetLastWriteTime (path As String, lastWriteTime As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetLastWriteTime(System::String ^ path, DateTime lastWriteTime);" />
      <MemberSignature Language="F#" Value="static member SetLastWriteTime : string * DateTime -&gt; unit" Usage="System.IO.File.SetLastWriteTime (path, lastWriteTime)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="lastWriteTime" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">O arquivo para o qual obter as informações de data e hora.</param>
        <param name="lastWriteTime">Um <see cref="T:System.DateTime" /> que contém o valor a ser definido para a última data e hora de gravação de <c>path</c>. Esse valor é expresso no horário local.</param>
        <summary>Define a data e hora em que o arquivo especificado foi usado para gravação pela última vez.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `path` parâmetro tem permissão para especificar informações de caminho relativo ou absoluto. As informações do caminho relativo são interpretadas como relativas ao diretório de trabalho atual. Para obter o diretório de trabalho atual, consulte <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 O exemplo a seguir verifica o sistema de arquivos para o arquivo especificado, criando o arquivo se necessário e, em seguida, define e obtém a hora da última gravação do arquivo.  
  
 [!code-cpp[file setlastwrite#1](~/samples/snippets/cpp/VS_Snippets_CLR/File SetLastWrite/CPP/file setlastwrite.cpp#1)]
 [!code-csharp[file setlastwrite#1](~/samples/snippets/csharp/VS_Snippets_CLR/File SetLastWrite/CS/file setlastwrite.cs#1)]
 [!code-vb[file setlastwrite#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File SetLastWrite/VB/file setlastwrite.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou um ou mais caracteres inválidos, conforme definido por <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema.</exception>
        <exception cref="T:System.IO.FileNotFoundException">O caminho especificado não foi encontrado.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> está em um formato inválido.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="lastWriteTime" /> especifica um valor fora do intervalo de datas, horas permitido para esta operação.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para gravar no arquivo especificado. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="SetLastWriteTimeUtc">
      <MemberSignature Language="C#" Value="public static void SetLastWriteTimeUtc (string path, DateTime lastWriteTimeUtc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetLastWriteTimeUtc(string path, valuetype System.DateTime lastWriteTimeUtc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.SetLastWriteTimeUtc(System.String,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetLastWriteTimeUtc (path As String, lastWriteTimeUtc As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetLastWriteTimeUtc(System::String ^ path, DateTime lastWriteTimeUtc);" />
      <MemberSignature Language="F#" Value="static member SetLastWriteTimeUtc : string * DateTime -&gt; unit" Usage="System.IO.File.SetLastWriteTimeUtc (path, lastWriteTimeUtc)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="lastWriteTimeUtc" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">O arquivo para o qual obter as informações de data e hora.</param>
        <param name="lastWriteTimeUtc">Um <see cref="T:System.DateTime" /> que contém o valor a ser definido para a última data e hora de gravação de <c>path</c>. Esse valor é expresso em horário UTC.</param>
        <summary>Define a data e hora, em UTC (Tempo Universal Coordenado), em que o arquivo especificado foi gravado pela última vez.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `path` parâmetro tem permissão para especificar informações de caminho relativo ou absoluto. As informações do caminho relativo são interpretadas como relativas ao diretório de trabalho atual. Para obter o diretório de trabalho atual, consulte <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou um ou mais caracteres inválidos, conforme definido por <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema.</exception>
        <exception cref="T:System.IO.FileNotFoundException">O caminho especificado não foi encontrado.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> está em um formato inválido.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="lastWriteTimeUtc" /> especifica um valor fora do intervalo de datas, horas permitido para esta operação.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para gravar no arquivo especificado. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="WriteAllBytes">
      <MemberSignature Language="C#" Value="public static void WriteAllBytes (string path, byte[] bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteAllBytes(string path, unsigned int8[] bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.WriteAllBytes(System.String,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteAllBytes (path As String, bytes As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteAllBytes(System::String ^ path, cli::array &lt;System::Byte&gt; ^ bytes);" />
      <MemberSignature Language="F#" Value="static member WriteAllBytes : string * byte[] -&gt; unit" Usage="System.IO.File.WriteAllBytes (path, bytes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="bytes" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="path">O arquivo para gravação.</param>
        <param name="bytes">Os bytes a serem gravados no arquivo.</param>
        <summary>Cria um novo arquivo, grava a matriz de bytes especificada no arquivo e fecha o arquivo. Se o arquivo de destino já existir, ele será substituído.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dada uma matriz de bytes e um caminho de arquivo, este método abre o arquivo especificado, grava o conteúdo da matriz de bytes no arquivo e, em seguida, fecha o arquivo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou um ou mais caracteres inválidos, conforme definido por <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> é <see langword="null" /> ou a matriz de bytes está vazia.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">O caminho especificado é inválido (por exemplo, ele está em uma unidade não mapeada).</exception>
        <exception cref="T:System.IO.IOException">Um erro de E/S ocorreu ao abrir o arquivo.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> especificou um arquivo somente leitura.  -ou-  Essa operação não é compatível com a plataforma atual.  -ou-  <paramref name="path" /> especificou um diretório.  -ou-  O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> está em um formato inválido.</exception>
        <exception cref="T:System.Security.SecurityException">O chamador não tem a permissão necessária.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para acesso de gravação para um arquivo ou diretório. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="WriteAllBytesAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task WriteAllBytesAsync (string path, byte[] bytes, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task WriteAllBytesAsync(string path, unsigned int8[] bytes, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.WriteAllBytesAsync(System.String,System.Byte[],System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="static member WriteAllBytesAsync : string * byte[] * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="System.IO.File.WriteAllBytesAsync (path, bytes, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="bytes">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteAllLines">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Cria um novo arquivo, grava uma ou mais cadeias de caracteres nele e o fecha.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteAllLines">
      <MemberSignature Language="C#" Value="public static void WriteAllLines (string path, System.Collections.Generic.IEnumerable&lt;string&gt; contents);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteAllLines(string path, class System.Collections.Generic.IEnumerable`1&lt;string&gt; contents) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.WriteAllLines(System.String,System.Collections.Generic.IEnumerable{System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteAllLines (path As String, contents As IEnumerable(Of String))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteAllLines(System::String ^ path, System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ contents);" />
      <MemberSignature Language="F#" Value="static member WriteAllLines : string * seq&lt;string&gt; -&gt; unit" Usage="System.IO.File.WriteAllLines (path, contents)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="path">O arquivo para gravação.</param>
        <param name="contents">As linhas a serem gravadas no arquivo.</param>
        <summary>Cria um novo arquivo, grava uma coleção de cadeias de caracteres no arquivo e fecha o arquivo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O comportamento padrão do <xref:System.IO.File.WriteAllLines%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29> método é para gravar dados usando a codificação UTF-8 sem uma marca de ordem de byte (BOM). Se for necessário incluir um identificador de UTF-8, como uma marca de ordem de byte no início de um arquivo, use o <xref:System.IO.File.WriteAllLines%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%2CSystem.Text.Encoding%29> sobrecarga de método com <xref:System.Text.Encoding.UTF8%2A> codificação.  
  
 Se o arquivo de destino já existir, ele será substituído.  
  
 Você pode usar esse método para criar o conteúdo para uma classe de coleção que usa um <xref:System.Collections.Generic.IEnumerable%601> em seu construtor, tal como uma <xref:System.Collections.Generic.List%601.%23ctor%2A>, <xref:System.Collections.Generic.HashSet%601.%23ctor%2A>, ou um <xref:System.Collections.Generic.SortedSet%601.%23ctor%2A> classe.  
  
   
  
## Examples  
 O exemplo a seguir grava linhas selecionadas de um arquivo de dados de exemplo em um arquivo.  
  
 [!code-csharp[System.IO.File.WriteAllAppendAll#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.file.writeallappendall/cs/program.cs#1)]
 [!code-vb[System.IO.File.WriteAllAppendAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.file.writeallappendall/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou contém um ou mais caracteres inválidos definidos pelo método <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">O <paramref name="path" /> ou <paramref name="contents" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <paramref name="path" /> é inválido (por exemplo, está em uma unidade não mapeada).</exception>
        <exception cref="T:System.IO.IOException">Um erro de E/S ocorreu ao abrir o arquivo.</exception>
        <exception cref="T:System.IO.PathTooLongException">
          <paramref name="path" /> excede o tamanho máximo definido pelo sistema.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> está em um formato inválido.</exception>
        <exception cref="T:System.Security.SecurityException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> especifica um arquivo somente leitura.  -ou-  Essa operação não é compatível com a plataforma atual.  -ou- <paramref name="path" /> é um diretório.  -ou-  O chamador não tem a permissão necessária.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteAllLines">
      <MemberSignature Language="C#" Value="public static void WriteAllLines (string path, string[] contents);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteAllLines(string path, string[] contents) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.WriteAllLines(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteAllLines (path As String, contents As String())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteAllLines(System::String ^ path, cli::array &lt;System::String ^&gt; ^ contents);" />
      <MemberSignature Language="F#" Value="static member WriteAllLines : string * string[] -&gt; unit" Usage="System.IO.File.WriteAllLines (path, contents)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="path">O arquivo para gravação.</param>
        <param name="contents">A matriz de cadeia de caracteres a ser gravada no arquivo.</param>
        <summary>Cria um novo arquivo, grava a matriz de cadeia de caracteres especificada no arquivo e fecha o arquivo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se o arquivo de destino já existir, ele será substituído.  
  
 O comportamento padrão do <xref:System.IO.File.WriteAllLines%2A> método é para gravar dados usando a codificação UTF-8 sem uma marca de ordem de byte (BOM). Se for necessário incluir um identificador de UTF-8, como uma marca de ordem de byte no início de um arquivo, use o <xref:System.IO.File.WriteAllLines%28System.String%2CSystem.String%5B%5D%2CSystem.Text.Encoding%29> sobrecarga de método com <xref:System.Text.Encoding.UTF8%2A> codificação.  
  
 Dada uma matriz de cadeia de caracteres e um caminho de arquivo, este método abre o arquivo especificado, grava a matriz de cadeia de caracteres para o arquivo e, em seguida, fecha o arquivo.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso do <xref:System.IO.File.WriteAllLines%2A> método para gravar texto em um arquivo. Neste exemplo um arquivo é criado, se ele ainda não existir, e o texto é adicionado a ele.  
  
 [!code-csharp[System.IO.File.AllLines#00](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.File.AllLines/cs/AllText.cs#00)]
 [!code-vb[System.IO.File.AllLines#00](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.File.AllLines/vb/AllText.vb#00)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou um ou mais caracteres inválidos, conforme definido por <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">O <paramref name="path" /> ou <paramref name="contents" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">O caminho especificado é inválido (por exemplo, ele está em uma unidade não mapeada).</exception>
        <exception cref="T:System.IO.IOException">Um erro de E/S ocorreu ao abrir o arquivo.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> especificou um arquivo somente leitura.  -ou-  Essa operação não é compatível com a plataforma atual.  -ou-  <paramref name="path" /> especificou um diretório.  -ou-  O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> está em um formato inválido.</exception>
        <exception cref="T:System.Security.SecurityException">O chamador não tem a permissão necessária.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para acesso de gravação para um arquivo ou diretório. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="WriteAllLines">
      <MemberSignature Language="C#" Value="public static void WriteAllLines (string path, System.Collections.Generic.IEnumerable&lt;string&gt; contents, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteAllLines(string path, class System.Collections.Generic.IEnumerable`1&lt;string&gt; contents, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.WriteAllLines(System.String,System.Collections.Generic.IEnumerable{System.String},System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteAllLines(System::String ^ path, System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ contents, System::Text::Encoding ^ encoding);" />
      <MemberSignature Language="F#" Value="static member WriteAllLines : string * seq&lt;string&gt; * System.Text.Encoding -&gt; unit" Usage="System.IO.File.WriteAllLines (path, contents, encoding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="path">O arquivo para gravação.</param>
        <param name="contents">As linhas a serem gravadas no arquivo.</param>
        <param name="encoding">A codificação de caracteres a ser usada.</param>
        <summary>Cria um novo arquivo usando a codificação especificada, grava uma coleção de cadeias de caracteres no arquivo e fecha o arquivo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se o arquivo de destino já existir, ele será substituído.  
  
 Você pode usar esse método para criar um arquivo que contém o seguinte:  
  
-   Os resultados de uma [LINQ to Objects](http://msdn.microsoft.com/library/73cafe73-37cf-46e7-bfa7-97c7eea7ced9) consultar as linhas de um arquivo, como obtida usando o <xref:System.IO.File.ReadLines%2A> método.  
  
-   O conteúdo de uma coleção que implementa um <xref:System.Collections.Generic.IEnumerable%601> de cadeias de caracteres.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou contém um ou mais caracteres inválidos definidos pelo método <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" />, <paramref name="contents" /> ou <paramref name="encoding" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <paramref name="path" /> é inválido (por exemplo, está em uma unidade não mapeada).</exception>
        <exception cref="T:System.IO.IOException">Um erro de E/S ocorreu ao abrir o arquivo.</exception>
        <exception cref="T:System.IO.PathTooLongException">
          <paramref name="path" /> excede o tamanho máximo definido pelo sistema.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> está em um formato inválido.</exception>
        <exception cref="T:System.Security.SecurityException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> especifica um arquivo somente leitura.  -ou-  Essa operação não é compatível com a plataforma atual.  -ou- <paramref name="path" /> é um diretório.  -ou-  O chamador não tem a permissão necessária.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteAllLines">
      <MemberSignature Language="C#" Value="public static void WriteAllLines (string path, string[] contents, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteAllLines(string path, string[] contents, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.WriteAllLines(System.String,System.String[],System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteAllLines(System::String ^ path, cli::array &lt;System::String ^&gt; ^ contents, System::Text::Encoding ^ encoding);" />
      <MemberSignature Language="F#" Value="static member WriteAllLines : string * string[] * System.Text.Encoding -&gt; unit" Usage="System.IO.File.WriteAllLines (path, contents, encoding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.String[]" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="path">O arquivo para gravação.</param>
        <param name="contents">A matriz de cadeia de caracteres a ser gravada no arquivo.</param>
        <param name="encoding">Um objeto <see cref="T:System.Text.Encoding" /> que representa a codificação de caracteres aplicada à matriz de cadeia de caracteres.</param>
        <summary>Cria um novo arquivo, grava a matriz de cadeia de caracteres especificada no arquivo usando a codificação especificada e fecha o arquivo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se o arquivo de destino já existir, ele será substituído.  
  
 Dada uma matriz de cadeia de caracteres e um caminho de arquivo, este método abre o arquivo especificado, grava a matriz de cadeia de caracteres para o arquivo usando a codificação especificada e, em seguida, fecha o arquivo.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso do <xref:System.IO.File.WriteAllLines%2A> método para gravar texto em um arquivo. Neste exemplo um arquivo é criado, se ele ainda não existir, e o texto é adicionado a ele.  
  
 [!code-csharp[System.IO.File.AllLines_Encoding#00](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.File.AllLines_Encoding/cs/AllText_Encoding.cs#00)]
 [!code-vb[System.IO.File.AllLines_Encoding#00](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.File.AllLines_Encoding/vb/AllText_Encoding.vb#00)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou um ou mais caracteres inválidos, conforme definido por <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">O <paramref name="path" /> ou <paramref name="contents" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">O caminho especificado é inválido (por exemplo, ele está em uma unidade não mapeada).</exception>
        <exception cref="T:System.IO.IOException">Um erro de E/S ocorreu ao abrir o arquivo.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> especificou um arquivo somente leitura.  -ou-  Essa operação não é compatível com a plataforma atual.  -ou-  <paramref name="path" /> especificou um diretório.  -ou-  O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> está em um formato inválido.</exception>
        <exception cref="T:System.Security.SecurityException">O chamador não tem a permissão necessária.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para acesso de gravação para um arquivo ou diretório. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="WriteAllLinesAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task WriteAllLinesAsync (string path, System.Collections.Generic.IEnumerable&lt;string&gt; contents, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task WriteAllLinesAsync(string path, class System.Collections.Generic.IEnumerable`1&lt;string&gt; contents, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.WriteAllLinesAsync(System.String,System.Collections.Generic.IEnumerable{System.String},System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="static member WriteAllLinesAsync : string * seq&lt;string&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="System.IO.File.WriteAllLinesAsync (path, contents, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="contents">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteAllLinesAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task WriteAllLinesAsync (string path, System.Collections.Generic.IEnumerable&lt;string&gt; contents, System.Text.Encoding encoding, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task WriteAllLinesAsync(string path, class System.Collections.Generic.IEnumerable`1&lt;string&gt; contents, class System.Text.Encoding encoding, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.WriteAllLinesAsync(System.String,System.Collections.Generic.IEnumerable{System.String},System.Text.Encoding,System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="static member WriteAllLinesAsync : string * seq&lt;string&gt; * System.Text.Encoding * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="System.IO.File.WriteAllLinesAsync (path, contents, encoding, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="contents">To be added.</param>
        <param name="encoding">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteAllText">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Cria um novo arquivo, grava os conteúdos nele e o fecha. Se o arquivo de destino já existir, ele será substituído.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteAllText">
      <MemberSignature Language="C#" Value="public static void WriteAllText (string path, string contents);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteAllText(string path, string contents) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.WriteAllText(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteAllText (path As String, contents As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteAllText(System::String ^ path, System::String ^ contents);" />
      <MemberSignature Language="F#" Value="static member WriteAllText : string * string -&gt; unit" Usage="System.IO.File.WriteAllText (path, contents)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">O arquivo para gravação.</param>
        <param name="contents">A cadeia de caracteres a ser gravada no arquivo.</param>
        <summary>Cria um novo arquivo, grava a cadeia de caracteres especificada no arquivo e fecha o arquivo. Se o arquivo de destino já existir, ele será substituído.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método usa UTF-8 codificação sem uma marca de ordem de Byte (BOM), portanto, usar o <xref:System.Text.Encoding.GetPreamble%2A> método retornará uma matriz de bytes vazia. Se for necessário incluir um identificador de UTF-8, como uma marca de ordem de byte no início de um arquivo, use o <xref:System.IO.File.WriteAllText%28System.String%2CSystem.String%2CSystem.Text.Encoding%29> sobrecarga de método com <xref:System.Text.Encoding.UTF8%2A> codificação.  
  
 Dada uma cadeia de caracteres e um caminho de arquivo, este método abre o arquivo especificado, grava a cadeia de caracteres no arquivo e, em seguida, fecha o arquivo.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso do <xref:System.IO.File.WriteAllText%2A> método para gravar texto em um arquivo. Neste exemplo um arquivo é criado, se ele ainda não existir, e o texto é adicionado a ele.  
  
 [!code-csharp[System.IO.File.AllText#00](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.File.AllText/cs/AllText.cs#00)]
 [!code-vb[System.IO.File.AllText#00](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.File.AllText/vb/AllText.vb#00)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou um ou mais caracteres inválidos, conforme definido por <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> é <see langword="null" /> ou <paramref name="contents" /> está vazio.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">O caminho especificado é inválido (por exemplo, ele está em uma unidade não mapeada).</exception>
        <exception cref="T:System.IO.IOException">Um erro de E/S ocorreu ao abrir o arquivo.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> especificou um arquivo somente leitura.  -ou-  Essa operação não é compatível com a plataforma atual.  -ou-  <paramref name="path" /> especificou um diretório.  -ou-  O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> está em um formato inválido.</exception>
        <exception cref="T:System.Security.SecurityException">O chamador não tem a permissão necessária.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para acesso de gravação para um arquivo ou diretório. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="WriteAllText">
      <MemberSignature Language="C#" Value="public static void WriteAllText (string path, string contents, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteAllText(string path, string contents, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.WriteAllText(System.String,System.String,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteAllText(System::String ^ path, System::String ^ contents, System::Text::Encoding ^ encoding);" />
      <MemberSignature Language="F#" Value="static member WriteAllText : string * string * System.Text.Encoding -&gt; unit" Usage="System.IO.File.WriteAllText (path, contents, encoding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.String" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="path">O arquivo para gravação.</param>
        <param name="contents">A cadeia de caracteres a ser gravada no arquivo.</param>
        <param name="encoding">A codificação a ser aplicada à cadeia de caracteres.</param>
        <summary>Cria um novo arquivo, grava a cadeia de caracteres especificada no arquivo usando a codificação especificada e fecha o arquivo. Se o arquivo de destino já existir, ele será substituído.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dada uma cadeia de caracteres e um caminho de arquivo, este método abre o arquivo especificado, grava a cadeia de caracteres no arquivo usando a codificação especificada e, em seguida, fecha o arquivo. O identificador de arquivo é garantido para ser fechada por esse método, mesmo se as exceções são geradas.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso do <xref:System.IO.File.WriteAllText%2A> método para gravar texto em um arquivo. Neste exemplo um arquivo é criado, se ele ainda não existir, e o texto é adicionado a ele.  
  
 [!code-csharp[System.IO.File.AllText_Encoding#00](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.File.AllText_Encoding/cs/AllText.cs#00)]
 [!code-vb[System.IO.File.AllText_Encoding#00](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.File.AllText_Encoding/vb/AllText.vb#00)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou um ou mais caracteres inválidos, conforme definido por <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> é <see langword="null" /> ou <paramref name="contents" /> está vazio.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">O caminho especificado é inválido (por exemplo, ele está em uma unidade não mapeada).</exception>
        <exception cref="T:System.IO.IOException">Um erro de E/S ocorreu ao abrir o arquivo.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> especificou um arquivo somente leitura.  -ou-  Essa operação não é compatível com a plataforma atual.  -ou-  <paramref name="path" /> especificou um diretório.  -ou-  O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> está em um formato inválido.</exception>
        <exception cref="T:System.Security.SecurityException">O chamador não tem a permissão necessária.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para acesso de gravação para um arquivo ou diretório. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="WriteAllTextAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task WriteAllTextAsync (string path, string contents, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task WriteAllTextAsync(string path, string contents, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.WriteAllTextAsync(System.String,System.String,System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="static member WriteAllTextAsync : string * string * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="System.IO.File.WriteAllTextAsync (path, contents, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.String" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="contents">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteAllTextAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task WriteAllTextAsync (string path, string contents, System.Text.Encoding encoding, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task WriteAllTextAsync(string path, string contents, class System.Text.Encoding encoding, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.WriteAllTextAsync(System.String,System.String,System.Text.Encoding,System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="static member WriteAllTextAsync : string * string * System.Text.Encoding * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="System.IO.File.WriteAllTextAsync (path, contents, encoding, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.String" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="contents">To be added.</param>
        <param name="encoding">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>