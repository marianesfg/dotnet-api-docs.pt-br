<Type Name="StreamReader" FullName="System.IO.StreamReader">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="6ed9f819d65f24412cf975b5e6987236e22e04ba" />
    <Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="pt-BR" />
    <Meta Name="ms.lasthandoff" Value="10/04/2018" />
    <Meta Name="ms.locfileid" Value="48645866" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class StreamReader : System.IO.TextReader" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit StreamReader extends System.IO.TextReader" />
  <TypeSignature Language="DocId" Value="T:System.IO.StreamReader" />
  <TypeSignature Language="VB.NET" Value="Public Class StreamReader&#xA;Inherits TextReader" />
  <TypeSignature Language="C++ CLI" Value="public ref class StreamReader : System::IO::TextReader" />
  <TypeSignature Language="F#" Value="type StreamReader = class&#xA;    inherit TextReader" />
  <AssemblyInfo>
    <AssemblyName>System.IO</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.IO.TextReader</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Implementa um <see cref="T:System.IO.TextReader" /> que lê caracteres de um fluxo de bytes em uma codificação específica.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.StreamReader> foi projetado para entrada de caracteres em uma determinada codificação, enquanto o <xref:System.IO.Stream> classe foi criada para bytes de entrada e saída. Use <xref:System.IO.StreamReader> para a leitura de linhas de informações de um arquivo de texto padrão.  
  
> [!IMPORTANT]
>  Esse tipo implementa o <xref:System.IDisposable> interface. Quando você terminar de usar o tipo, você deve descartá-lo diretamente ou indiretamente. Para descartar o tipo diretamente, chame seu <xref:System.IDisposable.Dispose%2A> método em um `try` / `catch` bloco. Para descartá-los indiretamente, usar uma construção de linguagem, como `using` (em c#) ou `Using` (no Visual Basic). Para obter mais informações, consulte a seção "Usando um objeto que implementa IDisposable" o <xref:System.IDisposable> tópico da interface.  
  
 <xref:System.IO.StreamReader> o padrão é a codificação UTF-8, a menos que especificado de outra forma, em vez de padronizar para a página de código ANSI para o sistema atual. UTF-8 lida com caracteres Unicode corretamente e fornece resultados consistentes em versões localizadas do sistema operacional. Se você receber a codificação de caracteres atual usando o <xref:System.IO.StreamReader.CurrentEncoding%2A> propriedade, o valor não é confiável até após a primeira <xref:System.IO.StreamReader.Read%2A> método, já que a detecção automática de codificação é feita após a primeira chamada para um <xref:System.IO.StreamReader.Read%2A> método.  
  
 Por padrão, um <xref:System.IO.StreamReader> não é thread-safe. Consulte <xref:System.IO.TextReader.Synchronized%2A?displayProperty=nameWithType> para um wrapper thread-safe.  
  
 O <xref:System.IO.StreamReader.Read%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> e <xref:System.IO.StreamWriter.Write%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> sobrecargas do método ler e gravar o número de caracteres especificada pelo `count` parâmetro. Estes devem ser distinguidos <xref:System.IO.BufferedStream.Read%2A?displayProperty=nameWithType> e <xref:System.IO.BufferedStream.Write%2A?displayProperty=nameWithType>, que leem e gravam o número de bytes especificado pelo `count` parâmetro. Use o <xref:System.IO.BufferedStream> métodos somente para leitura e gravação de um número integral de byte elementos da matriz.  
  
> [!NOTE]
>  Ao ler de um <xref:System.IO.Stream>, é mais eficiente usar um buffer que é o mesmo tamanho que o buffer interno do fluxo.  
  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 O exemplo a seguir usa uma instância de <xref:System.IO.StreamReader> ler texto de um arquivo. Não há suporte para o construtor usado neste exemplo para uso em [!INCLUDE[win8_appstore_long](~/includes/win8-appstore-long-md.md)] aplicativos.  
  
 [!code-cpp[readtextfile#1](~/samples/snippets/cpp/VS_Snippets_CLR/ReadTextFile/CPP/readtextfile.cpp#1)]
 [!code-csharp[readtextfile#1](~/samples/snippets/csharp/VS_Snippets_CLR/ReadTextFile/CS/readtextfile.cs#1)]
 [!code-vb[readtextfile#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ReadTextFile/VB/readtextfile.vb#1)]  
  
 O exemplo a seguir instancia um <xref:System.IO.StreamReader> objeto e chama seu <xref:System.IO.StreamReader.ReadAsync%2A> método para ler um arquivo de forma assíncrona.  
  
 [!code-csharp[System.IO.StreamReader#51](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/asyncex1.cs#51)]
 [!code-vb[System.IO.StreamReader#51](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/asyncex1.vb#51)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Text.Encoding" />
    <altmember cref="T:System.IO.Stream" />
    <altmember cref="T:System.IO.StreamWriter" />
    <related type="Article" href="~/docs/standard/io/index.md">E/S de arquivo e de fluxo</related>
    <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Como ler texto de um arquivo</related>
    <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Como gravar texto em um arquivo</related>
    <related type="Article" href="~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md">Como ler e gravar em um arquivo de dados recém-criado</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.IO.StreamReader" /> para o fluxo especificado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamReader (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.#ctor(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StreamReader(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="new System.IO.StreamReader : System.IO.Stream -&gt; System.IO.StreamReader" Usage="new System.IO.StreamReader stream" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">O fluxo a ser lido.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.IO.StreamReader" /> para o fluxo especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este construtor inicializa a codificação para <xref:System.Text.UTF8Encoding>, o <xref:System.IO.StreamReader.BaseStream%2A> propriedade usando o `stream` parâmetro e o tamanho do buffer interno para 1024 bytes.  
  
 O <xref:System.IO.StreamReader> chamadas do objeto <xref:System.IO.Stream.Dispose> nos <xref:System.IO.Stream> objeto quando <xref:System.IO.StreamReader.Dispose%2A?displayProperty=nameWithType> é chamado.  
  
> [!CAUTION]
>  Quando você compila um conjunto de caracteres com uma configuração cultural específica e recupera os mesmos caracteres com uma configuração cultural diferente, os caracteres talvez não sejam interpretáveis e poderá causar uma exceção seja lançada.  
  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra isso <xref:System.IO.StreamReader> construtor.  
  
 [!code-cpp[strmreader ctor1#1](~/samples/snippets/cpp/VS_Snippets_CLR/StrmReader Ctor1/CPP/strmreader ctor1.cpp#1)]
 [!code-csharp[strmreader ctor1#1](~/samples/snippets/csharp/VS_Snippets_CLR/StrmReader Ctor1/CS/strmreader ctor1.cs#1)]
 [!code-vb[strmreader ctor1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StrmReader Ctor1/VB/strmreader ctor1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="stream" /> não dá suporte à leitura.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stream" /> é <see langword="null" />.</exception>
        <related type="Article" href="~/docs/standard/io/index.md">E/S de arquivo e de fluxo</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Como ler texto de um arquivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Como gravar texto em um arquivo</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamReader (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StreamReader(System::String ^ path);" />
      <MemberSignature Language="F#" Value="new System.IO.StreamReader : string -&gt; System.IO.StreamReader" Usage="new System.IO.StreamReader path" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">O caminho completo do arquivo a ser lido.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.IO.StreamReader" /> para o nome de arquivo especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O caminho de arquivo completo é especificado pelo `path` parâmetro. Este construtor inicializa a codificação como <xref:System.Text.UTF8Encoding> e o tamanho do buffer para 1024 bytes.  
  
 O `path` parâmetro pode ser um nome de arquivo, incluindo um arquivo em um compartilhamento de convenção de nomenclatura Universal (UNC).  
  
 O `path` parâmetro não é necessário ser um arquivo armazenado no disco; ele pode ser qualquer parte de um sistema que dá suporte ao acesso usando fluxos.  
  
> [!CAUTION]
>  Quando você compila um conjunto de caracteres com uma configuração cultural específica e recupera os mesmos caracteres com uma configuração cultural diferente, os caracteres talvez não sejam interpretáveis e poderá causar uma exceção seja lançada.  
  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra isso <xref:System.IO.StreamReader> construtor.  
  
 [!code-cpp[strmreader ctor2#1](~/samples/snippets/cpp/VS_Snippets_CLR/StrmReader Ctor2/CPP/strmreader ctor2.cpp#1)]
 [!code-csharp[strmreader ctor2#1](~/samples/snippets/csharp/VS_Snippets_CLR/StrmReader Ctor2/CS/strmreader ctor2.cs#1)]
 [!code-vb[strmreader ctor2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StrmReader Ctor2/VB/strmreader ctor2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> é uma cadeia de caracteres vazia ("").</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">O arquivo não pode ser encontrado.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">O caminho especificado é inválido, por exemplo, ele está em uma unidade não mapeada.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" /> inclui uma sintaxe incorreta ou inválida para o nome do arquivo, nome do diretório ou rótulo do volume.</exception>
        <altmember cref="T:System.Text.Encoding" />
        <related type="Article" href="~/docs/standard/io/index.md">E/S de arquivo e de fluxo</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Como ler texto de um arquivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Como gravar texto em um arquivo</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamReader (System.IO.Stream stream, bool detectEncodingFromByteOrderMarks);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream stream, bool detectEncodingFromByteOrderMarks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.#ctor(System.IO.Stream,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StreamReader(System::IO::Stream ^ stream, bool detectEncodingFromByteOrderMarks);" />
      <MemberSignature Language="F#" Value="new System.IO.StreamReader : System.IO.Stream * bool -&gt; System.IO.StreamReader" Usage="new System.IO.StreamReader (stream, detectEncodingFromByteOrderMarks)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="detectEncodingFromByteOrderMarks" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="stream">O fluxo a ser lido.</param>
        <param name="detectEncodingFromByteOrderMarks">Indica se é necessário procurar marcas de ordem de byte no início do arquivo.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.IO.StreamReader" /> para o fluxo especificado, com a opção de detecção da marca da ordem de byte especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este construtor inicializa a codificação para <xref:System.Text.UTF8Encoding>, o <xref:System.IO.StreamReader.BaseStream%2A> propriedade usando o `stream` parâmetro e o tamanho do buffer interno para 1024 bytes.  
  
 O `detectEncodingFromByteOrderMarks` parâmetro detecta a codificação, observando os primeiros quatro bytes do fluxo. Ele reconhece automaticamente Unicode UTF-8, little endian, Unicode big endian, a little endian UTF-32 e big-endian UTF-32 texto se o arquivo começa com as marcas de ordem de byte apropriado. Consulte o método <xref:System.Text.Encoding.GetPreamble%2A?displayProperty=nameWithType> para obter mais informações.  
  
 O <xref:System.IO.StreamReader> chamadas do objeto <xref:System.IO.Stream.Dispose> nos <xref:System.IO.Stream> objeto quando <xref:System.IO.StreamReader.Dispose%2A?displayProperty=nameWithType> é chamado.  
  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra isso <xref:System.IO.StreamReader> construtor.  
  
 [!code-cpp[System.IO.StreamReader#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.StreamReader/CPP/streamreadersample.cpp#2)]
 [!code-csharp[System.IO.StreamReader#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/streamreadersample.cs#2)]
 [!code-vb[System.IO.StreamReader#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/streamreadersample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="stream" /> não dá suporte à leitura.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stream" /> é <see langword="null" />.</exception>
        <related type="Article" href="~/docs/standard/io/index.md">E/S de arquivo e de fluxo</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Como ler texto de um arquivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Como gravar texto em um arquivo</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamReader (System.IO.Stream stream, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream stream, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.#ctor(System.IO.Stream,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StreamReader(System::IO::Stream ^ stream, System::Text::Encoding ^ encoding);" />
      <MemberSignature Language="F#" Value="new System.IO.StreamReader : System.IO.Stream * System.Text.Encoding -&gt; System.IO.StreamReader" Usage="new System.IO.StreamReader (stream, encoding)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="stream">O fluxo a ser lido.</param>
        <param name="encoding">A codificação de caracteres a ser usada.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.IO.StreamReader" /> para o fluxo especificado, com a codificação de caractere especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A codificação de caracteres é definida pelo `encoding` parâmetro e o tamanho do buffer é definida como 1024 bytes. O <xref:System.IO.StreamReader> objeto tenta detectar a codificação, observando os primeiros quatro bytes do fluxo. Ele reconhece automaticamente Unicode UTF-8, little endian, Unicode big endian, a little endian UTF-32 e big-endian UTF-32 texto se o arquivo começa com as marcas de ordem de byte apropriado. Caso contrário, a codificação fornecida pelo usuário é usada. Consulte o método <xref:System.Text.Encoding.GetPreamble%2A?displayProperty=nameWithType> para obter mais informações.  
  
 O <xref:System.IO.StreamReader> chamadas do objeto <xref:System.IO.Stream.Dispose> nos <xref:System.IO.Stream> objeto quando <xref:System.IO.StreamReader.Dispose%2A?displayProperty=nameWithType> é chamado.  
  
> [!CAUTION]
>  Quando você compila um conjunto de caracteres com uma configuração cultural específica e recupera os mesmos caracteres com uma configuração cultural diferente, os caracteres talvez não sejam interpretáveis e poderá causar uma exceção seja lançada.  
  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra isso <xref:System.IO.StreamReader> construtor.  
  
 [!code-cpp[System.IO.StreamReader#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.StreamReader/CPP/streamreadersample.cpp#2)]
 [!code-csharp[System.IO.StreamReader#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/streamreadersample.cs#2)]
 [!code-vb[System.IO.StreamReader#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/streamreadersample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="stream" /> não dá suporte à leitura.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stream" /> ou <paramref name="encoding" /> é <see langword="null" />.</exception>
        <altmember cref="T:System.Text.Encoding" />
        <related type="Article" href="~/docs/standard/io/index.md">E/S de arquivo e de fluxo</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Como ler texto de um arquivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Como gravar texto em um arquivo</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamReader (string path, bool detectEncodingFromByteOrderMarks);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, bool detectEncodingFromByteOrderMarks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.#ctor(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, detectEncodingFromByteOrderMarks As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StreamReader(System::String ^ path, bool detectEncodingFromByteOrderMarks);" />
      <MemberSignature Language="F#" Value="new System.IO.StreamReader : string * bool -&gt; System.IO.StreamReader" Usage="new System.IO.StreamReader (path, detectEncodingFromByteOrderMarks)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="detectEncodingFromByteOrderMarks" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">O caminho completo do arquivo a ser lido.</param>
        <param name="detectEncodingFromByteOrderMarks">Indica se é necessário procurar marcas de ordem de byte no início do arquivo.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.IO.StreamReader" /> do nome do arquivo especificado, com a opção de detecção de marca de ordem de byte especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este construtor inicializa a codificação para <xref:System.Text.UTF8Encoding>, o <xref:System.IO.StreamReader.BaseStream%2A> propriedade usando o `stream` parâmetro e o tamanho do buffer interno para 1024 bytes.  
  
 O `path` parâmetro pode ser um nome de arquivo, incluindo um arquivo em um compartilhamento de convenção de nomenclatura Universal (UNC).  
  
 O `path` parâmetro não é necessário ser um arquivo armazenado no disco; ele pode ser qualquer parte de um sistema que dá suporte ao acesso usando fluxos.  
  
 O `detectEncodingFromByteOrderMarks` parâmetro detecta a codificação, observando os primeiros quatro bytes do fluxo. Ele reconhece automaticamente Unicode UTF-8, little endian, Unicode big endian, a little endian UTF-32 e big-endian UTF-32 texto se o arquivo começa com as marcas de ordem de byte apropriado. Caso contrário, o <xref:System.Text.UTF8Encoding> é usado. Consulte o método <xref:System.Text.Encoding.GetPreamble%2A?displayProperty=nameWithType> para obter mais informações.  
  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra isso <xref:System.IO.StreamReader> construtor.  
  
 [!code-cpp[System.IO.StreamReader#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.StreamReader/CPP/streamreadersample.cpp#2)]
 [!code-csharp[System.IO.StreamReader#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/streamreadersample.cs#2)]
 [!code-vb[System.IO.StreamReader#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/streamreadersample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> é uma cadeia de caracteres vazia ("").</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">O arquivo não pode ser encontrado.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">O caminho especificado é inválido, por exemplo, ele está em uma unidade não mapeada.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" /> inclui uma sintaxe incorreta ou inválida para o nome do arquivo, nome do diretório ou rótulo do volume.</exception>
        <related type="Article" href="~/docs/standard/io/index.md">E/S de arquivo e de fluxo</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Como ler texto de um arquivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Como gravar texto em um arquivo</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamReader (string path, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.#ctor(System.String,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StreamReader(System::String ^ path, System::Text::Encoding ^ encoding);" />
      <MemberSignature Language="F#" Value="new System.IO.StreamReader : string * System.Text.Encoding -&gt; System.IO.StreamReader" Usage="new System.IO.StreamReader (path, encoding)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="path">O caminho completo do arquivo a ser lido.</param>
        <param name="encoding">A codificação de caracteres a ser usada.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.IO.StreamReader" /> para o nome de arquivo especificado, com a codificação de caractere especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este construtor inicializa a codificação conforme especificado pelo `encoding` parâmetro e o tamanho do buffer interno para 1024 bytes. O <xref:System.IO.StreamReader> objeto tenta detectar a codificação, observando os primeiros quatro bytes do fluxo. Ele reconhece automaticamente Unicode UTF-8, little endian, Unicode big endian, a little endian UTF-32 e big-endian UTF-32 texto se o arquivo começa com as marcas de ordem de byte apropriado. Caso contrário, a codificação fornecida pelo usuário é usada. Consulte o método <xref:System.Text.Encoding.GetPreamble%2A?displayProperty=nameWithType> para obter mais informações.  
  
 O `path` parâmetro pode ser um nome de arquivo, incluindo um arquivo em um compartilhamento de convenção de nomenclatura Universal (UNC).  
  
 O `path` parâmetro não é necessário ser um arquivo armazenado no disco; ele pode ser qualquer parte de um sistema que dá suporte ao acesso usando fluxos.  
  
> [!CAUTION]
>  Quando você compila um conjunto de caracteres com uma configuração cultural específica e recupera os mesmos caracteres com uma configuração cultural diferente, os caracteres talvez não sejam interpretáveis e poderá causar uma exceção seja lançada.  
  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra isso <xref:System.IO.StreamReader> construtor.  
  
 [!code-cpp[System.IO.StreamReader#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.StreamReader/CPP/streamreadersample.cpp#2)]
 [!code-csharp[System.IO.StreamReader#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/streamreadersample.cs#2)]
 [!code-vb[System.IO.StreamReader#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/streamreadersample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> é uma cadeia de caracteres vazia ("").</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ou <paramref name="encoding" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">O arquivo não pode ser encontrado.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">O caminho especificado é inválido, por exemplo, ele está em uma unidade não mapeada.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> inclui uma sintaxe incorreta ou inválida para o nome do arquivo, nome do diretório ou rótulo do volume.</exception>
        <altmember cref="T:System.Text.Encoding" />
        <related type="Article" href="~/docs/standard/io/index.md">E/S de arquivo e de fluxo</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Como ler texto de um arquivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Como gravar texto em um arquivo</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamReader (System.IO.Stream stream, System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream stream, class System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.#ctor(System.IO.Stream,System.Text.Encoding,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StreamReader(System::IO::Stream ^ stream, System::Text::Encoding ^ encoding, bool detectEncodingFromByteOrderMarks);" />
      <MemberSignature Language="F#" Value="new System.IO.StreamReader : System.IO.Stream * System.Text.Encoding * bool -&gt; System.IO.StreamReader" Usage="new System.IO.StreamReader (stream, encoding, detectEncodingFromByteOrderMarks)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
        <Parameter Name="detectEncodingFromByteOrderMarks" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="stream">O fluxo a ser lido.</param>
        <param name="encoding">A codificação de caracteres a ser usada.</param>
        <param name="detectEncodingFromByteOrderMarks">Indica se é necessário procurar marcas de ordem de byte no início do arquivo.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.IO.StreamReader" /> para o fluxo especificado, com a codificação de caracteres e a opção de detecção de marca de ordem de byte especificadas.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este construtor inicializa a codificação conforme especificado pelo `encoding` parâmetro, o <xref:System.IO.StreamReader.BaseStream%2A> propriedade usando o `stream` parâmetro e o tamanho do buffer interno para 1024 bytes.  
  
 O `detectEncodingFromByteOrderMarks` parâmetro detecta a codificação, observando os primeiros quatro bytes do fluxo. Ele reconhece automaticamente Unicode UTF-8, little endian, Unicode big endian, a little endian UTF-32 e big-endian UTF-32 texto se o arquivo começa com as marcas de ordem de byte apropriado. Caso contrário, a codificação fornecida pelo usuário é usada. Consulte o método <xref:System.Text.Encoding.GetPreamble%2A?displayProperty=nameWithType> para obter mais informações.  
  
 O <xref:System.IO.StreamReader> chamadas do objeto <xref:System.IO.Stream.Dispose> nos <xref:System.IO.Stream> objeto quando <xref:System.IO.StreamReader.Dispose%2A?displayProperty=nameWithType> é chamado.  
  
> [!CAUTION]
>  Quando você compila um conjunto de caracteres com uma configuração cultural específica e recupera os mesmos caracteres com uma configuração cultural diferente, os caracteres talvez não sejam interpretáveis e poderá causar uma exceção seja lançada.  
  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra isso <xref:System.IO.StreamReader> construtor.  
  
 [!code-cpp[System.IO.StreamReader#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.StreamReader/CPP/streamreadersample.cpp#2)]
 [!code-csharp[System.IO.StreamReader#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/streamreadersample.cs#2)]
 [!code-vb[System.IO.StreamReader#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/streamreadersample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="stream" /> não dá suporte à leitura.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stream" /> ou <paramref name="encoding" /> é <see langword="null" />.</exception>
        <altmember cref="T:System.Text.Encoding" />
        <related type="Article" href="~/docs/standard/io/index.md">E/S de arquivo e de fluxo</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Como ler texto de um arquivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Como gravar texto em um arquivo</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamReader (string path, System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, class System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.#ctor(System.String,System.Text.Encoding,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StreamReader(System::String ^ path, System::Text::Encoding ^ encoding, bool detectEncodingFromByteOrderMarks);" />
      <MemberSignature Language="F#" Value="new System.IO.StreamReader : string * System.Text.Encoding * bool -&gt; System.IO.StreamReader" Usage="new System.IO.StreamReader (path, encoding, detectEncodingFromByteOrderMarks)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
        <Parameter Name="detectEncodingFromByteOrderMarks" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">O caminho completo do arquivo a ser lido.</param>
        <param name="encoding">A codificação de caracteres a ser usada.</param>
        <param name="detectEncodingFromByteOrderMarks">Indica se é necessário procurar marcas de ordem de byte no início do arquivo.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.IO.StreamReader" /> para o nome de arquivo especificado, com a codificação de caractere e opção de detecção da marca da ordem de byte especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este construtor inicializa a codificação conforme especificado pelo `encoding` parâmetro e o tamanho do buffer interno para 1024 bytes.  
  
 O `detectEncodingFromByteOrderMarks` parâmetro detecta a codificação, observando os primeiros quatro bytes do fluxo. Ele reconhece automaticamente Unicode UTF-8, little endian, Unicode big endian, a little endian UTF-32 e big-endian UTF-32 texto se o arquivo começa com as marcas de ordem de byte apropriado. Caso contrário, a codificação fornecida pelo usuário é usada. Consulte o método <xref:System.Text.Encoding.GetPreamble%2A?displayProperty=nameWithType> para obter mais informações.  
  
 O `path` parâmetro pode ser um nome de arquivo, incluindo um arquivo em um compartilhamento de convenção de nomenclatura Universal (UNC).  
  
 O `path` parâmetro não é necessário ser um arquivo armazenado no disco; ele pode ser qualquer parte de um sistema que dá suporte ao acesso usando fluxos.  
  
> [!CAUTION]
>  Quando você compila um conjunto de caracteres com uma configuração cultural específica e recupera os mesmos caracteres com uma configuração cultural diferente, os caracteres talvez não sejam interpretáveis e poderá causar uma exceção seja lançada.  
  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra isso <xref:System.IO.StreamReader> construtor.  
  
 [!code-cpp[System.IO.StreamReader#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.StreamReader/CPP/streamreadersample.cpp#2)]
 [!code-csharp[System.IO.StreamReader#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/streamreadersample.cs#2)]
 [!code-vb[System.IO.StreamReader#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/streamreadersample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> é uma cadeia de caracteres vazia ("").</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ou <paramref name="encoding" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">O arquivo não pode ser encontrado.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">O caminho especificado é inválido, por exemplo, ele está em uma unidade não mapeada.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> inclui uma sintaxe incorreta ou inválida para o nome do arquivo, nome do diretório ou rótulo do volume.</exception>
        <altmember cref="T:System.Text.Encoding" />
        <related type="Article" href="~/docs/standard/io/index.md">E/S de arquivo e de fluxo</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Como ler texto de um arquivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Como gravar texto em um arquivo</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamReader (System.IO.Stream stream, System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream stream, class System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.#ctor(System.IO.Stream,System.Text.Encoding,System.Boolean,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StreamReader(System::IO::Stream ^ stream, System::Text::Encoding ^ encoding, bool detectEncodingFromByteOrderMarks, int bufferSize);" />
      <MemberSignature Language="F#" Value="new System.IO.StreamReader : System.IO.Stream * System.Text.Encoding * bool * int -&gt; System.IO.StreamReader" Usage="new System.IO.StreamReader (stream, encoding, detectEncodingFromByteOrderMarks, bufferSize)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
        <Parameter Name="detectEncodingFromByteOrderMarks" Type="System.Boolean" />
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="stream">O fluxo a ser lido.</param>
        <param name="encoding">A codificação de caracteres a ser usada.</param>
        <param name="detectEncodingFromByteOrderMarks">Indica se é necessário procurar marcas de ordem de byte no início do arquivo.</param>
        <param name="bufferSize">O tamanho mínimo do buffer.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.IO.StreamReader" /> para o fluxo especificado, com a codificação de caracteres, a opção de detecção de marca de ordem de byte e o tamanho do buffer especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O tamanho do buffer, em número de caracteres de 16 bits, é definido pelo `bufferSize` parâmetro. Se `bufferSize` é menor que o tamanho mínimo permitido (de 128 caracteres), o tamanho mínimo permitido é usado.  
  
 Este construtor permite que você alterar a codificação na primeira vez que você ler a partir de <xref:System.IO.StreamReader> objeto. O `detectEncodingFromByteOrderMarks` parâmetro detecta a codificação, observando os primeiros quatro bytes do fluxo. Ele reconhece automaticamente Unicode UTF-8, little endian, Unicode big endian, a little endian UTF-32 e big-endian UTF-32 texto se o arquivo começa com as marcas de ordem de byte apropriado. Caso contrário, a codificação fornecida pelo usuário é usada. Consulte o método <xref:System.Text.Encoding.GetPreamble%2A?displayProperty=nameWithType> para obter mais informações.  
  
 O <xref:System.IO.StreamReader> chamadas do objeto <xref:System.IO.Stream.Dispose> nos <xref:System.IO.Stream> objeto quando <xref:System.IO.StreamReader.Dispose%2A?displayProperty=nameWithType> é chamado.  
  
> [!NOTE]
>  Ao ler de um <xref:System.IO.Stream>, é mais eficiente usar um buffer que é o mesmo tamanho que o buffer interno do fluxo.  
  
> [!CAUTION]
>  Quando você compila um conjunto de caracteres com uma configuração cultural específica e recupera os mesmos caracteres com uma configuração cultural diferente, os caracteres talvez não sejam interpretáveis e poderá causar uma exceção seja lançada.  
  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra isso <xref:System.IO.StreamReader> construtor.  
  
 [!code-cpp[System.IO.StreamReader#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.StreamReader/CPP/streamreadersample.cpp#2)]
 [!code-csharp[System.IO.StreamReader#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/streamreadersample.cs#2)]
 [!code-vb[System.IO.StreamReader#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/streamreadersample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Não há suporte para leitura no fluxo.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stream" /> ou <paramref name="encoding" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="bufferSize" /> é menor que ou igual a zero.</exception>
        <altmember cref="T:System.Text.Encoding" />
        <related type="Article" href="~/docs/standard/io/index.md">E/S de arquivo e de fluxo</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Como ler texto de um arquivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Como gravar texto em um arquivo</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamReader (string path, System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, class System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.#ctor(System.String,System.Text.Encoding,System.Boolean,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StreamReader(System::String ^ path, System::Text::Encoding ^ encoding, bool detectEncodingFromByteOrderMarks, int bufferSize);" />
      <MemberSignature Language="F#" Value="new System.IO.StreamReader : string * System.Text.Encoding * bool * int -&gt; System.IO.StreamReader" Usage="new System.IO.StreamReader (path, encoding, detectEncodingFromByteOrderMarks, bufferSize)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
        <Parameter Name="detectEncodingFromByteOrderMarks" Type="System.Boolean" />
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="path">O caminho completo do arquivo a ser lido.</param>
        <param name="encoding">A codificação de caracteres a ser usada.</param>
        <param name="detectEncodingFromByteOrderMarks">Indica se é necessário procurar marcas de ordem de byte no início do arquivo.</param>
        <param name="bufferSize">O tamanho do buffer mínimo, em número de caracteres de 16 bits.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.IO.StreamReader" /> para o nome de arquivo especificado, com a codificação de caracteres, a opção de detecção de marca de ordem de byte e o tamanho do buffer especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este construtor inicializa a codificação conforme especificado pelo `encoding` parâmetro.  
  
 Este construtor permite que você alterar a codificação na primeira vez que você ler a partir de <xref:System.IO.StreamReader> objeto. O `detectEncodingFromByteOrderMarks` parâmetro detecta a codificação, observando os primeiros quatro bytes do fluxo. Ele reconhece automaticamente Unicode UTF-8, little endian, Unicode big endian, a little endian UTF-32 e big-endian UTF-32 texto se o arquivo começa com as marcas de ordem de byte apropriado. Caso contrário, a codificação fornecida pelo usuário é usada. Consulte o método <xref:System.Text.Encoding.GetPreamble%2A?displayProperty=nameWithType> para obter mais informações.  
  
 O tamanho do buffer, em número de caracteres de 16 bits, é definido pelo `bufferSize` parâmetro. Se `bufferSize` é menor que o tamanho mínimo permitido (de 128 caracteres), o tamanho mínimo permitido é usado.  
  
 O `path` parâmetro pode ser um nome de arquivo, incluindo um arquivo em um compartilhamento de convenção de nomenclatura Universal (UNC).  
  
 O `path` parâmetro não é necessário ser um arquivo armazenado no disco; ele pode ser qualquer parte de um sistema que dá suporte ao acesso usando fluxos.  
  
> [!CAUTION]
>  Quando você compila um conjunto de caracteres com uma configuração cultural específica e recupera os mesmos caracteres com uma configuração cultural diferente, os caracteres talvez não sejam interpretáveis e poderá causar uma exceção seja lançada.  
  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra isso <xref:System.IO.StreamReader> construtor.  
  
 [!code-cpp[System.IO.StreamReader#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.StreamReader/CPP/streamreadersample.cpp#2)]
 [!code-csharp[System.IO.StreamReader#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/streamreadersample.cs#2)]
 [!code-vb[System.IO.StreamReader#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/streamreadersample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> é uma cadeia de caracteres vazia ("").</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ou <paramref name="encoding" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">O arquivo não pode ser encontrado.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">O caminho especificado é inválido, por exemplo, ele está em uma unidade não mapeada.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> inclui uma sintaxe incorreta ou inválida para o nome do arquivo, nome do diretório ou rótulo do volume.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="buffersize" /> é menor que ou igual a zero.</exception>
        <altmember cref="T:System.Text.Encoding" />
        <related type="Article" href="~/docs/standard/io/index.md">E/S de arquivo e de fluxo</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Como ler texto de um arquivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Como gravar texto em um arquivo</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamReader (System.IO.Stream stream, System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks, int bufferSize, bool leaveOpen);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream stream, class System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks, int32 bufferSize, bool leaveOpen) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.#ctor(System.IO.Stream,System.Text.Encoding,System.Boolean,System.Int32,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StreamReader(System::IO::Stream ^ stream, System::Text::Encoding ^ encoding, bool detectEncodingFromByteOrderMarks, int bufferSize, bool leaveOpen);" />
      <MemberSignature Language="F#" Value="new System.IO.StreamReader : System.IO.Stream * System.Text.Encoding * bool * int * bool -&gt; System.IO.StreamReader" Usage="new System.IO.StreamReader (stream, encoding, detectEncodingFromByteOrderMarks, bufferSize, leaveOpen)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
        <Parameter Name="detectEncodingFromByteOrderMarks" Type="System.Boolean" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="leaveOpen" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="stream">O fluxo a ser lido.</param>
        <param name="encoding">A codificação de caracteres a ser usada.</param>
        <param name="detectEncodingFromByteOrderMarks">
          <see langword="true" /> para procurar marcas de ordem de byte no início do arquivo; caso contrário, <see langword="false" />.</param>
        <param name="bufferSize">O tamanho mínimo do buffer.</param>
        <param name="leaveOpen">
          <see langword="true" /> para deixar o fluxo aberto após o objeto <see cref="T:System.IO.StreamReader" /> ser descartado; caso contrário, <see langword="false" />.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.IO.StreamReader" /> para o fluxo especificado com base na codificação de caractere especificada, na opção de detecção de marca de ordem de byte, no tamanho do buffer e, opcionalmente, deixa o fluxo aberto.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A menos que você defina as `leaveOpen` parâmetro para `true`, o <xref:System.IO.StreamReader> chamadas do objeto <xref:System.IO.Stream.Dispose> nos <xref:System.IO.Stream> objeto quando <xref:System.IO.StreamReader.Dispose%2A?displayProperty=nameWithType> é chamado.  
  
 O tamanho do buffer, em número de caracteres de 16 bits, é definido pelo `bufferSize` parâmetro. Se `bufferSize` é menor que o tamanho mínimo permitido (de 128 caracteres), o tamanho mínimo permitido é usado.  
  
 Este construtor permite que você alterar a codificação na primeira vez que você ler a partir de <xref:System.IO.StreamReader> objeto. Se o `detectEncodingFromByteOrderMarks` parâmetro é `true`, o construtor detecta a codificação, observando os primeiros quatro bytes do fluxo. Ele reconhece automaticamente Unicode UTF-8, little endian, Unicode big endian, a little endian UTF-32 e big-endian UTF-32 texto se o arquivo começa com as marcas de ordem de byte apropriado. Caso contrário, a codificação fornecida pelo usuário é usada. Consulte o método <xref:System.Text.Encoding.GetPreamble%2A?displayProperty=nameWithType> para obter mais informações.  
  
> [!NOTE]
>  Ao ler de um <xref:System.IO.Stream>, é mais eficiente usar um buffer que é o mesmo tamanho que o buffer interno do fluxo.  
  
> [!CAUTION]
>  Quando você compila um conjunto de caracteres com uma configuração cultural específica e recupera os mesmos caracteres com uma configuração cultural diferente, os caracteres não podem ser interpretados corretamente e poderá causar uma exceção seja lançada.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BaseStream">
      <MemberSignature Language="C#" Value="public virtual System.IO.Stream BaseStream { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Stream BaseStream" />
      <MemberSignature Language="DocId" Value="P:System.IO.StreamReader.BaseStream" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property BaseStream As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::IO::Stream ^ BaseStream { System::IO::Stream ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseStream : System.IO.Stream" Usage="System.IO.StreamReader.BaseStream" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Retorna o fluxo subjacente.</summary>
        <value>O fluxo subjacente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você pode usar essa propriedade para acessar o fluxo subjacente. O <xref:System.IO.StreamReader> entrada de buffers do fluxo subjacente de classe quando você chama um do <xref:System.IO.StreamReader.Read%2A> métodos. Se você manipular a posição do fluxo subjacente após a leitura de dados no buffer, a posição do fluxo subjacente pode não corresponder a posição do buffer interno. Para redefinir o buffer interno, chame o <xref:System.IO.StreamReader.DiscardBufferedData%2A> método; no entanto, esse método reduz o desempenho e deve ser chamado somente quando absolutamente necessário. O <xref:System.IO.StreamReader> construtores que têm o `detectEncodingFromByteOrderMarks` parâmetro pode alterar a codificação na primeira vez que você ler a partir de <xref:System.IO.StreamReader> objeto.  
  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md">E/S de arquivo e de fluxo</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Como ler texto de um arquivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Como gravar texto em um arquivo</related>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public override void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Close();" />
      <MemberSignature Language="F#" Value="override this.Close : unit -&gt; unit" Usage="streamReader.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Fecha o objeto <see cref="T:System.IO.StreamReader" /> e o fluxo subjacente e libera os recursos do sistema associados ao leitor.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método substitui o <xref:System.IO.TextWriter.Close%2A?displayProperty=nameWithType> método.  
  
 Essa implementação do <xref:System.IO.StreamReader.Close%2A> chamadas a <xref:System.IO.StreamReader.Dispose%2A> método passando um `true` valor.  
  
 Liberando o fluxo não liberar seu codificador subjacente, a menos que você chamar explicitamente <xref:System.IO.StreamReader.Close%2A>. Definindo <xref:System.IO.StreamWriter.AutoFlush%2A> para `true` significa que dados serão liberados do buffer no fluxo, mas o estado de codificador não será liberado. Isso permite que o codificador deve manter o estado (caracteres parcial), para que ele pode codificar o próximo bloco de caracteres corretamente. Esse cenário afeta UTF8 e UTF7, em que determinados caracteres podem ser codificados somente depois que o codificador recebe adjacentes ou mais caracteres.  
  
 Após uma chamada para <xref:System.IO.StreamReader.Close%2A>, todas as operações no leitor podem gerar exceções.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md">E/S de arquivo e de fluxo</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Como ler texto de um arquivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Como gravar texto em um arquivo</related>
      </Docs>
    </Member>
    <Member MemberName="CurrentEncoding">
      <MemberSignature Language="C#" Value="public virtual System.Text.Encoding CurrentEncoding { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.Encoding CurrentEncoding" />
      <MemberSignature Language="DocId" Value="P:System.IO.StreamReader.CurrentEncoding" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CurrentEncoding As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Text::Encoding ^ CurrentEncoding { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentEncoding : System.Text.Encoding" Usage="System.IO.StreamReader.CurrentEncoding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém a codificação de caracteres atual que está sendo usada pelo objeto <see cref="T:System.IO.StreamReader" /> atual.</summary>
        <value>A codificação de caracteres atual usada pelo leitor atual. O valor pode ser diferente após a primeira chamada para qualquer método <see cref="Overload:System.IO.StreamReader.Read" /> de <see cref="T:System.IO.StreamReader" />, pois a detecção automática de codificação só é feita após a primeira chamada a um método <see cref="Overload:System.IO.StreamReader.Read" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 O exemplo de código a seguir obtém a codificação especificada <xref:System.IO.StreamReader> objeto.  
  
 [!code-cpp[strmreader currentencoding#1](~/samples/snippets/cpp/VS_Snippets_CLR/StrmReader CurrentEncoding/CPP/strmreader currentencoding.cpp#1)]
 [!code-csharp[strmreader currentencoding#1](~/samples/snippets/csharp/VS_Snippets_CLR/StrmReader CurrentEncoding/CS/strmreader currentencoding.cs#1)]
 [!code-vb[strmreader currentencoding#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StrmReader CurrentEncoding/VB/strmreader currentencoding.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md">E/S de arquivo e de fluxo</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Como ler texto de um arquivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Como gravar texto em um arquivo</related>
      </Docs>
    </Member>
    <Member MemberName="DiscardBufferedData">
      <MemberSignature Language="C#" Value="public void DiscardBufferedData ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DiscardBufferedData() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.DiscardBufferedData" />
      <MemberSignature Language="VB.NET" Value="Public Sub DiscardBufferedData ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DiscardBufferedData();" />
      <MemberSignature Language="F#" Value="member this.DiscardBufferedData : unit -&gt; unit" Usage="streamReader.DiscardBufferedData " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Limpa o buffer interno.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use o <xref:System.IO.StreamReader.DiscardBufferedData%2A> método para redefinir o buffer interno para o <xref:System.IO.StreamReader> objeto. Você precisa chamar esse método somente quando a posição do buffer interno e o <xref:System.IO.StreamReader.BaseStream%2A> não coincidem. Essas posições podem se tornar incompatíveis quando você ler dados no buffer e, em seguida, busca uma nova posição no fluxo subjacente. Esse método reduz o desempenho e deve ser usado somente quando absolutamente necessário, como quando você deseja ler uma parte do conteúdo de um <xref:System.IO.StreamReader> objeto mais de uma vez.  
  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 O exemplo a seguir mostra um cenário em que o <xref:System.IO.StreamReader.DiscardBufferedData%2A> método deve ser chamado para sincronizar o buffer interno e o fluxo subjacente. O arquivo de exemplo é usado para ilustrar a posição e consiste no texto `abcdefghijklmnopqrstuvwxyz`. Chamando <xref:System.IO.StreamReader.DiscardBufferedData%2A> depois que os dados são lidos, o exemplo funciona conforme o esperado. Depois que os 15 primeiros caracteres são lidos, a posição é redefinida para o valor de deslocamento de 2 e todos os caracteres restantes são lidas. Se você remover a chamada para <xref:System.IO.StreamReader.DiscardBufferedData%2A>, o exemplo não funcionar conforme o esperado. Os primeiros 15 caracteres são lidos, mas apenas a posição do fluxo subjacente é redefinida. O buffer interno do <xref:System.IO.StreamReader> objeto ainda está no 16º caractere. Portanto, <xref:System.IO.StreamReader.ReadToEnd%2A> retorna todos os caracteres no buffer mais os caracteres no fluxo subjacente, começando na posição do redefinição.  
  
 [!code-csharp[System.IO.StreamReader#30](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/program.cs#30)]
 [!code-vb[System.IO.StreamReader#30](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/module1.vb#30)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md">E/S de arquivo e de fluxo</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Como ler texto de um arquivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Como gravar texto em um arquivo</related>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="streamReader.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> para liberar recursos gerenciados e não gerenciados; <see langword="false" /> para liberar apenas recursos não gerenciados.</param>
        <summary>Fecha o fluxo subjacente, libera os recursos não gerenciados usados pelo <see cref="T:System.IO.StreamReader" /> e, opcionalmente, libera os recursos gerenciados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método é chamado pelo método público <xref:System.IDisposable.Dispose%2A> e pelo método <xref:System.Object.Finalize%2A>. <xref:System.IDisposable.Dispose%2A> invoca o protegido <xref:System.IO.StreamReader.Dispose%2A> método com o `disposing` como verdadeiro. <xref:System.Object.Finalize%2A> invoca <xref:System.IO.StreamReader.Dispose%2A> com `disposing` definido como false.  
  
 Quando o `disposing` parâmetro é `true`, esse versões de método, todos os recursos mantidos por qualquer gerenciados objetos que o <xref:System.IO.StreamReader> referências de objeto. Este método invoca o método <xref:System.IDisposable.Dispose%2A> de cada objeto referenciado.  
  
 .  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Dispose pode ser chamado várias vezes por outros objetos. Ao substituir <see cref="M:System.IO.StreamReader.Dispose(System.Boolean)" />, tenha cuidado para referenciar objetos que tenham sido descartados anteriormente em uma chamada anterior para Dispose [cref...] não. Para obter mais informações sobre como implementar <see cref="M:System.IO.StreamReader.Dispose(System.Boolean)" /> ver [implementando um método Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
Para obter mais informações sobre <see cref="M:System.IDisposable.Dispose" /> e <see cref="M:System.Object.Finalize" />, consulte [limpeza de recursos não gerenciados](~/docs/standard/garbage-collection/unmanaged.md).</para>
        </block>
        <related type="Article" href="~/docs/standard/io/index.md">E/S de arquivo e de fluxo</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Como ler texto de um arquivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Como gravar texto em um arquivo</related>
      </Docs>
    </Member>
    <Member MemberName="EndOfStream">
      <MemberSignature Language="C#" Value="public bool EndOfStream { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EndOfStream" />
      <MemberSignature Language="DocId" Value="P:System.IO.StreamReader.EndOfStream" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property EndOfStream As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EndOfStream { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.EndOfStream : bool" Usage="System.IO.StreamReader.EndOfStream" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se a posição do fluxo atual está no final do fluxo.</summary>
        <value>
          <see langword="true" /> se a posição do fluxo atual estiver no final do fluxo; caso contrário, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">O fluxo subjacente foi descartado.</exception>
      </Docs>
    </Member>
    <Member MemberName="Null">
      <MemberSignature Language="C#" Value="public static readonly System.IO.StreamReader Null;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.IO.StreamReader Null" />
      <MemberSignature Language="DocId" Value="F:System.IO.StreamReader.Null" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Null As StreamReader " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::IO::StreamReader ^ Null;" />
      <MemberSignature Language="F#" Value=" staticval mutable Null : System.IO.StreamReader" Usage="System.IO.StreamReader.Null" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.StreamReader</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Um objeto <see cref="T:System.IO.StreamReader" /> em torno de um fluxo vazio.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ao ler os métodos são invocados em <xref:System.IO.StreamReader.Null>, sempre será retornado zero. Quando <xref:System.IO.StreamReader.ReadLine%2A> é invocado na <xref:System.IO.StreamReader.Null>, `null` será retornado.  
  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md">E/S de arquivo e de fluxo</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Como ler texto de um arquivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Como gravar texto em um arquivo</related>
      </Docs>
    </Member>
    <Member MemberName="Peek">
      <MemberSignature Language="C#" Value="public override int Peek ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Peek() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.Peek" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Peek () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Peek();" />
      <MemberSignature Language="F#" Value="override this.Peek : unit -&gt; int" Usage="streamReader.Peek " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna o próximo caractere disponível, mas não o consome.</summary>
        <returns>Um inteiro que representa o próximo caractere a ser lido, ou -1, se não houver nenhum caractere a ser lido ou se o fluxo não der suporte para busca.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.IO.StreamReader.Peek%2A> método retorna um valor inteiro para determinar se o final do arquivo ou outro erro ocorreu. Isso permite que um usuário para primeiro verificar se o valor retornado será -1 antes de convertê-la para um <xref:System.Char> tipo.  
  
 Este método substitui <xref:System.IO.TextReader.Peek%2A?displayProperty=nameWithType>.  
  
 A posição atual do <xref:System.IO.StreamReader> objeto não é alterado pela <xref:System.IO.StreamReader.Peek%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir lê linhas de um arquivo até o final do arquivo for atingido.  
  
 [!code-cpp[strmreader peek#1](~/samples/snippets/cpp/VS_Snippets_CLR/StrmReader Peek/CPP/strmreader peek.cpp#1)]
 [!code-csharp[strmreader peek#1](~/samples/snippets/csharp/VS_Snippets_CLR/StrmReader Peek/CS/strmreader peek.cs#1)]
 [!code-vb[strmreader peek#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StrmReader Peek/VB/strmreader peek.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ocorre um erro de E/S.</exception>
        <related type="Article" href="~/docs/standard/io/index.md">E/S de arquivo e de fluxo</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Como ler texto de um arquivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Como gravar texto em um arquivo</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Read">
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Lê o próximo caractere ou o próximo conjunto de caracteres do fluxo de entrada.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.Read" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read();" />
      <MemberSignature Language="F#" Value="override this.Read : unit -&gt; int" Usage="streamReader.Read " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lê o próximo caractere do fluxo de entrada e avança a posição do caractere em um caractere.</summary>
        <returns>O próximo caractere do fluxo de entrada representado como um objeto <see cref="T:System.Int32" />, ou -1, se não houver mais caracteres disponíveis.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método substitui <xref:System.IO.TextReader.Read%2A?displayProperty=nameWithType>.  
  
 Esse método retorna um inteiro para que ele possa retornar -1 se o final do fluxo foi atingido. Se você manipular a posição do fluxo subjacente após a leitura de dados no buffer, a posição do fluxo subjacente pode não corresponder a posição do buffer interno. Para redefinir o buffer interno, chame o <xref:System.IO.StreamReader.DiscardBufferedData%2A> método; no entanto, esse método reduz o desempenho e deve ser chamado somente quando absolutamente necessário.  
  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra um uso simples dos <xref:System.IO.StreamReader.Read%2A> método.  
  
 [!code-cpp[strmreader read1#1](~/samples/snippets/cpp/VS_Snippets_CLR/StrmReader Read1/CPP/strmreader read1.cpp#1)]
 [!code-csharp[strmreader read1#1](~/samples/snippets/csharp/VS_Snippets_CLR/StrmReader Read1/CS/strmreader read1.cs#1)]
 [!code-vb[strmreader read1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StrmReader Read1/VB/strmreader read1.vb#1)]  
  
 O exemplo de código a seguir demonstra a leitura de um único caractere usando o <xref:System.IO.StreamReader.Read> sobrecarga de método, formatação de inteiro de ASCII de saída como decimais e hexadecimais.  
  
 [!code-cpp[StrmRdrRead#1](~/samples/snippets/cpp/VS_Snippets_CLR/StrmRdrRead/CPP/strmrdrread.cpp#1)]
 [!code-csharp[StrmRdrRead#1](~/samples/snippets/csharp/VS_Snippets_CLR/StrmRdrRead/CS/strmrdrread.cs#1)]
 [!code-vb[StrmRdrRead#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StrmRdrRead/VB/strmrdrread.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ocorre um erro de E/S.</exception>
        <related type="Article" href="~/docs/standard/io/index.md">E/S de arquivo e de fluxo</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Como ler texto de um arquivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Como gravar texto em um arquivo</related>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (Span&lt;char&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read(valuetype System.Span`1&lt;char&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.Read(System.Span{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read (buffer As Span(Of Char)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read(Span&lt;char&gt; buffer);" />
      <MemberSignature Language="F#" Value="override this.Read : Span&lt;char&gt; -&gt; int" Usage="streamReader.Read buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read([out] char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.Read(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read (buffer As Char(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read(cli::array &lt;char&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="override this.Read : char[] * int * int -&gt; int" Usage="streamReader.Read (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Quando esse método é retornado, ele contém a matriz de caracteres especificada com os valores entre <c>índice</c> e (<c>índice + contagem - 1</c>) substituídos pelos caracteres lidos da origem atual.</param>
        <param name="index">O índice do <c>buffer</c> no qual a gravação é iniciada.</param>
        <param name="count">O número máximo de caracteres a serem lidos.</param>
        <summary>Lê um máximo especificado de caracteres do fluxo atual em um buffer, começando no índice especificado.</summary>
        <returns>O número de caracteres que foram lidos, ou 0, se estiver no final do fluxo e nenhum dado foi lido. O número será menor ou igual ao parâmetro <paramref name="count" />, dependendo se os dados estão disponíveis no fluxo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método substitui <xref:System.IO.TextReader.Read%2A?displayProperty=nameWithType>.  
  
 Esse método retorna um inteiro para que ele possa retornar 0 se o final do fluxo foi atingido.  
  
 Ao usar o <xref:System.IO.StreamReader.Read%2A> método, é mais eficiente usar um buffer que é o mesmo tamanho que o buffer interno do fluxo, em que o buffer interno for definido como o tamanho do bloco desejado e para ler sempre menor que o tamanho do bloco. Se o tamanho do buffer interno foi especificado quando o fluxo foi construído, o tamanho padrão é 4 KB (4096 bytes). Se você manipular a posição do fluxo subjacente após a leitura de dados no buffer, a posição do fluxo subjacente pode não corresponder a posição do buffer interno. Para redefinir o buffer interno, chame o <xref:System.IO.StreamReader.DiscardBufferedData%2A> método; no entanto, esse método reduz o desempenho e deve ser chamado somente quando absolutamente necessário.  
  
 Esse método retorna o número de caracteres especificada pelo depois de uma a `count` parâmetro são lidos ou o final do arquivo for atingido. <xref:System.IO.TextReader.ReadBlock%2A> é uma versão de bloqueio de <xref:System.IO.StreamReader.Read%2A>.  
  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 O exemplo de código a seguir lê os cinco caracteres de cada vez até o final do arquivo for atingido.  
  
 [!code-cpp[strmreader read2#1](~/samples/snippets/cpp/VS_Snippets_CLR/StrmReader Read2/CPP/strmreader read2.cpp#1)]
 [!code-csharp[strmreader read2#1](~/samples/snippets/csharp/VS_Snippets_CLR/StrmReader Read2/CS/strmreader read2.cs#1)]
 [!code-vb[strmreader read2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StrmReader Read2/VB/strmreader read2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O tamanho do buffer menos <paramref name="index" /> é menor que <paramref name="count" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> ou <paramref name="count" /> é negativo.</exception>
        <exception cref="T:System.IO.IOException">Erro de E/S, por exemplo, o fluxo está fechado.</exception>
        <related type="Article" href="~/docs/standard/io/index.md">E/S de arquivo e de fluxo</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Como ler texto de um arquivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Como gravar texto em um arquivo</related>
      </Docs>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.ValueTask&lt;int&gt; ReadAsync (Memory&lt;char&gt; buffer, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Threading.Tasks.ValueTask`1&lt;int32&gt; ReadAsync(valuetype System.Memory`1&lt;char&gt; buffer, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.ReadAsync(System.Memory{System.Char},System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="override this.ReadAsync : Memory&lt;char&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.ValueTask&lt;int&gt;" Usage="streamReader.ReadAsync (buffer, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ValueTask&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Memory&lt;System.Char&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task&lt;int&gt; ReadAsync (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadAsync(char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.ReadAsync(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadAsync (buffer As Char(), index As Integer, count As Integer) As Task(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task&lt;int&gt; ^ ReadAsync(cli::array &lt;char&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="override this.ReadAsync : char[] * int * int -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="streamReader.ReadAsync (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Quando esse método é retornado, ele contém a matriz de caracteres especificada com os valores entre <c>índice</c> e (<c>índice</c> + <c>contagem</c> - 1) substituídos pelos caracteres lidos da origem atual.</param>
        <param name="index">A posição no <c>buffer</c> no qual a gravação deve ser iniciada.</param>
        <param name="count">O número máximo de caracteres a serem lidos. Se o final do fluxo for atingido antes que o número especificado de caracteres seja gravado no buffer, o método atual será retornado.</param>
        <summary>Lê um máximo especificado de caracteres do fluxo atual de forma assíncrona e grava os dados em um buffer, começando no índice especificado.</summary>
        <returns>Uma tarefa que representa a operação de leitura assíncrona. O valor do parâmetro <paramref name="TResult" /> contém o número total de caracteres lidos no buffer. O valor do resultado poderá ser menor que o número de caracteres solicitados se o número de caracteres disponíveis no momento for menor que o número solicitado ou poderá ser 0 (zero) se o final do fluxo for atingido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tarefa é concluída após o número de caracteres especificada pelo `count` parâmetro são lidos ou o final do fluxo for atingido.  
  
   
  
## Examples  
 O exemplo a seguir mostra como ler todos os caracteres em um arquivo usando o <xref:System.IO.StreamReader.ReadAsync%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> método. Ele verifica se cada caractere é uma letra, dígito ou espaço em branco antes de adicionar o caractere a uma instância da <xref:System.Text.StringBuilder> classe.  
  
 [!code-csharp[System.IO.StreamReader#42](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/example42.cs#42)]
 [!code-vb[System.IO.StreamReader#42](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/example42.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> ou <paramref name="count" /> é negativo.</exception>
        <exception cref="T:System.ArgumentException">A soma de <paramref name="index" /> e <paramref name="count" /> é maior que o tamanho do buffer.</exception>
        <exception cref="T:System.ObjectDisposedException">O fluxo foi descartado.</exception>
        <exception cref="T:System.InvalidOperationException">O leitor está sendo usado no momento por uma operação de leitura anterior.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadBlock">
      <MemberSignature Language="C#" Value="public override int ReadBlock (Span&lt;char&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 ReadBlock(valuetype System.Span`1&lt;char&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.ReadBlock(System.Span{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadBlock (buffer As Span(Of Char)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int ReadBlock(Span&lt;char&gt; buffer);" />
      <MemberSignature Language="F#" Value="override this.ReadBlock : Span&lt;char&gt; -&gt; int" Usage="streamReader.ReadBlock buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadBlock">
      <MemberSignature Language="C#" Value="public override int ReadBlock (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 ReadBlock([out] char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.ReadBlock(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadBlock (buffer As Char(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int ReadBlock(cli::array &lt;char&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="override this.ReadBlock : char[] * int * int -&gt; int" Usage="streamReader.ReadBlock (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Quando esse método é retornado, ele contém a matriz de caracteres especificada com os valores entre <c>índice</c> e (<c>índice + contagem - 1</c>) substituídos pelos caracteres lidos da origem atual.</param>
        <param name="index">A posição no <c>buffer</c> no qual a gravação deve ser iniciada.</param>
        <param name="count">O número máximo de caracteres a serem lidos.</param>
        <summary>Lê um máximo especificado de caracteres do fluxo atual e grava os dados em um buffer, começando no índice especificado.</summary>
        <returns>O número de caracteres que foram lidos. O número será menor ou igual a <paramref name="count" />, dependendo se todos os caracteres de entrada tiverem sido lidos.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A posição do fluxo subjacente é avançada pelo número de caracteres que foram lidos no `buffer`.  
  
 Os blocos de método até que `count` caracteres será lido ou o final do fluxo foi atingido. Esta é uma versão de bloqueio de <xref:System.IO.StreamReader.Read%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">O tamanho do buffer menos <paramref name="index" /> é menor que <paramref name="count" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> ou <paramref name="count" /> é negativo.</exception>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.IO.StreamReader" /> está fechado.</exception>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadBlockAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.ValueTask&lt;int&gt; ReadBlockAsync (Memory&lt;char&gt; buffer, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Threading.Tasks.ValueTask`1&lt;int32&gt; ReadBlockAsync(valuetype System.Memory`1&lt;char&gt; buffer, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.ReadBlockAsync(System.Memory{System.Char},System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="override this.ReadBlockAsync : Memory&lt;char&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.ValueTask&lt;int&gt;" Usage="streamReader.ReadBlockAsync (buffer, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ValueTask&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Memory&lt;System.Char&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadBlockAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task&lt;int&gt; ReadBlockAsync (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadBlockAsync(char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.ReadBlockAsync(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadBlockAsync (buffer As Char(), index As Integer, count As Integer) As Task(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task&lt;int&gt; ^ ReadBlockAsync(cli::array &lt;char&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="override this.ReadBlockAsync : char[] * int * int -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="streamReader.ReadBlockAsync (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Quando esse método é retornado, ele contém a matriz de caracteres especificada com os valores entre <c>índice</c> e (<c>índice</c> + <c>contagem</c> - 1) substituídos pelos caracteres lidos da origem atual.</param>
        <param name="index">A posição no <c>buffer</c> no qual a gravação deve ser iniciada.</param>
        <param name="count">O número máximo de caracteres a serem lidos. Se o final do fluxo for atingido antes que o número especificado de caracteres seja gravado no buffer, o método será retornado.</param>
        <summary>Lê um máximo especificado de caracteres do fluxo atual de forma assíncrona e grava os dados em um buffer, começando no índice especificado.</summary>
        <returns>Uma tarefa que representa a operação de leitura assíncrona. O valor do parâmetro <paramref name="TResult" /> contém o número total de caracteres lidos no buffer. O valor do resultado poderá ser menor que o número de caracteres solicitados se o número de caracteres disponíveis no momento for menor que o número solicitado ou poderá ser 0 (zero) se o final do fluxo for atingido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tarefa não for concluída até que o número de caracteres especificada pelo `count` parâmetro são lidos ou o final do fluxo foi atingido.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> ou <paramref name="count" /> é negativo.</exception>
        <exception cref="T:System.ArgumentException">A soma de <paramref name="index" /> e <paramref name="count" /> é maior que o tamanho do buffer.</exception>
        <exception cref="T:System.ObjectDisposedException">O fluxo foi descartado.</exception>
        <exception cref="T:System.InvalidOperationException">O leitor está sendo usado no momento por uma operação de leitura anterior.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadLine">
      <MemberSignature Language="C#" Value="public override string ReadLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ReadLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.ReadLine" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadLine () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ReadLine();" />
      <MemberSignature Language="F#" Value="override this.ReadLine : unit -&gt; string" Usage="streamReader.ReadLine " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lê uma linha de caracteres do fluxo atual e retorna os dados como uma cadeia de caracteres.</summary>
        <returns>A próxima linha do fluxo de entrada, ou <see langword="null" />, se o final do fluxo de entrada for atingido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uma linha é definida como uma sequência de caracteres seguida por uma linha de alimentação ("\n"), retorno de um carro ("\r") ou um retorno de carro seguido imediatamente por uma linha de alimentação ("\r\n"). A cadeia de caracteres retornada não contém o retorno de carro ou alimentação de linha de terminação. O valor retornado é `null` se o final do fluxo de entrada for atingido.  
  
 Este método substitui <xref:System.IO.TextReader.ReadLine%2A?displayProperty=nameWithType>.  
  
 Se o método atual gerará um <xref:System.OutOfMemoryException>, a posição do leitor subjacente <xref:System.IO.Stream> objeto é avançado pelo número de caracteres que o método foi capaz de ler, mas caracteres já são lidos em interno <xref:System.IO.StreamReader.ReadLine%2A> buffer são descartados . Se você manipular a posição do fluxo subjacente após a leitura de dados no buffer, a posição do fluxo subjacente pode não corresponder a posição do buffer interno. Para redefinir o buffer interno, chame o <xref:System.IO.StreamReader.DiscardBufferedData%2A> método; no entanto, esse método reduz o desempenho e deve ser chamado somente quando absolutamente necessário.  
  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 O exemplo de código a seguir lê linhas de um arquivo até o final do arquivo for atingido.  
  
 [!code-cpp[strmreader readline#1](~/samples/snippets/cpp/VS_Snippets_CLR/StrmReader ReadLine/CPP/strmreader readline.cpp#1)]
 [!code-csharp[strmreader readline#1](~/samples/snippets/csharp/VS_Snippets_CLR/StrmReader ReadLine/CS/strmreader readline.cs#1)]
 [!code-vb[strmreader readline#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StrmReader ReadLine/VB/strmreader readline.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OutOfMemoryException">Não há memória suficiente para alocar um buffer à cadeia de caracteres retornada.</exception>
        <exception cref="T:System.IO.IOException">Ocorre um erro de E/S.</exception>
        <related type="Article" href="~/docs/standard/io/index.md">E/S de arquivo e de fluxo</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Como ler texto de um arquivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Como gravar texto em um arquivo</related>
      </Docs>
    </Member>
    <Member MemberName="ReadLineAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task&lt;string&gt; ReadLineAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task`1&lt;string&gt; ReadLineAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.ReadLineAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadLineAsync () As Task(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task&lt;System::String ^&gt; ^ ReadLineAsync();" />
      <MemberSignature Language="F#" Value="override this.ReadLineAsync : unit -&gt; System.Threading.Tasks.Task&lt;string&gt;" Usage="streamReader.ReadLineAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lê uma linha de caracteres assincronamente do fluxo atual e retorna os dados como uma cadeia de caracteres.</summary>
        <returns>Uma tarefa que representa a operação de leitura assíncrona. O valor do parâmetro <paramref name="TResult" /> contém a próxima linha do fluxo ou <see langword="null" /> se todos os caracteres tiverem sido lidos.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir mostra como ler a primeira linha de um arquivo usando o <xref:System.IO.StreamReader.ReadLineAsync> método.  
  
 [!code-csharp[System.IO.StreamReader#41](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/example41.cs#41)]
 [!code-vb[System.IO.StreamReader#41](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/example41.vb#41)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">O número de caracteres na próxima linha é maior que <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.ObjectDisposedException">O fluxo foi descartado.</exception>
        <exception cref="T:System.InvalidOperationException">O leitor está sendo usado no momento por uma operação de leitura anterior.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadToEnd">
      <MemberSignature Language="C#" Value="public override string ReadToEnd ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ReadToEnd() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.ReadToEnd" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadToEnd () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ReadToEnd();" />
      <MemberSignature Language="F#" Value="override this.ReadToEnd : unit -&gt; string" Usage="streamReader.ReadToEnd " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lê todos os caracteres da posição atual até o final do fluxo.</summary>
        <returns>O restante do fluxo como uma cadeia de caracteres, da posição atual até o final. Se a posição atual estiver no final do fluxo, será retornada uma cadeia de caracteres vazia ("").</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método substitui <xref:System.IO.TextReader.ReadToEnd%2A?displayProperty=nameWithType>.  
  
 <xref:System.IO.StreamReader.ReadToEnd%2A> funciona melhor quando você precisa ler todas as entradas da posição atual até o final do fluxo. Se mais controle sobre o número de caracteres é lidos do fluxo, use o <xref:System.IO.StreamReader.Read%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> sobrecarga de método, que geralmente resulta em melhor desempenho.  
  
 <xref:System.IO.StreamReader.ReadToEnd%2A> pressupõe-se de que o fluxo sabe quando atingiu um final. Para protocolos interativos no qual o servidor envia dados somente quando pedi-lo e não fecha a conexão, <xref:System.IO.StreamReader.ReadToEnd%2A> podem bloquear indefinidamente, porque ele não atingir um fim e deve ser evitado.  
  
 Observe que, ao usar o <xref:System.IO.StreamReader.Read%2A> método, é mais eficiente usar um buffer que é o mesmo tamanho que o buffer interno do fluxo. Se o tamanho do buffer foi especificado quando o fluxo foi construído, o tamanho padrão é 4 KB (4096 bytes).  
  
 Se o método atual gerará um <xref:System.OutOfMemoryException>, a posição do leitor subjacente <xref:System.IO.Stream> objeto é avançado pelo número de caracteres que o método foi capaz de ler, mas caracteres já são lidos em interno <xref:System.IO.StreamReader.ReadLine%2A> buffer são descartados . Se você manipular a posição do fluxo subjacente após a leitura de dados no buffer, a posição do fluxo subjacente pode não corresponder a posição do buffer interno. Para redefinir o buffer interno, chame o <xref:System.IO.StreamReader.DiscardBufferedData%2A> método; no entanto, esse método reduz o desempenho e deve ser chamado somente quando absolutamente necessário.  
  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 O exemplo de código a seguir lê até o final de um arquivo em uma única operação.  
  
 [!code-cpp[strmreader readtoend#1](~/samples/snippets/cpp/VS_Snippets_CLR/StrmReader ReadToEnd/CPP/strmreader readtoend.cpp#1)]
 [!code-csharp[strmreader readtoend#1](~/samples/snippets/csharp/VS_Snippets_CLR/StrmReader ReadToEnd/CS/strmreader readtoend.cs#1)]
 [!code-vb[strmreader readtoend#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StrmReader ReadToEnd/VB/strmreader readtoend.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OutOfMemoryException">Não há memória suficiente para alocar um buffer à cadeia de caracteres retornada.</exception>
        <exception cref="T:System.IO.IOException">Ocorre um erro de E/S.</exception>
        <related type="Article" href="~/docs/standard/io/index.md">E/S de arquivo e de fluxo</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Como ler texto de um arquivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Como gravar texto em um arquivo</related>
      </Docs>
    </Member>
    <Member MemberName="ReadToEndAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task&lt;string&gt; ReadToEndAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task`1&lt;string&gt; ReadToEndAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.ReadToEndAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadToEndAsync () As Task(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task&lt;System::String ^&gt; ^ ReadToEndAsync();" />
      <MemberSignature Language="F#" Value="override this.ReadToEndAsync : unit -&gt; System.Threading.Tasks.Task&lt;string&gt;" Usage="streamReader.ReadToEndAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lê todos os caracteres da posição atual até o final do fluxo de forma assíncrona e os retorna como uma cadeia de caracteres.</summary>
        <returns>Uma tarefa que representa a operação de leitura assíncrona. O valor do parâmetro <paramref name="TResult" /> contém uma cadeia de caracteres da posição atual até o final do fluxo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir mostra como ler o conteúdo de um arquivo usando o <xref:System.IO.StreamReader.ReadToEndAsync> método.  
  
 [!code-csharp[System.IO.StreamReader#40](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/example40.cs#40)]
 [!code-vb[System.IO.StreamReader#40](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/example40.vb#40)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">O número de caracteres é maior que <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.ObjectDisposedException">O fluxo foi descartado.</exception>
        <exception cref="T:System.InvalidOperationException">O leitor está sendo usado no momento por uma operação de leitura anterior.</exception>
      </Docs>
    </Member>
  </Members>
</Type>