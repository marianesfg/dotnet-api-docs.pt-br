<Type Name="FileStream" FullName="System.IO.FileStream">
  <Metadata><Meta Name="ms.openlocfilehash" Value="9e1ad3a4a28f5e7aa66e97d7fa51dd4ec88555a0" /><Meta Name="ms.sourcegitcommit" Value="220917117f9d774aaa482439aa7324e39dc1f5b6" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pt-BR" /><Meta Name="ms.lasthandoff" Value="02/25/2019" /><Meta Name="ms.locfileid" Value="56759460" /></Metadata><TypeSignature Language="C#" Value="public class FileStream : System.IO.Stream" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit FileStream extends System.IO.Stream" />
  <TypeSignature Language="DocId" Value="T:System.IO.FileStream" />
  <TypeSignature Language="VB.NET" Value="Public Class FileStream&#xA;Inherits Stream" />
  <TypeSignature Language="C++ CLI" Value="public ref class FileStream : System::IO::Stream" />
  <TypeSignature Language="F#" Value="type FileStream = class&#xA;    inherit Stream" />
  <AssemblyInfo>
    <AssemblyName>System.IO.FileSystem</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.IO.Stream</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Fornece um <see cref="T:System.IO.Stream" /> para um arquivo, dando suporte a operações de leitura e gravação síncronas e assíncronas.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use o <xref:System.IO.FileStream> classe para leitura, gravação, abrir e fechar arquivos em um sistema de arquivos e para manipular outros identificadores do sistema de operacional relacionadas ao arquivo, incluindo pipes, entrada e saída padrão. Você pode usar o <xref:System.IO.FileStream.Read%2A>, <xref:System.IO.FileStream.Write%2A>, <xref:System.IO.Stream.CopyTo%2A>, e <xref:System.IO.FileStream.Flush%2A> métodos para realizar operações síncronas, ou o <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>, e <xref:System.IO.FileStream.FlushAsync%2A> métodos para executar assíncrona operações. Use os métodos assíncronos para executar operações de arquivo de uso intensivo de recursos sem bloquear o thread principal. Essa consideração sobre o desempenho é particularmente importante em um aplicativo [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] ou [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] em que uma operação demorada de fluxo pode bloquear o thread de interface do usuário e fazer seu aplicativo parecer como se não estivesse funcionando. <xref:System.IO.FileStream> buffers de entrada e saída para melhorar o desempenho.  
  
> [!IMPORTANT]
>  Esse tipo implementa o <xref:System.IDisposable> interface. Quando você terminar de usar o tipo, você deve descartá-lo diretamente ou indiretamente. Para descartar o tipo diretamente, chame seu <xref:System.IDisposable.Dispose%2A> método em um `try` / `catch` bloco. Para descartá-los indiretamente, usar uma construção de linguagem, como `using` (em c#) ou `Using` (no Visual Basic). Para obter mais informações, consulte a seção "Usando um objeto que implementa IDisposable" o <xref:System.IDisposable> tópico da interface.  
  
 O <xref:System.IO.FileStream.IsAsync%2A> propriedade detecta se o identificador de arquivo foi aberto de forma assíncrona. Especifique esse valor quando você cria uma instância das <xref:System.IO.FileStream> classe usando um construtor que tem um `isAsync`, `useAsync`, ou `options` parâmetro. Quando a propriedade for `true`, utiliza o fluxo de e/s sobreposta para executar operações de arquivo de forma assíncrona. No entanto, o <xref:System.IO.FileStream.IsAsync%2A> propriedade não precisa ser `true` para chamar o <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, ou <xref:System.IO.Stream.CopyToAsync%2A> método. Quando o <xref:System.IO.FileStream.IsAsync%2A> é de propriedade `false` e chamar a leitura assíncrona e operações de gravação, o thread de interface do usuário ainda não está bloqueado, mas a operação de e/s real é executada de forma síncrona.  
  
 O <xref:System.IO.FileStream.Seek%2A> método dá suporte ao acesso aleatório a arquivos. <xref:System.IO.FileStream.Seek%2A> permite que a posição de leitura/gravação a ser movido para qualquer posição dentro do arquivo. Isso é feito com parâmetros de ponto de referência de deslocamento de bytes. O deslocamento de bytes é relativo ao ponto de referência de busca, que pode ser no início, a posição atual ou o final do arquivo subjacente, conforme representado pelos membros de três a <xref:System.IO.SeekOrigin> enumeração.  
  
> [!NOTE]
>  Arquivos de disco sempre oferecem suporte a acesso aleatório. No momento da construção, o <xref:System.IO.FileStream.CanSeek%2A> o valor da propriedade é definido como `true` ou `false` dependendo do tipo de arquivo subjacente. Se o tipo de arquivo subjacente é FILE_TYPE_DISK, conforme definido em Winbase, o <xref:System.IO.FileStream.CanSeek%2A> é o valor da propriedade `true`. Caso contrário, o <xref:System.IO.FileStream.CanSeek%2A> é o valor da propriedade `false`.  
  
 Se um processo é encerrado com parte de um arquivo bloqueado ou fecha um arquivo que tenha bloqueios pendentes, o comportamento será indefinido.  
  
 Para operações de diretório e outras operações de arquivo, consulte o <xref:System.IO.File>, <xref:System.IO.Directory>, e <xref:System.IO.Path> classes. O <xref:System.IO.File> é uma classe de utilitário que tem métodos estáticos principalmente para a criação de <xref:System.IO.FileStream> objetos com base em caminhos de arquivo. O <xref:System.IO.MemoryStream> classe cria um fluxo de uma matriz de bytes e é semelhante ao <xref:System.IO.FileStream> classe.  
  
 Para obter uma lista de operações de diretório e arquivos comuns, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
## <a name="detection-of-stream-position-changes"></a>Detecção de alterações feitas na posição de fluxo  
 Quando um <xref:System.IO.FileStream> objeto não tiver uma espera exclusiva em seu identificador, outro thread poderia acessar o identificador de arquivo simultaneamente e alterar a posição do ponteiro de arquivo do sistema operacional que está associado com o identificador de arquivo. Nesse caso, a posição em cache no <xref:System.IO.FileStream> pode comprometer a objeto e os dados armazenados no buffer. O <xref:System.IO.FileStream> objeto rotineiramente executa verificações nos métodos que acessam o buffer em cache para garantir que a posição do identificador do sistema operacional é o mesmo que a posição em cache usada pelo <xref:System.IO.FileStream> objeto.  
  
 Se uma alteração inesperada na alça de posição é detectada em uma chamada para o <xref:System.IO.FileStream.Read%2A> descarta o conteúdo do buffer de método, o .NET Framework e lê o fluxo do arquivo novamente. Isso pode afetar o desempenho, dependendo do tamanho do arquivo e outros processos que poderiam afetar a posição do fluxo de arquivo.  
  
 Se uma alteração inesperada na alça de posição é detectada em uma chamada para o <xref:System.IO.FileStream.Write%2A> método, o conteúdo do buffer são descartados e um <xref:System.IO.IOException> exceção é lançada.  
  
 Um <xref:System.IO.FileStream> objeto não terá uma espera exclusiva em seu identificador quando qualquer um dos <xref:System.IO.FileStream.SafeFileHandle%2A> propriedade é acessada para expor o identificador ou o <xref:System.IO.FileStream> objeto receberá o <xref:System.IO.FileStream.SafeFileHandle%2A> propriedade em seu construtor.  
  
   
  
## Examples  
 O exemplo a seguir demonstra algumas do <xref:System.IO.FileStream> construtores.  
  
 [!code-cpp[fstream class#1](~/samples/snippets/cpp/VS_Snippets_CLR/FStream Class/CPP/fstream class.cpp#1)]
 [!code-csharp[fstream class#1](~/samples/snippets/csharp/VS_Snippets_CLR/FStream Class/CS/fstream class.cs#1)]
 [!code-vb[fstream class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FStream Class/VB/fstream class.vb#1)]  
  
 O exemplo a seguir mostra como gravar em um arquivo de forma assíncrona. Esse código é executado em um aplicativo WPF que tem um TextBlock chamado UserInput e um botão vinculada a um manipulador de eventos Button_Click chamado. O caminho do arquivo precisa ser alterado para um arquivo que existe no computador.  
  
 [!code-csharp[Asynchronous_File_IO_async#3](~/samples/snippets/csharp/VS_Snippets_CLR/Asynchronous_File_IO_async/cs/example3.cs#3)]
 [!code-vb[Asynchronous_File_IO_async#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Asynchronous_File_IO_async/vb/example3.vb#3)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.IO.File" />
    <altmember cref="T:System.IO.FileAccess" />
    <altmember cref="T:System.IO.FileMode" />
    <altmember cref="T:System.IO.FileShare" />
    <related type="Article" href="~/docs/standard/io/index.md">E/S de arquivo e de fluxo</related>
    <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Como ler texto de um arquivo</related>
    <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Como gravar texto em um arquivo</related>
    <related type="Article" href="~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md">Como ler e gravar em um arquivo de dados recém-criado</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.IO.FileStream" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (Microsoft.Win32.SafeHandles.SafeFileHandle handle, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Microsoft.Win32.SafeHandles.SafeFileHandle handle, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As SafeFileHandle, access As FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(Microsoft::Win32::SafeHandles::SafeFileHandle ^ handle, System::IO::FileAccess access);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : Microsoft.Win32.SafeHandles.SafeFileHandle * System.IO.FileAccess -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (handle, access)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="Microsoft.Win32.SafeHandles.SafeFileHandle" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="handle">Um identificador de arquivo para o arquivo que o objeto <see langword="FileStream" /> atual encapsulará.</param>
        <param name="access">Uma constante que define as propriedades <see cref="P:System.IO.FileStream.CanRead" /> e <see cref="P:System.IO.FileStream.CanWrite" /> do objeto <see langword="FileStream" />.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.IO.FileStream" /> para o identificador de arquivo especificado, com a permissão de leitura/gravação especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando <xref:System.IO.Stream.Close%2A> é chamado, o identificador também é fechado e a contagem de identificadores do arquivo é decrementada.  
  
 `FileStream` pressupõe-se de que ele tenha controle exclusivo sobre a alça. Leitura, gravação ou de busca enquanto um `FileStream` também está mantendo um identificador pode resultar em corrupção de dados. Para segurança de dados, chame <xref:System.IO.FileStream.Flush%2A> antes de usando o identificador e evitar chamar métodos diferentes de `Close` depois de concluir usando o identificador.  
  
> [!CAUTION]
>  Quando você compila um conjunto de caracteres com uma configuração cultural específica e recupera os mesmos caracteres com uma configuração cultural diferente, os caracteres talvez não sejam interpretáveis e poderá causar uma exceção seja lançada.  
  
 `FileShare.Read` é o padrão para aqueles <xref:System.IO.FileStream> construtores sem um `FileShare` parâmetro.  
  
 Para obter uma lista de operações de diretório e arquivos comuns, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="access" /> não é um campo de <see cref="T:System.IO.FileAccess" />.</exception>
        <exception cref="T:System.Security.SecurityException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S, como um erro de disco.  
  
- ou - 
O fluxo foi fechado.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O <paramref name="access" /> solicitado não é permitido pelo sistema operacional para o identificador de arquivo especificado, como quando <paramref name="access" /> é <see langword="Write" /> ou <see langword="ReadWrite" /> e o identificador de arquivo está definido para o acesso somente leitura.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para ler, gravar e anexando a arquivos. Enumerações associadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, e <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
        <related type="Article" href="~/docs/standard/io/index.md">E/S de arquivo e de fluxo</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Como ler texto de um arquivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Como gravar texto em um arquivo</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (IntPtr handle, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(native int handle, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As IntPtr, access As FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(IntPtr handle, System::IO::FileAccess access);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : nativeint * System.IO.FileAccess -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (handle, access)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use FileStream(SafeFileHandle handle, FileAccess access) instead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This constructor has been deprecated.  Please use new FileStream(SafeFileHandle handle, FileAccess access) instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0">
          <AttributeName>System.Obsolete("This constructor has been deprecated.  Please use new FileStream(SafeFileHandle handle, FileAccess access) instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="handle">Um identificador de arquivo para o arquivo que o objeto <see langword="FileStream" /> atual encapsulará.</param>
        <param name="access">Uma constante que define as propriedades <see cref="P:System.IO.FileStream.CanRead" /> e <see cref="P:System.IO.FileStream.CanWrite" /> do objeto <see langword="FileStream" />.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.IO.FileStream" /> para o identificador de arquivo especificado, com a permissão de leitura/gravação especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando <xref:System.IO.Stream.Close%2A> é chamado, o identificador também é fechado e a contagem de identificadores do arquivo é decrementada.  
  
 `FileStream` pressupõe-se de que ele tenha controle exclusivo sobre a alça. Leitura, gravação ou de busca enquanto um `FileStream` também está mantendo um identificador pode resultar em corrupção de dados. Para segurança de dados, chame <xref:System.IO.FileStream.Flush%2A> antes de usando o identificador e evitar chamar métodos diferentes de `Close` depois de concluir usando o identificador.  
  
> [!CAUTION]
>  Quando você compila um conjunto de caracteres com uma configuração cultural específica e recupera os mesmos caracteres com uma configuração cultural diferente, os caracteres talvez não sejam interpretáveis e poderá causar uma exceção seja lançada.  
  
 `FileShare.Read` é o padrão para aqueles <xref:System.IO.FileStream> construtores sem um `FileShare` parâmetro.  
  
 Para obter uma lista de operações de diretório e arquivos comuns, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="access" /> não é um campo de <see cref="T:System.IO.FileAccess" />.</exception>
        <exception cref="T:System.Security.SecurityException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S, como um erro de disco.  
  
- ou - 
O fluxo foi fechado.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O <paramref name="access" /> solicitado não é permitido pelo sistema operacional para o identificador de arquivo especificado, como quando <paramref name="access" /> é <see langword="Write" /> ou <see langword="ReadWrite" /> e o identificador de arquivo está definido para o acesso somente leitura.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para ler, gravar e anexando a arquivos. Enumerações associadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, e <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
        <related type="Article" href="~/docs/standard/io/index.md">E/S de arquivo e de fluxo</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Como ler texto de um arquivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Como gravar texto em um arquivo</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(System::String ^ path, System::IO::FileMode mode);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : string * System.IO.FileMode -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (path, mode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
      </Parameters>
      <Docs>
        <param name="path">Um caminho relativo ou absoluto para o arquivo que o objeto <see langword="FileStream" /> atual encapsulará.</param>
        <param name="mode">Uma constante que determina como abrir ou criar o arquivo.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.IO.FileStream" /> com o modo de criação e o caminho especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O .NET Framework não dá suporte a acesso direto aos discos físicos por meio de caminhos que são nomes de dispositivo, como "\\\\. \PHYSICALDRIVE0".  
  
 O `path` parâmetro pode ser um nome de arquivo, incluindo um arquivo em um compartilhamento de convenção de nomenclatura Universal (UNC).  
  
 O construtor recebe acesso de leitura/gravação para o arquivo e ele é aberto, compartilhando o acesso de leitura (ou seja, as solicitações para abrir o arquivo para gravação por este ou outro processo falharão até que o `FileStream` o objeto foi fechado, mas as tentativas de leitura será bem-sucedida).  
  
 Você não pode usar esse construtor para abrir arquivos somente leitura; em vez disso, você deve usar um construtor que aceita uma `FileAccess` parâmetro com o valor definido como `FileAccess.Read`.  
  
 O tamanho do buffer é definido como o tamanho padrão de 4096 bytes (4 KB).  
  
> [!NOTE]
>  `path` não é necessário ser um arquivo armazenado no disco; ele pode ser qualquer parte de um sistema que dá suporte ao acesso por meio de fluxos. Por exemplo, dependendo do sistema, essa classe pode acessar um dispositivo físico.  
  
 <xref:System.IO.Stream.CanSeek%2A> está `true` para todos os <xref:System.IO.FileStream> objetos que encapsulam os arquivos. Se `path` indica um dispositivo que não dá suporte à busca, o <xref:System.IO.FileStream.CanSeek%2A> propriedade em resultante <xref:System.IO.FileStream> é `false`. Para obter mais informações, consulte: <xref:System.IO.Stream.CanSeek%2A>.  
  
 `FileShare.Read` é o padrão para aqueles <xref:System.IO.FileStream> construtores sem um `FileShare` parâmetro.  
  
 Para construtores sem um <xref:System.IO.FileAccess> parâmetro, se o `mode` parâmetro for definido como <xref:System.IO.FileMode.Append>, <xref:System.IO.FileAccess.Write> é o acesso padrão. Caso contrário, o acesso é definido como <xref:System.IO.FileAccess.ReadWrite>.  
  
> [!CAUTION]
>  Quando você compila um conjunto de caracteres com uma configuração cultural específica e recupera os mesmos caracteres com uma configuração cultural diferente, os caracteres talvez não sejam interpretáveis e poderá causar uma exceção seja lançada.  
  
 Para obter uma lista de operações de diretório e arquivos comuns, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como gravar dados em um arquivo, byte por byte e, em seguida, verifique se que os dados foram gravados corretamente.  
  
 [!code-cpp[System.IO.FileStream1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream1/CPP/source.cpp#1)]
 [!code-csharp[System.IO.FileStream1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream1/CS/source.cs#1)]
 [!code-vb[System.IO.FileStream1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> é uma cadeia de caracteres vazia (“”), contém somente espaços em branco ou contém um ou mais caracteres inválidos.  
  
- ou - 
 <paramref name="path" /> refere-se a um dispositivo não de arquivo, como "con:", "com1:", "lpt1:", etc. em um ambiente NTFS.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" /> refere-se a um dispositivo não de arquivo, como "con:", "com1:", "lpt1:", etc. em um ambiente não NTFS.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Não é possível localizar o arquivo, por exemplo, quando <paramref name="mode" /> é <see langword="FileMode.Truncate" /> ou <see langword="FileMode.Open" /> e o arquivo especificado por <paramref name="path" /> não existe. O arquivo já deve existir em um desses modos.</exception>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S, como especificar <see langword="FileMode.CreateNew" /> quando o arquivo especificado por <paramref name="path" /> já existe.  
  
- ou - 
O fluxo foi fechado.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">O caminho especificado é inválido, por exemplo, ele está em uma unidade não mapeada.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="mode" /> contém um valor inválido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para ler, gravar e anexando a arquivos. Enumerações associadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, e <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
        <altmember cref="F:System.IO.Path.InvalidPathChars" />
        <related type="Article" href="~/docs/standard/io/index.md">E/S de arquivo e de fluxo</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Como ler texto de um arquivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Como gravar texto em um arquivo</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (Microsoft.Win32.SafeHandles.SafeFileHandle handle, System.IO.FileAccess access, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Microsoft.Win32.SafeHandles.SafeFileHandle handle, valuetype System.IO.FileAccess access, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As SafeFileHandle, access As FileAccess, bufferSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(Microsoft::Win32::SafeHandles::SafeFileHandle ^ handle, System::IO::FileAccess access, int bufferSize);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : Microsoft.Win32.SafeHandles.SafeFileHandle * System.IO.FileAccess * int -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (handle, access, bufferSize)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="Microsoft.Win32.SafeHandles.SafeFileHandle" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="handle">Um identificador de arquivo para o arquivo que o objeto <see langword="FileStream" /> atual encapsulará.</param>
        <param name="access">Uma constante <see cref="T:System.IO.FileAccess" /> que define as propriedades <see cref="P:System.IO.FileStream.CanRead" /> e <see cref="P:System.IO.FileStream.CanWrite" /> do objeto <see langword="FileStream" />.</param>
        <param name="bufferSize">Um valor <see cref="T:System.Int32" /> positivo maior que 0, indicando o tamanho do buffer. O tamanho do buffer padrão é 4096.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.IO.FileStream" /> para o identificador de arquivo especificado, com a permissão de leitura/gravação especificada e tamanho do buffer.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileStream` pressupõe-se de que ele tenha controle exclusivo sobre a alça. Leitura, gravação ou de busca enquanto um `FileStream` também está mantendo um identificador pode resultar em corrupção de dados. Para segurança de dados, chame <xref:System.IO.FileStream.Flush%2A> antes de usando o identificador e evitar chamar métodos diferentes de `Close` depois de concluir usando o identificador. Como alternativa, ler e gravar o identificador antes de chamar isso `FileStream` construtor.  
  
 `FileShare.Read` é o padrão para aqueles <xref:System.IO.FileStream> construtores sem um `FileShare` parâmetro.  
  
> [!CAUTION]
>  Quando você compila um conjunto de caracteres com uma configuração cultural específica e recupera os mesmos caracteres com uma configuração cultural diferente, os caracteres talvez não sejam interpretáveis e poderá causar uma exceção seja lançada.  
  
 Para obter uma lista de operações de diretório e arquivos comuns, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O parâmetro <paramref name="handle" /> é um identificador inválido.  
  
- ou - 
O parâmetro <paramref name="handle" /> é um identificador síncrono e foi usado assincronamente.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">O parâmetro <paramref name="bufferSize" /> é negativo.</exception>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S, como um erro de disco.  
  
- ou - 
O fluxo foi fechado.</exception>
        <exception cref="T:System.Security.SecurityException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O <paramref name="access" /> solicitado não é permitido pelo sistema operacional para o identificador de arquivo especificado, como quando <paramref name="access" /> é <see langword="Write" /> ou <see langword="ReadWrite" /> e o identificador de arquivo está definido para o acesso somente leitura.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para ler, gravar e anexando a arquivos. Enumerações associadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, e <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">permissão chamar código não gerenciado. Enumerações associadas: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">E/S de arquivo e de fluxo</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Como ler texto de um arquivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Como gravar texto em um arquivo</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (IntPtr handle, System.IO.FileAccess access, bool ownsHandle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(native int handle, valuetype System.IO.FileAccess access, bool ownsHandle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As IntPtr, access As FileAccess, ownsHandle As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(IntPtr handle, System::IO::FileAccess access, bool ownsHandle);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : nativeint * System.IO.FileAccess * bool -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (handle, access, ownsHandle)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use FileStream(SafeFileHandle handle, FileAccess access) instead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This constructor has been deprecated.  Please use new FileStream(SafeFileHandle handle, FileAccess access) instead, and optionally make a new SafeFileHandle with ownsHandle=false if needed.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0">
          <AttributeName>System.Obsolete("This constructor has been deprecated.  Please use new FileStream(SafeFileHandle handle, FileAccess access) instead, and optionally make a new SafeFileHandle with ownsHandle=false if needed.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="ownsHandle" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="handle">Um identificador de arquivo para o arquivo que o objeto <see langword="FileStream" /> atual encapsulará.</param>
        <param name="access">Uma constante que define as propriedades <see cref="P:System.IO.FileStream.CanRead" /> e <see cref="P:System.IO.FileStream.CanWrite" /> do objeto <see langword="FileStream" />.</param>
        <param name="ownsHandle"><see langword="true" /> se o identificador de arquivo será de propriedade dessa instância <see langword="FileStream" />; caso contrário, <see langword="false" />.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.IO.FileStream" /> para o identificador de arquivo especificado, com a permissão de leitura/gravação especificada e a propriedade da instância <see langword="FileStream" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `FileStream` objeto receberá o acesso especificado para o arquivo. A propriedade do identificador poderá ser conforme especificado. Se esse processo possui o identificador, uma chamada para o <xref:System.IO.Stream.Close%2A> método também fechará o identificador e a contagem de identificadores do arquivo é decrementada. O `FileStream` objeto recebe o tamanho do buffer padrão de 4096 bytes.  
  
 `FileStream` pressupõe-se de que ele tenha controle exclusivo sobre a alça. Leitura, gravação ou de busca enquanto um `FileStream` também está mantendo um identificador pode resultar em corrupção de dados. Para segurança de dados, chame <xref:System.IO.FileStream.Flush%2A> antes de usar o identificador e evitar chamar métodos diferentes de `Close` depois de concluir usando o identificador.  
  
 `FileShare.Read` é o padrão para aqueles <xref:System.IO.FileStream> construtores sem um `FileShare` parâmetro.  
  
> [!CAUTION]
>  Quando você compila um conjunto de caracteres com uma configuração cultural específica e recupera os mesmos caracteres com uma configuração cultural diferente, os caracteres talvez não sejam interpretáveis e poderá causar uma exceção seja lançada.  
  
 Para obter uma lista de operações de diretório e arquivos comuns, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="access" /> não é um campo de <see cref="T:System.IO.FileAccess" />.</exception>
        <exception cref="T:System.Security.SecurityException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S, como um erro de disco.  
  
- ou - 
O fluxo foi fechado.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O <paramref name="access" /> solicitado não é permitido pelo sistema operacional para o identificador de arquivo especificado, como quando <paramref name="access" /> é <see langword="Write" /> ou <see langword="ReadWrite" /> e o identificador de arquivo está definido para o acesso somente leitura.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para ler, gravar e anexando a arquivos. Enumerações associadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, e <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
        <related type="Article" href="~/docs/standard/io/index.md">E/S de arquivo e de fluxo</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Como ler texto de um arquivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Como gravar texto em um arquivo</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : string * System.IO.FileMode * System.IO.FileAccess -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (path, mode, access)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="path">Um caminho relativo ou absoluto para o arquivo que o objeto <see langword="FileStream" /> atual encapsulará.</param>
        <param name="mode">Uma constante que determina como abrir ou criar o arquivo.</param>
        <param name="access">Uma constante que determina como o arquivo pode ser acessado pelo objeto <see langword="FileStream" />. Isso também determina os valores retornados pelas propriedades <see cref="P:System.IO.FileStream.CanRead" /> e <see cref="P:System.IO.FileStream.CanWrite" /> do objeto <see langword="FileStream" />. <see cref="P:System.IO.FileStream.CanSeek" /> será <see langword="true" /> se <paramref name="path" /> especificar um arquivo de disco.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.IO.FileStream" /> com o caminho, o modo de criação e a permissão de leitura/gravação especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O .NET Framework não dá suporte a acesso direto aos discos físicos por meio de caminhos que são nomes de dispositivo, como "\\\\. \PHYSICALDRIVE0".  
  
 O `path` parâmetro pode ser um nome de arquivo, incluindo um arquivo em um compartilhamento de convenção de nomenclatura Universal (UNC).  
  
 O construtor recebe acesso de leitura/gravação para o arquivo e ele é aberto, compartilhando o acesso de leitura (ou seja, as solicitações para abrir o arquivo para gravação por este ou outro processo falharão até que o `FileStream` o objeto foi fechado, mas as tentativas de leitura será bem-sucedida). O tamanho do buffer é definido como o tamanho padrão de 4096 bytes (4 KB).  
  
> [!NOTE]
>  `path` não é necessário ser um arquivo armazenado no disco; ele pode ser qualquer parte de um sistema que dá suporte ao acesso por meio de fluxos. Por exemplo, dependendo do sistema, essa classe pode acessar um dispositivo físico.  
  
 <xref:System.IO.Stream.CanSeek%2A> está `true` para todos os <xref:System.IO.FileStream> objetos que encapsulam os arquivos. Se `path` indica um dispositivo que não dá suporte à busca, o <xref:System.IO.FileStream.CanSeek%2A> propriedade em resultante <xref:System.IO.FileStream> é `false`. Para obter mais informações, consulte: <xref:System.IO.Stream.CanSeek%2A>.  
  
 `FileShare.Read` é o padrão para aqueles <xref:System.IO.FileStream> construtores sem um `FileShare` parâmetro.  
  
> [!CAUTION]
>  Quando você compila um conjunto de caracteres com uma configuração cultural específica e recupera os mesmos caracteres com uma configuração cultural diferente, os caracteres talvez não sejam interpretáveis e poderá causar uma exceção seja lançada.  
  
 Para obter uma lista de operações de diretório e arquivos comuns, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> é uma cadeia de caracteres vazia (“”), contém somente espaços em branco ou contém um ou mais caracteres inválidos.  
  
- ou - 
 <paramref name="path" /> refere-se a um dispositivo não de arquivo, como "con:", "com1:", "lpt1:", etc. em um ambiente NTFS.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" /> refere-se a um dispositivo não de arquivo, como "con:", "com1:", "lpt1:", etc. em um ambiente não NTFS.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Não é possível localizar o arquivo, por exemplo, quando <paramref name="mode" /> é <see langword="FileMode.Truncate" /> ou <see langword="FileMode.Open" /> e o arquivo especificado por <paramref name="path" /> não existe. O arquivo já deve existir em um desses modos.</exception>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S, como especificar <see langword="FileMode.CreateNew" /> quando o arquivo especificado por <paramref name="path" /> já existe.  
  
- ou - 
O fluxo foi fechado.</exception>
        <exception cref="T:System.Security.SecurityException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">O caminho especificado é inválido, por exemplo, ele está em uma unidade não mapeada.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O <paramref name="access" /> solicitado não é permitido pelo sistema operacional para o <paramref name="path" /> especificado, como quando <paramref name="access" /> é <see langword="Write" /> ou <see langword="ReadWrite" />, e o arquivo ou diretório está configurado para acesso somente leitura.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="mode" /> contém um valor inválido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para ler, gravar e anexando a arquivos. Enumerações associadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, e <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
        <related type="Article" href="~/docs/standard/io/index.md">E/S de arquivo e de fluxo</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Como ler texto de um arquivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Como gravar texto em um arquivo</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (Microsoft.Win32.SafeHandles.SafeFileHandle handle, System.IO.FileAccess access, int bufferSize, bool isAsync);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Microsoft.Win32.SafeHandles.SafeFileHandle handle, valuetype System.IO.FileAccess access, int32 bufferSize, bool isAsync) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As SafeFileHandle, access As FileAccess, bufferSize As Integer, isAsync As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(Microsoft::Win32::SafeHandles::SafeFileHandle ^ handle, System::IO::FileAccess access, int bufferSize, bool isAsync);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : Microsoft.Win32.SafeHandles.SafeFileHandle * System.IO.FileAccess * int * bool -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (handle, access, bufferSize, isAsync)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="Microsoft.Win32.SafeHandles.SafeFileHandle" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="isAsync" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="handle">Um identificador de arquivo para o arquivo que este objeto <see langword="FileStream" /> encapsulará.</param>
        <param name="access">Uma constante que define as propriedades <see cref="P:System.IO.FileStream.CanRead" /> e <see cref="P:System.IO.FileStream.CanWrite" /> do objeto <see langword="FileStream" />.</param>
        <param name="bufferSize">Um valor <see cref="T:System.Int32" /> positivo maior que 0, indicando o tamanho do buffer. O tamanho do buffer padrão é 4096.</param>
        <param name="isAsync"><see langword="true" /> se o identificador foi aberto assincronicamente (isto é, no modo E/S sobreposto), caso contrário, <see langword="false" />.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.IO.FileStream" /> para o identificador de arquivo, com a permissão de leitura/gravação, o tamanho do buffer e o estado síncrono ou assíncrono especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Defina as `isAsync` parâmetro para `true` para abrir o identificador de arquivo de forma assíncrona. Quando o parâmetro for `true`, utiliza o fluxo de e/s sobreposta para executar operações de arquivo de forma assíncrona. No entanto, o parâmetro não precisa ser `true` para chamar o <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, ou <xref:System.IO.Stream.CopyToAsync%2A> método. Quando o `isAsync` parâmetro é `false` e chamar a leitura assíncrona e operações de gravação, o thread de interface do usuário ainda não está bloqueado, mas a operação de e/s real é executada de forma síncrona.  
  
 `FileStream` pressupõe-se de que ele tenha controle exclusivo sobre a alça. Leitura, gravação ou de busca enquanto um `FileStream` também está mantendo um identificador pode resultar em corrupção de dados. Para segurança de dados, chame <xref:System.IO.FileStream.Flush%2A> antes de usando o identificador e evitar chamar métodos diferentes de `Close` depois de concluir usando o identificador. Como alternativa, ler e gravar o identificador antes de chamar isso `FileStream` construtor.  
  
 `FileShare.Read` é o padrão para aqueles <xref:System.IO.FileStream> construtores sem um `FileShare` parâmetro.  
  
> [!CAUTION]
>  Quando você compila um conjunto de caracteres com uma configuração cultural específica e recupera os mesmos caracteres com uma configuração cultural diferente, os caracteres talvez não sejam interpretáveis e poderá causar uma exceção seja lançada.  
  
 Para obter uma lista de operações de diretório e arquivos comuns, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O parâmetro <paramref name="handle" /> é um identificador inválido.  
  
- ou - 
O parâmetro <paramref name="handle" /> é um identificador síncrono e foi usado assincronamente.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">O parâmetro <paramref name="bufferSize" /> é negativo.</exception>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S, como um erro de disco.  
  
- ou - 
O fluxo foi fechado.</exception>
        <exception cref="T:System.Security.SecurityException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O <paramref name="access" /> solicitado não é permitido pelo sistema operacional para o identificador de arquivo especificado, como quando <paramref name="access" /> é <see langword="Write" /> ou <see langword="ReadWrite" /> e o identificador de arquivo está definido para o acesso somente leitura.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para ler, gravar e anexando a arquivos. Enumerações associadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, e <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">permissão chamar código não gerenciado. Enumerações associadas: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">E/S de arquivo e de fluxo</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Como ler texto de um arquivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Como gravar texto em um arquivo</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (IntPtr handle, System.IO.FileAccess access, bool ownsHandle, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(native int handle, valuetype System.IO.FileAccess access, bool ownsHandle, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As IntPtr, access As FileAccess, ownsHandle As Boolean, bufferSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(IntPtr handle, System::IO::FileAccess access, bool ownsHandle, int bufferSize);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : nativeint * System.IO.FileAccess * bool * int -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (handle, access, ownsHandle, bufferSize)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use FileStream(SafeFileHandle handle, FileAccess access, int bufferSize) instead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This constructor has been deprecated.  Please use new FileStream(SafeFileHandle handle, FileAccess access, int bufferSize) instead, and optionally make a new SafeFileHandle with ownsHandle=false if needed.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0">
          <AttributeName>System.Obsolete("This constructor has been deprecated.  Please use new FileStream(SafeFileHandle handle, FileAccess access, int bufferSize) instead, and optionally make a new SafeFileHandle with ownsHandle=false if needed.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="ownsHandle" Type="System.Boolean" />
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="handle">Um identificador de arquivo para o arquivo que este objeto <see langword="FileStream" /> encapsulará.</param>
        <param name="access">Uma constante que define as propriedades <see cref="P:System.IO.FileStream.CanRead" /> e <see cref="P:System.IO.FileStream.CanWrite" /> do objeto <see langword="FileStream" />.</param>
        <param name="ownsHandle"><see langword="true" /> se o identificador de arquivo será de propriedade dessa instância <see langword="FileStream" />; caso contrário, <see langword="false" />.</param>
        <param name="bufferSize">Um valor <see cref="T:System.Int32" /> positivo maior que 0, indicando o tamanho do buffer. O tamanho do buffer padrão é 4096.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.IO.FileStream" /> para o identificador de arquivo especificado, com a permissão de leitura/gravação, a propriedade da instância <see langword="FileStream" /> e o tamanho do buffer especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `FileStream` objeto receberá o acesso especificado para o arquivo. A propriedade do identificador poderá ser conforme especificado. Se este `FileStream` possui o identificador, uma chamada para o <xref:System.IO.Stream.Close%2A> método também fechará o identificador. Em particular, a contagem de identificadores do arquivo é decrementada. O `FileStream` objeto é dado o tamanho do buffer especificado.  
  
 `FileStream` pressupõe-se de que ele tenha controle exclusivo sobre a alça. Leitura, gravação ou de busca enquanto um `FileStream` também está mantendo um identificador pode resultar em corrupção de dados. Para segurança de dados, chame <xref:System.IO.FileStream.Flush%2A> antes de usando o identificador e evitar chamar métodos diferentes de `Close` depois de concluir usando o identificador. Como alternativa, ler e gravar o identificador antes de chamar isso `FileStream` construtor.  
  
 `FileShare.Read` é o padrão para aqueles <xref:System.IO.FileStream> construtores sem um `FileShare` parâmetro.  
  
> [!CAUTION]
>  Quando você compila um conjunto de caracteres com uma configuração cultural específica e recupera os mesmos caracteres com uma configuração cultural diferente, os caracteres talvez não sejam interpretáveis e poderá causar uma exceção seja lançada.  
  
 Para obter uma lista de operações de diretório e arquivos comuns, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="bufferSize" /> é negativo.</exception>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S, como um erro de disco.  
  
- ou - 
O fluxo foi fechado.</exception>
        <exception cref="T:System.Security.SecurityException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O <paramref name="access" /> solicitado não é permitido pelo sistema operacional para o identificador de arquivo especificado, como quando <paramref name="access" /> é <see langword="Write" /> ou <see langword="ReadWrite" /> e o identificador de arquivo está definido para o acesso somente leitura.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para ler, gravar e anexando a arquivos. Enumerações associadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, e <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
        <related type="Article" href="~/docs/standard/io/index.md">E/S de arquivo e de fluxo</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Como ler texto de um arquivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Como gravar texto em um arquivo</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess, share As FileShare)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : string * System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (path, mode, access, share)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
      </Parameters>
      <Docs>
        <param name="path">Um caminho relativo ou absoluto para o arquivo que o objeto <see langword="FileStream" /> atual encapsulará.</param>
        <param name="mode">Uma constante que determina como abrir ou criar o arquivo.</param>
        <param name="access">Uma constante que determina como o arquivo pode ser acessado pelo objeto <see langword="FileStream" />. Isso também determina os valores retornados pelas propriedades <see cref="P:System.IO.FileStream.CanRead" /> e <see cref="P:System.IO.FileStream.CanWrite" /> do objeto <see langword="FileStream" />. <see cref="P:System.IO.FileStream.CanSeek" /> será <see langword="true" /> se <paramref name="path" /> especificar um arquivo de disco.</param>
        <param name="share">Uma constante que determina como o arquivo será compartilhado pelos processos.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.IO.FileStream" /> com o caminho especificado, o modo de criação, permissão de leitura/gravação e permissões de compartilhamento.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O .NET Framework não dá suporte a acesso direto aos discos físicos por meio de caminhos que são nomes de dispositivo, como "\\\\. \PHYSICALDRIVE0".  
  
 O `path` parâmetro pode ser um nome de arquivo, incluindo um arquivo em um compartilhamento de convenção de nomenclatura Universal (UNC).  
  
 O construtor recebe acesso de leitura/gravação para o arquivo e ele é aberto, compartilhando o acesso de leitura (ou seja, as solicitações para abrir o arquivo para gravação por este ou outro processo falharão até que o `FileStream` o objeto foi fechado, mas as tentativas de leitura será bem-sucedida). O tamanho do buffer é definido como o tamanho padrão de 4096 bytes (4 KB).  
  
> [!NOTE]
>  `path` não é necessário ser um arquivo armazenado no disco; ele pode ser qualquer parte de um sistema que dá suporte ao acesso por meio de fluxos. Por exemplo, dependendo do sistema, essa classe pode acessar um dispositivo físico.  
  
 <xref:System.IO.Stream.CanSeek%2A> está `true` para todos os <xref:System.IO.FileStream> objetos que encapsulam os arquivos. Se `path` indica um dispositivo que não dá suporte à busca, o <xref:System.IO.FileStream.CanSeek%2A> propriedade em resultante <xref:System.IO.FileStream> é `false`. Para obter mais informações, consulte: <xref:System.IO.Stream.CanSeek%2A>.  
  
> [!CAUTION]
>  Quando você compila um conjunto de caracteres com uma configuração cultural específica e recupera os mesmos caracteres com uma configuração cultural diferente, os caracteres talvez não sejam interpretáveis e poderá causar uma exceção seja lançada.  
  
 Para obter uma lista de operações de diretório e arquivos comuns, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Este exemplo de código é parte de um exemplo maior fornecido para o <xref:System.IO.FileStream.Lock%2A> método.  
  
 [!code-cpp[System.IO.FileStream3#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream3/CPP/fstreamlock.cpp#2)]
 [!code-csharp[System.IO.FileStream3#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream3/CS/fstreamlock.cs#2)]
 [!code-vb[System.IO.FileStream3#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream3/VB/fstreamlock.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> é uma cadeia de caracteres vazia (“”), contém somente espaços em branco ou contém um ou mais caracteres inválidos.  
  
- ou - 
 <paramref name="path" /> refere-se a um dispositivo não de arquivo, como "con:", "com1:", "lpt1:", etc. em um ambiente NTFS.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" /> refere-se a um dispositivo não de arquivo, como "con:", "com1:", "lpt1:", etc. em um ambiente não NTFS.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Não é possível localizar o arquivo, por exemplo, quando <paramref name="mode" /> é <see langword="FileMode.Truncate" /> ou <see langword="FileMode.Open" /> e o arquivo especificado por <paramref name="path" /> não existe. O arquivo já deve existir em um desses modos.</exception>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S, como especificar <see langword="FileMode.CreateNew" /> quando o arquivo especificado por <paramref name="path" /> já existe.  
  
- ou - 
O sistema está executando o Windows 98 ou o Windows 98 Second Edition e <paramref name="share" /> está definido como <see langword="FileShare.Delete" />.  
  
- ou - 
O fluxo foi fechado.</exception>
        <exception cref="T:System.Security.SecurityException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">O caminho especificado é inválido, por exemplo, ele está em uma unidade não mapeada.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O <paramref name="access" /> solicitado não é permitido pelo sistema operacional para o <paramref name="path" /> especificado, como quando <paramref name="access" /> é <see langword="Write" /> ou <see langword="ReadWrite" />, e o arquivo ou diretório está configurado para acesso somente leitura.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="mode" /> contém um valor inválido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para ler, gravar e anexando a arquivos. Enumerações associadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, e <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
        <related type="Article" href="~/docs/standard/io/index.md">E/S de arquivo e de fluxo</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Como ler texto de um arquivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Como gravar texto em um arquivo</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (IntPtr handle, System.IO.FileAccess access, bool ownsHandle, int bufferSize, bool isAsync);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(native int handle, valuetype System.IO.FileAccess access, bool ownsHandle, int32 bufferSize, bool isAsync) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As IntPtr, access As FileAccess, ownsHandle As Boolean, bufferSize As Integer, isAsync As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(IntPtr handle, System::IO::FileAccess access, bool ownsHandle, int bufferSize, bool isAsync);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : nativeint * System.IO.FileAccess * bool * int * bool -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (handle, access, ownsHandle, bufferSize, isAsync)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use FileStream(SafeFileHandle handle, FileAccess access, int bufferSize, bool isAsync) instead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This constructor has been deprecated.  Please use new FileStream(SafeFileHandle handle, FileAccess access, int bufferSize, bool isAsync) instead, and optionally make a new SafeFileHandle with ownsHandle=false if needed.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0">
          <AttributeName>System.Obsolete("This constructor has been deprecated.  Please use new FileStream(SafeFileHandle handle, FileAccess access, int bufferSize, bool isAsync) instead, and optionally make a new SafeFileHandle with ownsHandle=false if needed.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="ownsHandle" Type="System.Boolean" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="isAsync" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="handle">Um identificador de arquivo para o arquivo que este objeto <see langword="FileStream" /> encapsulará.</param>
        <param name="access">Uma constante que define as propriedades <see cref="P:System.IO.FileStream.CanRead" /> e <see cref="P:System.IO.FileStream.CanWrite" /> do objeto <see langword="FileStream" />.</param>
        <param name="ownsHandle"><see langword="true" /> se o identificador de arquivo será de propriedade dessa instância <see langword="FileStream" />; caso contrário, <see langword="false" />.</param>
        <param name="bufferSize">Um valor <see cref="T:System.Int32" /> positivo maior que 0, indicando o tamanho do buffer. O tamanho do buffer padrão é 4096.</param>
        <param name="isAsync"><see langword="true" /> se o identificador foi aberto assincronicamente (isto é, no modo E/S sobreposto), caso contrário, <see langword="false" />.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.IO.FileStream" /> para o identificador de arquivo especificado, com a permissão de leitura/gravação, a propriedade da instância <see langword="FileStream" />, o tamanho do buffer e o estado síncrono ou assíncrono especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `FileStream` objeto receberá o acesso especificado para o arquivo. A propriedade do identificador poderá ser conforme especificado. Se este `FileStream` possui o identificador, uma chamada para o <xref:System.IO.Stream.Close%2A> método também fechará o identificador. Em particular, a contagem de identificadores do arquivo é decrementada. O `FileStream` objeto é dado o tamanho do buffer especificado.  
  
 `FileStream` pressupõe-se de que ele tenha controle exclusivo sobre a alça. Leitura, gravação ou de busca enquanto um `FileStream` também está mantendo um identificador pode resultar em corrupção de dados. Para segurança de dados, chame <xref:System.IO.FileStream.Flush%2A> antes de usando o identificador e evitar chamar métodos diferentes de `Close` depois de concluir usando o identificador. Como alternativa, ler e gravar o identificador antes de chamar isso `FileStream` construtor.  
  
 `FileShare.Read` é o padrão para aqueles <xref:System.IO.FileStream> construtores sem um `FileShare` parâmetro.  
  
> [!CAUTION]
>  Quando você compila um conjunto de caracteres com uma configuração cultural específica e recupera os mesmos caracteres com uma configuração cultural diferente, os caracteres talvez não sejam interpretáveis e poderá causar uma exceção seja lançada.  
  
 Para obter uma lista de operações de diretório e arquivos comuns, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="access" /> é menor que <see langword="FileAccess.Read" /> ou maior que <see langword="FileAccess.ReadWrite" /> ou <paramref name="bufferSize" /> é menor ou igual a 0.</exception>
        <exception cref="T:System.ArgumentException">O manipulador é inválido.</exception>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S, como um erro de disco.  
  
- ou - 
O fluxo foi fechado.</exception>
        <exception cref="T:System.Security.SecurityException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O <paramref name="access" /> solicitado não é permitido pelo sistema operacional para o identificador de arquivo especificado, como quando <paramref name="access" /> é <see langword="Write" /> ou <see langword="ReadWrite" /> e o identificador de arquivo está definido para o acesso somente leitura.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para acesso a código não gerenciado. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
        <related type="Article" href="~/docs/standard/io/index.md">E/S de arquivo e de fluxo</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Como ler texto de um arquivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Como gravar texto em um arquivo</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess, share As FileShare, bufferSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share, int bufferSize);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : string * System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare * int -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (path, mode, access, share, bufferSize)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="path">Um caminho relativo ou absoluto para o arquivo que o objeto <see langword="FileStream" /> atual encapsulará.</param>
        <param name="mode">Uma constante que determina como abrir ou criar o arquivo.</param>
        <param name="access">Uma constante que determina como o arquivo pode ser acessado pelo objeto <see langword="FileStream" />. Isso também determina os valores retornados pelas propriedades <see cref="P:System.IO.FileStream.CanRead" /> e <see cref="P:System.IO.FileStream.CanWrite" /> do objeto <see langword="FileStream" />. <see cref="P:System.IO.FileStream.CanSeek" /> será <see langword="true" /> se <paramref name="path" /> especificar um arquivo de disco.</param>
        <param name="share">Uma constante que determina como o arquivo será compartilhado pelos processos.</param>
        <param name="bufferSize">Um valor <see cref="T:System.Int32" /> positivo maior que 0, indicando o tamanho do buffer. O tamanho do buffer padrão é 4096.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.IO.FileStream" /> com o caminho, o modo de criação, as permissões de leitura/gravação e compartilhamento e o tamanho do buffer especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O .NET Framework não dá suporte a acesso direto aos discos físicos por meio de caminhos que são nomes de dispositivo, como "\\\\. \PHYSICALDRIVE0".  
  
 O `path` parâmetro pode ser um nome de arquivo, incluindo um arquivo em um compartilhamento de convenção de nomenclatura Universal (UNC).  
  
> [!NOTE]
>  `path` não é necessário ser um arquivo armazenado no disco; ele pode ser qualquer parte de um sistema que dá suporte ao acesso por meio de fluxos. Por exemplo, dependendo do sistema, essa classe pode acessar um dispositivo físico.  
  
 <xref:System.IO.Stream.CanSeek%2A> está `true` para todos os <xref:System.IO.FileStream> objetos que encapsulam os arquivos. Se `path` indica um dispositivo que não dá suporte à busca, o <xref:System.IO.FileStream.CanSeek%2A> propriedade em resultante <xref:System.IO.FileStream> é `false`. Para obter mais informações, consulte: <xref:System.IO.Stream.CanSeek%2A>.  
  
> [!CAUTION]
>  Quando você compila um conjunto de caracteres com uma configuração cultural específica e recupera os mesmos caracteres com uma configuração cultural diferente, os caracteres talvez não sejam interpretáveis e poderá causar uma exceção seja lançada.  
  
 Para obter uma lista de operações de diretório e arquivos comuns, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> é uma cadeia de caracteres vazia (“”), contém somente espaços em branco ou contém um ou mais caracteres inválidos.  
  
- ou - 
 <paramref name="path" /> refere-se a um dispositivo não de arquivo, como "con:", "com1:", "lpt1:", etc. em um ambiente NTFS.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" /> refere-se a um dispositivo não de arquivo, como "con:", "com1:", "lpt1:", etc. em um ambiente não NTFS.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="bufferSize" /> é negativo ou zero.  
  
- ou - 
 <paramref name="mode" />, <paramref name="access" /> ou <paramref name="share" /> contém um valor inválido.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Não é possível localizar o arquivo, por exemplo, quando <paramref name="mode" /> é <see langword="FileMode.Truncate" /> ou <see langword="FileMode.Open" /> e o arquivo especificado por <paramref name="path" /> não existe. O arquivo já deve existir em um desses modos.</exception>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S, como especificar <see langword="FileMode.CreateNew" /> quando o arquivo especificado por <paramref name="path" /> já existe.  
  
- ou - 
O sistema está executando o Windows 98 ou o Windows 98 Second Edition e <paramref name="share" /> está definido como <see langword="FileShare.Delete" />.  
  
- ou - 
O fluxo foi fechado.</exception>
        <exception cref="T:System.Security.SecurityException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">O caminho especificado é inválido, por exemplo, ele está em uma unidade não mapeada.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O <paramref name="access" /> solicitado não é permitido pelo sistema operacional para o <paramref name="path" /> especificado, como quando <paramref name="access" /> é <see langword="Write" /> ou <see langword="ReadWrite" />, e o arquivo ou diretório está configurado para acesso somente leitura.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para ler, gravar e anexando a arquivos. Enumerações associadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, e <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
        <related type="Article" href="~/docs/standard/io/index.md">E/S de arquivo e de fluxo</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Como ler texto de um arquivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Como gravar texto em um arquivo</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize, bool useAsync);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share, int32 bufferSize, bool useAsync) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess, share As FileShare, bufferSize As Integer, useAsync As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share, int bufferSize, bool useAsync);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : string * System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare * int * bool -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (path, mode, access, share, bufferSize, useAsync)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="useAsync" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">Um caminho relativo ou absoluto para o arquivo que o objeto <see langword="FileStream" /> atual encapsulará.</param>
        <param name="mode">Uma constante que determina como abrir ou criar o arquivo.</param>
        <param name="access">Uma constante que determina como o arquivo pode ser acessado pelo objeto <see langword="FileStream" />. Isso também determina os valores retornados pelas propriedades <see cref="P:System.IO.FileStream.CanRead" /> e <see cref="P:System.IO.FileStream.CanWrite" /> do objeto <see langword="FileStream" />. <see cref="P:System.IO.FileStream.CanSeek" /> será <see langword="true" /> se <paramref name="path" /> especificar um arquivo de disco.</param>
        <param name="share">Uma constante que determina como o arquivo será compartilhado pelos processos.</param>
        <param name="bufferSize">Um valor <see cref="T:System.Int32" /> positivo maior que 0, indicando o tamanho do buffer. O tamanho do buffer padrão é 4096.</param>
        <param name="useAsync">Especifica se é necessário usar E/S síncrona ou assíncrona. No entanto, observe que o sistema operacional subjacente pode não dar suporte a E/S assíncrona, então, ao especificar <see langword="true" />, o identificador poderá ser aberto sincronicamente, dependendo da plataforma. Quando aberto de forma assíncrona, os métodos <see cref="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> e <see cref="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> executam melhor em leituras ou gravações grandes, mas podem ser muito mais lentos em leituras ou gravações pequenas. Se o aplicativo foi projetado para tirar proveito de E/S assíncrona, defina o parâmetro <paramref name="useAsync" /> como <see langword="true" />. Usar E/S assíncrona corretamente pode acelerar os aplicativos em até um fator de 10, mas usá-la sem recriar o aplicativo para E/S assíncrona pode diminuir o desempenho em até um fator de 10.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.IO.FileStream" /> com o caminho especificado, o modo de criação, leitura/gravação e permissões de compartilhamento, tamanho do buffer e estado síncrono ou assíncrono.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O .NET Framework não dá suporte a acesso direto aos discos físicos por meio de caminhos que são nomes de dispositivo, como "\\\\. \PHYSICALDRIVE0".  
  
 O `path` parâmetro pode ser um nome de arquivo, incluindo um arquivo em um compartilhamento de convenção de nomenclatura Universal (UNC).  
  
> [!NOTE]
>  `path` não é necessário ser um arquivo armazenado no disco; ele pode ser qualquer parte de um sistema que dá suporte ao acesso por meio de fluxos. Por exemplo, dependendo do sistema, essa classe pode acessar um dispositivo físico.  
  
 <xref:System.IO.Stream.CanSeek%2A> está `true` para todos os <xref:System.IO.FileStream> objetos que encapsulam os arquivos. Se `path` indica um dispositivo que não dá suporte à busca, o <xref:System.IO.FileStream.CanSeek%2A> propriedade em resultante <xref:System.IO.FileStream> é `false`. Para obter mais informações, consulte: <xref:System.IO.Stream.CanSeek%2A>.  
  
> [!CAUTION]
>  Quando você compila um conjunto de caracteres com uma configuração cultural específica e recupera os mesmos caracteres com uma configuração cultural diferente, os caracteres talvez não sejam interpretáveis e poderá causar uma exceção seja lançada.  
  
 Para obter uma lista de operações de diretório e arquivos comuns, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como gravar dados em um arquivo de forma assíncrona e, em seguida, verifique se que os dados foram gravados corretamente. Um `State` objeto é criado para passar informações do thread principal para o `EndReadCallback` e `EndWriteCallback` métodos.  
  
 [!code-cpp[System.IO.FileStream2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream2/CPP/source.cpp#1)]
 [!code-csharp[System.IO.FileStream2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream2/CS/source.cs#1)]
 [!code-vb[System.IO.FileStream2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> é uma cadeia de caracteres vazia (“”), contém somente espaços em branco ou contém um ou mais caracteres inválidos.  
  
- ou - 
 <paramref name="path" /> refere-se a um dispositivo não de arquivo, como "con:", "com1:", "lpt1:", etc. em um ambiente NTFS.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" /> refere-se a um dispositivo não de arquivo, como "con:", "com1:", "lpt1:", etc. em um ambiente não NTFS.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="bufferSize" /> é negativo ou zero.  
  
- ou - 
 <paramref name="mode" />, <paramref name="access" /> ou <paramref name="share" /> contém um valor inválido.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Não é possível localizar o arquivo, por exemplo, quando <paramref name="mode" /> é <see langword="FileMode.Truncate" /> ou <see langword="FileMode.Open" /> e o arquivo especificado por <paramref name="path" /> não existe. O arquivo já deve existir em um desses modos.</exception>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S, como especificar <see langword="FileMode.CreateNew" /> quando o arquivo especificado por <paramref name="path" /> já existe.  
  
- ou - 
O sistema está executando o Windows 98 ou o Windows 98 Second Edition e <paramref name="share" /> está definido como <see langword="FileShare.Delete" />.  
  
- ou - 
O fluxo foi fechado.</exception>
        <exception cref="T:System.Security.SecurityException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">O caminho especificado é inválido, por exemplo, ele está em uma unidade não mapeada.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O <paramref name="access" /> solicitado não é permitido pelo sistema operacional para o <paramref name="path" /> especificado, como quando <paramref name="access" /> é <see langword="Write" /> ou <see langword="ReadWrite" />, e o arquivo ou diretório está configurado para acesso somente leitura.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para ler, gravar e anexando a arquivos. Enumerações associadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, e <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
        <altmember cref="T:System.IO.File" />
        <related type="Article" href="~/docs/standard/io/index.md">E/S de arquivo e de fluxo</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Como ler texto de um arquivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Como gravar texto em um arquivo</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize, System.IO.FileOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share, int32 bufferSize, valuetype System.IO.FileOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess, share As FileShare, bufferSize As Integer, options As FileOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share, int bufferSize, System::IO::FileOptions options);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : string * System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare * int * System.IO.FileOptions -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (path, mode, access, share, bufferSize, options)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="options" Type="System.IO.FileOptions" />
      </Parameters>
      <Docs>
        <param name="path">Um caminho relativo ou absoluto para o arquivo que o objeto <see langword="FileStream" /> atual encapsulará.</param>
        <param name="mode">Uma constante que determina como abrir ou criar o arquivo.</param>
        <param name="access">Uma constante que determina como o arquivo pode ser acessado pelo objeto <see langword="FileStream" />. Isso também determina os valores retornados pelas propriedades <see cref="P:System.IO.FileStream.CanRead" /> e <see cref="P:System.IO.FileStream.CanWrite" /> do objeto <see langword="FileStream" />. <see cref="P:System.IO.FileStream.CanSeek" /> será <see langword="true" /> se <paramref name="path" /> especificar um arquivo de disco.</param>
        <param name="share">Uma constante que determina como o arquivo será compartilhado pelos processos.</param>
        <param name="bufferSize">Um valor <see cref="T:System.Int32" /> positivo maior que 0, indicando o tamanho do buffer. O tamanho do buffer padrão é 4096.</param>
        <param name="options">Um valor que especifica as opções de arquivo adicionais.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.IO.FileStream" /> com o caminho, o modo de criação, a permissão de compartilhamento e leitura/gravação, o acesso que outros FileStreams podem ter ao mesmo arquivo, o tamanho do buffer e as opções de arquivo adicionais especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O .NET Framework não dá suporte a acesso direto aos discos físicos por meio de caminhos que são nomes de dispositivo, como "\\\\. \PHYSICALDRIVE0".  
  
 O `fileOptions` parâmetro é usado para fornecer acesso a operações mais avançadas que podem ser aproveitados ao criar um <xref:System.IO.FileStream> objeto.  
  
 O `path` parâmetro pode ser um nome de arquivo, incluindo um arquivo em um compartilhamento de convenção de nomenclatura Universal (UNC).  
  
> [!NOTE]
>  `path` não é necessário ser um arquivo armazenado no disco; ele pode ser qualquer parte de um sistema que dá suporte ao acesso por meio de fluxos. Por exemplo, dependendo do sistema, essa classe pode acessar um dispositivo físico.  
  
 <xref:System.IO.Stream.CanSeek%2A> está `true` para todos os <xref:System.IO.FileStream> objetos que encapsulam os arquivos. Se `path` indica um dispositivo que não dá suporte à busca, o <xref:System.IO.FileStream.CanSeek%2A> propriedade em resultante <xref:System.IO.FileStream> é `false`. Para obter mais informações, consulte: <xref:System.IO.Stream.CanSeek%2A>.  
  
> [!CAUTION]
>  Quando você compila um conjunto de caracteres com uma configuração cultural específica e recupera os mesmos caracteres com uma configuração cultural diferente, os caracteres talvez não sejam interpretáveis e poderá causar uma exceção seja lançada.  
  
 Para obter uma lista de operações de diretório e arquivos comuns, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 O exemplo a seguir grava dados em um arquivo e, em seguida, lê os dados usando o <xref:System.IO.FileStream> objeto.  
  
 [!code-cpp[IO.FileStream.ctor1#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.FileStream.ctor1/cpp/example.cpp#1)]
 [!code-csharp[IO.FileStream.ctor1#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.FileStream.ctor1/CS/example.cs#1)]
 [!code-vb[IO.FileStream.ctor1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.FileStream.ctor1/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> é uma cadeia de caracteres vazia (“”), contém somente espaços em branco ou contém um ou mais caracteres inválidos.  
  
- ou - 
 <paramref name="path" /> refere-se a um dispositivo não de arquivo, como "con:", "com1:", "lpt1:", etc. em um ambiente NTFS.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" /> refere-se a um dispositivo não de arquivo, como "con:", "com1:", "lpt1:", etc. em um ambiente não NTFS.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="bufferSize" /> é negativo ou zero.  
  
- ou - 
 <paramref name="mode" />, <paramref name="access" /> ou <paramref name="share" /> contém um valor inválido.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Não é possível localizar o arquivo, por exemplo, quando <paramref name="mode" /> é <see langword="FileMode.Truncate" /> ou <see langword="FileMode.Open" /> e o arquivo especificado por <paramref name="path" /> não existe. O arquivo já deve existir em um desses modos.</exception>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S, como especificar <see langword="FileMode.CreateNew" /> quando o arquivo especificado por <paramref name="path" /> já existe.  
  
- ou - 
O fluxo foi fechado.</exception>
        <exception cref="T:System.Security.SecurityException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">O caminho especificado é inválido, por exemplo, ele está em uma unidade não mapeada.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O <paramref name="access" /> solicitado não é permitido pelo sistema operacional para o <paramref name="path" /> especificado, como quando <paramref name="access" /> é <see langword="Write" /> ou <see langword="ReadWrite" />, e o arquivo ou diretório está configurado para acesso somente leitura.  
  
- ou - 
 <see cref="F:System.IO.FileOptions.Encrypted" /> é especificado para <paramref name="options" />, mas a criptografia de arquivo não tem suporte na plataforma atual.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para ler, gravar e anexando a arquivos. Enumerações associadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, e <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
        <related type="Article" href="~/docs/standard/io/index.md">E/S de arquivo e de fluxo</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Como ler texto de um arquivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Como gravar texto em um arquivo</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.Security.AccessControl.FileSystemRights rights, System.IO.FileShare share, int bufferSize, System.IO.FileOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.Security.AccessControl.FileSystemRights rights, valuetype System.IO.FileShare share, int32 bufferSize, valuetype System.IO.FileOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, rights As FileSystemRights, share As FileShare, bufferSize As Integer, options As FileOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(System::String ^ path, System::IO::FileMode mode, System::Security::AccessControl::FileSystemRights rights, System::IO::FileShare share, int bufferSize, System::IO::FileOptions options);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : string * System.IO.FileMode * System.Security.AccessControl.FileSystemRights * System.IO.FileShare * int * System.IO.FileOptions -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (path, mode, rights, share, bufferSize, options)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="rights" Type="System.Security.AccessControl.FileSystemRights" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="options" Type="System.IO.FileOptions" />
      </Parameters>
      <Docs>
        <param name="path">Um caminho relativo ou absoluto para o arquivo que o objeto <see cref="T:System.IO.FileStream" /> atual encapsulará.</param>
        <param name="mode">Uma constante que determina como abrir ou criar o arquivo.</param>
        <param name="rights">Uma constante que determina os direitos de acesso a serem usados ao criar regras de acesso e auditoria para o arquivo.</param>
        <param name="share">Uma constante que determina como o arquivo será compartilhado pelos processos.</param>
        <param name="bufferSize">Um valor <see cref="T:System.Int32" /> positivo maior que 0, indicando o tamanho do buffer. O tamanho do buffer padrão é 4096.</param>
        <param name="options">Uma constante que especifica opções de arquivo adicionais.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.IO.FileStream" /> com o caminho, o modo de criação, os direitos de acesso e a permissão de compartilhamento, o tamanho do buffer e as opções de arquivo adicionais especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O .NET Framework não dá suporte a acesso direto aos discos físicos por meio de caminhos que são nomes de dispositivo, como "\\\\. \PHYSICALDRIVE0".  
  
 Use esta <xref:System.IO.FileStream.%23ctor%2A> construtor para aplicar o acesso de direitos no ponto de criação de um arquivo. Para acessar ou modificar os direitos em um arquivo existente, considere usar o <xref:System.IO.File.GetAccessControl%2A> e <xref:System.IO.File.SetAccessControl%2A> métodos.  
  
 O `fileOptions` parâmetro é usado para fornecer acesso a operações mais avançadas que podem ser aproveitados ao criar um <xref:System.IO.FileStream> objeto.  
  
 O `path` parâmetro pode ser um nome de arquivo, incluindo um arquivo em um compartilhamento de convenção de nomenclatura Universal (UNC).  
  
> [!NOTE]
>  `path` não é necessário ser um arquivo armazenado no disco; ele pode ser qualquer parte de um sistema que dá suporte ao acesso por meio de fluxos. Por exemplo, dependendo do sistema, essa classe pode acessar um dispositivo físico.  
  
 <xref:System.IO.Stream.CanSeek%2A> está `true` para todos os <xref:System.IO.FileStream> objetos que encapsulam os arquivos. Se `path` indica um dispositivo que não dá suporte à busca, o <xref:System.IO.FileStream.CanSeek%2A> propriedade em resultante <xref:System.IO.FileStream> é `false`. Para obter mais informações, consulte: <xref:System.IO.Stream.CanSeek%2A>.  
  
> [!CAUTION]
>  Quando você compila um conjunto de caracteres com uma configuração cultural específica e recupera os mesmos caracteres com uma configuração cultural diferente, os caracteres talvez não sejam interpretáveis e poderá causar uma exceção seja lançada.  
  
 Para obter uma lista de operações de diretório e arquivos comuns, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> é uma cadeia de caracteres vazia (“”), contém somente espaços em branco ou contém um ou mais caracteres inválidos.  
  
- ou - 
 <paramref name="path" /> refere-se a um dispositivo não de arquivo, como "con:", "com1:", "lpt1:", etc. em um ambiente NTFS.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" /> refere-se a um dispositivo não de arquivo, como "con:", "com1:", "lpt1:", etc. em um ambiente não NTFS.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="bufferSize" /> é negativo ou zero.  
  
- ou - 
 <paramref name="mode" />, <paramref name="access" /> ou <paramref name="share" /> contém um valor inválido.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Não é possível localizar o arquivo, por exemplo, quando <paramref name="mode" /> é <see langword="FileMode.Truncate" /> ou <see langword="FileMode.Open" /> e o arquivo especificado por <paramref name="path" /> não existe. O arquivo já deve existir em um desses modos.</exception>
        <exception cref="T:System.PlatformNotSupportedException">O sistema operacional atual não é o Windows NT ou posterior.</exception>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S, como especificar <see langword="FileMode.CreateNew" /> quando o arquivo especificado por <paramref name="path" /> já existe.  
  
- ou - 
O fluxo foi fechado.</exception>
        <exception cref="T:System.Security.SecurityException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">O caminho especificado é inválido, por exemplo, ele está em uma unidade não mapeada.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O <paramref name="access" /> solicitado não é permitido pelo sistema operacional para o <paramref name="path" /> especificado, como quando <paramref name="access" /> é <see langword="Write" /> ou <see langword="ReadWrite" />, e o arquivo ou diretório está configurado para acesso somente leitura.  
  
- ou - 
 <see cref="F:System.IO.FileOptions.Encrypted" /> é especificado para <paramref name="options" />, mas a criptografia de arquivo não tem suporte na plataforma atual.</exception>
        <exception cref="T:System.IO.PathTooLongException">O <paramref name="path" /> especificado, o nome de arquivo ou ambos ultrapassam o tamanho máximo definido pelo sistema.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para ler, gravar e anexando a arquivos. Enumerações associadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, e <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
        <related type="Article" href="~/docs/standard/io/index.md">E/S de arquivo e de fluxo</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Como ler texto de um arquivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Como gravar texto em um arquivo</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.Security.AccessControl.FileSystemRights rights, System.IO.FileShare share, int bufferSize, System.IO.FileOptions options, System.Security.AccessControl.FileSecurity fileSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.Security.AccessControl.FileSystemRights rights, valuetype System.IO.FileShare share, int32 bufferSize, valuetype System.IO.FileOptions options, class System.Security.AccessControl.FileSecurity fileSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(System::String ^ path, System::IO::FileMode mode, System::Security::AccessControl::FileSystemRights rights, System::IO::FileShare share, int bufferSize, System::IO::FileOptions options, System::Security::AccessControl::FileSecurity ^ fileSecurity);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : string * System.IO.FileMode * System.Security.AccessControl.FileSystemRights * System.IO.FileShare * int * System.IO.FileOptions * System.Security.AccessControl.FileSecurity -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (path, mode, rights, share, bufferSize, options, fileSecurity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="rights" Type="System.Security.AccessControl.FileSystemRights" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="options" Type="System.IO.FileOptions" />
        <Parameter Name="fileSecurity" Type="System.Security.AccessControl.FileSecurity" />
      </Parameters>
      <Docs>
        <param name="path">Um caminho relativo ou absoluto para o arquivo que o objeto <see cref="T:System.IO.FileStream" /> atual encapsulará.</param>
        <param name="mode">Uma constante que determina como abrir ou criar o arquivo.</param>
        <param name="rights">Uma constante que determina os direitos de acesso a serem usados ao criar regras de acesso e auditoria para o arquivo.</param>
        <param name="share">Uma constante que determina como o arquivo será compartilhado pelos processos.</param>
        <param name="bufferSize">Um valor <see cref="T:System.Int32" /> positivo maior que 0, indicando o tamanho do buffer. O tamanho do buffer padrão é 4096.</param>
        <param name="options">Uma constante que especifica opções de arquivo adicionais.</param>
        <param name="fileSecurity">Uma constante que determina o controle de acesso e a segurança de auditoria para o arquivo.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.IO.FileStream" /> com o caminho, o modo de criação, os direitos de acesso e a permissão de compartilhamento, o tamanho do buffer, as opções de arquivo adicionais, o controle de acesso e a segurança de auditoria especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O .NET Framework não dá suporte a acesso direto aos discos físicos por meio de caminhos que são nomes de dispositivo, como "\\\\. \PHYSICALDRIVE0".  
  
 Use esta <xref:System.IO.FileStream.%23ctor%2A> construtor para aplicar o acesso de direitos no ponto de criação de um arquivo. Para acessar ou modificar os direitos em um arquivo existente, considere usar o <xref:System.IO.File.GetAccessControl%2A> e <xref:System.IO.File.SetAccessControl%2A> métodos.  
  
 O `fileOptions` parâmetro é usado para fornecer acesso a operações mais avançadas que podem ser aproveitados ao criar um <xref:System.IO.FileStream> objeto.  
  
 O `path` parâmetro pode ser um nome de arquivo, incluindo um arquivo em um compartilhamento de convenção de nomenclatura Universal (UNC).  
  
> [!NOTE]
>  `path` não é necessário ser um arquivo armazenado no disco; ele pode ser qualquer parte de um sistema que dá suporte ao acesso por meio de fluxos. Por exemplo, dependendo do sistema, essa classe pode acessar um dispositivo físico.  
  
 <xref:System.IO.Stream.CanSeek%2A> está `true` para todos os <xref:System.IO.FileStream> objetos que encapsulam os arquivos. Se `path` indica um dispositivo que não dá suporte à busca, o <xref:System.IO.FileStream.CanSeek%2A> propriedade em resultante <xref:System.IO.FileStream> é `false`. Para obter mais informações, consulte: <xref:System.IO.Stream.CanSeek%2A>.  
  
> [!CAUTION]
>  Quando você compila um conjunto de caracteres com uma configuração cultural específica e recupera os mesmos caracteres com uma configuração cultural diferente, os caracteres talvez não sejam interpretáveis e poderá causar uma exceção seja lançada.  
  
 Para obter uma lista de operações de diretório e arquivos comuns, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 O exemplo a seguir grava dados em um arquivo e, em seguida, lê os dados usando o <xref:System.IO.FileStream> objeto.  
  
 [!code-cpp[IO.FileStream.ctor2#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.FileStream.ctor2/cpp/example.cpp#1)]
 [!code-csharp[IO.FileStream.ctor2#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.FileStream.ctor2/CS/example.cs#1)]
 [!code-vb[IO.FileStream.ctor2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.FileStream.ctor2/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> é uma cadeia de caracteres vazia (“”), contém somente espaços em branco ou contém um ou mais caracteres inválidos.  
  
- ou - 
 <paramref name="path" /> refere-se a um dispositivo não de arquivo, como "con:", "com1:", "lpt1:", etc. em um ambiente NTFS.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" /> refere-se a um dispositivo não de arquivo, como "con:", "com1:", "lpt1:", etc. em um ambiente não NTFS.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="bufferSize" /> é negativo ou zero.  
  
- ou - 
 <paramref name="mode" />, <paramref name="access" /> ou <paramref name="share" /> contém um valor inválido.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Não é possível localizar o arquivo, por exemplo, quando <paramref name="mode" /> é <see langword="FileMode.Truncate" /> ou <see langword="FileMode.Open" /> e o arquivo especificado por <paramref name="path" /> não existe. O arquivo já deve existir em um desses modos.</exception>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S, como especificar <see langword="FileMode.CreateNew" /> quando o arquivo especificado por <paramref name="path" /> já existe.  
  
- ou - 
O fluxo foi fechado.</exception>
        <exception cref="T:System.Security.SecurityException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">O caminho especificado é inválido, por exemplo, ele está em uma unidade não mapeada.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O <paramref name="access" /> solicitado não é permitido pelo sistema operacional para o <paramref name="path" /> especificado, como quando <paramref name="access" /> é <see langword="Write" /> ou <see langword="ReadWrite" />, e o arquivo ou diretório está configurado para acesso somente leitura.  
  
- ou - 
 <see cref="F:System.IO.FileOptions.Encrypted" /> é especificado para <paramref name="options" />, mas a criptografia de arquivo não tem suporte na plataforma atual.</exception>
        <exception cref="T:System.IO.PathTooLongException">O <paramref name="path" /> especificado, o nome de arquivo ou ambos ultrapassam o tamanho máximo definido pelo sistema.</exception>
        <exception cref="T:System.PlatformNotSupportedException">O sistema operacional atual não é o Windows NT ou posterior.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para ler, gravar e anexando a arquivos. Enumerações associadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, e <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
        <related type="Article" href="~/docs/standard/io/index.md">E/S de arquivo e de fluxo</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Como ler texto de um arquivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Como gravar texto em um arquivo</related>
      </Docs>
    </Member>
    <Member MemberName="BeginRead">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginRead (byte[] array, int offset, int numBytes, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginRead(unsigned int8[] array, int32 offset, int32 numBytes, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginRead (array As Byte(), offset As Integer, numBytes As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginRead(cli::array &lt;System::Byte&gt; ^ array, int offset, int numBytes, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="F#" Value="override this.BeginRead : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="fileStream.BeginRead (array, offset, numBytes, callback, state)" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginRead (byte[] array, int offset, int numBytes, AsyncCallback userCallback, object stateObject);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginRead(unsigned int8[] array, int32 offset, int32 numBytes, class System.AsyncCallback userCallback, object stateObject) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginRead (array As Byte(), offset As Integer, numBytes As Integer, userCallback As AsyncCallback, stateObject As Object) As IAsyncResult" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginRead(cli::array &lt;System::Byte&gt; ^ array, int offset, int numBytes, AsyncCallback ^ userCallback, System::Object ^ stateObject);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="override this.BeginRead : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="fileStream.BeginRead (array, offset, numBytes, userCallback, stateObject)" FrameworkAlternate="netcore-2.0;netcore-3.0;netframework-1.1" />
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginRead (byte[] buffer, int offset, int count, AsyncCallback callback, object state);" FrameworkAlternate="netcore-2.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginRead(unsigned int8[] buffer, int32 offset, int32 count, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginRead (buffer As Byte(), offset As Integer, count As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-2.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginRead(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-2.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-2.0;netcore-3.0" />
        <Parameter Name="numBytes" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-2.0;netcore-3.0" />
        <Parameter Name="userCallback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="4" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-2.0;netcore-3.0" />
        <Parameter Name="stateObject" Type="System.Object" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="array">O buffer no qual os dados serão lidos.</param>
        <param name="buffer">To be added.</param>
        <param name="offset">O deslocamento de bytes em <paramref name="array" /> no qual será iniciada a leitura.</param>
        <param name="numBytes">O número máximo de bytes a serem lidos.</param>
        <param name="count">To be added.</param>
        <param name="callback">O método a ser chamado quando a operação de leitura assíncrona for concluída.</param>
        <param name="userCallback">O método a ser chamado quando a operação de leitura assíncrona for concluída.</param>
        <param name="state">Um objeto fornecido pelo usuário que distingue essa solicitação de leitura assíncrona específica de outras solicitações.</param>
        <param name="stateObject">Um objeto fornecido pelo usuário que distingue essa solicitação de leitura assíncrona específica de outras solicitações.</param>
        <summary>Inicia uma operação de leitura assíncrona. Considere o uso de <see cref="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" /> em seu lugar.</summary>
        <returns>Um objeto que faz referência à leitura assíncrona.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">O tamanho da matriz menos <paramref name="offset" /> é menor que <paramref name="numBytes" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> ou <paramref name="numBytes" /> é negativo.</exception>
        <exception cref="T:System.IO.IOException">Ocorreu uma tentativa de leitura assíncrona após o final do arquivo.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginWrite">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginWrite (byte[] array, int offset, int numBytes, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginWrite(unsigned int8[] array, int32 offset, int32 numBytes, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginWrite (array As Byte(), offset As Integer, numBytes As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginWrite(cli::array &lt;System::Byte&gt; ^ array, int offset, int numBytes, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="F#" Value="override this.BeginWrite : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="fileStream.BeginWrite (array, offset, numBytes, callback, state)" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginWrite (byte[] array, int offset, int numBytes, AsyncCallback userCallback, object stateObject);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginWrite(unsigned int8[] array, int32 offset, int32 numBytes, class System.AsyncCallback userCallback, object stateObject) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginWrite (array As Byte(), offset As Integer, numBytes As Integer, userCallback As AsyncCallback, stateObject As Object) As IAsyncResult" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginWrite(cli::array &lt;System::Byte&gt; ^ array, int offset, int numBytes, AsyncCallback ^ userCallback, System::Object ^ stateObject);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="override this.BeginWrite : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="fileStream.BeginWrite (array, offset, numBytes, userCallback, stateObject)" FrameworkAlternate="netcore-2.0;netcore-3.0;netframework-1.1" />
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginWrite (byte[] buffer, int offset, int count, AsyncCallback callback, object state);" FrameworkAlternate="netcore-2.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginWrite(unsigned int8[] buffer, int32 offset, int32 count, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginWrite (buffer As Byte(), offset As Integer, count As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-2.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginWrite(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-2.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-2.0;netcore-3.0" />
        <Parameter Name="numBytes" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-2.0;netcore-3.0" />
        <Parameter Name="userCallback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="4" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-2.0;netcore-3.0" />
        <Parameter Name="stateObject" Type="System.Object" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="array">O buffer que contém dados a serem gravados no fluxo atual.</param>
        <param name="buffer">To be added.</param>
        <param name="offset">O deslocamento de bytes baseado em zero em <paramref name="array" /> no qual será iniciada a cópia de bytes no fluxo atual.</param>
        <param name="numBytes">O número máximo de bytes a serem gravados.</param>
        <param name="count">To be added.</param>
        <param name="callback">O método a ser chamado quando a operação de gravação assíncrona for concluída.</param>
        <param name="userCallback">O método a ser chamado quando a operação de gravação assíncrona for concluída.</param>
        <param name="state">Um objeto fornecido pelo usuário que distingue essa solicitação de gravação assíncrona específica de outras solicitações.</param>
        <param name="stateObject">Um objeto fornecido pelo usuário que distingue essa solicitação de gravação assíncrona específica de outras solicitações.</param>
        <summary>Inicia uma operação de gravação assíncrona. Considere o uso de <see cref="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" /> em seu lugar.</summary>
        <returns>Um objeto que faz referência à gravação assíncrona.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">O tamanho de <paramref name="array" /> menos <paramref name="offset" /> é menor que <paramref name="numBytes" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> ou <paramref name="numBytes" /> é negativo.</exception>
        <exception cref="T:System.NotSupportedException">Não há suporte para gravação no fluxo.</exception>
        <exception cref="T:System.ObjectDisposedException">O fluxo está fechado.</exception>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S.</exception>
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public override bool CanRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRead" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.CanRead" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanRead As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanRead { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanRead : bool" Usage="System.IO.FileStream.CanRead" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o fluxo atual dá suporte a leitura.</summary>
        <value><see langword="true" /> se o fluxo dá suporte à leitura; <see langword="false" /> se o fluxo está fechado ou foi aberto com acesso somente gravação.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se uma classe derivada de <xref:System.IO.Stream> não dá suporte à leitura, chamadas para o <xref:System.IO.FileStream.Read%2A>, <xref:System.IO.FileStream.ReadByte%2A>, e <xref:System.IO.FileStream.BeginRead%2A> métodos geram uma <xref:System.NotSupportedException>.  
  
 Se o fluxo está fechado, essa propriedade retornará `false`.  
  
   
  
## Examples  
 O exemplo a seguir demonstra um uso do `CanRead` propriedade. A saída desse código é "Myfile. txt não é gravável." Para obter a mensagem de saída "Myfile. txt pode ser gravados e lidos do.", altere a `FileAccess` parâmetro para `ReadWrite` no `FileStream` construtor.  
  
 [!code-cpp[Classic FileStream.CanRead Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic FileStream.CanRead Example/CPP/source.cpp#1)]
 [!code-csharp[Classic FileStream.CanRead Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic FileStream.CanRead Example/CS/source.cs#1)]
 [!code-vb[Classic FileStream.CanRead Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic FileStream.CanRead Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md">E/S de arquivo e de fluxo</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Como ler texto de um arquivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Como gravar texto em um arquivo</related>
      </Docs>
    </Member>
    <Member MemberName="CanSeek">
      <MemberSignature Language="C#" Value="public override bool CanSeek { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanSeek" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.CanSeek" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanSeek As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanSeek { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanSeek : bool" Usage="System.IO.FileStream.CanSeek" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o fluxo atual dá suporte a busca.</summary>
        <value><see langword="true" /> se o fluxo der suporte à busca; <see langword="false" /> se o fluxo estiver fechado ou se o <see langword="FileStream" /> tiver sido construído de um identificador de sistema operacional, como um pipe ou uma saída para o console.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se uma classe derivada de <xref:System.IO.Stream> não dá suporte à busca, as chamadas a <xref:System.IO.FileStream.Length%2A>, <xref:System.IO.FileStream.SetLength%2A>, <xref:System.IO.FileStream.Position%2A>, e <xref:System.IO.FileStream.Seek%2A> lançar um <xref:System.NotSupportedException>.  
  
 Se o fluxo está fechado, essa propriedade retornará `false`.  
  
   
  
## Examples  
 O exemplo a seguir usa o `CanSeek` propriedade para verificar se um fluxo oferece suporte à busca.  
  
 [!code-cpp[fstream canseek#1](~/samples/snippets/cpp/VS_Snippets_CLR/FStream CanSeek/CPP/fstream canseek.cpp#1)]
 [!code-csharp[fstream canseek#1](~/samples/snippets/csharp/VS_Snippets_CLR/FStream CanSeek/CS/fstream canseek.cs#1)]
 [!code-vb[fstream canseek#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FStream CanSeek/VB/fstream canseek.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md">E/S de arquivo e de fluxo</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Como ler texto de um arquivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Como gravar texto em um arquivo</related>
      </Docs>
    </Member>
    <Member MemberName="CanWrite">
      <MemberSignature Language="C#" Value="public override bool CanWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWrite" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.CanWrite" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanWrite As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanWrite { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanWrite : bool" Usage="System.IO.FileStream.CanWrite" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o fluxo atual dá suporte a gravação.</summary>
        <value><see langword="true" /> se o fluxo der suporte à gravação; <see langword="false" /> se o fluxo estiver fechado ou tiver sido aberto com acesso somente leitura.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se uma classe derivada de <xref:System.IO.Stream> não oferece suporte à gravação, uma chamada para <xref:System.IO.FileStream.SetLength%2A>, <xref:System.IO.FileStream.Write%2A>, <xref:System.IO.FileStream.BeginWrite%2A>, ou <xref:System.IO.FileStream.WriteByte%2A> lança um <xref:System.NotSupportedException>.  
  
 Se o fluxo está fechado, essa propriedade retornará `false`.  
  
   
  
## Examples  
 O exemplo a seguir usa o `CanWrite` propriedade para verificar se um fluxo dá suporte à gravação.  
  
 [!code-cpp[fstream canwrite#1](~/samples/snippets/cpp/VS_Snippets_CLR/FStream CanWrite/CPP/fstream canwrite.cpp#1)]
 [!code-csharp[fstream canwrite#1](~/samples/snippets/csharp/VS_Snippets_CLR/FStream CanWrite/CS/fstream canwrite.cs#1)]
 [!code-vb[fstream canwrite#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FStream CanWrite/VB/fstream canwrite.vb#1)]  
  
 A seguir está um exemplo usando o `CanWrite` propriedade. A saída desse código é "Myfile. txt é gravável." Para obter a mensagem de saída "Myfile. txt pode ser gravados e lidos do.", altere a `FileAccess` parâmetro para `ReadWrite` no `FileStream` construtor.  
  
 [!code-cpp[Classic FileStream.CanWrite Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic FileStream.CanWrite Example/CPP/source.cpp#1)]
 [!code-csharp[Classic FileStream.CanWrite Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic FileStream.CanWrite Example/CS/source.cs#1)]
 [!code-vb[Classic FileStream.CanWrite Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic FileStream.CanWrite Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md">E/S de arquivo e de fluxo</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Como ler texto de um arquivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Como gravar texto em um arquivo</related>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public override void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Close();" />
      <MemberSignature Language="F#" Value="override this.Close : unit -&gt; unit" Usage="fileStream.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Este membro substitui <see cref="M:System.IO.Stream.Close" />, e pode haver uma documentação mais completa disponível nesse tópico.

Fecha o fluxo atual e libera todos os recursos (como soquetes e identificadores de arquivos) associados ao fluxo atual.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="fileStream.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><see langword="true" /> para liberar recursos gerenciados e não gerenciados; <see langword="false" /> para liberar apenas recursos não gerenciados.</param>
        <summary>Libera os recursos não gerenciados usados pelo <see cref="T:System.IO.FileStream" /> e opcionalmente libera os recursos gerenciados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método é chamado pelo método público <xref:System.ComponentModel.Component.Dispose%2A> e pelo método <xref:System.Object.Finalize%2A>. <xref:System.ComponentModel.Component.Dispose%2A> invoca o método <xref:System.IO.FileStream.Dispose%2A> protegido com o parâmetro `disposing` definido como `true`. <xref:System.Object.Finalize%2A> invoca <xref:System.IO.FileStream.Dispose%2A> com `disposing` definido como `false`.  
  
 Quando o `disposing` parâmetro é `true`, esse método libera todos os recursos mantidos por qualquer objeto gerenciado que este <xref:System.IO.FileStream> referências. Este método invoca o método <xref:System.ComponentModel.Component.Dispose%2A> de cada objeto referenciado.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>
            <see cref="M:System.ComponentModel.Component.Dispose" /> pode ser chamado várias vezes por outros objetos. Ao substituir <see cref="M:System.IO.FileStream.Dispose(System.Boolean)" /> tenha cuidado para não referenciar objetos que tenham sido descartados anteriormente em uma chamada anterior para <see cref="M:System.ComponentModel.Component.Dispose" />. Para obter mais informações sobre como implementar <see cref="M:System.IO.FileStream.Dispose(System.Boolean)" />, consulte [implementando um método Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
Para obter mais informações sobre <see cref="M:System.ComponentModel.Component.Dispose" /> e <see cref="M:System.Object.Finalize" />, consulte [limpeza de recursos não gerenciados](~/docs/standard/garbage-collection/unmanaged.md).</para></block>
        <related type="Article" href="~/docs/standard/io/index.md">E/S de arquivo e de fluxo</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Como ler texto de um arquivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Como gravar texto em um arquivo</related>
      </Docs>
    </Member>
    <Member MemberName="DisposeAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.ValueTask DisposeAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Threading.Tasks.ValueTask DisposeAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.DisposeAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function DisposeAsync () As ValueTask" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::ValueTask DisposeAsync();" />
      <MemberSignature Language="F#" Value="override this.DisposeAsync : unit -&gt; System.Threading.Tasks.ValueTask" Usage="fileStream.DisposeAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ValueTask</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndRead">
      <MemberSignature Language="C#" Value="public override int EndRead (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 EndRead(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.EndRead(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function EndRead (asyncResult As IAsyncResult) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int EndRead(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="override this.EndRead : IAsyncResult -&gt; int" Usage="fileStream.EndRead asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">A referência à solicitação assíncrona pendente que deverá ser aguardada.</param>
        <summary>Aguarda a operação de leitura assíncrona pendente ser concluída. (Considere o uso de <see cref="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" /> em seu lugar.)</summary>
        <returns>O número de bytes lidos do fluxo, entre 0 e o número de bytes solicitado. Os fluxos retornam somente 0 no final do fluxo, caso contrário, eles devem ser bloqueados até que pelo menos 1 byte esteja disponível.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 No .NET Framework 4 e versões anteriores, você precisa usar métodos como <xref:System.IO.FileStream.BeginRead%2A> e <xref:System.IO.FileStream.EndRead%2A> para implementar operações de arquivo assíncrono. Esses métodos ainda estão disponíveis na [!INCLUDE[net_v45](~/includes/net-v45-md.md)] para dar suporte ao código herdado; no entanto, os novos métodos assíncronos, como <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>, e <xref:System.IO.FileStream.FlushAsync%2A>, ajudam a implementar operações de arquivo assíncronas com mais facilidade.  
  
 <xref:System.IO.FileStream.EndRead%2A> deve ser chamado exatamente para que todas as chamadas para <xref:System.IO.FileStream.BeginRead%2A>. Falha ao encerrar um processo de leitura antes de iniciar outra leitura pode causar um comportamento indesejável, como o deadlock.  
  
 Este método substitui <xref:System.IO.Stream.EndRead%2A>.  
  
 <xref:System.IO.FileStream.EndRead%2A> pode ser chamado em cada <xref:System.IAsyncResult> de <xref:System.IO.FileStream.BeginRead%2A>. Chamar <xref:System.IO.FileStream.EndRead%2A> informa quantos bytes foram lidos do fluxo. <xref:System.IO.FileStream.EndRead%2A> será bloqueada até que a operação de e/s seja concluída.  
  
   
  
## Examples  
 Este exemplo de código é parte de um exemplo maior fornecido para o <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> construtor.  
  
 [!code-cpp[System.IO.FileStream2#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream2/CPP/source.cpp#4)]
 [!code-csharp[System.IO.FileStream2#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream2/CS/source.cs#4)]
 [!code-vb[System.IO.FileStream2#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream2/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Este objeto <see cref="T:System.IAsyncResult" /> não foi criado chamando <see cref="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> nesta classe.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.IO.FileStream.EndRead(System.IAsyncResult)" /> é chamado várias vezes.</exception>
        <exception cref="T:System.IO.IOException">O fluxo está fechado ou ocorreu um erro interno.</exception>
        <related type="Article" href="~/docs/standard/io/index.md">E/S de arquivo e de fluxo</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Como ler texto de um arquivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Como gravar texto em um arquivo</related>
        <related type="Article" href="~/docs/standard/io/asynchronous-file-i-o.md">E/S de arquivo assíncrona</related>
      </Docs>
    </Member>
    <Member MemberName="EndWrite">
      <MemberSignature Language="C#" Value="public override void EndWrite (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void EndWrite(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.EndWrite(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub EndWrite (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void EndWrite(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="override this.EndWrite : IAsyncResult -&gt; unit" Usage="fileStream.EndWrite asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">A solicitação de E/S assíncrona pendente.</param>
        <summary>Termina uma operação de gravação assíncrona e bloqueia até que a operação de E/S seja concluída. (Considere o uso de <see cref="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" /> em seu lugar.)</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 No .NET Framework 4 e versões anteriores, você precisa usar métodos como <xref:System.IO.FileStream.BeginWrite%2A> e <xref:System.IO.FileStream.EndWrite%2A> para implementar operações de arquivo assíncrono. Esses métodos ainda estão disponíveis na [!INCLUDE[net_v45](~/includes/net-v45-md.md)] para dar suporte ao código herdado; no entanto, os novos métodos assíncronos, como <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>, e <xref:System.IO.FileStream.FlushAsync%2A>, ajudam a implementar operações de arquivo assíncronas com mais facilidade.  
  
 Este método substitui <xref:System.IO.Stream.EndWrite%2A>.  
  
 <xref:System.IO.FileStream.EndWrite%2A> deve ser chamado exatamente uma vez em cada <xref:System.IAsyncResult> de <xref:System.IO.FileStream.BeginWrite%2A>. <xref:System.IO.FileStream.EndWrite%2A> será bloqueada até que a operação de e/s seja concluída.  
  
   
  
## Examples  
 Este exemplo de código é parte de um exemplo maior fornecido para o <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> construtor.  
  
 [!code-cpp[System.IO.FileStream2#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream2/CPP/source.cpp#3)]
 [!code-csharp[System.IO.FileStream2#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream2/CS/source.cs#3)]
 [!code-vb[System.IO.FileStream2#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream2/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Este objeto <see cref="T:System.IAsyncResult" /> não foi criado chamando <see cref="M:System.IO.Stream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> nesta classe.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.IO.FileStream.EndWrite(System.IAsyncResult)" /> é chamado várias vezes.</exception>
        <exception cref="T:System.IO.IOException">O fluxo está fechado ou ocorreu um erro interno.</exception>
        <related type="Article" href="~/docs/standard/io/index.md">E/S de arquivo e de fluxo</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Como ler texto de um arquivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Como gravar texto em um arquivo</related>
        <related type="Article" href="~/docs/standard/io/asynchronous-file-i-o.md">E/S de arquivo assíncrona</related>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~FileStream ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!FileStream ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="fileStream.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Garante que os recursos são liberados e outras operações de limpeza são executadas quando o coletor de lixo recupera o objeto <see langword="FileStream" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O coletor de lixo chama `Finalize` quando o objeto atual está pronto para ser finalizado. `Finalize` Fecha o `FileStream`.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md">E/S de arquivo e de fluxo</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Como ler texto de um arquivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Como gravar texto em um arquivo</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Flush">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Limpa os buffers desse fluxo e faz com que todos os dados armazenados em buffer sejam gravados no arquivo.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public override void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Flush();" />
      <MemberSignature Language="F#" Value="override this.Flush : unit -&gt; unit" Usage="fileStream.Flush " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Limpa os buffers desse fluxo e faz com que todos os dados armazenados em buffer sejam gravados no arquivo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método substitui <xref:System.IO.Stream.Flush%2A?displayProperty=nameWithType>.  
  
 Quando você chama o <xref:System.IO.FileStream.Flush%2A?displayProperty=nameWithType> método, o buffer de e/s de sistema de operacional também é liberado.  
  
 Codificador do fluxo não é liberado, a menos que você chamar explicitamente <xref:System.IO.FileStream.Flush%2A> ou descartar o objeto. Definindo <xref:System.IO.StreamWriter.AutoFlush%2A?displayProperty=nameWithType> para `true` significa que dados serão liberados do buffer no fluxo, mas o estado de codificador não será liberado. Isso permite que o codificador deve manter o estado (caracteres parcial), para que ele pode codificar o próximo bloco de caracteres corretamente. Esse cenário afeta UTF8 e UTF7 em que determinados caracteres podem ser codificados apenas depois que o codificador recebe adjacentes ou mais caracteres.  
  
 Como um buffer pode ser usado para leitura ou gravação, <xref:System.IO.FileStream.Flush> executa duas funções a seguir:  
  
-   Os dados previamente gravados em buffer são copiados para o arquivo e o buffer é limpo, exceto para seu estado de codificador.  
  
-   Se <xref:System.IO.BufferedStream.CanSeek%2A?displayProperty=nameWithType> é `true` e dados foi copiados anteriormente do arquivo para o buffer para leitura, a posição atual dentro do arquivo é subtraída pelo número de bytes não lidos no buffer. O buffer, em seguida, será limpo.  
  
 Use o <xref:System.IO.FileStream.Flush%28System.Boolean%29> sobrecarga do método quando desejar garantir que todos os dados em buffer nos buffers de arquivo intermediário é gravada no disco.  
  
   
  
## Examples  
 Este exemplo de código é parte de um exemplo maior fornecido para o <xref:System.IO.FileStream.Lock%2A> método.  
  
 [!code-cpp[System.IO.FileStream3#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream3/CPP/fstreamlock.cpp#4)]
 [!code-csharp[System.IO.FileStream3#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream3/CS/fstreamlock.cs#4)]
 [!code-vb[System.IO.FileStream3#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream3/VB/fstreamlock.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S.</exception>
        <exception cref="T:System.ObjectDisposedException">O fluxo está fechado.</exception>
        <altmember cref="M:System.IO.FileStream.Flush(System.Boolean)" />
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Como gravar texto em um arquivo</related>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public virtual void Flush (bool flushToDisk);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Flush(bool flushToDisk) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Flush(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Flush (flushToDisk As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Flush(bool flushToDisk);" />
      <MemberSignature Language="F#" Value="override this.Flush : bool -&gt; unit" Usage="fileStream.Flush flushToDisk" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="flushToDisk" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="flushToDisk"><see langword="true" /> para limpar todos os buffers de arquivo intermediário; caso contrário, <see langword="false" />.</param>
        <summary>Limpa os buffers desse fluxo e faz com que os dados armazenados em buffer sejam gravados no arquivo e também limpa todos os buffers de arquivo intermediário.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use essa sobrecarga quando você deseja garantir que todos os dados em buffer nos buffers de arquivo intermediário é gravada no disco.  
  
 Quando você chama o <xref:System.IO.FileStream.Flush%2A> método, o buffer de e/s de sistema de operacional também é liberado.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IO.FileStream.Flush" />
      </Docs>
    </Member>
    <Member MemberName="FlushAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task FlushAsync (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task FlushAsync(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.FlushAsync(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ FlushAsync(System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.FlushAsync : System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="fileStream.FlushAsync cancellationToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">O token a se monitorar para solicitações de cancelamento.</param>
        <summary>Limpa todos os buffers nesse fluxo de forma assíncrona, faz com que os dados armazenados em buffer sejam gravados no dispositivo subjacente e monitora as solicitações de cancelamento.</summary>
        <returns>Uma tarefa que representa a operação de liberação assíncrona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando você chama o <xref:System.IO.FileStream.FlushAsync%2A> método, o buffer de e/s de sistema de operacional também é liberado.  
  
 Se a operação for cancelada antes de ser concluída, a tarefa retornada contém o <xref:System.Threading.Tasks.TaskStatus.Canceled> de valor para o <xref:System.Threading.Tasks.Task.Status%2A> propriedade. Se o identificador para o arquivo é descartado, a tarefa retornada contém o <xref:System.ObjectDisposedException> exceção no <xref:System.Threading.Tasks.Task.Exception%2A> propriedade.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">O fluxo foi descartado.</exception>
        <related type="Article" href="~/docs/standard/threading/cancellation-in-managed-threads.md">Cancelamento</related>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.FileSecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.FileSecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.GetAccessControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl () As FileSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::FileSecurity ^ GetAccessControl();" />
      <MemberSignature Language="F#" Value="member this.GetAccessControl : unit -&gt; System.Security.AccessControl.FileSecurity" Usage="fileStream.GetAccessControl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.FileSecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtém um objeto <see cref="T:System.Security.AccessControl.FileSecurity" /> que encapsula as entradas da ACL (lista de controle de acesso) do arquivo descrito pelo objeto <see cref="T:System.IO.FileStream" /> atual.</summary>
        <returns>Um objeto que encapsula as configurações de controle de acesso para o arquivo descrito pelo objeto <see cref="T:System.IO.FileStream" /> atual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Enquanto o <xref:System.IO.FileStream> classe e <xref:System.IO.FileStream.GetAccessControl%2A> pode ser usado para recuperar as entradas de ACL (lista) de controle de acesso de um arquivo existente, considere o uso de <xref:System.IO.File.GetAccessControl%2A?displayProperty=nameWithType> método, pois ele é mais fácil de usar.  
  
 Use o <xref:System.IO.FileStream.GetAccessControl%2A> método para recuperar as entradas ACL para um arquivo.  
  
 Uma ACL descreve indivíduos e/ou grupos que têm ou não tem direitos para ações específicas no arquivo em questão. Para saber mais, confira [Como adicionar ou remover entradas da lista de controle de acesso](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">O arquivo está fechado.</exception>
        <exception cref="T:System.IO.IOException">Um erro de E/S ocorreu ao abrir o arquivo.</exception>
        <exception cref="T:System.SystemException">Não foi possível encontrar o arquivo.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Não há suporte para essa operação na plataforma atual.  
  
- ou - 
O chamador não tem a permissão necessária.</exception>
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public virtual IntPtr Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.Handle" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property IntPtr Handle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.Handle : nativeint" Usage="System.IO.FileStream.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use SafeFileHandle instead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use FileStream's SafeFileHandle property instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use FileStream's SafeFileHandle property instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o identificador de arquivo do sistema operacional do arquivo que o objeto <see langword="FileStream" /> atual encapsula.</summary>
        <value>O identificador de arquivo do sistema operacional para o arquivo encapsulado por esse objeto <see langword="FileStream" /> ou -1 se o <see langword="FileStream" /> tiver sido fechado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propriedade é um identificador de sistema operacional para uso com chamadas do sistema operacional-fornecido pelo sistema (como `ReadFile` no Windows). Ele não funcionará com as funções de biblioteca de C que esperam um descritor de arquivo, como `fread`.  
  
 O identificador do sistema operacional pode ter sido aberto de forma síncrona ou assíncrona, dependendo de qual `FileStream` construtor foi chamado. Use o <xref:System.IO.FileStream.IsAsync%2A> propriedade para descobrir se esse identificador foi aberto de forma assíncrona. No Win32, isso significa que o identificador foi aberto para e/s sobreposta, e ele exige parâmetros diferentes `ReadFile` e `WriteFile`.  
  
> [!CAUTION]
>  Corrupção de dados pode ocorrer se um `FileStream` é criado, seu identificador for passado, alguma operação Move o ponteiro de arquivo do identificador e, em seguida, o `FileStream` é usado novamente. Vários threads com segurança não é possível gravar no mesmo arquivo simultaneamente, e `FileStream` buffer código pressupõe que ele controla exclusivamente a alça. `FileStream` pode lançar uma <xref:System.IO.IOException> se `FileStream` detecta que algum outro processo passou o ponteiro do arquivo. Para evitar isso, não grave todos os dados em uma parte do arquivo que `FileStream` pode ter armazenado em buffer e restaurar o ponteiro do arquivo para o local que tinha quando métodos foram chamados pela última vez no `FileStream`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">O chamador não tem a permissão necessária.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para a capacidade de acessar código não gerenciado. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> Ação de segurança: <see cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand" />.</permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
        <related type="Article" href="~/docs/standard/io/index.md">E/S de arquivo e de fluxo</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Como ler texto de um arquivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Como gravar texto em um arquivo</related>
      </Docs>
    </Member>
    <Member MemberName="IsAsync">
      <MemberSignature Language="C#" Value="public virtual bool IsAsync { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAsync" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.IsAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsAsync As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsAsync { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAsync : bool" Usage="System.IO.FileStream.IsAsync" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se <see langword="FileStream" /> foi aberto de forma assíncrona ou síncrona.</summary>
        <value><see langword="true" /> se o <see langword="FileStream" /> tiver sido aberto de forma assíncrona; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `IsAsync` propriedade detecta se o `FileStream` identificador foi aberto de forma assíncrona, permitindo que seu código para usar o <xref:System.IO.FileStream.Handle%2A> propriedade corretamente. No Win32, `IsAsync` sendo true significa que o identificador foi aberto para e/s sobrepostas e, portanto, exige parâmetros diferentes `ReadFile` e `WriteFile`.  
  
 Especifique esse valor quando você cria uma instância das <xref:System.IO.FileStream> classe usando um construtor que tem um `isAsync`, `useAsync`, ou `options` parâmetro. Quando a propriedade for `true`, utiliza o fluxo de e/s sobreposta para executar operações de arquivo de forma assíncrona. No entanto, o <xref:System.IO.FileStream.IsAsync%2A> propriedade não precisa ser `true` para chamar o <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, ou <xref:System.IO.Stream.CopyToAsync%2A> método. Quando o <xref:System.IO.FileStream.IsAsync%2A> é de propriedade `false` e chamar a leitura assíncrona e operações de gravação, o thread de interface do usuário ainda não está bloqueado, mas a operação de e/s real é executada de forma síncrona.  
  
   
  
## Examples  
 Este exemplo de código é parte de um exemplo maior fornecido para o <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> construtor.  
  
 [!code-cpp[System.IO.FileStream2#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream2/CPP/source.cpp#2)]
 [!code-csharp[System.IO.FileStream2#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream2/CS/source.cs#2)]
 [!code-vb[System.IO.FileStream2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream2/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md">E/S de arquivo e de fluxo</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Como ler texto de um arquivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Como gravar texto em um arquivo</related>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public override long Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Length" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.Length" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Length As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Length { long get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int64" Usage="System.IO.FileStream.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o tamanho do fluxo em bytes.</summary>
        <value>Um valor longo que representa o tamanho do fluxo em bytes.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obter uma lista de operações de diretório e arquivos comuns, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 O exemplo a seguir usa o `Length` e `Position` propriedades para verificar se há uma condição de fim-de-arquivo.  
  
 [!code-cpp[Classic FileStream.Length Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic FileStream.Length Example/CPP/source.cpp#1)]
 [!code-csharp[Classic FileStream.Length Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic FileStream.Length Example/CS/source.cs#1)]
 [!code-vb[Classic FileStream.Length Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic FileStream.Length Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><see cref="P:System.IO.FileStream.CanSeek" /> para esse fluxo é <see langword="false" />.</exception>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S, como o arquivo ser fechado.</exception>
        <related type="Article" href="~/docs/standard/io/index.md">E/S de arquivo e de fluxo</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Como ler texto de um arquivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Como gravar texto em um arquivo</related>
      </Docs>
    </Member>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public virtual void Lock (long position, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Lock(int64 position, int64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Lock(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Lock (position As Long, length As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Lock(long position, long length);" />
      <MemberSignature Language="F#" Value="abstract member Lock : int64 * int64 -&gt; unit&#xA;override this.Lock : int64 * int64 -&gt; unit" Usage="fileStream.Lock (position, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int64" />
        <Parameter Name="length" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="position">O início do intervalo a ser bloqueado. O valor desse parâmetro deve ser igual ou maior que zero (0).</param>
        <param name="length">O intervalo a ser bloqueado.</param>
        <summary>Impede que outros processos façam a leitura ou gravação no <see cref="T:System.IO.FileStream" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bloqueio de um intervalo de um fluxo de arquivos oferece os threads do bloqueio acesso exclusivo do processo para esse intervalo de fluxo de arquivos.  
  
 Para obter uma lista de operações de diretório e arquivos comuns, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como parte de um arquivo de bloqueio para que outro processo não possa acessar essa parte do arquivo, mesmo que ela tenha acesso de leitura/gravação para o arquivo. Execute o programa simultaneamente em janelas de comando diferente e investigue usando as opções de entrada de console diferentes.  
  
 [!code-cpp[System.IO.FileStream3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream3/CPP/fstreamlock.cpp#1)]
 [!code-csharp[System.IO.FileStream3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream3/CS/fstreamlock.cs#1)]
 [!code-vb[System.IO.FileStream3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream3/VB/fstreamlock.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="position" /> ou <paramref name="length" /> é negativo.</exception>
        <exception cref="T:System.ObjectDisposedException">O arquivo está fechado.</exception>
        <exception cref="T:System.IO.IOException">O processo não pode acessar o arquivo porque outro processo bloqueou uma parte dele.</exception>
        <related type="Article" href="~/docs/standard/io/index.md">E/S de arquivo e de fluxo</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Como ler texto de um arquivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Como gravar texto em um arquivo</related>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.Name" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.IO.FileStream.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o caminho absoluto do arquivo aberto no <see langword="FileStream" />.</summary>
        <value>Uma cadeia de caracteres que é o caminho absoluto do arquivo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

Se o caminho absoluto não é conhecido, essa propriedade retornará uma cadeia de caracteres semelhante a "[desconhecido]".

 Para obter uma lista de operações de diretório e arquivos comuns, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Este exemplo de código é parte de um exemplo maior fornecido para o <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> construtor.  
  
 [!code-cpp[System.IO.FileStream2#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream2/CPP/source.cpp#4)]
 [!code-csharp[System.IO.FileStream2#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream2/CS/source.cs#4)]
 [!code-vb[System.IO.FileStream2#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream2/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para acesso ao caminho. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">E/S de arquivo e de fluxo</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Como ler texto de um arquivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Como gravar texto em um arquivo</related>
      </Docs>
    </Member>
    <Member MemberName="Position">
      <MemberSignature Language="C#" Value="public override long Position { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Position" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.Position" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Position As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Position { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.Position : int64 with get, set" Usage="System.IO.FileStream.Position" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define a posição atual desse fluxo.</summary>
        <value>A posição atual do fluxo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Há suporte para busca em qualquer local além do comprimento do fluxo.  Quando você busca além do comprimento do arquivo, o tamanho do arquivo aumenta.  No Microsoft Windows NT e mais recentes, os dados adicionados ao final do arquivo são definidos como zero.  No Microsoft Windows 98 ou anterior, os dados adicionados ao final do arquivo não estão definidos como zero, o que significa que os dados excluídos anteriormente está visível no fluxo. Definir a posição do fluxo com um valor grande após o fim do fluxo no Windows 98 ou anterior pode resultar em uma exceção que está sendo gerada.  
  
 Para obter uma lista de operações de diretório e arquivos comuns, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 O exemplo a seguir usa o `Length` e `Position` propriedades para verificar se há uma condição de fim-de-arquivo.  
  
 [!code-cpp[Classic FileStream.Length Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic FileStream.Length Example/CPP/source.cpp#1)]
 [!code-csharp[Classic FileStream.Length Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic FileStream.Length Example/CS/source.cs#1)]
 [!code-vb[Classic FileStream.Length Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic FileStream.Length Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">O fluxo não dá suporte à busca.</exception>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S.  
  
- ou - 
A posição foi definida com um valor muito grande após o final do fluxo no Windows 98 ou anterior.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Tentativa de definir a posição com um valor negativo.</exception>
        <exception cref="T:System.IO.EndOfStreamException">Tentativa de busca após o término de um fluxo que não dá suporte a essa operação.</exception>
        <related type="Article" href="~/docs/standard/io/index.md">E/S de arquivo e de fluxo</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Como ler texto de um arquivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Como gravar texto em um arquivo</related>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (Span&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read(valuetype System.Span`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Read(System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read (buffer As Span(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read(Span&lt;System::Byte&gt; buffer);" />
      <MemberSignature Language="F#" Value="override this.Read : Span&lt;byte&gt; -&gt; int" Usage="fileStream.Read buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (byte[] array, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read([out] unsigned int8[] array, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read (array As Byte(), offset As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read(cli::array &lt;System::Byte&gt; ^ array, int offset, int count);" />
      <MemberSignature Language="F#" Value="override this.Read : byte[] * int * int -&gt; int" Usage="fileStream.Read (array, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Quando este método retorna, ele contém a matriz de bytes especificada com os valores entre <paramref name="offset" /> e (<paramref name="offset" /> + <paramref name="count" /> -1<c>)</c> substituídos pelos bytes lidos da fonte atual.</param>
        <param name="offset">O deslocamento de bytes no <paramref name="array" /> no qual os bytes lidos serão colocados.</param>
        <param name="count">O número máximo de bytes a serem lidos.</param>
        <summary>Lê um bloco de bytes do fluxo e grava os dados em um buffer específico.</summary>
        <returns>O número total de bytes lidos do buffer. Isso poderá ser menor que o número de bytes solicitado se esse número de bytes não estiver disponível no momento, ou zero, se o final do fluxo for atingido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método substitui <xref:System.IO.Stream.Read%2A>.  
  
 O `offset` parâmetro fornece o deslocamento do byte em `array` (o índice do buffer) no qual será iniciada a leitura e o `count` parâmetro fornece o número máximo de bytes a serem lidos desse fluxo. O valor retornado é o número real de bytes lidos, ou zero se o final do fluxo for atingido. Se a operação de leitura for bem-sucedida, avança a posição atual do fluxo pelo número de bytes lidos. Se ocorrer uma exceção, a posição atual do fluxo está inalterada.  
  
 O <xref:System.IO.FileStream.Read%2A> método retorna zero somente depois de atingir o final do fluxo. Caso contrário, <xref:System.IO.FileStream.Read%2A> lê sempre pelo menos um byte do fluxo antes de retornar. Se nenhum dado está disponível no fluxo após uma chamada para <xref:System.IO.FileStream.Read%2A>, o método será bloqueado até que pelo menos um byte de dados pode ser retornado. Uma implementação está livre para retornar menos bytes que solicitado, mesmo se o final do fluxo não foi atingido.  
  
 Use <xref:System.IO.BinaryReader> para ler os tipos de dados primitivos.  
  
 Interrompe um thread que está executando uma operação de leitura. Embora o aplicativo possa aparecer ser executado com êxito depois que o thread será desbloqueado, a interrupção pode diminuir o desempenho e a confiabilidade do seu aplicativo.  
  
 Para obter uma lista de operações de diretório e arquivos comuns, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 O exemplo a seguir lê o conteúdo de um <xref:System.IO.FileStream> e grava-o em outro <xref:System.IO.FileStream>.  
  
 [!code-csharp[FSRead#1](~/samples/snippets/csharp/VS_Snippets_CLR/FSRead/CS/fsread.cs#1)]
 [!code-vb[FSRead#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FSRead/VB/fsread.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> ou <paramref name="count" /> é negativo.</exception>
        <exception cref="T:System.NotSupportedException">Não há suporte para leitura no fluxo.</exception>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="offset" /> e <paramref name="count" /> descrevem um intervalo inválido em <paramref name="array" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Foram chamados métodos depois que o fluxo foi fechado.</exception>
        <related type="Article" href="~/docs/standard/io/index.md">E/S de arquivo e de fluxo</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Como ler texto de um arquivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Como gravar texto em um arquivo</related>
      </Docs>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.ValueTask&lt;int&gt; ReadAsync (Memory&lt;byte&gt; buffer, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Threading.Tasks.ValueTask`1&lt;int32&gt; ReadAsync(valuetype System.Memory`1&lt;unsigned int8&gt; buffer, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.ReadAsync(System.Memory{System.Byte},System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="override this.ReadAsync : Memory&lt;byte&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.ValueTask&lt;int&gt;" Usage="fileStream.ReadAsync (buffer, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ValueTask&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Memory&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task&lt;int&gt; ReadAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadAsync(unsigned int8[] buffer, int32 offset, int32 count, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task&lt;int&gt; ^ ReadAsync(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.ReadAsync : byte[] * int * int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="fileStream.ReadAsync (buffer, offset, count, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="buffer">O buffer no qual os dados serão gravados.</param>
        <param name="offset">O deslocamento de bytes no <paramref name="buffer" /> no qual será iniciada a gravação de dados no fluxo.</param>
        <param name="count">O número máximo de bytes a serem lidos.</param>
        <param name="cancellationToken">O token a se monitorar para solicitações de cancelamento.</param>
        <summary>Lê de forma assíncrona uma sequência de bytes do fluxo atual, avança a posição no fluxo até o número de bytes lidos e monitora as solicitações de cancelamento.</summary>
        <returns>Uma tarefa que representa a operação de leitura assíncrona. O valor do parâmetro <paramref name="TResult" /> contém o número total de bytes lidos no buffer. O valor do resultado poderá ser menor que o número de bytes solicitados se o número de bytes disponíveis no momento for menor que o número solicitado ou poderá ser 0 (zero) se o final do fluxo foi atingido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.IO.FileStream.ReadAsync%2A> método permite que você execute operações de arquivo de uso intensivo de recursos sem bloquear o thread principal. Essa consideração sobre o desempenho é particularmente importante em um aplicativo [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] ou [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] em que uma operação demorada de fluxo pode bloquear o thread de interface do usuário e fazer seu aplicativo parecer como se não estivesse funcionando. Os métodos assíncronos são usados em conjunto com o `async` e `await` palavras-chave no Visual Basic e c#.  
  
 Use o <xref:System.IO.FileStream.CanRead%2A> propriedade para determinar se a instância atual dá suporte à leitura.  
  
 Se a operação for cancelada antes de ser concluída, a tarefa retornada contém o <xref:System.Threading.Tasks.TaskStatus.Canceled> de valor para o <xref:System.Threading.Tasks.Task.Status%2A> propriedade. Se o identificador para o arquivo é descartado, a tarefa retornada contém o <xref:System.ObjectDisposedException> exceção no <xref:System.Threading.Tasks.Task.Exception%2A> propriedade.  
  
   
  
## Examples  
 O exemplo a seguir mostra como ler de um arquivo de forma assíncrona.  
  
 [!code-csharp[Asynchronous_File_IO_async#4](~/samples/snippets/csharp/VS_Snippets_CLR/Asynchronous_File_IO_async/cs/example4.cs#4)]
 [!code-vb[Asynchronous_File_IO_async#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Asynchronous_File_IO_async/vb/example4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> ou <paramref name="count" /> é negativo.</exception>
        <exception cref="T:System.ArgumentException">A soma de <paramref name="offset" /> e <paramref name="count" /> é maior que o tamanho do buffer.</exception>
        <exception cref="T:System.NotSupportedException">Não há suporte para leitura no fluxo.</exception>
        <exception cref="T:System.ObjectDisposedException">O fluxo foi descartado.</exception>
        <exception cref="T:System.InvalidOperationException">O fluxo está sendo usado no momento por uma operação de leitura anterior.</exception>
        <related type="Article" href="~/docs/standard/threading/cancellation-in-managed-threads.md">Cancelamento</related>
      </Docs>
    </Member>
    <Member MemberName="ReadByte">
      <MemberSignature Language="C#" Value="public override int ReadByte ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 ReadByte() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.ReadByte" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadByte () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int ReadByte();" />
      <MemberSignature Language="F#" Value="override this.ReadByte : unit -&gt; int" Usage="fileStream.ReadByte " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lê um byte do arquivo e avança a posição de leitura em um byte.</summary>
        <returns>O byte, convertido em um <see cref="T:System.Int32" />, ou -1 se o final do fluxo foi atingido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método substitui <xref:System.IO.Stream.ReadByte%2A>.  
  
> [!NOTE]
>  Use o <xref:System.IO.FileStream.CanRead%2A> propriedade para determinar se a instância atual dá suporte à leitura. Para obter mais informações, consulte: <xref:System.IO.Stream.CanRead%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como gravar dados em um arquivo, byte por byte e, em seguida, verifique se que os dados foram gravados corretamente.  
  
 [!code-cpp[System.IO.FileStream1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream1/CPP/source.cpp#1)]
 [!code-csharp[System.IO.FileStream1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream1/CS/source.cs#1)]
 [!code-vb[System.IO.FileStream1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Não há suporte para a leitura no fluxo atual.</exception>
        <exception cref="T:System.ObjectDisposedException">O fluxo atual está fechado.</exception>
        <block subset="none" type="overrides"><para>A implementação padrão em <see langword="Stream" /> cria uma nova matriz de byte único e, em seguida, chama <see cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" />. Embora isso seja correto formalmente, é ineficiente. Qualquer fluxo com um buffer interno deve substituir esse método e fornecer uma versão muito mais eficiente do que lê o buffer diretamente, evitando a alocação de matriz extra em cada chamada.  
  
Para obter uma lista de operações de diretório e arquivos comuns, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).</para></block>
        <related type="Article" href="~/docs/standard/io/index.md">E/S de arquivo e de fluxo</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Como ler texto de um arquivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Como gravar texto em um arquivo</related>
      </Docs>
    </Member>
    <Member MemberName="SafeFileHandle">
      <MemberSignature Language="C#" Value="public virtual Microsoft.Win32.SafeHandles.SafeFileHandle SafeFileHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeFileHandle SafeFileHandle" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.SafeFileHandle" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SafeFileHandle As SafeFileHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Microsoft::Win32::SafeHandles::SafeFileHandle ^ SafeFileHandle { Microsoft::Win32::SafeHandles::SafeFileHandle ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SafeFileHandle : Microsoft.Win32.SafeHandles.SafeFileHandle" Usage="System.IO.FileStream.SafeFileHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeFileHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um objeto <see cref="T:Microsoft.Win32.SafeHandles.SafeFileHandle" /> que representa o identificador de arquivo do sistema operacional para o arquivo que o objeto <see cref="T:System.IO.FileStream" /> atual encapsula.</summary>
        <value>Um objeto que representa o identificador de arquivo do sistema operacional para o arquivo que o objeto <see cref="T:System.IO.FileStream" /> atual encapsula.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.IO.FileStream.SafeFileHandle%2A> propriedade automaticamente libera o fluxo e define a posição atual do fluxo como 0.  Isso permite que o arquivo a ser movido ou a posição do fluxo ser redefinidas por outro fluxo usando o <xref:System.IO.FileStream.SafeFileHandle%2A> retornado por essa propriedade.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">permissão chamar código não gerenciado.  
  
Ação de segurança: Demanda de link 
Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
        <related type="Article" href="~/docs/standard/io/index.md">E/S de arquivo e de fluxo</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Como ler texto de um arquivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Como gravar texto em um arquivo</related>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public override long Seek (long offset, System.IO.SeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int64 Seek(int64 offset, valuetype System.IO.SeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Seek(System.Int64,System.IO.SeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Seek (offset As Long, origin As SeekOrigin) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override long Seek(long offset, System::IO::SeekOrigin origin);" />
      <MemberSignature Language="F#" Value="override this.Seek : int64 * System.IO.SeekOrigin -&gt; int64" Usage="fileStream.Seek (offset, origin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="origin" Type="System.IO.SeekOrigin" />
      </Parameters>
      <Docs>
        <param name="offset">O ponto relativo a <paramref name="origin" /> do qual começar a busca.</param>
        <param name="origin">Especifica a posição inicial, final ou atual como um ponto de referência para <paramref name="offset" /> usando um valor do tipo <see cref="T:System.IO.SeekOrigin" />.</param>
        <summary>Define a posição atual do fluxo para o valor especificado.</summary>
        <returns>A nova posição no fluxo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método substitui <xref:System.IO.Stream.Seek%2A?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Use o <xref:System.IO.FileStream.CanSeek%2A?displayProperty=nameWithType> propriedade para determinar se a instância atual dá suporte à busca. Para obter mais informações, consulte: <xref:System.IO.Stream.CanSeek%2A?displayProperty=nameWithType>.  
  
 Você pode buscar em qualquer local além do comprimento do fluxo. Quando você busca além do comprimento do arquivo, o tamanho do arquivo aumenta. No Windows NT e versões posteriores, adicionados ao final do arquivo de dados são definidos como zero. No Windows 98 ou versões anteriores, os dados adicionados ao final do arquivo não estão definidos como zero, o que significa que os dados excluídos anteriormente está visível no fluxo.  
  
 Para obter uma lista de operações de diretório e arquivos comuns, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 O exemplo a seguir mostra como gravar dados em um arquivo, byte por byte e, em seguida, verifique se que os dados foram gravados corretamente.  
  
 [!code-cpp[System.IO.FileStream1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream1/CPP/source.cpp#1)]
 [!code-csharp[System.IO.FileStream1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream1/CS/source.cs#1)]
 [!code-vb[System.IO.FileStream1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream1/VB/source.vb#1)]  
  
 O exemplo a seguir lê o texto na direção inversa, do final do arquivo para o início do arquivo, usando as diversas <xref:System.IO.SeekOrigin> valores com o <xref:System.IO.FileStream.Seek%2A> método.  
  
 [!code-csharp[System.IO.FileStream.Seek#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.filestream.seek/cs/source.cs#1)]
 [!code-vb[System.IO.FileStream.Seek#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.filestream.seek/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S.</exception>
        <exception cref="T:System.NotSupportedException">O fluxo não dá suporte a busca, como se o <see langword="FileStream" /> fosse construído por meio de uma saída do console ou pipe.</exception>
        <exception cref="T:System.ArgumentException">A busca é tentada antes do início do fluxo.</exception>
        <exception cref="T:System.ObjectDisposedException">Foram chamados métodos depois que o fluxo foi fechado.</exception>
        <related type="Article" href="~/docs/standard/io/index.md">E/S de arquivo e de fluxo</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Como ler texto de um arquivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Como gravar texto em um arquivo</related>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.Security.AccessControl.FileSecurity fileSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.Security.AccessControl.FileSecurity fileSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.SetAccessControl(System.Security.AccessControl.FileSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessControl(System::Security::AccessControl::FileSecurity ^ fileSecurity);" />
      <MemberSignature Language="F#" Value="member this.SetAccessControl : System.Security.AccessControl.FileSecurity -&gt; unit" Usage="fileStream.SetAccessControl fileSecurity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileSecurity" Type="System.Security.AccessControl.FileSecurity" />
      </Parameters>
      <Docs>
        <param name="fileSecurity">Um objeto que descreve uma entrada ACL para aplicar ao arquivo atual.</param>
        <summary>Aplica-se a entradas ACL (Lista de Controle de Acesso) descritas por um objeto <see cref="T:System.Security.AccessControl.FileSecurity" /> para o arquivo descrito pelo objeto <see cref="T:System.IO.FileStream" /> atual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Enquanto o <xref:System.IO.FileStream> classe e <xref:System.IO.FileStream.SetAccessControl%2A> pode ser usado em um arquivo existente, considere usar o <xref:System.IO.File.SetAccessControl%2A?displayProperty=nameWithType> método como ele é mais fácil de usar.  
  
 O <xref:System.IO.FileStream.SetAccessControl%2A> método se aplica a entradas ACL (lista) de controle de acesso a um arquivo que representa a lista ACL noninherited.  
  
> [!CAUTION]
>  A ACL é especificado para o `fileSecurity` parâmetro substitui a ACL existente para o arquivo. Para adicionar permissões para um novo usuário, use o <xref:System.IO.FileStream.GetAccessControl%2A> método para obter a ACL existente, modificá-lo e, em seguida, usar <xref:System.IO.FileStream.SetAccessControl%2A> para aplicá-la de volta para o arquivo.  
  
 Uma ACL descreve indivíduos e/ou grupos que têm ou não tem direitos para ações específicas no arquivo em questão. Para saber mais, confira [Como adicionar ou remover entradas da lista de controle de acesso](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">O arquivo está fechado.</exception>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="fileSecurity" /> é <see langword="null" />.</exception>
        <exception cref="T:System.SystemException">O arquivo não pôde ser encontrado ou modificado.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O processo atual não tem acesso para abrir o arquivo.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetLength">
      <MemberSignature Language="C#" Value="public override void SetLength (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void SetLength(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.SetLength(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub SetLength (value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void SetLength(long value);" />
      <MemberSignature Language="F#" Value="override this.SetLength : int64 -&gt; unit" Usage="fileStream.SetLength value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">O novo tamanho do fluxo.</param>
        <summary>Define o tamanho deste fluxo para o valor especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método substitui <xref:System.IO.Stream.SetLength%2A>.  
  
 Se o valor especificado é menor que o tamanho atual do fluxo, o fluxo será truncado. Nesse cenário, se a posição atual é maior que o novo tamanho, a posição atual é movida para o último byte do fluxo. Se o valor fornecido for maior que o tamanho atual do fluxo, o fluxo é expandido e a posição atual permanece o mesmo. Se o fluxo é expandido, o conteúdo de fluxo entre o antigo e o novo comprimento serão indefinido.  
  
 Um fluxo deve oferecer suporte a gravação e busca para `SetLength` funcione.  
  
> [!NOTE]
>  Use o <xref:System.IO.FileStream.CanWrite%2A> propriedade para determinar se a instância atual dá suporte à gravação e o <xref:System.IO.FileStream.CanSeek%2A> propriedade para determinar se há suporte para busca. Para obter mais informações, consulte <xref:System.IO.Stream.CanWrite%2A> e <xref:System.IO.Stream.CanSeek%2A>.  
  
 Para obter uma lista de operações de diretório e arquivos comuns, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S.</exception>
        <exception cref="T:System.NotSupportedException">O fluxo não dá suporte para gravação e busca.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Tentativa de definir o parâmetro <paramref name="value" /> como menos que 0.</exception>
        <related type="Article" href="~/docs/standard/io/index.md">E/S de arquivo e de fluxo</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Como ler texto de um arquivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Como gravar texto em um arquivo</related>
      </Docs>
    </Member>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public virtual void Unlock (long position, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Unlock(int64 position, int64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Unlock(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Unlock (position As Long, length As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Unlock(long position, long length);" />
      <MemberSignature Language="F#" Value="abstract member Unlock : int64 * int64 -&gt; unit&#xA;override this.Unlock : int64 * int64 -&gt; unit" Usage="fileStream.Unlock (position, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int64" />
        <Parameter Name="length" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="position">O início do intervalo a ser desbloqueado.</param>
        <param name="length">O intervalo a ser desbloqueado.</param>
        <summary>Permite o acesso por outros processos a todo ou parte de um arquivo que foi bloqueado anteriormente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obter uma lista de operações de diretório e arquivos comuns, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como parte de um arquivo de bloqueio para que outro processo não pode acessar essa parte do arquivo, mesmo que ela tenha acesso de leitura/gravação para o arquivo e, em seguida, desbloqueie a parte especificada do arquivo. Execute o programa simultaneamente em janelas de comando diferente e investigue usando as opções de entrada de console diferentes.  
  
 [!code-cpp[System.IO.FileStream3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream3/CPP/fstreamlock.cpp#1)]
 [!code-csharp[System.IO.FileStream3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream3/CS/fstreamlock.cs#1)]
 [!code-vb[System.IO.FileStream3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream3/VB/fstreamlock.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="position" /> ou <paramref name="length" /> é negativo.</exception>
        <related type="Article" href="~/docs/standard/io/index.md">E/S de arquivo e de fluxo</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Como ler texto de um arquivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Como gravar texto em um arquivo</related>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public override void Write (ReadOnlySpan&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Write(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Write(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Write (buffer As ReadOnlySpan(Of Byte))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Write(ReadOnlySpan&lt;System::Byte&gt; buffer);" />
      <MemberSignature Language="F#" Value="override this.Write : ReadOnlySpan&lt;byte&gt; -&gt; unit" Usage="fileStream.Write buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public override void Write (byte[] array, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Write(unsigned int8[] array, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Write(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Write (array As Byte(), offset As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Write(cli::array &lt;System::Byte&gt; ^ array, int offset, int count);" />
      <MemberSignature Language="F#" Value="override this.Write : byte[] * int * int -&gt; unit" Usage="fileStream.Write (array, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">O buffer que contém dados a serem gravados no fluxo.</param>
        <param name="offset">O deslocamento de bytes baseado em zero em <paramref name="array" /> do qual será iniciada a cópia de bytes no fluxo.</param>
        <param name="count">O número máximo de bytes a serem gravados.</param>
        <summary>Grava um bloco de bytes no fluxo de arquivo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método substitui <xref:System.IO.Stream.Write%2A>.  
  
 O `offset` parâmetro fornece o deslocamento do byte em `array` (o índice do buffer) no qual será iniciada a cópia e o `count` parâmetro fornece o número de bytes que serão gravados no fluxo. Se a operação de gravação for bem-sucedida, avança a posição atual do fluxo pelo número de bytes gravados. Se ocorrer uma exceção, a posição atual do fluxo está inalterada.  
  
> [!NOTE]
>  Use o <xref:System.IO.FileStream.CanWrite%2A> propriedade para determinar se a instância atual dá suporte à gravação. Para obter mais informações, consulte: <xref:System.IO.Stream.CanWrite%2A>.  
  
 Interrompe um thread que está executando uma operação de gravação. Embora o aplicativo possa aparecer ser executado com êxito depois que o thread será desbloqueado, a interrupção pode diminuir o desempenho e a confiabilidade do seu aplicativo.  
  
 Para obter uma lista de operações de diretório e arquivos comuns, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Este exemplo de código é parte de um exemplo maior fornecido para o <xref:System.IO.FileStream.Lock%2A> método.  
  
 [!code-cpp[System.IO.FileStream3#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream3/CPP/fstreamlock.cpp#3)]
 [!code-csharp[System.IO.FileStream3#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream3/CS/fstreamlock.cs#3)]
 [!code-vb[System.IO.FileStream3#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream3/VB/fstreamlock.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="offset" /> e <paramref name="count" /> descrevem um intervalo inválido em <paramref name="array" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> ou <paramref name="count" /> é negativo.</exception>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S.  
  
- ou - 
Outro thread pode ter causado uma alteração inesperada na posição do identificador de arquivo do sistema operacional.</exception>
        <exception cref="T:System.ObjectDisposedException">O fluxo está fechado.</exception>
        <exception cref="T:System.NotSupportedException">A instância de fluxo atual não dá suporte à gravação.</exception>
        <related type="Article" href="~/docs/standard/io/index.md">E/S de arquivo e de fluxo</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Como ler texto de um arquivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Como gravar texto em um arquivo</related>
      </Docs>
    </Member>
    <Member MemberName="WriteAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.ValueTask WriteAsync (ReadOnlyMemory&lt;byte&gt; buffer, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Threading.Tasks.ValueTask WriteAsync(valuetype System.ReadOnlyMemory`1&lt;unsigned int8&gt; buffer, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.WriteAsync(System.ReadOnlyMemory{System.Byte},System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="override this.WriteAsync : ReadOnlyMemory&lt;byte&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.ValueTask" Usage="fileStream.WriteAsync (buffer, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ValueTask</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlyMemory&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task WriteAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task WriteAsync(unsigned int8[] buffer, int32 offset, int32 count, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ WriteAsync(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.WriteAsync : byte[] * int * int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="fileStream.WriteAsync (buffer, offset, count, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="buffer">O buffer do qual os dados serão gravados.</param>
        <param name="offset">O deslocamento de bytes baseado em zero em <paramref name="buffer" /> do qual será iniciada a cópia de bytes no fluxo.</param>
        <param name="count">O número máximo de bytes a serem gravados.</param>
        <param name="cancellationToken">O token a se monitorar para solicitações de cancelamento.</param>
        <summary>Grava uma sequência de bytes no fluxo atual assincronamente, avança a posição atual dentro desse fluxo pelo número de bytes gravados e monitora as solicitações de cancelamento.</summary>
        <returns>Uma tarefa que representa a operação de gravação assíncrona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.IO.FileStream.WriteAsync%2A> método permite que você execute operações de arquivo de uso intensivo de recursos sem bloquear o thread principal. Essa consideração sobre o desempenho é particularmente importante em um aplicativo [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] ou [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] em que uma operação demorada de fluxo pode bloquear o thread de interface do usuário e fazer seu aplicativo parecer como se não estivesse funcionando. Os métodos assíncronos são usados em conjunto com o `async` e `await` palavras-chave no Visual Basic e c#.  
  
 Use o <xref:System.IO.FileStream.CanWrite%2A> propriedade para determinar se a instância atual dá suporte à gravação.  
  
 Se a operação for cancelada antes de ser concluída, a tarefa retornada contém o <xref:System.Threading.Tasks.TaskStatus.Canceled> de valor para o <xref:System.Threading.Tasks.Task.Status%2A> propriedade. Se o identificador para o arquivo é descartado, a tarefa retornada contém o <xref:System.ObjectDisposedException> exceção no <xref:System.Threading.Tasks.Task.Exception%2A> propriedade.  
  
   
  
## Examples  
 O exemplo a seguir mostra como gravar em um arquivo de forma assíncrona.  
  
 [!code-csharp[Asynchronous_File_IO_async#3](~/samples/snippets/csharp/VS_Snippets_CLR/Asynchronous_File_IO_async/cs/example3.cs#3)]
 [!code-vb[Asynchronous_File_IO_async#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Asynchronous_File_IO_async/vb/example3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> ou <paramref name="count" /> é negativo.</exception>
        <exception cref="T:System.ArgumentException">A soma de <paramref name="offset" /> e <paramref name="count" /> é maior que o tamanho do buffer.</exception>
        <exception cref="T:System.NotSupportedException">Não há suporte para gravação no fluxo.</exception>
        <exception cref="T:System.ObjectDisposedException">O fluxo foi descartado.</exception>
        <exception cref="T:System.InvalidOperationException">O fluxo está em uso no momento por uma operação de gravação anterior.</exception>
        <related type="Article" href="~/docs/standard/threading/cancellation-in-managed-threads.md">Cancelamento</related>
      </Docs>
    </Member>
    <Member MemberName="WriteByte">
      <MemberSignature Language="C#" Value="public override void WriteByte (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteByte(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.WriteByte(System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteByte (value As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteByte(System::Byte value);" />
      <MemberSignature Language="F#" Value="override this.WriteByte : byte -&gt; unit" Usage="fileStream.WriteByte value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">Um byte a ser gravado no fluxo.</param>
        <summary>Grava um byte na posição atual no fluxo de arquivos.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método substitui <xref:System.IO.Stream.WriteByte%2A>.  
  
 Use `WriteByte` para gravar um byte para um `FileStream` com eficiência. Se o fluxo está fechado ou não gravável, uma exceção será gerada.  
  
> [!NOTE]
>  Use o <xref:System.IO.FileStream.CanWrite%2A> propriedade para determinar se a instância atual dá suporte à gravação. Para obter mais informações, consulte: <xref:System.IO.Stream.CanWrite%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como gravar dados em um arquivo, byte por byte e, em seguida, verifique se que os dados foram gravados corretamente.  
  
 [!code-cpp[System.IO.FileStream1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream1/CPP/source.cpp#1)]
 [!code-csharp[System.IO.FileStream1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream1/CS/source.cs#1)]
 [!code-vb[System.IO.FileStream1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">O fluxo está fechado.</exception>
        <exception cref="T:System.NotSupportedException">Não há suporte para gravação no fluxo.</exception>
        <block subset="none" type="overrides"><para>A implementação padrão em <see langword="Stream" /> cria uma nova matriz de byte único e, em seguida, chama <see cref="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" />. Embora isso seja correto formalmente, é ineficiente. Qualquer fluxo com um buffer interno deve substituir esse método e fornecer uma versão muito mais eficiente do que lê o buffer diretamente, evitando a alocação de matriz extra em cada chamada.  
  
Para obter uma lista de operações de diretório e arquivos comuns, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).</para></block>
        <related type="Article" href="~/docs/standard/io/index.md">E/S de arquivo e de fluxo</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Como ler texto de um arquivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Como gravar texto em um arquivo</related>
      </Docs>
    </Member>
  </Members>
</Type>