<Type Name="FileSystemWatcher" FullName="System.IO.FileSystemWatcher">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="a474b39e321ea84a98c73e1946fa4241dbf6722f" />
    <Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="pt-BR" />
    <Meta Name="ms.lasthandoff" Value="10/04/2018" />
    <Meta Name="ms.locfileid" Value="48740053" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class FileSystemWatcher : System.ComponentModel.Component, System.ComponentModel.ISupportInitialize" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit FileSystemWatcher extends System.ComponentModel.Component implements class System.ComponentModel.ISupportInitialize" />
  <TypeSignature Language="DocId" Value="T:System.IO.FileSystemWatcher" />
  <TypeSignature Language="VB.NET" Value="Public Class FileSystemWatcher&#xA;Inherits Component&#xA;Implements ISupportInitialize" />
  <TypeSignature Language="C++ CLI" Value="public ref class FileSystemWatcher : System::ComponentModel::Component, System::ComponentModel::ISupportInitialize" />
  <TypeSignature Language="F#" Value="type FileSystemWatcher = class&#xA;    inherit Component&#xA;    interface ISupportInitialize" />
  <AssemblyInfo>
    <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.DefaultEvent("Changed")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinmac-3.0">
      <AttributeName>System.IO.IODescription("")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.IO.IODescription("FileSystemWatcherDesc")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Monitora as notificações de alteração do sistema de arquivos e gera eventos quando um diretório, ou um arquivo em um diretório, é alterado.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use <xref:System.IO.FileSystemWatcher> observar alterações em um diretório especificado. Você pode observar alterações em arquivos e subdiretórios do diretório especificado. Você pode criar um componente para assistir a arquivos em um computador local, uma unidade de rede ou em um computador remoto.  
  
 Para assistir a alterações em todos os arquivos, defina as <xref:System.IO.FileSystemWatcher.Filter%2A> propriedade para uma cadeia de caracteres vazia ("") ou usar caracteres curinga ("*.\*"). Para assistir a um arquivo específico, defina o <xref:System.IO.FileSystemWatcher.Filter%2A> propriedade para o nome do arquivo. Por exemplo, para aguardar as alterações no arquivo doc, defina o <xref:System.IO.FileSystemWatcher.Filter%2A> propriedade como "Doc". Você também pode observar alterações em um determinado tipo de arquivo. Por exemplo, para observar alterações em arquivos de texto, defina as <xref:System.IO.FileSystemWatcher.Filter%2A> propriedade para "\*. txt".  
  
 Há vários tipos de alterações que você pode observar em um arquivo ou diretório. Por exemplo, você pode observar alterações em `Attributes`, o `LastWrite` data e hora, ou o `Size` de arquivos ou diretórios. Isso é feito definindo a <xref:System.IO.FileSystemWatcher.NotifyFilter%2A> propriedade para um do <xref:System.IO.NotifyFilters> valores. Para obter mais informações sobre o tipo de alterações que você pode assistir, consulte <xref:System.IO.NotifyFilters>.  
  
 Você pode assistir a renomeação, exclusão, ou a criação de arquivos ou diretórios. Por exemplo, para assistir a renomeação de arquivos de texto, defina a <xref:System.IO.FileSystemWatcher.Filter%2A> propriedade para "*. txt" e a chamada a <xref:System.IO.FileSystemWatcher.WaitForChanged%2A> método com um <xref:System.IO.WatcherChangeTypes.Renamed> especificado para o parâmetro.  
  
 O sistema operacional Windows notifica seu componente de alterações de arquivo em um buffer criado pelo <xref:System.IO.FileSystemWatcher>. Se houver muitas alterações em um curto período, o buffer pode estourar. Isso faz com que o componente de perder o controle de alterações no diretório e ele apenas fornecerá notificação amplas. Aumentar o tamanho do buffer com o <xref:System.IO.FileSystemWatcher.InternalBufferSize%2A> propriedade é cara, já que provém de memória não paginada que não pode ser trocada por disco, portanto, manter o buffer tão pequeno mas grande suficiente para não perder qualquer arquivo de eventos de alteração. Para evitar um estouro de buffer, use o <xref:System.IO.FileSystemWatcher.NotifyFilter%2A> e <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A> as notificações de alteração de propriedades para que você pode filtrar as indesejados.  
  
 Para obter uma lista de valores de propriedade inicial para uma instância do <xref:System.IO.FileSystemWatcher>, consulte o <xref:System.IO.FileSystemWatcher.%23ctor%2A> construtor.  
  
 Observe o seguinte ao usar o <xref:System.IO.FileSystemWatcher> classe.  
  
-   Arquivos ocultos não são ignorados.  
  
-   Em alguns sistemas, <xref:System.IO.FileSystemWatcher> informa as alterações nos arquivos usando o formato de nome de 8.3 arquivo curto. Por exemplo, uma alteração "LongFileName.LongExtension" poderia ser relatada como "LongFil ~. LON".  
  
-   Esta classe contém uma demanda de link e uma demanda de herança no nível de classe que se aplica a todos os membros. Um <xref:System.Security.SecurityException> é lançado quando o chamador imediato ou a classe derivada não tem permissão de confiança total. Para obter detalhes sobre demandas de segurança, consulte [demandas de Link](~/docs/framework/misc/link-demands.md).  
  
-   O tamanho máximo que você pode definir para o <xref:System.IO.FileSystemWatcher.InternalBufferSize%2A> propriedade para o monitoramento de um diretório pela rede é de 64 KB.  
  
> [!NOTE]
>  Executando <xref:System.IO.FileSystemWatcher> no Windows 98 não tem suporte.  
  
## <a name="copying-and-moving-folders"></a>Copiando e movendo pastas  
 O sistema operacional e <xref:System.IO.FileSystemWatcher> objeto interpretar uma ação de copiar e colar ou uma ação de movimentação como uma ação de renomeação para uma pasta e seu conteúdo. Se você recortar e colar uma pasta com arquivos em uma pasta sendo observada, os <xref:System.IO.FileSystemWatcher> objeto relata apenas a pasta como novo, mas não seu conteúdo, porque eles são essencialmente apenas renomeados.  
  
 Para ser notificado de que o conteúdo das pastas foram movido ou copiado para uma pasta monitorada, fornecer <xref:System.IO.FileSystemWatcher.OnChanged%2A> e <xref:System.IO.FileSystemWatcher.OnRenamed%2A> métodos de manipulador de eventos conforme sugerido na tabela a seguir.  
  
|Manipulador de eventos|Eventos manipulados|Executa|  
|-------------------|--------------------|--------------|  
|<xref:System.IO.FileSystemWatcher.OnChanged%2A>|<xref:System.IO.FileSystemWatcher.Changed>, <xref:System.IO.FileSystemWatcher.Created>, <xref:System.IO.FileSystemWatcher.Deleted>|As alterações em atributos de arquivo, arquivos criados e excluídos arquivos de relatório.|  
|<xref:System.IO.FileSystemWatcher.OnRenamed%2A>|<xref:System.IO.FileSystemWatcher.Renamed>|Lista os novos e antigos caminhos dos arquivos renomeados e pastas, expandir recursivamente, se necessário.|  
  
## <a name="events-and-buffer-sizes"></a>Eventos e tamanhos de buffer  
 Observe que vários fatores podem afetar o sistema de arquivos de eventos de alteração são gerados, conforme descrito a seguir:  
  
-   Operações comuns de sistema de arquivos podem gerar mais de um evento. Por exemplo, quando um arquivo é movido de um diretório para outro, diversas <xref:System.IO.FileSystemWatcher.OnChanged%2A> e algumas <xref:System.IO.FileSystemWatcher.OnCreated%2A> e <xref:System.IO.FileSystemWatcher.OnDeleted%2A> eventos poderão ser gerados. Portanto, um arquivo é uma operação complexa que consiste em várias operações simples de mover, acionando vários eventos. Da mesma forma, alguns aplicativos (por exemplo, um software antivírus) podem fazer com que eventos do sistema de arquivos adicionais que são detectados pelo <xref:System.IO.FileSystemWatcher>.  
  
-   O <xref:System.IO.FileSystemWatcher> pode assistir a discos, desde que eles não são alternados ou removidos. O <xref:System.IO.FileSystemWatcher> não gera eventos para CDs e DVDs, porque não é possível alterar os carimbos de hora e propriedades. Computadores remotos devem ter uma das plataformas necessárias instaladas para o componente funcione corretamente.  
  
-   Se vários <xref:System.IO.FileSystemWatcher> objetos estão observando o mesmo caminho UNC no Windows XP Service Pack 1 antes de, ou Windows 2000 SP2 ou anterior, então somente um dos objetos será gerado um evento. Em computadores executando o Windows XP SP1 e mais recente, Windows 2000 SP3 ou mais recente ou o Windows Server 2003, todos os <xref:System.IO.FileSystemWatcher> objetos irá gerar os eventos apropriados.  
  
 Observe que um <xref:System.IO.FileSystemWatcher> poderá perder um evento quando o tamanho do buffer for excedido. Para evitar a perda de eventos, siga estas diretrizes:  
  
-   Aumentar o tamanho do buffer, definindo o <xref:System.IO.FileSystemWatcher.InternalBufferSize%2A> propriedade.  
  
-   Evite observar arquivos com nomes de arquivo longos, porque um nome de arquivo longo contribui para preencher o buffer. Considere renomear esses arquivos usando nomes mais curtos.  
  
-   Mantenha seu código mais curto possível de manipulação de eventos.  
  
   
  
## Examples  
 O exemplo a seguir cria um <xref:System.IO.FileSystemWatcher> para observar o diretório especificado em tempo de execução. O componente é definido para observar alterações em `LastWrite` e `LastAccess` a hora, a criação, exclusão, ou renomeação de arquivos de texto no diretório. Se um arquivo for alterado, criado ou excluído, o caminho para o arquivo imprime no console. Quando um arquivo é renomeado, os caminhos de novos e antigos imprimir no console.  
  
 Use o <xref:System.Diagnostics> e <xref:System.IO> namespaces para este exemplo.  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Security.Permissions.SecurityPermission">para derivar do <see cref="T:System.Diagnostics.ProcessStartInfo" /> classe. Valor de demanda: <see cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand" />; Conjuntos de permissões nomeadas: <see langword="FullTrust" />.</permission>
    <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
    <altmember cref="T:System.IO.NotifyFilters" />
    <altmember cref="T:System.IO.FileSystemEventArgs" />
    <altmember cref="T:System.IO.FileSystemEventHandler" />
    <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
    <altmember cref="P:System.IO.FileSystemWatcher.IncludeSubdirectories" />
    <altmember cref="T:System.IO.InternalBufferOverflowException" />
    <altmember cref="T:System.IO.RenamedEventArgs" />
    <altmember cref="T:System.IO.RenamedEventHandler" />
    <altmember cref="T:System.IO.WaitForChangedResult" />
    <altmember cref="T:System.IO.WatcherChangeTypes" />
    <related type="ExternalDocumentation" href="https://code.msdn.microsoft.com/Using-a-FileSystemWatcher-4bc97af4">Usando um componente FileSystemWatcher em um formulário do Windows</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.IO.FileSystemWatcher" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileSystemWatcher ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileSystemWatcher();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.IO.FileSystemWatcher" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você não é possível assistir a um computador remoto que não tenha o Windows NT ou Windows 2000. Você não é possível assistir a um computador remoto do Windows NT 4.0 em um computador Windows NT 4.0.  
  
 A tabela a seguir mostra os valores de propriedade inicial para uma instância do <xref:System.IO.FileSystemWatcher>.  
  
|Propriedade|Valor inicial|  
|--------------|-------------------|  
|<xref:System.IO.FileSystemWatcher.NotifyFilter%2A>|combinação OR bit a bit de `LastWrite`, `FileName`, e `DirectoryName`|  
|<xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A>|`false`|  
|<xref:System.IO.FileSystemWatcher.Filter%2A>|"*. \*"(Assista a todos os arquivos.)|  
|<xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A>|`false`|  
|<xref:System.IO.FileSystemWatcher.InternalBufferSize%2A>|8192|  
|<xref:System.IO.FileSystemWatcher.Path%2A>|cadeia de caracteres vazia ("")|  
  
> [!NOTE]
>  O componente não observará o diretório especificado até que o <xref:System.IO.FileSystemWatcher.Path%2A> for definido, e <xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A> é `true`.  
  
   
  
## Examples  
 O exemplo a seguir cria um <xref:System.IO.FileSystemWatcher> objeto assistir o diretório especificado em tempo de execução. O <xref:System.IO.FileSystemWatcher> observa as alterações no objeto `LastWrite` e `LastAccess` horários e para a criação, exclusão ou renomeação de texto de arquivos no diretório. Se um arquivo for alterado, criado ou excluído, o caminho para o arquivo exibe no console. Quando um arquivo é renomeado, os caminhos de novos e antigos exibem no console.  
  
 Este exemplo usa o <xref:System.Diagnostics> e <xref:System.IO> namespaces.  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <altmember cref="T:System.IO.NotifyFilters" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
        <altmember cref="T:System.IO.InternalBufferOverflowException" />
        <altmember cref="P:System.IO.FileSystemWatcher.Path" />
        <altmember cref="T:System.IO.RenamedEventArgs" />
        <altmember cref="T:System.IO.RenamedEventHandler" />
        <altmember cref="T:System.IO.WaitForChangedResult" />
        <altmember cref="T:System.IO.WatcherChangeTypes" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileSystemWatcher (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileSystemWatcher(System::String ^ path);" />
      <MemberSignature Language="F#" Value="new System.IO.FileSystemWatcher : string -&gt; System.IO.FileSystemWatcher" Usage="new System.IO.FileSystemWatcher path" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">O diretório a ser monitorado, em notação UNC (Universal Naming Convention) ou padrão.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.IO.FileSystemWatcher" />, conforme o diretório especificado para monitorar.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  O componente não observará o diretório especificado até que o <xref:System.IO.FileSystemWatcher.Path%2A> for definido, e <xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A> é `true`.  
  
 O componente pode assistir a arquivos em seu computador pessoal, uma unidade de rede ou um computador remoto.  
  
 Você não é possível assistir a um computador remoto que não tenha o Windows NT ou Windows 2000. Você não é possível assistir a um computador remoto do Windows NT 4.0 em um computador Windows NT 4.0. O <xref:System.IO.FileSystemWatcher.Filter%2A> propriedade é definida por padrão para observar todos os arquivos.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">O parâmetro <paramref name="path" /> é uma cadeia de caracteres vazia ("").  
  
- ou - 
O caminho especificado por meio do parâmetro <paramref name="path" /> não existe.</exception>
        <exception cref="T:System.IO.PathTooLongException">
          <paramref name="path" /> é muito longo.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <altmember cref="T:System.IO.NotifyFilters" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
        <altmember cref="T:System.IO.InternalBufferOverflowException" />
        <altmember cref="P:System.IO.FileSystemWatcher.Path" />
        <altmember cref="T:System.IO.RenamedEventArgs" />
        <altmember cref="T:System.IO.RenamedEventHandler" />
        <altmember cref="T:System.IO.WaitForChangedResult" />
        <altmember cref="T:System.IO.WatcherChangeTypes" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileSystemWatcher (string path, string filter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, string filter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.#ctor(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, filter As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileSystemWatcher(System::String ^ path, System::String ^ filter);" />
      <MemberSignature Language="F#" Value="new System.IO.FileSystemWatcher : string * string -&gt; System.IO.FileSystemWatcher" Usage="new System.IO.FileSystemWatcher (path, filter)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="filter" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">O diretório a ser monitorado, em notação UNC (Universal Naming Convention) ou padrão.</param>
        <param name="filter">O tipo de arquivos a ser inspecionado. Por exemplo, "*. txt" observa alterações em todos os arquivos de texto.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.IO.FileSystemWatcher" />, conforme o diretório especificado e os tipos de arquivo a se monitorar.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  O componente não observará o diretório especificado até que o <xref:System.IO.FileSystemWatcher.Path%2A> for definido, e <xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A> é `true`.  
  
 O componente pode assistir a arquivos em seu computador pessoal, uma unidade de rede ou um computador remoto.  
  
 Você não é possível assistir a um computador remoto que não tenha o Windows NT ou Windows 2000. Você não é possível assistir a um computador remoto do Windows NT 4.0 em um computador Windows NT 4.0.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="path" /> é <see langword="null" />.  
  
- ou - 
O parâmetro <paramref name="filter" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">O parâmetro <paramref name="path" /> é uma cadeia de caracteres vazia ("").  
  
- ou - 
O caminho especificado por meio do parâmetro <paramref name="path" /> não existe.</exception>
        <exception cref="T:System.IO.PathTooLongException">
          <paramref name="path" /> é muito longo.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <altmember cref="T:System.IO.NotifyFilters" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
        <altmember cref="T:System.IO.InternalBufferOverflowException" />
        <altmember cref="P:System.IO.FileSystemWatcher.Path" />
        <altmember cref="T:System.IO.RenamedEventArgs" />
        <altmember cref="T:System.IO.RenamedEventHandler" />
        <altmember cref="T:System.IO.WaitForChangedResult" />
        <altmember cref="T:System.IO.WatcherChangeTypes" />
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginInit();" />
      <MemberSignature Language="F#" Value="abstract member BeginInit : unit -&gt; unit&#xA;override this.BeginInit : unit -&gt; unit" Usage="fileSystemWatcher.BeginInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.BeginInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Inicia a inicialização de um <see cref="T:System.IO.FileSystemWatcher" /> usado em um formulário ou por outro componente. A inicialização ocorre no tempo de execução.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] design ambiente usa esse método para iniciar a inicialização de um componente usado em um formulário ou por outro componente. O <xref:System.IO.FileSystemWatcher.EndInit%2A> método encerra a inicialização. Usando o <xref:System.IO.FileSystemWatcher.BeginInit%2A> e <xref:System.IO.FileSystemWatcher.EndInit%2A> métodos impede que o controle seja usado antes de ser totalmente inicializado.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IO.FileSystemWatcher.EndInit" />
      </Docs>
    </Member>
    <Member MemberName="Changed">
      <MemberSignature Language="C#" Value="public event System.IO.FileSystemEventHandler Changed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.IO.FileSystemEventHandler Changed" />
      <MemberSignature Language="DocId" Value="E:System.IO.FileSystemWatcher.Changed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Changed As FileSystemEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::IO::FileSystemEventHandler ^ Changed;" />
      <MemberSignature Language="F#" Value="member this.Changed : System.IO.FileSystemEventHandler " Usage="member this.Changed : System.IO.FileSystemEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.IO.IODescription("Occurs when a file/directory change matches the filter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.IO.IODescription("FSW_Changed")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileSystemEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre quando um arquivo ou diretório no <see cref="P:System.IO.FileSystemWatcher.Path" /> especificado é alterado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.IO.FileSystemWatcher.Changed> é gerado quando alterações são feitas para o tamanho, atributos de sistema, da última gravação hora, hora do último acesso ou permissões de segurança de um arquivo ou diretório no diretório que está sendo monitorado.  
  
> [!NOTE]
>  Operações comuns de sistema de arquivos podem gerar mais de um evento. Por exemplo, quando um arquivo é movido de um diretório para outro, diversas <xref:System.IO.FileSystemWatcher.OnChanged%2A> e algumas <xref:System.IO.FileSystemWatcher.OnCreated%2A> e <xref:System.IO.FileSystemWatcher.OnDeleted%2A> eventos poderão ser gerados. Portanto, um arquivo é uma operação complexa que consiste em várias operações simples de mover, acionando vários eventos. Da mesma forma, alguns aplicativos (por exemplo, um software antivírus) podem fazer com que eventos do sistema de arquivos adicionais que são detectados pelo <xref:System.IO.FileSystemWatcher>.  
  
 Use <xref:System.IO.FileSystemWatcher.NotifyFilter%2A> para restringir o número de notificações gerada quando esse evento é manipulado.  
  
> [!NOTE]
>  O <xref:System.IO.FileSystemWatcher.Changed> evento é gerado inesperadamente quando um arquivo é renomeado, mas não é acionado quando um diretório é renomeado. Para assistir a renomeação, use o <xref:System.IO.FileSystemWatcher.Renamed> eventos.  
  
> [!NOTE]
>  A ordem na qual o <xref:System.IO.FileSystemWatcher.Changed> é gerado em relação a outra <xref:System.IO.FileSystemWatcher> eventos pode ser alterado quando o <xref:System.IO.FileSystemWatcher.SynchronizingObject%2A> propriedade não é `null`.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.IO.FileSystemWatcher.Changed> evento para exibir o caminho do arquivo para o console sempre que o arquivo observado é alterado.  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnChanged(System.IO.FileSystemEventArgs)" />
        <altmember cref="P:System.IO.FileSystemWatcher.SynchronizingObject" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="Created">
      <MemberSignature Language="C#" Value="public event System.IO.FileSystemEventHandler Created;" />
      <MemberSignature Language="ILAsm" Value=".event class System.IO.FileSystemEventHandler Created" />
      <MemberSignature Language="DocId" Value="E:System.IO.FileSystemWatcher.Created" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Created As FileSystemEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::IO::FileSystemEventHandler ^ Created;" />
      <MemberSignature Language="F#" Value="member this.Created : System.IO.FileSystemEventHandler " Usage="member this.Created : System.IO.FileSystemEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.IO.IODescription("Occurs when a file/directory creation matches the filter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.IO.IODescription("FSW_Created")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileSystemEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre quando um arquivo ou diretório no <see cref="P:System.IO.FileSystemWatcher.Path" /> especificado é criado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Algumas ocorrências comuns, como copiar ou mover um arquivo ou diretório, não correspondem diretamente a um evento, mas essas ocorrências fazem com que eventos a serem gerados. Quando você copia um arquivo ou diretório, o sistema gera um <xref:System.IO.FileSystemWatcher.Created> eventos no diretório ao qual o arquivo foi copiado, se esse diretório está sendo observado. Se o diretório do qual você copiou estava sendo observado por outra instância do <xref:System.IO.FileSystemWatcher>, nenhum evento seria criado. Por exemplo, crie duas instâncias de <xref:System.IO.FileSystemWatcher>. FileSystemWatcher1 é definido como assistir "C:\My documentos" e FileSystemWatcher2 é definido como assistir "C:\Your documentos". Se você copiar um arquivo de "Meus documentos" em "Your documentos", um <xref:System.IO.FileSystemWatcher.Created> evento será acionado pela FileSystemWatcher2, mas nenhum evento é gerado para FileSystemWatcher1. Ao contrário de copiar, mover um arquivo ou diretório aumentaria dois eventos. Do exemplo anterior, se você tiver movido um arquivo de "Meus documentos" para "Your documentos", uma <xref:System.IO.FileSystemWatcher.Created> evento teria gerado pelo FileSystemWatcher2 e um <xref:System.IO.FileSystemWatcher.Deleted> evento teria gerado pelo FileSystemWatcher1.  
  
> [!NOTE]
>  Operações comuns de sistema de arquivos podem gerar mais de um evento. Por exemplo, quando um arquivo é movido de um diretório para outro, diversas <xref:System.IO.FileSystemWatcher.OnChanged%2A> e algumas <xref:System.IO.FileSystemWatcher.OnCreated%2A> e <xref:System.IO.FileSystemWatcher.OnDeleted%2A> eventos poderão ser gerados. Portanto, um arquivo é uma operação complexa que consiste em várias operações simples de mover, acionando vários eventos. Da mesma forma, alguns aplicativos (por exemplo, um software antivírus) podem fazer com que eventos do sistema de arquivos adicionais que são detectados pelo <xref:System.IO.FileSystemWatcher>.  
  
> [!NOTE]
>  A ordem na qual o <xref:System.IO.FileSystemWatcher.Created> é gerado em relação a outra <xref:System.IO.FileSystemWatcher> eventos pode ser alterado quando o <xref:System.IO.FileSystemWatcher.SynchronizingObject%2A> propriedade não é `null`.  
  
 O <xref:System.IO.FileSystemWatcher.OnCreated%2A> é gerado assim que um arquivo é criado. Se um arquivo está sendo copiado ou transferidos para um diretório observado, os <xref:System.IO.FileSystemWatcher.OnCreated%2A> evento será gerado imediatamente, seguido por um ou mais <xref:System.IO.FileSystemWatcher.OnChanged%2A> eventos.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.IO.FileSystemWatcher.Created> evento para exibir o caminho do arquivo para o console sempre que o arquivo observado é criado.  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.IO.FileSystemWatcher.Deleted" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnDeleted(System.IO.FileSystemEventArgs)" />
        <altmember cref="P:System.IO.FileSystemWatcher.SynchronizingObject" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnCreated(System.IO.FileSystemEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="Deleted">
      <MemberSignature Language="C#" Value="public event System.IO.FileSystemEventHandler Deleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.IO.FileSystemEventHandler Deleted" />
      <MemberSignature Language="DocId" Value="E:System.IO.FileSystemWatcher.Deleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Deleted As FileSystemEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::IO::FileSystemEventHandler ^ Deleted;" />
      <MemberSignature Language="F#" Value="member this.Deleted : System.IO.FileSystemEventHandler " Usage="member this.Deleted : System.IO.FileSystemEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.IO.IODescription("Occurs when a file/directory deletion matches the filter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.IO.IODescription("FSW_Deleted")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileSystemEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre quando um arquivo ou diretório no <see cref="P:System.IO.FileSystemWatcher.Path" /> especificado é excluído.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Algumas ocorrências comuns, como copiar ou mover um arquivo ou diretório, não correspondem diretamente a um evento, mas essas ocorrências fazem com que eventos a serem gerados. Quando você copia um arquivo ou diretório, o sistema gera um <xref:System.IO.FileSystemWatcher.Created> eventos no diretório ao qual o arquivo foi copiado, se esse diretório está sendo observado. Se o diretório do qual você copiou estava sendo observado por outra instância do <xref:System.IO.FileSystemWatcher>, nenhum evento seria criado. Por exemplo, crie duas instâncias de <xref:System.IO.FileSystemWatcher>. FileSystemWatcher1 é definido como assistir "C:\My documentos" e FileSystemWatcher2 é definido como assistir "C:\Your documentos". Se você copiar um arquivo de "Meus documentos" em "Your documentos", um <xref:System.IO.FileSystemWatcher.Created> evento será acionado pela FileSystemWatcher2, mas nenhum evento é gerado para FileSystemWatcher1. Ao contrário de copiar, mover um arquivo ou diretório aumentaria dois eventos. Do exemplo anterior, se você tiver movido um arquivo de "Meus documentos" para "Your documentos", uma <xref:System.IO.FileSystemWatcher.Created> evento teria gerado pelo FileSystemWatcher2 e um <xref:System.IO.FileSystemWatcher.Deleted> evento teria gerado pelo FileSystemWatcher1.  
  
> [!NOTE]
>  Operações comuns de sistema de arquivos podem gerar mais de um evento. Por exemplo, quando um arquivo é movido de um diretório para outro, diversas <xref:System.IO.FileSystemWatcher.OnChanged%2A> e algumas <xref:System.IO.FileSystemWatcher.OnCreated%2A> e <xref:System.IO.FileSystemWatcher.OnDeleted%2A> eventos poderão ser gerados. Portanto, um arquivo é uma operação complexa que consiste em várias operações simples de mover, acionando vários eventos. Da mesma forma, alguns aplicativos (por exemplo, um software antivírus) podem fazer com que eventos do sistema de arquivos adicionais que são detectados pelo <xref:System.IO.FileSystemWatcher>.  
  
> [!NOTE]
>  A ordem na qual o <xref:System.IO.FileSystemWatcher.Deleted> é gerado em relação a outra <xref:System.IO.FileSystemWatcher> eventos pode ser alterado quando o <xref:System.IO.FileSystemWatcher.SynchronizingObject%2A> propriedade não é `null`.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.IO.FileSystemWatcher.Deleted> evento para exibir o caminho do arquivo para o console sempre que o arquivo observado é excluído.  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.IO.FileSystemWatcher.Created" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnCreated(System.IO.FileSystemEventArgs)" />
        <altmember cref="P:System.IO.FileSystemWatcher.SynchronizingObject" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnDeleted(System.IO.FileSystemEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public virtual void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="override this.Dispose : unit -&gt; unit" Usage="fileSystemWatcher.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="fileSystemWatcher.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> para liberar recursos gerenciados e não gerenciados; <see langword="false" /> para liberar apenas recursos não gerenciados.</param>
        <summary>Libera os recursos não gerenciados usados pelo <see cref="T:System.IO.FileSystemWatcher" /> e opcionalmente libera os recursos gerenciados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método é chamado pelo método público <xref:System.ComponentModel.Component.Dispose%2A> e pelo método <xref:System.Object.Finalize%2A>. <xref:System.ComponentModel.Component.Dispose%2A> invoca o método <xref:System.IO.FileSystemWatcher.Dispose%2A> protegido com o parâmetro `disposing` definido como `true`. <xref:System.Object.Finalize%2A> invoca <xref:System.IO.FileSystemWatcher.Dispose%2A> com `disposing` definido como `false`.  
  
 Quando o `disposing` parâmetro é `true`, esse método libera todos os recursos mantidos por qualquer objeto gerenciado que este <xref:System.IO.Compression.DeflateStream> referências. Este método invoca o método <xref:System.ComponentModel.Component.Dispose%2A> de cada objeto referenciado.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see cref="M:System.ComponentModel.Component.Dispose" /> pode ser chamado várias vezes por outros objetos. Ao substituir <see cref="M:System.IO.FileSystemWatcher.Dispose(System.Boolean)" /> tenha cuidado para não referenciar objetos que tenham sido descartados anteriormente em uma chamada anterior para <see cref="M:System.ComponentModel.Component.Dispose" />. Para obter mais informações sobre como implementar <see cref="M:System.IO.FileSystemWatcher.Dispose(System.Boolean)" />, consulte [implementando um método Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
Para obter mais informações sobre <see cref="M:System.ComponentModel.Component.Dispose" /> e <see cref="M:System.Object.Finalize" />, consulte [limpeza de recursos não gerenciados](~/docs/standard/garbage-collection/unmanaged.md).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="EnableRaisingEvents">
      <MemberSignature Language="C#" Value="public bool EnableRaisingEvents { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableRaisingEvents" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.EnableRaisingEvents" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableRaisingEvents As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableRaisingEvents { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableRaisingEvents : bool with get, set" Usage="System.IO.FileSystemWatcher.EnableRaisingEvents" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.IO.IODescription("Flag to indicate if this instance is active")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.IO.IODescription("FSW_Enabled")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica se o componente está habilitado.</summary>
        <value>
          <see langword="true" /> se o componente estiver habilitado; caso contrário, <see langword="false" />. O padrão é <see langword="false" />. Se você estiver usando o componente em um designer no [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)], o padrão é <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O componente não irá gerar eventos, a menos que você definir <xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A> para `true`.  
  
> [!NOTE]
>  O componente não observará o diretório especificado até que o <xref:System.IO.FileSystemWatcher.Path%2A> propriedade foi definida e <xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A> é `true`.  
  
 O <xref:System.IO.FileSystemWatcher.WaitForChanged%2A> método permite que os manipuladores de eventos a ser invocado para responder às alterações de arquivo, mesmo se essa propriedade é definida como `false`.  
  
   
  
## Examples  
 O exemplo a seguir cria um <xref:System.IO.FileSystemWatcher> para observar o diretório especificado em tempo de execução. O componente é definido para observar alterações em `LastWrite` e `LastAccess` a hora, a criação, exclusão, ou renomeação de arquivos de texto no diretório. Se um arquivo for alterado, criado ou excluído, o caminho para o arquivo imprime no console. Quando um arquivo é renomeado, os caminhos de novos e antigos imprimir no console.  
  
 Use o <xref:System.Diagnostics> e <xref:System.IO> namespaces para este exemplo.  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">O objeto <see cref="T:System.IO.FileSystemWatcher" /> foi descartado.</exception>
        <exception cref="T:System.PlatformNotSupportedException">O sistema operacional atual não é o Microsoft Windows NT ou posterior.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Não foi possível encontrar o diretório especificado em <see cref="P:System.IO.FileSystemWatcher.Path" />.</exception>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.IO.FileSystemWatcher.Path" /> não foi definido ou é inválido.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndInit();" />
      <MemberSignature Language="F#" Value="abstract member EndInit : unit -&gt; unit&#xA;override this.EndInit : unit -&gt; unit" Usage="fileSystemWatcher.EndInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.EndInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Encerra a inicialização de um <see cref="T:System.IO.FileSystemWatcher" /> usado em um formulário ou por outro componente. A inicialização ocorre no tempo de execução.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] design ambiente usa esse método para terminar a inicialização de um componente usado em um formulário ou por outro componente. O <xref:System.IO.FileSystemWatcher.BeginInit%2A> método começa a inicialização. Usando o <xref:System.IO.FileSystemWatcher.BeginInit%2A> e <xref:System.IO.FileSystemWatcher.EndInit%2A> métodos impede que o controle seja usado antes de ser totalmente inicializado.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IO.FileSystemWatcher.BeginInit" />
      </Docs>
    </Member>
    <Member MemberName="Error">
      <MemberSignature Language="C#" Value="public event System.IO.ErrorEventHandler Error;" />
      <MemberSignature Language="ILAsm" Value=".event class System.IO.ErrorEventHandler Error" />
      <MemberSignature Language="DocId" Value="E:System.IO.FileSystemWatcher.Error" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Error As ErrorEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::IO::ErrorEventHandler ^ Error;" />
      <MemberSignature Language="F#" Value="member this.Error : System.IO.ErrorEventHandler " Usage="member this.Error : System.IO.ErrorEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.ErrorEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre quando a instância de <see cref="T:System.IO.FileSystemWatcher" /> não pode continuar a monitorar alterações ou quando o buffer interno estoura.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse evento é gerado sempre que algo impede que o <xref:System.IO.FileSystemWatcher> objeto de monitoramento de alterações. Por exemplo, se o objeto está monitorando as alterações em um diretório remoto e a conexão para esse diretório é perdido, o <xref:System.IO.FileSystemWatcher.Error> é gerado.  
  
 O sistema notifica você sobre alterações de arquivo e armazena essas alterações em um buffer que o componente cria e passa para as APIs. Se houver muitas alterações em um curto período, o buffer pode estourar. Isso faz com que o componente de perder o controle de alterações no diretório e ele apenas fornecerá notificação amplas. Aumentar o tamanho do buffer é cara, porque se trata de não paginável memória que não pode ser trocada por disco, portanto, mantenha o buffer o menor possível. Para evitar um estouro de buffer, use o <xref:System.IO.FileSystemWatcher.NotifyFilter%2A>, <xref:System.IO.FileSystemWatcher.Filter%2A>, e <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A> as notificações de alteração de propriedades para filtrar indesejados.  
  
> [!NOTE]
>  Operações comuns de sistema de arquivos podem gerar mais de um evento. Por exemplo, quando um arquivo é movido de um diretório para outro, diversas <xref:System.IO.FileSystemWatcher.OnChanged%2A> e algumas <xref:System.IO.FileSystemWatcher.OnCreated%2A> e <xref:System.IO.FileSystemWatcher.OnDeleted%2A> eventos poderão ser gerados. Portanto, um arquivo é uma operação complexa que consiste em várias operações simples de mover, acionando vários eventos. Da mesma forma, alguns aplicativos (por exemplo, um software antivírus) podem fazer com que eventos do sistema de arquivos adicionais que são detectados pelo <xref:System.IO.FileSystemWatcher>.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
        <altmember cref="T:System.IO.ErrorEventArgs" />
        <altmember cref="T:System.IO.ErrorEventHandler" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
        <altmember cref="P:System.IO.FileSystemWatcher.IncludeSubdirectories" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnError(System.IO.ErrorEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="Filter">
      <MemberSignature Language="C#" Value="public string Filter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Filter" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.Filter" />
      <MemberSignature Language="VB.NET" Value="Public Property Filter As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Filter { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Filter : string with get, set" Usage="System.IO.FileSystemWatcher.Filter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue("*.*")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.IO.IODescription("File name filter pattern")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.IO.IODescription("FSW_Filter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8">
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define a cadeia de caracteres de filtro usada para determinar quais arquivos são monitorados em um diretório.</summary>
        <value>Cadeia de caracteres de filtro. O padrão é "*. \*"(Inspeciona todos os arquivos.)</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para assistir a alterações em todos os arquivos, defina o <xref:System.IO.FileSystemWatcher.Filter%2A> propriedade como uma cadeia de caracteres vazia (""). Para assistir a um arquivo específico, defina o <xref:System.IO.FileSystemWatcher.Filter%2A> propriedade para o nome do arquivo. Por exemplo, para aguardar as alterações no arquivo doc, defina o <xref:System.IO.FileSystemWatcher.Filter%2A> propriedade como "Doc". Você também pode observar alterações em um determinado tipo de arquivo. Por exemplo, para observar alterações em quaisquer arquivos de texto, defina o <xref:System.IO.FileSystemWatcher.Filter%2A> propriedade como "*. txt". Uso de vários filtros, como "\*. txt&#124;\*. doc" não tem suporte.  
  
 O <xref:System.IO.FileSystemWatcher.Filter%2A> propriedade pode ser alterada após o <xref:System.IO.FileSystemWatcher> objeto foi iniciada com o recebimento de eventos.  
  
 Para obter mais informações sobre a filtragem de notificações indesejadas, consulte a <xref:System.IO.FileSystemWatcher.NotifyFilter%2A>, <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A>, e <xref:System.IO.FileSystemWatcher.InternalBufferSize%2A> propriedades.  
  
 <xref:System.IO.FileSystemWatcher.Filter%2A> aceita caracteres curinga para arquivos correspondentes, conforme mostrado nos exemplos a seguir.  
  
|Cadeia de caracteres de filtro|Observa os arquivos a seguir|  
|-------------------|---------------------------------|  
|*.\*|Todos os arquivos (padrão). Uma cadeia de caracteres vazia ("") também inspeciona todos os arquivos.|  
|*.txt|Todos os arquivos com uma extensão "txt".|  
|*recipe.doc|Todos os arquivos que terminam em "receita" com uma extensão "doc".|  
|win*.xml|Todos os arquivos que começam com "win" com a extensão "xml".|  
|Vendas * 200?. xls|Corresponda ao seguinte:<br /><br /> Julho de vendas 2001.xlsSales ago 2002.xlsSales março 2004.xls<br /><br /> mas não corresponde:<br /><br /> 1999.xls de vendas de novembro|  
|MyReport.Doc|Observa MyReport somente|  
  
   
  
## Examples  
 O exemplo a seguir cria um <xref:System.IO.FileSystemWatcher> para observar o diretório especificado em tempo de execução. O componente é definido para observar alterações em `LastWrite` e `LastAccess` a hora, a criação, exclusão, ou renomeação de arquivos de texto no diretório. Se um arquivo for alterado, criado ou excluído, o caminho para o arquivo imprime no console. Quando um arquivo é renomeado, os caminhos de novos e antigos imprimir no console.  
  
 Use o <xref:System.Diagnostics> e <xref:System.IO> namespaces para este exemplo.  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
        <altmember cref="P:System.IO.FileSystemWatcher.IncludeSubdirectories" />
        <altmember cref="P:System.IO.FileSystemWatcher.InternalBufferSize" />
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~FileSystemWatcher ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!FileSystemWatcher ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="fileSystemWatcher.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IncludeSubdirectories">
      <MemberSignature Language="C#" Value="public bool IncludeSubdirectories { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IncludeSubdirectories" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.IncludeSubdirectories" />
      <MemberSignature Language="VB.NET" Value="Public Property IncludeSubdirectories As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IncludeSubdirectories { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IncludeSubdirectories : bool with get, set" Usage="System.IO.FileSystemWatcher.IncludeSubdirectories" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.IO.IODescription("Flag to indicate we want to watch subdirectories")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.IO.IODescription("FSW_IncludeSubdirectories")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica se as subpastas no caminho especificado devem ser monitoradas.</summary>
        <value>
          <see langword="true" /> se você quiser monitorar subdiretórios; caso contrário, <see langword="false" />. O padrão é <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Definir <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A> para `true` quando você deseja assistir as notificações de alteração para arquivos e diretórios contidos no diretório especificado por meio de <xref:System.IO.FileSystemWatcher.Path%2A> propriedade e seus subdiretórios. Definindo o <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A> propriedade para `false` ajuda a reduzir o número de notificações enviadas para o buffer interno. Para obter mais informações sobre filtragem de notificações indesejadas, consulte a <xref:System.IO.FileSystemWatcher.NotifyFilter%2A> e <xref:System.IO.FileSystemWatcher.InternalBufferSize%2A> propriedades.  
  
 Quando `true`, <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A> é recursiva através da árvore inteira sub, não apenas os diretórios filho imediatos. Retorna o caminho relativo para um arquivo ou diretório dentro da árvore sub a <xref:System.IO.FileSystemEventArgs.Name%2A> propriedade de <xref:System.IO.FileSystemEventArgs> e o <xref:System.IO.RenamedEventArgs.OldName%2A> propriedade do <xref:System.IO.RenamedEventArgs>, dependendo das alterações que você está observando para. Você pode obter o caminho totalmente qualificado do <xref:System.IO.FileSystemEventArgs.FullPath%2A> propriedade de <xref:System.IO.FileSystemEventArgs> e o <xref:System.IO.RenamedEventArgs.OldFullPath%2A> propriedade <xref:System.IO.RenamedEventArgs>, dependendo das alterações que você está observando para.  
  
 Se um diretório é criado na árvore do diretório que você está observando, sub e <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A> é `true`, esse diretório automaticamente será observado.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
        <altmember cref="P:System.IO.FileSystemEventArgs.FullPath" />
        <altmember cref="P:System.IO.RenamedEventArgs.OldFullPath" />
        <altmember cref="P:System.IO.FileSystemWatcher.InternalBufferSize" />
        <altmember cref="P:System.IO.FileSystemEventArgs.Name" />
        <altmember cref="P:System.IO.RenamedEventArgs.OldName" />
        <altmember cref="P:System.IO.FileSystemWatcher.Path" />
        <altmember cref="T:System.IO.RenamedEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="InternalBufferSize">
      <MemberSignature Language="C#" Value="public int InternalBufferSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 InternalBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.InternalBufferSize" />
      <MemberSignature Language="VB.NET" Value="Public Property InternalBufferSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int InternalBufferSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.InternalBufferSize : int with get, set" Usage="System.IO.FileSystemWatcher.InternalBufferSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(8192)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o tamanho (em bytes) do buffer interno.</summary>
        <value>O tamanho do buffer interno em bytes. O padrão é 8192 (8 KB).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você pode definir o buffer de 4 KB ou maior, mas ele não deve exceder 64 KB. Se você tentar definir a <xref:System.IO.FileSystemWatcher.InternalBufferSize%2A> propriedade para menos de 4096 bytes, o valor será descartada e o <xref:System.IO.FileSystemWatcher.InternalBufferSize%2A> estiver definida como 4096 bytes. Para obter melhor desempenho, use um múltiplo de 4 KB em computadores baseados em Intel.  
  
 O sistema notifica o componente das alterações de arquivo e armazena essas alterações em um buffer que o componente cria e passa para as APIs. Cada evento pode usar até 16 bytes de memória, não incluindo o nome do arquivo. Se houver muitas alterações em um curto período, o buffer pode estourar. Isso faz com que o componente de perder o controle de alterações no diretório e ele apenas fornecerá notificação amplas. Aumentar o tamanho do buffer pode impedir que eventos de alteração do sistema de arquivo ausente. No entanto, aumentar o tamanho do buffer é cara, porque se trata da memória não paginável que não pode ser trocada por disco, portanto, manter o buffer o menor possível. Para evitar um estouro de buffer, use o <xref:System.IO.FileSystemWatcher.NotifyFilter%2A> e <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A> as notificações de alteração de propriedades para filtrar indesejados.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnError(System.IO.ErrorEventArgs)" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
        <altmember cref="P:System.IO.FileSystemWatcher.IncludeSubdirectories" />
        <altmember cref="T:System.IO.InternalBufferOverflowException" />
      </Docs>
    </Member>
    <Member MemberName="NotifyFilter">
      <MemberSignature Language="C#" Value="public System.IO.NotifyFilters NotifyFilter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.NotifyFilters NotifyFilter" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.NotifyFilter" />
      <MemberSignature Language="VB.NET" Value="Public Property NotifyFilter As NotifyFilters" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::NotifyFilters NotifyFilter { System::IO::NotifyFilters get(); void set(System::IO::NotifyFilters value); };" />
      <MemberSignature Language="F#" Value="member this.NotifyFilter : System.IO.NotifyFilters with get, set" Usage="System.IO.FileSystemWatcher.NotifyFilter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.IO.IODescription("Flag to indicate which change event we want to monitor")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.IO.IODescription("FSW_ChangedFilter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.NotifyFilters</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o tipo de alterações a serem observadas.</summary>
        <value>Um dos valores de <see cref="T:System.IO.NotifyFilters" />. O padrão é a combinação OR bit a bit de <see langword="LastWrite" />, <see langword="FileName" /> e <see langword="DirectoryName" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você pode combinar os membros do <xref:System.IO.NotifyFilters> enumeração para assistir a mais de um tipo de alteração por vez. Por exemplo, você pode assistir para alterações no tamanho de um arquivo e alterações no `LastWrite` tempo. Isso gera um evento sempre que houver uma alteração no tamanho do arquivo ou pasta ou uma alteração no `LastWrite` hora do arquivo ou pasta.  
  
 Essa é uma maneira para filtrar notificações indesejadas. Para obter mais informações sobre filtragem de notificações indesejadas, consulte a <xref:System.IO.FileSystemWatcher.Filter%2A>, <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A>, e <xref:System.IO.FileSystemWatcher.InternalBufferSize%2A> propriedades.  
  
   
  
## Examples  
 O exemplo a seguir cria um <xref:System.IO.FileSystemWatcher> para observar o diretório especificado em tempo de execução. O componente é definido para observar alterações em `LastWrite` e `LastAccess` a hora, a criação, exclusão, ou renomeação de arquivos de texto no diretório. Se um arquivo for alterado, criado ou excluído, o caminho para o arquivo imprime no console. Quando um arquivo é renomeado, os caminhos de novos e antigos imprimir no console.  
  
 Use o <xref:System.Diagnostics> e <xref:System.IO> namespaces para este exemplo.  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O valor não é uma combinação OR bit a bit válida dos valores <see cref="T:System.IO.NotifyFilters" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">O valor que está sendo definido não é válido.</exception>
        <altmember cref="T:System.IO.NotifyFilters" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
        <altmember cref="P:System.IO.FileSystemWatcher.IncludeSubdirectories" />
        <altmember cref="P:System.IO.FileSystemWatcher.InternalBufferSize" />
      </Docs>
    </Member>
    <Member MemberName="OnChanged">
      <MemberSignature Language="C#" Value="protected void OnChanged (System.IO.FileSystemEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnChanged(class System.IO.FileSystemEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.OnChanged(System.IO.FileSystemEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnChanged (e As FileSystemEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnChanged(System::IO::FileSystemEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.OnChanged : System.IO.FileSystemEventArgs -&gt; unit" Usage="fileSystemWatcher.OnChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.IO.FileSystemEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Um <see cref="T:System.IO.FileSystemEventArgs" /> que contém os dados do evento.</param>
        <summary>Aciona o evento <see cref="E:System.IO.FileSystemWatcher.Changed" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileSystemWatcher.OnChanged%2A> é chamado quando forem feitas alterações ao tamanho, atributos de sistema, última hora de gravação, hora do último acesso ou permissões de segurança de um arquivo ou diretório no diretório que está sendo monitorado.  
  
 Use o <xref:System.IO.FileSystemWatcher.NotifyFilter%2A> propriedade para restringir o número de eventos gerado quando o <xref:System.IO.FileSystemWatcher.Changed> evento é manipulado.  
  
 O <xref:System.IO.FileSystemWatcher.OnCreated%2A> é gerado assim que um arquivo é criado. Se um arquivo está sendo copiado ou transferidos para um diretório observado, os <xref:System.IO.FileSystemWatcher.OnCreated%2A> evento será gerado imediatamente, seguido por um ou mais <xref:System.IO.FileSystemWatcher.OnChanged%2A> eventos.  
  
 A geração de um evento invoca o manipulador de eventos por meio de um delegado. Para obter mais informações, consulte [tratando e gerando eventos](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Ao substituir <see cref="M:System.IO.FileSystemWatcher.OnChanged(System.IO.FileSystemEventArgs)" /> em uma classe derivada, certifique-se de chamar a classe base <see cref="M:System.IO.FileSystemWatcher.OnChanged(System.IO.FileSystemEventArgs)" /> método.</para>
        </block>
        <altmember cref="E:System.IO.FileSystemWatcher.Changed" />
        <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="OnCreated">
      <MemberSignature Language="C#" Value="protected void OnCreated (System.IO.FileSystemEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnCreated(class System.IO.FileSystemEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.OnCreated(System.IO.FileSystemEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnCreated (e As FileSystemEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnCreated(System::IO::FileSystemEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.OnCreated : System.IO.FileSystemEventArgs -&gt; unit" Usage="fileSystemWatcher.OnCreated e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.IO.FileSystemEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Um <see cref="T:System.IO.FileSystemEventArgs" /> que contém os dados do evento.</param>
        <summary>Aciona o evento <see cref="E:System.IO.FileSystemWatcher.Created" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileSystemWatcher.OnCreated%2A> é chamado quando um arquivo ou diretório é criado no diretório que está sendo monitorado.  
  
 Algumas ocorrências comuns, como copiar ou mover um arquivo ou diretório, não correspondem diretamente a um evento, mas essas ocorrências fazem com que eventos a serem gerados. Quando você copia um arquivo ou diretório, o sistema gera um <xref:System.IO.FileSystemWatcher.Created> eventos no diretório ao qual o arquivo foi copiado, se esse diretório está sendo observado. Se o diretório do qual você copiou estava sendo observado por outra instância do <xref:System.IO.FileSystemWatcher>, nenhum evento seria criado. Por exemplo, crie duas instâncias de <xref:System.IO.FileSystemWatcher>. FileSystemWatcher1 é definido como assistir "C:\My documentos" e FileSystemWatcher2 é definido como assistir "C:\Your documentos". Se você copiar um arquivo de "Meus documentos" e cole-o em "Your documentos", um <xref:System.IO.FileSystemWatcher.Created> evento será gerado no FileSystemWatcher2, mas nenhum evento é gerado para FileSystemWatcher1. Ao contrário de copiar, mover um arquivo ou diretório gera dois eventos. Do exemplo anterior, se você tiver movido um arquivo de "Meus documentos" para "Your documentos", uma <xref:System.IO.FileSystemWatcher.Created> evento teria gerado no FileSystemWatcher2 e um <xref:System.IO.FileSystemWatcher.Deleted> evento teria gerado no FileSystemWatcher1.  
  
 O <xref:System.IO.FileSystemWatcher.OnCreated%2A> é gerado assim que um arquivo é criado. Se um arquivo está sendo copiado ou transferidos para um diretório observado, os <xref:System.IO.FileSystemWatcher.OnCreated%2A> evento será gerado imediatamente, seguido por um ou mais <xref:System.IO.FileSystemWatcher.OnChanged%2A> eventos.  
  
 A geração de um evento invoca o manipulador de eventos por meio de um delegado. Para obter mais informações, consulte [tratando e gerando eventos](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Ao substituir <see cref="M:System.IO.FileSystemWatcher.OnCreated(System.IO.FileSystemEventArgs)" /> em uma classe derivada, certifique-se de chamar a classe base <see cref="M:System.IO.FileSystemWatcher.OnCreated(System.IO.FileSystemEventArgs)" /> método.</para>
        </block>
        <altmember cref="E:System.IO.FileSystemWatcher.Created" />
        <altmember cref="E:System.IO.FileSystemWatcher.Deleted" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="OnDeleted">
      <MemberSignature Language="C#" Value="protected void OnDeleted (System.IO.FileSystemEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnDeleted(class System.IO.FileSystemEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.OnDeleted(System.IO.FileSystemEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnDeleted (e As FileSystemEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnDeleted(System::IO::FileSystemEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.OnDeleted : System.IO.FileSystemEventArgs -&gt; unit" Usage="fileSystemWatcher.OnDeleted e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.IO.FileSystemEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Um <see cref="T:System.IO.FileSystemEventArgs" /> que contém os dados do evento.</param>
        <summary>Aciona o evento <see cref="E:System.IO.FileSystemWatcher.Deleted" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileSystemWatcher.OnDeleted%2A> é chamado quando um arquivo ou diretório dentro do diretório que está sendo monitorado, é excluído.  
  
 Algumas ocorrências comuns, como copiar ou mover um arquivo ou diretório, não correspondem diretamente a um evento, mas essas ocorrências fazem com que eventos a serem gerados. Quando você copia um arquivo ou diretório, o sistema gera um <xref:System.IO.FileSystemWatcher.Created> eventos no diretório ao qual o arquivo foi copiado, se esse diretório está sendo observado. Se o diretório do qual você copiou estava sendo observado por outra instância do <xref:System.IO.FileSystemWatcher>, nenhum evento seria criado. Por exemplo, crie duas instâncias de <xref:System.IO.FileSystemWatcher>. FileSystemWatcher1 é definido como assistir "C:\My documentos" e FileSystemWatcher2 é definido como assistir "C:\Your documentos". Se você copiar um arquivo de "Meus documentos" em "Your documentos", um <xref:System.IO.FileSystemWatcher.Created> evento será acionado pela FileSystemWatcher2, mas nenhum evento é gerado para FileSystemWatcher1. Ao contrário de copiar, mover um arquivo ou diretório gera dois eventos. Do exemplo anterior, se você tiver movido um arquivo de "Meus documentos" para "Your documentos", uma <xref:System.IO.FileSystemWatcher.Created> evento teria gerado pelo FileSystemWatcher2 e um <xref:System.IO.FileSystemWatcher.Deleted> evento teria gerado pelo FileSystemWatcher1.  
  
 A geração de um evento invoca o manipulador de eventos por meio de um delegado. Para obter mais informações, consulte [tratando e gerando eventos](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Ao substituir <see cref="M:System.IO.FileSystemWatcher.OnDeleted(System.IO.FileSystemEventArgs)" /> em uma classe derivada, certifique-se de chamar a classe base <see cref="M:System.IO.FileSystemWatcher.OnDeleted(System.IO.FileSystemEventArgs)" /> método.</para>
        </block>
        <altmember cref="E:System.IO.FileSystemWatcher.Created" />
        <altmember cref="E:System.IO.FileSystemWatcher.Deleted" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="OnError">
      <MemberSignature Language="C#" Value="protected void OnError (System.IO.ErrorEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnError(class System.IO.ErrorEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.OnError(System.IO.ErrorEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnError (e As ErrorEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnError(System::IO::ErrorEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.OnError : System.IO.ErrorEventArgs -&gt; unit" Usage="fileSystemWatcher.OnError e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.IO.ErrorEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Um <see cref="T:System.IO.ErrorEventArgs" /> que contém os dados do evento.</param>
        <summary>Aciona o evento <see cref="E:System.IO.FileSystemWatcher.Error" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileSystemWatcher.OnError%2A> é chamado quando ocorre um erro.  
  
 A geração de um evento invoca o manipulador de eventos por meio de um delegado. Para obter mais informações, consulte [tratando e gerando eventos](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Ao substituir <see cref="M:System.IO.FileSystemWatcher.OnError(System.IO.ErrorEventArgs)" /> em uma classe derivada, certifique-se de chamar a classe base <see cref="M:System.IO.FileSystemWatcher.OnError(System.IO.ErrorEventArgs)" /> método.</para>
        </block>
        <altmember cref="E:System.IO.FileSystemWatcher.Error" />
        <altmember cref="T:System.IO.ErrorEventArgs" />
        <altmember cref="T:System.IO.ErrorEventHandler" />
        <altmember cref="T:System.IO.InternalBufferOverflowException" />
      </Docs>
    </Member>
    <Member MemberName="OnRenamed">
      <MemberSignature Language="C#" Value="protected void OnRenamed (System.IO.RenamedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnRenamed(class System.IO.RenamedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.OnRenamed(System.IO.RenamedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnRenamed (e As RenamedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnRenamed(System::IO::RenamedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.OnRenamed : System.IO.RenamedEventArgs -&gt; unit" Usage="fileSystemWatcher.OnRenamed e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.IO.RenamedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Um <see cref="T:System.IO.RenamedEventArgs" /> que contém os dados do evento.</param>
        <summary>Aciona o evento <see cref="E:System.IO.FileSystemWatcher.Renamed" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileSystemWatcher.OnRenamed%2A> é chamado quando um arquivo ou diretório dentro do diretório que está sendo monitorado é renomeado. Seu <xref:System.IO.RenamedEventArgs> argumento contém informações sobre a operação de renomeação, como o tipo de alteração, o caminho antigo e novo e o nome antigo e novo. Observe que seu <xref:System.IO.FileSystemEventArgs.Name> propriedade pode ser nula para renomeado eventos se o <xref:System.IO.FileSystemWatcher> não obter nome antigo e novo eventos correspondentes do sistema operacional. 
  
 A geração de um evento invoca o manipulador de eventos por meio de um delegado. Para obter mais informações, consulte [tratando e gerando eventos](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Ao substituir <see cref="M:System.IO.FileSystemWatcher.OnRenamed(System.IO.RenamedEventArgs)" /> em uma classe derivada, certifique-se de chamar a classe base <see cref="M:System.IO.FileSystemWatcher.OnRenamed(System.IO.RenamedEventArgs)" /> método.</para>
        </block>
        <altmember cref="E:System.IO.FileSystemWatcher.Renamed" />
        <altmember cref="T:System.IO.RenamedEventArgs" />
        <altmember cref="T:System.IO.RenamedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="Path">
      <MemberSignature Language="C#" Value="public string Path { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Path" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.Path" />
      <MemberSignature Language="VB.NET" Value="Public Property Path As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Path { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Path : string with get, set" Usage="System.IO.FileSystemWatcher.Path" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Editor("System.Diagnostics.Design.FSWPathEditor, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.IO.IODescription("The directory to monitor")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.Editor("System.Diagnostics.Design.FSWPathEditor, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.IO.IODescription("FSW_Path")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.Editor("System.Diagnostics.Design.FSWPathEditor, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8">
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o caminho do diretório a ser inspecionado.</summary>
        <value>O caminho a ser monitorado. O padrão é uma cadeia de caracteres vazia ("").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Isso é um caminho totalmente qualificado para um diretório. Se o <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A> é de propriedade `true`, esse diretório é a raiz no qual o sistema observa alterações; caso contrário, é o único diretório observado. Para assistir a um arquivo específico, defina as <xref:System.IO.FileSystemWatcher.Path%2A> propriedade para o diretório correto, totalmente qualificado e o <xref:System.IO.FileSystemWatcher.Filter%2A> propriedade para o nome do arquivo.  
  
 O <xref:System.IO.FileSystemWatcher.Path%2A> propriedade dá suporte a caminhos de convenção de nomenclatura Universal (UNC).  
  
> [!NOTE]
>  Essa propriedade deve ser definida antes que o componente pode detectar alterações.  
  
 Quando um diretório é renomeado, o <xref:System.IO.FileSystemWatcher> anexa novamente automaticamente para o item renomeado recentemente. Por exemplo, se você definir o <xref:System.IO.FileSystemWatcher.Path%2A> propriedade como "C:\My documentos" e, em seguida, renomeie manualmente o diretório para "C:\Your documentos", o componente continua a escuta as notificações de alteração no diretório recentemente renomeado. No entanto, quando você solicitar o <xref:System.IO.FileSystemWatcher.Path%2A> propriedade, ele contém o caminho antigo. Isso acontece porque o componente determina qual diretório inspeciona se baseia o identificador, em vez do nome do diretório. A renomeação não afeta o identificador. Portanto, se você destruir o componente e, em seguida, recriá-lo sem atualizar o <xref:System.IO.FileSystemWatcher.Path%2A> propriedade, o aplicativo falhará porque o diretório não existe mais.  
  
   
  
## Examples  
 O exemplo a seguir cria um <xref:System.IO.FileSystemWatcher> para observar o diretório especificado em tempo de execução. O componente é definido para observar alterações em `LastWrite` e `LastAccess` a hora, a criação, exclusão, ou renomeação de arquivos de texto no diretório. Se um arquivo for alterado, criado ou excluído, o caminho para o arquivo imprime no console. Quando um arquivo é renomeado, os caminhos de novos e antigos imprimir no console.  
  
 Use o <xref:System.Diagnostics> e <xref:System.IO> namespaces para este exemplo.  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O caminho especificado não existe ou não pôde ser encontrado.  
  
- ou - 
O caminho especificado contém caracteres curinga.  
  
- ou - 
O caminho especificado contém caracteres de caminho inválidos.</exception>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
      </Docs>
    </Member>
    <Member MemberName="Renamed">
      <MemberSignature Language="C#" Value="public event System.IO.RenamedEventHandler Renamed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.IO.RenamedEventHandler Renamed" />
      <MemberSignature Language="DocId" Value="E:System.IO.FileSystemWatcher.Renamed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Renamed As RenamedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::IO::RenamedEventHandler ^ Renamed;" />
      <MemberSignature Language="F#" Value="member this.Renamed : System.IO.RenamedEventHandler " Usage="member this.Renamed : System.IO.RenamedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.IO.IODescription("Occurs when a file/directory rename matches the filter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.IO.IODescription("FSW_Renamed")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.RenamedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre quando um arquivo ou diretório no <see cref="P:System.IO.FileSystemWatcher.Path" /> especificado é renomeado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `Renamed` evento é um <xref:System.IO.RenamedEventHandler> delegado que tem a seguinte assinatura:

 ```csharp
public delegate void Renamed(object sender, RenamedEventArgs e);
 ```
 ```vb
Public Delegate Sub RenamedEventHandler(sender As Object, e As RenamedEventArgs)
 ```
 O <xref:System.IO.RenamedEventArgs> objeto fornece informações sobre a operação de renomeação, como o tipo da renomeação (o <xref:System.IO.FileSystemEventArgs.ChangeType> propriedade), o nome antigo e novo e o caminho antigo e novo. Observe que o <xref:System.IO.FileSystemEventArgs.Name> propriedade pode ser nula para renomeado eventos se o <xref:System.IO.FileSystemWatcher> não obter nome antigo e novo eventos correspondentes do sistema operacional.

 Renomear o diretório que você está observando não gerará uma notificação. As notificações são geradas apenas para entradas de dentro do diretório que você está observando.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.IO.FileSystemWatcher.Renamed> evento para exibir o caminho do arquivo para o console sempre que o arquivo observado é renomeado.  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IO.FileSystemWatcher.OnRenamed(System.IO.RenamedEventArgs)" />
        <altmember cref="P:System.IO.FileSystemWatcher.SynchronizingObject" />
        <altmember cref="P:System.IO.FileSystemWatcher.Path" />
        <altmember cref="T:System.IO.RenamedEventArgs" />
        <altmember cref="T:System.IO.RenamedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="Site">
      <MemberSignature Language="C#" Value="public override System.ComponentModel.ISite Site { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISite Site" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.Site" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Site As ISite" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::ComponentModel::ISite ^ Site { System::ComponentModel::ISite ^ get(); void set(System::ComponentModel::ISite ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Site : System.ComponentModel.ISite with get, set" Usage="System.IO.FileSystemWatcher.Site" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISite</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um <see cref="T:System.ComponentModel.ISite" /> para o <see cref="T:System.IO.FileSystemWatcher" />.</summary>
        <value>Um <see cref="T:System.ComponentModel.ISite" /> para o <see cref="T:System.IO.FileSystemWatcher" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sites de associar uma <xref:System.ComponentModel.Component> para um <xref:System.ComponentModel.Design.IDesignerHost.Container%2A> e habilitar a comunicação entre eles, bem como fornecem uma maneira para o contêiner gerenciar seus componentes.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SynchronizingObject">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISynchronizeInvoke SynchronizingObject" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.SynchronizingObject" />
      <MemberSignature Language="VB.NET" Value="Public Property SynchronizingObject As ISynchronizeInvoke" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::ISynchronizeInvoke ^ SynchronizingObject { System::ComponentModel::ISynchronizeInvoke ^ get(); void set(System::ComponentModel::ISynchronizeInvoke ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SynchronizingObject : System.ComponentModel.ISynchronizeInvoke with get, set" Usage="System.IO.FileSystemWatcher.SynchronizingObject" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.IO.IODescription("The object used to marshal the event handler calls resulting from a directory change")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.IO.IODescription("FSW_SynchronizingObject")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISynchronizeInvoke</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o objeto usado para realizar marshaling das chamadas do manipulador de eventos emitidas como resultado de uma alteração de diretório.</summary>
        <value>O <see cref="T:System.ComponentModel.ISynchronizeInvoke" /> que representa o objeto usado para realizar marshaling das chamadas do manipulador de eventos emitidas como resultado de uma alteração de diretório. O padrão é <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando <xref:System.IO.FileSystemWatcher.SynchronizingObject%2A> é `null`, os métodos de tratamento de <xref:System.IO.FileSystemWatcher.Changed>, <xref:System.IO.FileSystemWatcher.Created>, <xref:System.IO.FileSystemWatcher.Deleted>, e <xref:System.IO.FileSystemWatcher.Renamed> eventos são chamados em um thread do pool de threads do sistema. Para obter mais informações sobre pools de threads do sistema, consulte <xref:System.Threading.ThreadPool>.  
  
 Quando o <xref:System.IO.FileSystemWatcher.Changed>, <xref:System.IO.FileSystemWatcher.Created>, <xref:System.IO.FileSystemWatcher.Deleted>, e <xref:System.IO.FileSystemWatcher.Renamed> eventos são manipulados por um componente de Windows Forms visual, como um <xref:System.Windows.Forms.Button>, acessando o componente através do pool de threads do sistema pode não funcionar ou pode resultar em uma exceção. Evitar isso, definindo <xref:System.IO.FileSystemWatcher.SynchronizingObject%2A> a um componente de Windows Forms, que faz com que os métodos que lidam com o <xref:System.IO.FileSystemWatcher.Changed>, <xref:System.IO.FileSystemWatcher.Created>, <xref:System.IO.FileSystemWatcher.Deleted>, e <xref:System.IO.FileSystemWatcher.Renamed> eventos a ser chamado no mesmo thread em que o componente foi criado.  
  
 Se o <xref:System.IO.FileSystemWatcher> é usado dentro de [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] em um designer de formulários do Windows <xref:System.IO.FileSystemWatcher.SynchronizingObject%2A> define automaticamente como o controle que contém o <xref:System.IO.FileSystemWatcher>. Por exemplo, se você colocar uma <xref:System.IO.FileSystemWatcher> em um designer para Form1 (que herda de <xref:System.Windows.Forms.Form>) a <xref:System.IO.FileSystemWatcher.SynchronizingObject%2A> propriedade do <xref:System.IO.FileSystemWatcher> está definido para a instância de Form1.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.ISynchronizeInvoke" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitForChanged">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Um método síncrono que retorna uma estrutura que contém informações específicas sobre a alteração ocorrida.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitForChanged">
      <MemberSignature Language="C#" Value="public System.IO.WaitForChangedResult WaitForChanged (System.IO.WatcherChangeTypes changeType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.IO.WaitForChangedResult WaitForChanged(valuetype System.IO.WatcherChangeTypes changeType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.WaitForChanged(System.IO.WatcherChangeTypes)" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForChanged (changeType As WatcherChangeTypes) As WaitForChangedResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::WaitForChangedResult WaitForChanged(System::IO::WatcherChangeTypes changeType);" />
      <MemberSignature Language="F#" Value="member this.WaitForChanged : System.IO.WatcherChangeTypes -&gt; System.IO.WaitForChangedResult" Usage="fileSystemWatcher.WaitForChanged changeType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.WaitForChangedResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="changeType" Type="System.IO.WatcherChangeTypes" />
      </Parameters>
      <Docs>
        <param name="changeType">O <see cref="T:System.IO.WatcherChangeTypes" /> a ser inspecionado.</param>
        <summary>Um método síncrono que retorna uma estrutura que contém informações específicas sobre a alteração ocorrida, considerando o tipo de alteração que você deseja monitorar.</summary>
        <returns>Um <see cref="T:System.IO.WaitForChangedResult" /> que contém informações específicas sobre a alteração ocorrida.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método aguarda indefinidamente até que a primeira alteração ocorre e, em seguida, retorna. Isso é o mesmo que usar <xref:System.IO.FileSystemWatcher.WaitForChanged%2A> com o `timeout` parâmetro definido como -1.  
  
> [!NOTE]
>  Esse método permite que um manipulador de eventos a ser invocado para responder ao mesmo se as alterações do arquivo a <xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A> estiver definida como `false`.  
  
 Em alguns sistemas, <xref:System.IO.FileSystemWatcher> informa as alterações nos arquivos usando o formato de nome de 8.3 arquivo curto. Por exemplo, uma alteração "LongFileName.LongExtension" poderia ser relatada como "LongFi ~. LON".  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.IO.WaitForChangedResult" />
      </Docs>
    </Member>
    <Member MemberName="WaitForChanged">
      <MemberSignature Language="C#" Value="public System.IO.WaitForChangedResult WaitForChanged (System.IO.WatcherChangeTypes changeType, int timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.IO.WaitForChangedResult WaitForChanged(valuetype System.IO.WatcherChangeTypes changeType, int32 timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.WaitForChanged(System.IO.WatcherChangeTypes,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForChanged (changeType As WatcherChangeTypes, timeout As Integer) As WaitForChangedResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::WaitForChangedResult WaitForChanged(System::IO::WatcherChangeTypes changeType, int timeout);" />
      <MemberSignature Language="F#" Value="member this.WaitForChanged : System.IO.WatcherChangeTypes * int -&gt; System.IO.WaitForChangedResult" Usage="fileSystemWatcher.WaitForChanged (changeType, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.WaitForChangedResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="changeType" Type="System.IO.WatcherChangeTypes" />
        <Parameter Name="timeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="changeType">O <see cref="T:System.IO.WatcherChangeTypes" /> a ser inspecionado.</param>
        <param name="timeout">O tempo (em milissegundos) de espera antes do tempo limite.</param>
        <summary>Um método síncrono que retorna uma estrutura que contém informações específicas sobre a alteração ocorrida, considerando o tipo de alteração que você deseja monitorar e o tempo (em milissegundos) de espera antes do tempo limite.</summary>
        <returns>Um <see cref="T:System.IO.WaitForChangedResult" /> que contém informações específicas sobre a alteração ocorrida.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método aguarda até que ocorre uma alteração ou ele expirou. Um valor de -1 para o `timeout` parâmetro significa aguardar indefinidamente.  
  
> [!NOTE]
>  Esse método permite que um manipulador de eventos a ser invocado para responder ao mesmo se as alterações do arquivo a <xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A> estiver definida como `false`.  
  
 Em alguns sistemas, <xref:System.IO.FileSystemWatcher> informa as alterações nos arquivos usando o formato de nome de 8.3 arquivo curto. Por exemplo, uma alteração "LongFileName.LongExtension" poderia ser relatada como "LongFi ~. LON".  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.IO.WaitForChangedResult" />
      </Docs>
    </Member>
  </Members>
</Type>