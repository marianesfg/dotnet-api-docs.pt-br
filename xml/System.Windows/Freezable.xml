<Type Name="Freezable" FullName="System.Windows.Freezable">
  <Metadata><Meta Name="ms.openlocfilehash" Value="97fc92af0ea25eec6f71bb4a67579fbfd994f7b4" /><Meta Name="ms.sourcegitcommit" Value="9e06b87bcfa4347dbbaaa4b3cc36b43b93b5badb" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="pt-BR" /><Meta Name="ms.lasthandoff" Value="11/20/2018" /><Meta Name="ms.locfileid" Value="52214099" /></Metadata><TypeSignature Language="C#" Value="public abstract class Freezable : System.Windows.DependencyObject" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit Freezable extends System.Windows.DependencyObject" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Freezable" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Freezable&#xA;Inherits DependencyObject" />
  <TypeSignature Language="C++ CLI" Value="public ref class Freezable abstract : System::Windows::DependencyObject" />
  <TypeSignature Language="F#" Value="type Freezable = class&#xA;    inherit DependencyObject" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.DependencyObject</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Define um objeto que tem um estado modificável e um estado somente leitura (congelado). Classes que derivam de <see cref="T:System.Windows.Freezable" /> fornecem notificação de alteração detalhada, podem ser transformadas em imutáveis e podem clonar a si mesmas.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Windows.Freezable> classe fornece recursos especiais que podem ajudar a melhoram o desempenho do aplicativo ao usar objetos que são caros de modificar ou copiar. Exemplos de <xref:System.Windows.Freezable> objetos incluem o seguinte:  
  
-   <xref:System.Windows.Media.Brush>  
  
-   <xref:System.Windows.Media.Pen>  
  
-   <xref:System.Windows.Media.Geometry>  
  
-   <xref:System.Windows.Media.Transform>  
  
-   <xref:System.Windows.Media.Animation.AnimationTimeline>  
  
## <a name="deriving-from-freezable"></a>Derivar de Freezable  
 Uma classe que deriva de <xref:System.Windows.Freezable> obtém os recursos a seguir:  
  
-   Estados especiais: estado somente leitura (congelado) e um estado gravável.  
  
-   Acesso thread-safe: um congelado <xref:System.Windows.Freezable> objeto pode ser compartilhado entre threads.  
  
-   Notificação de alteração detalhada: ao contrário de outras <xref:System.Windows.DependencyObject> objetos, um <xref:System.Windows.Freezable> objeto fornece notificações de alteração quando valores da subpropriedade são alteram.  
  
-   Fácil clonagem: a classe Congelável tem vários métodos já implementados que produzem clones profundos.  
  
 Para obter informações sobre como usar e criar seu próprio <xref:System.Windows.Freezable> objetos, consulte [visão geral de objetos congeláveis](~/docs/framework/wpf/advanced/freezable-objects-overview.md).  
  
 ]]></format>
    </remarks>
    <threadsafe>Qualquer público <see langword="static" /> desse tipo são thread-safe. Não há garantia de que qualquer membro de instância seja thread-safe.  
  
Quando o <see cref="P:System.Windows.Freezable.IsFrozen" /> é de propriedade <see langword="false" />, um <see cref="T:System.Windows.Freezable" /> objeto pode ser acessado somente do thread no qual ele foi criado. A tentativa de acessá-lo de lança de outro thread um <see cref="T:System.InvalidOperationException" />. O <see cref="Overload:System.Windows.Threading.Dispatcher.Invoke" /> e <see cref="Overload:System.Windows.Threading.Dispatcher.BeginInvoke" /> métodos oferecem suporte para a realização de marshaling do thread correto.  
  
Quando seus <see cref="P:System.Windows.Freezable.IsFrozen" /> é de propriedade <see langword="true" />, <see cref="T:System.Windows.Freezable" /> objetos são de thread livre.  Para obter mais informações, consulte a [Visão geral de objetos congeláveis](~/docs/framework/wpf/advanced/freezable-objects-overview.md).</threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Freezable ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Freezable();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Inicializa uma nova instância de uma classe derivada de <see cref="T:System.Windows.Freezable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este é o construtor de acessibilidade protegida de uma classe abstrata.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanFreeze">
      <MemberSignature Language="C#" Value="public bool CanFreeze { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanFreeze" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Freezable.CanFreeze" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanFreeze As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanFreeze { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanFreeze : bool" Usage="System.Windows.Freezable.CanFreeze" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o objeto pode se tornar não modificável.</summary>
        <value><see langword="true" /> se o objeto atual puder se tornar não modificável ou já for não modificável, caso contrário, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>Essa implementação do método usa o <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> método com <paramref name="isChecking" /> definido como <see langword="true" /> para determinar se um <see cref="T:System.Windows.Freezable" /> pode se tornar não modificável. Para modificar o comportamento dessa propriedade em uma classe derivada, substituir o <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> método.</para></block>
      </Docs>
    </Member>
    <Member MemberName="Changed">
      <MemberSignature Language="C#" Value="public event EventHandler Changed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Changed" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Freezable.Changed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Changed As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Changed;" />
      <MemberSignature Language="F#" Value="member this.Changed : EventHandler " Usage="member this.Changed : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre quando o <see cref="T:System.Windows.Freezable" /> ou um objeto nele contido é modificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se você tentar adicionar ou remover manipuladores de eventos quando o objeto atual não é modificável (quando o <xref:System.Windows.Freezable.IsFrozen%2A> é de propriedade `true`), uma exceção será lançada.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public System.Windows.Freezable Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Freezable Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Freezable ^ Clone();" />
      <MemberSignature Language="F#" Value="member this.Clone : unit -&gt; System.Windows.Freezable" Usage="freezable.Clone " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cria um clone modificável do <see cref="T:System.Windows.Freezable" />, fazendo cópias em profundidade dos valores do objeto. Ao copiar as propriedades de dependência do objeto, esse método copia as expressões (que talvez não possam mais ser resolvidas), mas não as animações nem seus valores atuais.</summary>
        <returns>Um clone modificável do objeto atual. A propriedade <see cref="P:System.Windows.Freezable.IsFrozen" /> do objeto clonado será <see langword="false" />, mesmo se a propriedade <see cref="P:System.Windows.Freezable.IsFrozen" /> da origem for <see langword="true." /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Windows.Freezable.Clone%2A> e <xref:System.Windows.Freezable.CloneCurrentValue%2A> métodos produzem clones modificáveis de congelado <xref:System.Windows.Freezable> objetos (os métodos também clonagem <xref:System.Windows.Freezable> objetos que não são congelados). O clone é efetivamente uma cópia em profundidade do objeto atual.  
  
 A tabela a seguir resume as diferenças entre o <xref:System.Windows.Freezable.Clone%2A> e <xref:System.Windows.Freezable.CloneCurrentValue%2A> métodos.  
  
|Ação|Comportamento do método clone|Comportamento do método CloneCurrentValue|  
|------------|---------------------------|---------------------------------------|  
|Copiando uma propriedade de dependência que tem uma expressão|A expressão é copiada, mas não pode mais resolver. Para obter mais informações, consulte a [Visão geral de objetos congeláveis](~/docs/framework/wpf/advanced/freezable-objects-overview.md).|O valor atual da expressão é copiado, mas não a própria expressão.|  
|Copiando uma propriedade de dependência animada|O valor da propriedade base (não animados) é copiado. Animações não são copiadas.|O valor da propriedade atual animado é copiado. Animações não são copiadas.|  
  
 Observe que as propriedades não definidas não são copiadas. Se uma propriedade não definida tem um valor padrão que é um congelado <xref:System.Windows.Freezable>, que o valor da propriedade permanece congelado no clone modificável caso contrário.  
  
## <a name="move-a-freezable-between-threads"></a>Mover um congelável entre Threads  
 Esse método pode ser útil para mover um <xref:System.Windows.Freezable> entre threads. Primeiro, verifique as <xref:System.Windows.Freezable> não modificável, chamando seu <xref:System.Windows.Freezable.Freeze%2A> método. Agora, outro thread pode acessar o <xref:System.Windows.Freezable> e faça uma local <xref:System.Windows.Freezable.Clone%2A> que ele possa acessar.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Esse método usa <see cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" /> para produzir o clone. Para modificar o comportamento desse método em uma classe derivada, substituir o <see cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" /> método.</para></block>
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValue" />
        <altmember cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="CloneCore">
      <MemberSignature Language="C#" Value="protected virtual void CloneCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void CloneCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub CloneCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void CloneCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="abstract member CloneCore : System.Windows.Freezable -&gt; unit&#xA;override this.CloneCore : System.Windows.Freezable -&gt; unit" Usage="freezable.CloneCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">O objeto a ser clonado.</param>
        <summary>Faz com que a instância seja um clone (cópia em profundidade) do <see cref="T:System.Windows.Freezable" /> especificado usando valores de propriedade base (não animados).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é chamado pelo <xref:System.Windows.Freezable.Clone%2A> método e não deve ser chamado diretamente do seu código de exceção ao chamar a implementação base ao substituir esse método. Para criar uma cópia modificável do objeto atual, chame <xref:System.Windows.Freezable.Clone%2A> em vez de chamar este método diretamente.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Se você derivar de <see cref="T:System.Windows.Freezable" />, talvez seja necessário substituir esse método. Motivos para substituir incluem o seguinte: 
-Sua classe derivada tem dados que não são expostos por meio de propriedades de dependência.  
  
-Sua classe derivada deverá executar o trabalho de inicialização extra que não pode ser realizado simplesmente substituindo <see cref="M:System.Windows.Freezable.CreateInstanceCore" />. Por exemplo, isso se aplica se sua classe derivada implementa <see cref="T:System.ComponentModel.ISupportInitialize" />.  
  
Classes que armazenam todos os seus dados nas propriedades de dependência e que não é necessário executar o trabalho de inicialização extra não precisará substituir <see cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" />.  
  
É essencial que todas as implementações de chamar a implementação base desse método. Implementações devem executar o trabalho que não é executado pela implementação do padrão. A implementação padrão faz cópias profundas de todas as propriedades graváveis, definidas localmente, incluindo expressões internas.  
  
Se o objeto tiver propriedades de dependência associado a dados, as expressões são copiadas, mas não podem mais resolver. Para obter mais informações sobre a clonagem de objetos de associação de dados, consulte [visão geral de objetos congeláveis](~/docs/framework/wpf/advanced/freezable-objects-overview.md). Se o objeto tiver propriedades de dependência animadas, o valor base (não animados) dessas propriedades é copiado. Animações não são copiadas.  
  
Observe que as propriedades não definidas não são copiadas, nem são propriedades somente leitura. Se essa propriedade tem um valor padrão que é um congelado <see cref="T:System.Windows.Freezable" />, que o valor da propriedade permanece congelado no clone modificável caso contrário.  
  
A lista a seguir resume o comportamento esperado para esse método: 
-A cópia produzida contém cópias de todos os <see cref="T:System.Windows.Freezable" /> subobjetos.  
  
-Propriedades unset e somente leitura não são copiadas.  
  
-Expressões são copiadas.  
  
-None esses subobjetos são congeladas na criação.  
  
-A cópia em si não está congelada.  
  
-Animações não são copiadas.  
  
-Somente os valores base de propriedade são copiados, não atualmente valores animados.</para></block>
        <altmember cref="M:System.Windows.Freezable.Clone" />
      </Docs>
    </Member>
    <Member MemberName="CloneCurrentValue">
      <MemberSignature Language="C#" Value="public System.Windows.Freezable CloneCurrentValue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Freezable CloneCurrentValue() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CloneCurrentValue" />
      <MemberSignature Language="VB.NET" Value="Public Function CloneCurrentValue () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Freezable ^ CloneCurrentValue();" />
      <MemberSignature Language="F#" Value="member this.CloneCurrentValue : unit -&gt; System.Windows.Freezable" Usage="freezable.CloneCurrentValue " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cria um clone modificável (cópia profunda) do <see cref="T:System.Windows.Freezable" /> usando seus valores atuais.</summary>
        <returns>Um clone modificável do objeto atual. A propriedade <see cref="P:System.Windows.Freezable.IsFrozen" /> do objeto clonado será <see langword="false" />, mesmo se a propriedade <see cref="P:System.Windows.Freezable.IsFrozen" /> da origem for <see langword="true." /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Windows.Freezable.Clone%2A> e <xref:System.Windows.Freezable.CloneCurrentValue%2A> métodos produzem clones modificáveis de congelado <xref:System.Windows.Freezable> objetos (os métodos também clonagem <xref:System.Windows.Freezable> objetos que não são congelados). O clone é efetivamente uma cópia em profundidade do objeto atual.  
  
 A tabela a seguir resume as diferenças entre o <xref:System.Windows.Freezable.Clone%2A> e <xref:System.Windows.Freezable.CloneCurrentValue%2A> métodos.  
  
|Ação|Comportamento do método clone|Comportamento do método CloneCurrentValue|  
|------------|---------------------------|---------------------------------------|  
|Copiando uma propriedade de dependência que tem uma expressão|A expressão é copiada, mas não pode mais resolver. Para obter mais informações, consulte a [Visão geral de objetos congeláveis](~/docs/framework/wpf/advanced/freezable-objects-overview.md).|O valor atual da expressão é copiado, mas não a própria expressão.|  
|Copiando uma propriedade de dependência animada|O valor da propriedade base (não animados) é copiado. Animações não são copiadas.|O valor da propriedade atual animado é copiado. Animações não são copiadas.|  
  
 Observe que as propriedades não definidas não são copiadas. Se uma propriedade não definida tem um valor padrão que é um congelado <xref:System.Windows.Freezable>, que o valor da propriedade permanece congelado no clone modificável caso contrário.  
  
## <a name="move-a-freezable-between-threads"></a>Mover um congelável entre Threads  
 Esse método pode ser útil para mover um <xref:System.Windows.Freezable> entre threads. Primeiro, verifique as <xref:System.Windows.Freezable> não modificável, usando seu <xref:System.Windows.Freezable.Freeze%2A> método. Agora, outro thread pode acessar o <xref:System.Windows.Freezable> e faça um clone local que ele possa acessar.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Esse método usa o <see cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" /> método para produzir o clone; <see cref="T:System.Windows.Freezable" /> implementadores que substituam <see cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" /> deve garantir que a cópia não está congelada na criação.</para></block>
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="CloneCurrentValueCore">
      <MemberSignature Language="C#" Value="protected virtual void CloneCurrentValueCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void CloneCurrentValueCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub CloneCurrentValueCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void CloneCurrentValueCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="abstract member CloneCurrentValueCore : System.Windows.Freezable -&gt; unit&#xA;override this.CloneCurrentValueCore : System.Windows.Freezable -&gt; unit" Usage="freezable.CloneCurrentValueCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">O <see cref="T:System.Windows.Freezable" /> a ser clonado.</param>
        <summary>Torna a instância um clone modificável (cópia em profundidade) do <see cref="T:System.Windows.Freezable" /> especificado usando os valores de propriedade atuais.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é chamado pelo <xref:System.Windows.Freezable.CloneCurrentValue%2A> método e não deve ser chamado diretamente do seu código de exceção ao chamar a implementação base ao substituir esse método. Para criar uma cópia modificável do objeto atual, chame <xref:System.Windows.Freezable.CloneCurrentValue%2A> em vez de chamar este método diretamente.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Se você derivar de <see cref="T:System.Windows.Freezable" />, talvez seja necessário substituir esse método. Motivos para substituir incluem o seguinte: 
-Sua classe derivada tem dados que não são expostos por meio de propriedades de dependência.  
  
-Sua classe derivada deverá executar o trabalho de inicialização extra que não pode ser realizado simplesmente substituindo <see cref="M:System.Windows.Freezable.CreateInstanceCore" />. Por exemplo, isso se aplica se sua classe derivada implementa <see cref="T:System.ComponentModel.ISupportInitialize" />.  
  
Classes que armazenam todos os seus dados nas propriedades de dependência e que não é necessário executar o trabalho de inicialização extra não precisará substituir <see cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />.  
  
É essencial que todas as implementações de chamar a implementação base desse método. Implementações devem executar o trabalho que não é executado pela implementação do padrão. A implementação padrão faz cópias profundas de todas as propriedades graváveis, definidas localmente. Se o objeto contém propriedades de dependência com expressões (como uma associação de dados), o valor atual da expressão é copiado, mas não a própria expressão.  
  
Se o objeto tem propriedades de dependência animadas, o valor animado atual dessas propriedades é copiado, mas as animações não são.  
  
Observe que as propriedades não definidas não são copiadas, nem são propriedades somente leitura. Se essa propriedade tem um valor padrão que é um congelado <see cref="T:System.Windows.Freezable" />, que o valor da propriedade permanece congelado no clone modificável caso contrário.  
  
A lista a seguir resume o comportamento esperado para esse método.  
  
-A cópia produzida contém cópias de todos os <see cref="T:System.Windows.Freezable" /> subobjetos.  
  
-Propriedades unset e somente leitura não são copiadas.  
  
-Se uma propriedade é animada, seu valor atual é copiado, mas a animação em si não é.  
  
-None esses subobjetos são congeladas na criação.  
  
-A cópia em si não está congelada.</para></block>
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValue" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="protected System.Windows.Freezable CreateInstance ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance class System.Windows.Freezable CreateInstance() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CreateInstance" />
      <MemberSignature Language="VB.NET" Value="Protected Function CreateInstance () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Windows::Freezable ^ CreateInstance();" />
      <MemberSignature Language="F#" Value="member this.CreateInstance : unit -&gt; System.Windows.Freezable" Usage="freezable.CreateInstance " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Windows.Freezable" />.</summary>
        <returns>A nova instância.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse é um método protegido e as implementações específicas do objeto reais para o comportamento são dependentes de implementação de substituição do <xref:System.Windows.Freezable.CreateInstanceCore%2A> método, que este método chama internamente.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Freezable.CreateInstanceCore" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceCore">
      <MemberSignature Language="C#" Value="protected abstract System.Windows.Freezable CreateInstanceCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Windows.Freezable CreateInstanceCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CreateInstanceCore" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function CreateInstanceCore () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Windows::Freezable ^ CreateInstanceCore();" />
      <MemberSignature Language="F#" Value="abstract member CreateInstanceCore : unit -&gt; System.Windows.Freezable" Usage="freezable.CreateInstanceCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quando implementado em uma classe derivada, cria uma nova instância da classe derivada <see cref="T:System.Windows.Freezable" />.</summary>
        <returns>A nova instância.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Não chame este método diretamente (exceto quando chamar base em uma implementação). Esse método é chamado internamente pelo <xref:System.Windows.Freezable.CreateInstance%2A> método sempre que uma nova instância do <xref:System.Windows.Freezable> é criado.  
  
   
  
## Examples  
 O exemplo a seguir mostra uma implementação típica do <xref:System.Windows.Freezable.CreateInstanceCore%2A>.  
  
 [!code-csharp[freezablesample_procedural#CreateInstanceCoreExample](~/samples/snippets/csharp/VS_Snippets_Wpf/freezablesample_procedural/CSharp/freezablesample.cs#createinstancecoreexample)]
 [!code-vb[freezablesample_procedural#CreateInstanceCoreExample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/freezablesample_procedural/visualbasic/freezablesample.vb#createinstancecoreexample)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Cada <see cref="T:System.Windows.Freezable" /> classe derivada deverá implementar esse método. Uma implementação típica é simplesmente chamar o construtor padrão e retornar o resultado.</para></block>
        <altmember cref="M:System.Windows.Freezable.CreateInstance" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Freeze">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Torna um objeto <see cref="T:System.Windows.Freezable" /> não modificável e define as propriedades <see cref="P:System.Windows.Freezable.IsFrozen" /> dele para <see langword="true" /> ou testa se é possível tornar um objeto <see cref="T:System.Windows.Freezable" /> não modificável.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Freeze">
      <MemberSignature Language="C#" Value="public void Freeze ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Freeze() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.Freeze" />
      <MemberSignature Language="VB.NET" Value="Public Sub Freeze ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Freeze();" />
      <MemberSignature Language="F#" Value="member this.Freeze : unit -&gt; unit" Usage="freezable.Freeze " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Torna o objeto atual não modificável e define sua propriedade <see cref="P:System.Windows.Freezable.IsFrozen" /> para <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para evitar a possibilidade de um <xref:System.InvalidOperationException> ao chamar esse método, verifique a <xref:System.Windows.Freezable.CanFreeze%2A> propriedade para determinar se o <xref:System.Windows.Freezable> pode se tornar não modificável antes de chamar esse método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">O <see cref="T:System.Windows.Freezable" /> não pode se tornar não modificável.</exception>
        <block subset="none" type="overrides"><para>Esse método usa o <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> método para fazer o <see cref="T:System.Windows.Freezable" /> não modificável. Para modificar o comportamento de congelamento, substituir o <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> método.</para></block>
        <altmember cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="Freeze">
      <MemberSignature Language="C#" Value="protected internal static bool Freeze (System.Windows.Freezable freezable, bool isChecking);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblystatic hidebysig bool Freeze(class System.Windows.Freezable freezable, bool isChecking) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.Freeze(System.Windows.Freezable,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; static bool Freeze(System::Windows::Freezable ^ freezable, bool isChecking);" />
      <MemberSignature Language="F#" Value="static member Freeze : System.Windows.Freezable * bool -&gt; bool" Usage="System.Windows.Freezable.Freeze (freezable, isChecking)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="freezable" Type="System.Windows.Freezable" />
        <Parameter Name="isChecking" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="freezable">O objeto a verificar ou tornar não modificável. Se <paramref name="isChecking" /> é <see langword="true" />, o objeto é verificado para determinar se ele pode ser tornado não modificável. Se <paramref name="isChecking" /> é <see langword="false" />, o objeto é tornado não modificável se possível.</param>
        <param name="isChecking"><see langword="true" /> para retornar uma indicação de que o objeto pode ou não ser congelado (sem realmente congelá-lo); <see langword="false" /> para realmente congelar o objeto.</param>
        <summary>Se o parâmetro <paramref name="isChecking" /> é <see langword="true" />, este método indica se o <see cref="T:System.Windows.Freezable" /> especificado pode ser tornado não modificável. Se o parâmetro <paramref name="isChecking" /> é <see langword="false" />, esse método tenta tornar o <see cref="T:System.Windows.Freezable" /> especificado não modificável e indica se a operação foi bem-sucedida.</summary>
        <returns>Se <paramref name="isChecking" /> for <see langword="true" />, esse método retornará <see langword="true" /> se o <see cref="T:System.Windows.Freezable" /> especificado puder ser transformado em não modificável ou então <see langword="false" />, se ele não puder ser transformado em não modificável. Se <paramref name="isChecking" /> for <see langword="false" />, esse método retornará <see langword="true" /> se o <see cref="T:System.Windows.Freezable" /> especificado for agora não modificável ou então <see langword="false" />, se ele não puder ser transformado em não modificável.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Não chame este método, a menos que você estiver derivando de <xref:System.Windows.Freezable> e substituindo o <xref:System.Windows.Freezable.FreezeCore%2A> método.  Esse método pode ser usado na <xref:System.Windows.Freezable.FreezeCore%2A> método para congelar a membros de dados de classe que também são <xref:System.Windows.Freezable> objetos.  
  
 É muito bem chamar esse método novamente em um <xref:System.Windows.Freezable> objeto que já está congelado (não modificável).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Quando <paramref name="isChecking" /> é <see langword="false" />, a tentativa de tornar <paramref name="freezable" /> não modificável não teve êxito; o objeto agora está em um estado desconhecido (ele pode estar parcialmente congelado).</exception>
        <block subset="none" type="overrides"><para>Esse método usa o <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> método para fazer o <see cref="T:System.Windows.Freezable" /> não modificável. Para modificar o comportamento de congelamento, substituir o <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> método.</para></block>
        <altmember cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="FreezeCore">
      <MemberSignature Language="C#" Value="protected virtual bool FreezeCore (bool isChecking);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool FreezeCore(bool isChecking) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function FreezeCore (isChecking As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool FreezeCore(bool isChecking);" />
      <MemberSignature Language="F#" Value="abstract member FreezeCore : bool -&gt; bool&#xA;override this.FreezeCore : bool -&gt; bool" Usage="freezable.FreezeCore isChecking" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="isChecking" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="isChecking"><see langword="true" /> para retornar uma indicação de que o objeto pode ou não ser congelado (sem realmente congelá-lo); <see langword="false" /> para realmente congelar o objeto.</param>
        <summary>Torna o objeto <see cref="T:System.Windows.Freezable" /> não modificável ou testa se ele pode ser transformado em não modificável.</summary>
        <returns>Se <paramref name="isChecking" /> for <see langword="true" />, esse método retornará <see langword="true" /> se o <see cref="T:System.Windows.Freezable" /> puder se tornar não modificável ou <see langword="false" /> se ele não puder se tornar não modificável. Se <paramref name="isChecking" /> for <see langword="false" />, esse método retornará <see langword="true" /> se o <see cref="T:System.Windows.Freezable" /> especificado for agora não modificável ou então <see langword="false" />, se ele não puder ser transformado em não modificável.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Não chame este método diretamente (exceto quando chamar base em uma implementação). Esse método é chamado internamente pelo <xref:System.Windows.Freezable.CanFreeze%2A> propriedade (com `isChecking` igual a `true`) e o <xref:System.Windows.Freezable.Freeze%2A> método (com `isChecking` igual a `false`).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>
            <see cref="T:System.Windows.Freezable" /> os implementadores devem substituir este método quando a classe contém dados que não são armazenados usando as propriedades de dependência.  
  
Uma implementação típica seria chamar base, em seguida, chame estático <see cref="M:System.Windows.Freezable.Freeze(System.Windows.Freezable,System.Boolean)" /> método em todos os <see cref="T:System.Windows.Freezable" /> que contém a classe, retornando propriedades de tipo acentuado <see langword="true" /> somente se todas as propriedades foram congeladas (ou poderia ter sido congeladas, caso você especifique <see langword="true" /> para <paramref name="isChecking" />).</para></block>
        <altmember cref="M:System.Windows.Freezable.Freeze" />
        <altmember cref="P:System.Windows.Freezable.CanFreeze" />
      </Docs>
    </Member>
    <Member MemberName="GetAsFrozen">
      <MemberSignature Language="C#" Value="public System.Windows.Freezable GetAsFrozen ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Freezable GetAsFrozen() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.GetAsFrozen" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAsFrozen () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Freezable ^ GetAsFrozen();" />
      <MemberSignature Language="F#" Value="member this.GetAsFrozen : unit -&gt; System.Windows.Freezable" Usage="freezable.GetAsFrozen " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cria uma cópia congelada o <see cref="T:System.Windows.Freezable" /> usando valores de propriedade base (não animadas). Já que a cópia está congelada, quaisquer subobjetos congelados são copiados por referência.</summary>
        <returns>Uma cópia congelada do <see cref="T:System.Windows.Freezable" />. A propriedade <see cref="P:System.Windows.Freezable.IsFrozen" /> da cópia está definida para <see langword="true" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você deve verificar a <xref:System.Windows.Freezable.CanFreeze%2A> propriedade antes de chamar este método para verificar se o <xref:System.Windows.Freezable> pode ser congelado. Usando esse método é semelhante à criação de uma cópia usando o <xref:System.Windows.Freezable.Clone%2A> e, em seguida, congelá-lo com o <xref:System.Windows.Freezable.Freeze%2A> método.  
  
 O <xref:System.Windows.Freezable.GetAsFrozen%2A> e <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> métodos podem melhorar o desempenho de cópia porque eles não clonagem <xref:System.Windows.Freezable> subobjetos que já estão congelados; eles apenas copiá-los por referência.  
  
 A tabela a seguir resume as diferenças entre o <xref:System.Windows.Freezable.GetAsFrozen%2A> e <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> métodos.  
  
|Ação|Comportamento do método GetAsFrozen|Comportamento do método GetCurrentValueAsFrozen|  
|------------|---------------------------------|---------------------------------------------|  
|Copiando uma propriedade de dependência que tem uma expressão|O método lança um <xref:System.InvalidOperationException> porque ele não é possível <xref:System.Windows.Freezable.Freeze%2A> a propriedade.|O valor atual da expressão é copiado, mas não a própria expressão.|  
|Copiando uma propriedade de dependência animada|O valor da propriedade base (não animados) é copiado. Animações não são copiadas.|O valor da propriedade atual animado é copiado. Animações não são copiadas.|  
  
 Observe que as propriedades não definidas não são copiadas, nem são propriedades somente leitura.  
  
 Para criar uma cópia do <xref:System.Windows.Freezable> que é não congelada, use o <xref:System.Windows.Freezable.Clone%2A> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">O <see cref="T:System.Windows.Freezable" /> não pode ser congelado porque ele contém expressões ou propriedades animadas.</exception>
        <block subset="none" type="overrides"><para>Esse método usa o virtual <see cref="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" /> método para produzir o clone.</para></block>
        <altmember cref="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="GetAsFrozenCore">
      <MemberSignature Language="C#" Value="protected virtual void GetAsFrozenCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void GetAsFrozenCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub GetAsFrozenCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void GetAsFrozenCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="abstract member GetAsFrozenCore : System.Windows.Freezable -&gt; unit&#xA;override this.GetAsFrozenCore : System.Windows.Freezable -&gt; unit" Usage="freezable.GetAsFrozenCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">A instância a ser copiada.</param>
        <summary>Torna a instância um clone congelado do <see cref="T:System.Windows.Freezable" /> especificado usando valores de propriedade base (não animados).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é chamado pelo <xref:System.Windows.Freezable.GetAsFrozen%2A> método e não deve ser chamado diretamente do seu código de exceção ao chamar a implementação base ao substituir esse método. Para criar uma cópia congelada do objeto atual, chame <xref:System.Windows.Freezable.GetAsFrozen%2A> em vez de chamar este método diretamente.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Se você derivar de <see cref="T:System.Windows.Freezable" /> talvez seja necessário substituir esse método. Motivos para substituir incluem o seguinte: 
-Sua classe derivada tem dados que não são expostos por meio de propriedades de dependência.  
  
-Sua classe derivada deverá executar o trabalho de inicialização extra que não pode ser realizado simplesmente substituindo <see cref="M:System.Windows.Freezable.CreateInstanceCore" />. Por exemplo, isso se aplica se sua classe derivada implementa <see cref="T:System.ComponentModel.ISupportInitialize" />.  
  
Classes que armazenam todos os seus dados nas propriedades de dependência e que não é necessário executar o trabalho de inicialização extra não precisará substituir <see cref="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" />.  
  
É essencial que todas as implementações de chamar a implementação base desse método. Implementações devem executar o trabalho que não é executado pela implementação do padrão. A implementação padrão faz cópias profundas de qualquer descongelados e superficiais cópias de todos os outros gravável, localmente conjunto de propriedades que ele contém. Se o objeto tiver propriedades de dependência associado a dados, as expressões são copiadas, mas não podem mais resolver; Para obter mais informações sobre a clonagem de objetos de associação de dados, consulte [visão geral de objetos congeláveis](~/docs/framework/wpf/advanced/freezable-objects-overview.md). Se o objeto tiver propriedades de dependência animadas, os valores base (não animados) dessas propriedades são copiados. Animações não são copiadas.  
  
Observe que as propriedades não definidas não são copiadas, nem são propriedades somente leitura.  
  
Se você substituir esse método, você deve chamar a implementação base.  
  
Você não precisará <see cref="M:System.Windows.Freezable.Freeze" /> valores conforme eles são copiados.  O resultado é congelado pelo <see cref="M:System.Windows.Freezable.GetAsFrozen" /> antes de serem retornados.</para></block>
        <altmember cref="M:System.Windows.Freezable.GetAsFrozen" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentValueAsFrozen">
      <MemberSignature Language="C#" Value="public System.Windows.Freezable GetCurrentValueAsFrozen ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Freezable GetCurrentValueAsFrozen() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.GetCurrentValueAsFrozen" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentValueAsFrozen () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Freezable ^ GetCurrentValueAsFrozen();" />
      <MemberSignature Language="F#" Value="member this.GetCurrentValueAsFrozen : unit -&gt; System.Windows.Freezable" Usage="freezable.GetCurrentValueAsFrozen " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cria uma cópia congelada do <see cref="T:System.Windows.Freezable" /> usando valores de propriedade atuais. Já que a cópia está congelada, quaisquer subobjetos congelados são copiados por referência.</summary>
        <returns>Uma cópia congelada do <see cref="T:System.Windows.Freezable" />. A propriedade <see cref="P:System.Windows.Freezable.IsFrozen" /> da cópia está definida para <see langword="true" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usando esse método é semelhante à criação de uma cópia usando o <xref:System.Windows.Freezable.CloneCurrentValue%2A> e, em seguida, congelá-lo com o <xref:System.Windows.Freezable.Freeze%2A> método.  
  
 O <xref:System.Windows.Freezable.GetAsFrozen%2A> e <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> métodos podem melhorar o desempenho de cópia porque eles não clonagem <xref:System.Windows.Freezable> subobjetos que já estão congelados; eles apenas copiá-los por referência.  
  
 A tabela a seguir resume as diferenças entre o <xref:System.Windows.Freezable.GetAsFrozen%2A> e <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> métodos.  
  
|Ação|Comportamento do método GetAsFrozen|Comportamento do método GetCurrentValueAsFrozen|  
|------------|---------------------------------|---------------------------------------------|  
|Copiando uma propriedade de dependência que tem uma expressão|O método lança um <xref:System.InvalidOperationException> porque ele não é possível <xref:System.Windows.Freezable.Freeze%2A> a propriedade.|O valor atual da expressão é copiado, mas não a própria expressão.|  
|Copiando uma propriedade de dependência animada|O valor da propriedade base (não animados) é copiado. Animações não são copiadas.|O valor da propriedade atual animado é copiado. Animações não são copiadas.|  
  
 Observe que as propriedades não definidas não são copiadas, nem são propriedades somente leitura.  
  
 Para criar uma cópia do <xref:System.Windows.Freezable> que é não congelada, use o <xref:System.Windows.Freezable.CloneCurrentValue%2A> método.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Esse método usa o virtual <see cref="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" /> método para produzir o clone.</para></block>
        <altmember cref="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" />
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValue" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentValueAsFrozenCore">
      <MemberSignature Language="C#" Value="protected virtual void GetCurrentValueAsFrozenCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void GetCurrentValueAsFrozenCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub GetCurrentValueAsFrozenCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void GetCurrentValueAsFrozenCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="abstract member GetCurrentValueAsFrozenCore : System.Windows.Freezable -&gt; unit&#xA;override this.GetCurrentValueAsFrozenCore : System.Windows.Freezable -&gt; unit" Usage="freezable.GetCurrentValueAsFrozenCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">O <see cref="T:System.Windows.Freezable" /> a ser copiado e congelado.</param>
        <summary>Torna a instância atual um clone congelado do <see cref="T:System.Windows.Freezable" /> especificado. Se o objeto tiver propriedades de dependência animadas, seus valores animados atuais serão copiados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é chamado pelo <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> método e não deve ser chamado diretamente do seu código de exceção ao chamar a implementação base ao substituir esse método. Para criar uma cópia congelada do objeto atual, chame <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> em vez de chamar este método diretamente.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Se você derivar de <see cref="T:System.Windows.Freezable" />, talvez seja necessário substituir esse método. Motivos para substituir incluem o seguinte: 
-Sua classe derivada tem dados que não são expostos por meio de propriedades de dependência.  
  
-Sua classe derivada deverá executar o trabalho de inicialização extra que não pode ser realizado simplesmente substituindo <see cref="M:System.Windows.Freezable.CreateInstanceCore" />. Por exemplo, isso se aplica se sua classe derivada implementa <see cref="T:System.ComponentModel.ISupportInitialize" />.  
  
Classes que armazenam todos os seus dados nas propriedades de dependência e que não é necessário executar o trabalho de inicialização extra não precisará substituir <see cref="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" />.  
  
É essencial que todas as implementações de chamar a implementação base desse método. Implementações devem executar o trabalho que não é executado pela implementação do padrão. A implementação padrão cria um novo <see cref="T:System.Windows.Freezable" /> usando o <see cref="M:System.Windows.Freezable.CreateInstance" /> superficiais cópias de todos os outros gravável e de método e faz cópias em profundidade dos descongelados localmente definir propriedades que ele contém. Se o objeto tiver propriedades de dependência associado a dados, as associações de dados são copiadas, mas não podem mais resolver; Para obter mais informações sobre a clonagem de objetos de associação de dados, consulte [visão geral de objetos congeláveis](~/docs/framework/wpf/advanced/freezable-objects-overview.md). Se o objeto tem propriedades de dependência animadas, o valor animado atual dessas propriedades é copiado, mas as animações não são.  
  
Propriedades de dependência somente leitura dentro de um <see cref="T:System.Windows.Freezable" /> não são copiadas por esta implementação padrão.  
  
Se você substituir esse método, você deve chamar a implementação base.  
  
Você não precisará <see cref="M:System.Windows.Freezable.Freeze" /> valores conforme eles são copiados.  O resultado é congelado pelo <see cref="M:System.Windows.Freezable.GetAsFrozen" /> antes de serem retornados.</para></block>
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="IsFrozen">
      <MemberSignature Language="C#" Value="public bool IsFrozen { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFrozen" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Freezable.IsFrozen" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFrozen As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFrozen { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFrozen : bool" Usage="System.Windows.Freezable.IsFrozen" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o objeto pode ser modificado no momento.</summary>
        <value><see langword="true" /> se o objeto estiver congelado e não puder ser modificado; <see langword="false" /> se o objeto poderá ser modificado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tentativa de modificar um objeto ao seu <xref:System.Windows.Freezable.IsFrozen%2A> é de propriedade `true` lança um <xref:System.InvalidOperationException>.  
  
 Essa propriedade é somente leitura da perspectiva do modelo de objeto. Algumas das documentações sobre <xref:System.Windows.Freezable> comportamentos podem mencionar "define <xref:System.Windows.Freezable.IsFrozen%2A> à `true`" ou linguagem semelhante ao discutir o comportamento de outros métodos de <xref:System.Windows.Freezable>, mas esse comportamento está acontecendo internamente em instâncias de classe, Quando os métodos da instância de manipulam as variáveis particulares que existem dentro da classe abstrata. Para definir o valor dessa propriedade, você deve chamar <xref:System.Windows.Freezable.Freeze%2A>. Isso é efetivamente uma operação única para alterar o <xref:System.Windows.Freezable.IsFrozen%2A> propriedade do padrão inicial `false` estado para o `true` estado. Não há nenhum meios disponíveis para definir o valor para `false`. Em vez disso, você pode alterar qualquer cópia em profundidade feita do original (consulte o <xref:System.Windows.Freezable.Clone%2A> método). Isso ocorre por design e é como qualquer classe derivada deve se comportar quando aplicado aos casos em que o <xref:System.Windows.Freezable> padrão é útil.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnChanged ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnChanged() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.OnChanged" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnChanged ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnChanged();" />
      <MemberSignature Language="F#" Value="abstract member OnChanged : unit -&gt; unit&#xA;override this.OnChanged : unit -&gt; unit" Usage="freezable.OnChanged " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Chamado quando o objeto <see cref="T:System.Windows.Freezable" /> atual é modificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é chamado sempre que o <xref:System.Windows.Freezable.Changed> evento ocorre.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Quando você implementa uma classe que deriva de <see cref="T:System.Windows.Freezable" />, você pode substituir esse método para executar tarefas.</para></block>
        <altmember cref="E:System.Windows.Freezable.Changed" />
      </Docs>
    </Member>
    <MemberGroup MemberName="OnFreezablePropertyChanged">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Garante que os ponteiros de contexto apropriados sejam estabelecidos para um membro de dados do tipo <see cref="T:System.Windows.DependencyObject" /> que foi recém-modificado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OnFreezablePropertyChanged">
      <MemberSignature Language="C#" Value="protected void OnFreezablePropertyChanged (System.Windows.DependencyObject oldValue, System.Windows.DependencyObject newValue);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnFreezablePropertyChanged(class System.Windows.DependencyObject oldValue, class System.Windows.DependencyObject newValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.OnFreezablePropertyChanged(System.Windows.DependencyObject,System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnFreezablePropertyChanged (oldValue As DependencyObject, newValue As DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnFreezablePropertyChanged(System::Windows::DependencyObject ^ oldValue, System::Windows::DependencyObject ^ newValue);" />
      <MemberSignature Language="F#" Value="member this.OnFreezablePropertyChanged : System.Windows.DependencyObject * System.Windows.DependencyObject -&gt; unit" Usage="freezable.OnFreezablePropertyChanged (oldValue, newValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.Windows.DependencyObject" />
        <Parameter Name="newValue" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="oldValue">O valor anterior do membro de dados.</param>
        <param name="newValue">O valor atual do membro de dados.</param>
        <summary>Garante que os ponteiros de contexto apropriados sejam estabelecidos para um membro de dados <see cref="T:System.Windows.DependencyObjectType" /> que foi recém-definido.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método deve ser chamado <xref:System.Windows.Freezable> herdeiros cada vez que um <xref:System.Windows.DependencyObject> membro de dados que não é armazenado como um <xref:System.Windows.DependencyProperty> está definido.  
  
 Esse método não precisa ser chamado para <xref:System.Windows.DependencyObject> membros de dados que são armazenados usando um <xref:System.Windows.DependencyProperty>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnFreezablePropertyChanged">
      <MemberSignature Language="C#" Value="protected void OnFreezablePropertyChanged (System.Windows.DependencyObject oldValue, System.Windows.DependencyObject newValue, System.Windows.DependencyProperty property);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnFreezablePropertyChanged(class System.Windows.DependencyObject oldValue, class System.Windows.DependencyObject newValue, class System.Windows.DependencyProperty property) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.OnFreezablePropertyChanged(System.Windows.DependencyObject,System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnFreezablePropertyChanged (oldValue As DependencyObject, newValue As DependencyObject, property As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnFreezablePropertyChanged(System::Windows::DependencyObject ^ oldValue, System::Windows::DependencyObject ^ newValue, System::Windows::DependencyProperty ^ property);" />
      <MemberSignature Language="F#" Value="member this.OnFreezablePropertyChanged : System.Windows.DependencyObject * System.Windows.DependencyObject * System.Windows.DependencyProperty -&gt; unit" Usage="freezable.OnFreezablePropertyChanged (oldValue, newValue, property)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.Windows.DependencyObject" />
        <Parameter Name="newValue" Type="System.Windows.DependencyObject" />
        <Parameter Name="property" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="oldValue">O valor anterior do membro de dados.</param>
        <param name="newValue">O valor atual do membro de dados.</param>
        <param name="property">A propriedade que foi alterada.</param>
        <summary>Este membro dá suporte à infraestrutura [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] e não se destina a ser usado diretamente do código.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanged">
      <MemberSignature Language="C#" Value="protected override void OnPropertyChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnPropertyChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnPropertyChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnPropertyChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="override this.OnPropertyChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="freezable.OnPropertyChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Dados de evento que contém informações sobre qual propriedade foi alterada e os respectivos valores, novos e antigos.</param>
        <summary>Substitui a implementação <see cref="T:System.Windows.DependencyObject" /> de <see cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" /> para também invocar quaisquer manipuladores <see cref="E:System.Windows.Freezable.Changed" /> em resposta à alteração de uma propriedade de dependência do tipo <see cref="T:System.Windows.Freezable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Os dados do evento contém apenas informações sobre o <xref:System.Windows.Freezable> em si. Nenhuma informação de subpropriedade deve ser obtida por meio de <xref:System.Windows.Freezable.Changed> manipuladores.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadPreamble">
      <MemberSignature Language="C#" Value="protected void ReadPreamble ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ReadPreamble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.ReadPreamble" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ReadPreamble ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ReadPreamble();" />
      <MemberSignature Language="F#" Value="member this.ReadPreamble : unit -&gt; unit" Usage="freezable.ReadPreamble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Garante que o <see cref="T:System.Windows.Freezable" /> esteja sendo acessado de um thread válido. Herdeiros do <see cref="T:System.Windows.Freezable" /> devem chamar esse método no início de qualquer [!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)] que lê membros de dados que não são propriedades de dependência.</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>Classes que derivam de <see cref="T:System.Windows.Freezable" /> deve chamar o <see cref="M:System.Windows.Freezable.ReadPreamble" /> método antes que eles tentam acessar todos os membros que não são propriedades de dependência. O <see cref="M:System.Windows.Freezable.WritePreamble" /> método deve ser chamado antes de qualquer esses membros são gravados.  
  
Esse método efetivamente não faz nada mais do que chamar <see cref="M:System.Windows.Threading.DispatcherObject.VerifyAccess" />.</para></block>
        <altmember cref="M:System.Windows.Freezable.WritePreamble" />
      </Docs>
    </Member>
    <Member MemberName="WritePostscript">
      <MemberSignature Language="C#" Value="protected void WritePostscript ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void WritePostscript() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.WritePostscript" />
      <MemberSignature Language="VB.NET" Value="Protected Sub WritePostscript ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void WritePostscript();" />
      <MemberSignature Language="F#" Value="member this.WritePostscript : unit -&gt; unit" Usage="freezable.WritePostscript " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Aciona o evento <see cref="E:System.Windows.Freezable.Changed" /> para o <see cref="T:System.Windows.Freezable" /> e invoca o respectivo método <see cref="M:System.Windows.Freezable.OnChanged" />. Classes que derivam de <see cref="T:System.Windows.Freezable" /> devem chamar este método no final de qualquer API que modifica os membros de classe que não são armazenados como propriedades de dependência.</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>Classes que derivam de <see cref="T:System.Windows.Freezable" /> deve chamar esse método no final de qualquer API que modifica um membro da classe que não é armazenado como um <see cref="T:System.Windows.DependencyProperty" />.</para></block>
      </Docs>
    </Member>
    <Member MemberName="WritePreamble">
      <MemberSignature Language="C#" Value="protected void WritePreamble ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void WritePreamble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.WritePreamble" />
      <MemberSignature Language="VB.NET" Value="Protected Sub WritePreamble ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void WritePreamble();" />
      <MemberSignature Language="F#" Value="member this.WritePreamble : unit -&gt; unit" Usage="freezable.WritePreamble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Verifica se o <see cref="T:System.Windows.Freezable" /> não está congelado e está sendo acessado de um contexto de threading válido. Herdeiros do <see cref="T:System.Windows.Freezable" /> devem chamar esse método no início de qualquer [!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)] que grava em membros de dados que não são propriedades de dependência.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método chama <xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> para verificar o contexto de threading está acessível e ele gerará uma exceção se o <xref:System.Windows.Freezable> instância já está congelada.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">A instância do <see cref="T:System.Windows.Freezable" /> está congelada e não pode ter seus membros gravados.</exception>
        <block subset="none" type="overrides"><para>Classes que derivam de <see cref="T:System.Windows.Freezable" /> deve chamar <see cref="M:System.Windows.Freezable.WritePreamble" /> antes de tentar gravar em todos os membros que não são propriedades de dependência. Se você chamar <see cref="M:System.Windows.Freezable.WritePreamble" /> em um [!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)], você pode omitir uma chamada para <see cref="M:System.Windows.Freezable.ReadPreamble" />.</para></block>
        <altmember cref="M:System.Windows.Freezable.ReadPreamble" />
      </Docs>
    </Member>
  </Members>
</Type>