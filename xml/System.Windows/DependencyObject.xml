<Type Name="DependencyObject" FullName="System.Windows.DependencyObject">
  <Metadata><Meta Name="ms.openlocfilehash" Value="e1c50a8a6bf5de1650ec4db222d0e7fe52ea28ad" /><Meta Name="ms.sourcegitcommit" Value="bac13a81377b1c4ebf3990e3287a6f1700f73751" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pt-BR" /><Meta Name="ms.lasthandoff" Value="03/19/2019" /><Meta Name="ms.locfileid" Value="57915445" /></Metadata><TypeSignature Language="C#" Value="public class DependencyObject : System.Windows.Threading.DispatcherObject" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit DependencyObject extends System.Windows.Threading.DispatcherObject" />
  <TypeSignature Language="DocId" Value="T:System.Windows.DependencyObject" />
  <TypeSignature Language="VB.NET" Value="Public Class DependencyObject&#xA;Inherits DispatcherObject" />
  <TypeSignature Language="C++ CLI" Value="public ref class DependencyObject : System::Windows::Threading::DispatcherObject" />
  <TypeSignature Language="F#" Value="type DependencyObject = class&#xA;    inherit DispatcherObject" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Threading.DispatcherObject</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.TypeDescriptionProvider(typeof(MS.Internal.ComponentModel.DependencyObjectProvider))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Windows.Markup.NameScopeProperty("NameScope", typeof(System.Windows.NameScope))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Representa um objeto que participa do sistema de propriedade de dependência.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Windows.DependencyObject> classe habilita [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] serviços do sistema de propriedade em suas muitas classes derivadas.  
  
 Função de principal do sistema de propriedades é para calcular os valores das propriedades e para fornecer uma notificação do sistema sobre os valores que foram alterados. É outra classe de chave que participa do sistema de propriedade <xref:System.Windows.DependencyProperty>. <xref:System.Windows.DependencyProperty> Habilita o registro das propriedades de dependência para o sistema de propriedades e fornece informações sobre cada propriedade de dependência e identificação enquanto <xref:System.Windows.DependencyObject> como uma classe base permite que os objetos para usar as propriedades de dependência.  
  
 <xref:System.Windows.DependencyObject> serviços e as características incluem o seguinte:  
  
-   Suporte à hospedagem de propriedade de dependência. Registrar uma propriedade de dependência, chame o <xref:System.Windows.DependencyProperty.Register%2A> método e armazenar o valor de retorno do método como um campo estático público em sua classe.  
  
-   Suporte à hospedagem de propriedade anexada. Registrar uma propriedade anexada chamando o <xref:System.Windows.DependencyProperty.RegisterAttached%2A> método e armazenar o valor de retorno do método como um campo estático público somente leitura em sua classe. (Também há requisitos adicionais de membro; Observe que isso representa um [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] implementação específica para propriedades anexadas. Para obter detalhes, consulte [visão geral das propriedades anexadas](~/docs/framework/wpf/advanced/attached-properties-overview.md).) A propriedade anexada, em seguida, pode ser definida em qualquer classe que deriva de <xref:System.Windows.DependencyObject>.  
  
-   Get, set e desmarque os métodos de utilitário para valores de todas as propriedades de dependência que existem no <xref:System.Windows.DependencyObject>.  
  
-   Metadados, forçar retornos de chamada de substituição para propriedades de dependência, notificação de alteração de propriedade e suporte de valor ou propriedades anexadas. Além disso, o <xref:System.Windows.DependencyObject> classe facilita os metadados de propriedade por proprietário para uma propriedade de dependência.  
  
-   Uma classe base comum para classes derivadas de <xref:System.Windows.ContentElement>, <xref:System.Windows.Freezable>, ou <xref:System.Windows.Media.Visual>. (<xref:System.Windows.UIElement>, outra classe de elemento base, tem uma hierarquia de classe inclui <xref:System.Windows.Media.Visual>.)  
  
   
  
## Examples  
 O exemplo a seguir é derivada de <xref:System.Windows.DependencyObject> para criar uma nova classe abstrata. A classe, em seguida, registra uma propriedade anexada e inclui membros de suporte para a propriedade anexada.  
  
 [!code-csharp[WPFAquariumSln#DOMain](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#domain)]
 [!code-vb[WPFAquariumSln#DOMain](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#domain)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.DependencyProperty" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DependencyObject ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DependencyObject();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Windows.DependencyObject" />.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Windows.DependencyProperty" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ClearValue">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Limpa o valor local de uma propriedade.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ClearValue">
      <MemberSignature Language="C#" Value="public void ClearValue (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearValue(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.ClearValue(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearValue (dp As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ClearValue(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="member this.ClearValue : System.Windows.DependencyProperty -&gt; unit" Usage="dependencyObject.ClearValue dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">A propriedade de dependência a ser limpa, identificada por uma referência de objeto <see cref="T:System.Windows.DependencyProperty" />.</param>
        <summary>Limpa o valor local de uma propriedade. A propriedade a ser limpa é especificada por um identificador <see cref="T:System.Windows.DependencyProperty" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Limpando o valor da propriedade chamando <xref:System.Windows.DependencyObject.ClearValue%2A> não necessariamente dá uma propriedade de dependência o valor padrão especificado nos metadados de propriedade de dependência. Limpando a propriedade somente especificamente limpa qualquer valor local tenham sido aplicado. Para obter mais informações, consulte [Precedência do valor da propriedade de dependência](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md).  
  
   
  
## Examples  
 O exemplo a seguir itera todas as propriedades que têm valores locais definidos em um objeto, em seguida, chama <xref:System.Windows.DependencyObject.ClearValue%2A> para limpar os valores de cada uma dessas propriedades.  
  
 [!code-csharp[DPClearValue#IterateLocalValuesAndClear](~/samples/snippets/csharp/VS_Snippets_Wpf/DPClearValue/CSharp/default.xaml.cs#iteratelocalvaluesandclear)]
 [!code-vb[DPClearValue#IterateLocalValuesAndClear](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DPClearValue/VisualBasic/default.xaml.vb#iteratelocalvaluesandclear)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Tentativa de chamar <see cref="M:System.Windows.DependencyObject.ClearValue(System.Windows.DependencyProperty)" /> em um <see cref="T:System.Windows.DependencyObject" /> lacrado.</exception>
        <altmember cref="M:System.Windows.DependencyObject.SetValue(System.Windows.DependencyProperty,System.Object)" />
        <altmember cref="P:System.Windows.DependencyObject.IsSealed" />
        <altmember cref="T:System.Windows.DependencyProperty" />
      </Docs>
    </Member>
    <Member MemberName="ClearValue">
      <MemberSignature Language="C#" Value="public void ClearValue (System.Windows.DependencyPropertyKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearValue(class System.Windows.DependencyPropertyKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.ClearValue(System.Windows.DependencyPropertyKey)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearValue (key As DependencyPropertyKey)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ClearValue(System::Windows::DependencyPropertyKey ^ key);" />
      <MemberSignature Language="F#" Value="member this.ClearValue : System.Windows.DependencyPropertyKey -&gt; unit" Usage="dependencyObject.ClearValue key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Windows.DependencyPropertyKey" />
      </Parameters>
      <Docs>
        <param name="key">A chave para a propriedade de dependência a ser limpa.</param>
        <summary>Limpa o valor local de uma propriedade somente leitura. A propriedade a ser limpa é especificada por um <see cref="T:System.Windows.DependencyPropertyKey" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um <xref:System.Windows.DependencyPropertyKey> identifica uma propriedade de dependência somente leitura para operações do sistema de propriedade. As classes que definem as propriedades de dependência somente leitura não devem expor essa chave com acesso público. Uma chave exposta publicamente forneceria um caminho de código público que negada o caractere de somente leitura da propriedade, se métodos como <xref:System.Windows.DependencyObject.ClearValue%2A> ou <xref:System.Windows.DependencyObject.SetValue%2A> poderia ser chamado fora da classe ou uma referência de assembly, a chave.  
  
 Limpando o valor da propriedade chamando <xref:System.Windows.DependencyObject.ClearValue%2A> não necessariamente dá uma propriedade de dependência o valor padrão especificado nos metadados de propriedade de dependência. Limpando o valor apenas especificamente limpa qualquer valor local tenham sido aplicado. Para obter mais informações, consulte [Precedência do valor da propriedade de dependência](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Tentativa de chamar <see cref="M:System.Windows.DependencyObject.ClearValue(System.Windows.DependencyProperty)" /> em um <see cref="T:System.Windows.DependencyObject" /> lacrado.</exception>
        <altmember cref="M:System.Windows.DependencyObject.SetValue(System.Windows.DependencyProperty,System.Object)" />
        <altmember cref="T:System.Windows.DependencyPropertyKey" />
      </Docs>
    </Member>
    <Member MemberName="CoerceValue">
      <MemberSignature Language="C#" Value="public void CoerceValue (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CoerceValue(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CoerceValue (dp As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CoerceValue(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="member this.CoerceValue : System.Windows.DependencyProperty -&gt; unit" Usage="dependencyObject.CoerceValue dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">O identificador para a propriedade de dependência impor.</param>
        <summary>Converte o valor da propriedade de dependência especificada. Isso é feito invocando qualquer função <see cref="T:System.Windows.CoerceValueCallback" /> especificada nos metadados de propriedade para a propriedade de dependência, visto que ela existe na chamada a <see cref="T:System.Windows.DependencyObject" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Além do que está sendo invocado explicitamente chamando <xref:System.Windows.DependencyObject.CoerceValue%2A>, o <xref:System.Windows.CoerceValueCallback> de uma dependência de propriedade também é chamada internamente sempre que o valor da propriedade de dependência está sendo reavaliado pelo [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] sistema de propriedades.  
  
 Quando você invoca o <xref:System.Windows.DependencyObject.CoerceValue%2A> método, por fim, você está invocando o retorno de chamada de valor forçados para a propriedade que você especificar. Normalmente, você vai invocar <xref:System.Windows.DependencyObject.CoerceValue%2A> somente se você souber que um retorno de chamada de valor de retornos existe e se você souber os critérios do retorno de chamada de coerção.  
  
 O cenário mais comum para chamada <xref:System.Windows.DependencyObject.CoerceValue%2A> está dentro da classe manipulação ou propriedade alteração retornos de chamada de propriedades relacionadas que influenciam uns dos outros valores de uma forma dependente. Para obter mais informações, consulte [Retornos de chamada da propriedade de dependência e validação](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md).  
  
   
  
## Examples  
 A exemplo a seguir chama <xref:System.Windows.DependencyObject.CoerceValue%2A> dentro de um <xref:System.Windows.PropertyChangedCallback> implementação que é usada como o <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> para um propriedades de dependência diferentes na mesma classe. Esse é um padrão comum para introduzir as dependências de valor verdadeiro entre as propriedades de dependência.  
  
 [!code-csharp[DPCallbackOverride#OnPCCurrent](~/samples/snippets/csharp/VS_Snippets_Wpf/DPCallbackOverride/CSharp/SDKSampleLibrary/class1.cs#onpccurrent)]
 [!code-vb[DPCallbackOverride#OnPCCurrent](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DPCallbackOverride/visualbasic/sdksamplelibrary/class1.vb#onpccurrent)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">O <paramref name="dp" /> especificado ou seu valor eram inválido ou não existem.</exception>
        <altmember cref="T:System.Windows.CoerceValueCallback" />
        <altmember cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="DependencyObjectType">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObjectType DependencyObjectType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyObjectType DependencyObjectType" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyObject.DependencyObjectType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DependencyObjectType As DependencyObjectType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DependencyObjectType ^ DependencyObjectType { System::Windows::DependencyObjectType ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DependencyObjectType : System.Windows.DependencyObjectType" Usage="System.Windows.DependencyObject.DependencyObjectType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObjectType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o <see cref="T:System.Windows.DependencyObjectType" /> que encapsula o tipo [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] dessa instância.</summary>
        <value>Um <see cref="T:System.Windows.DependencyObjectType" /> que encapsula o tipo [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] dessa instância.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa propriedade será útil se um objeto que é retornado de um método tem um tipo de valor de retorno de <xref:System.Windows.DependencyObject> e você deseja executar operações sistema de propriedades específico nele, dependendo de seu tipo. Por exemplo, ele é mais eficiente chamar <xref:System.Windows.DependencyProperty.GetMetadata%28System.Windows.DependencyObjectType%29> usando o <xref:System.Windows.DependencyObjectType> em vez de [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] tipo. <xref:System.Windows.DependencyObjectType> facilita a pesquisa mais rápida.  
  
   
  
## Examples  
 No exemplo de pseudocódigo a seguir `MySubClass` prevê que outras classes derivadas podem alterar o valor padrão de `MyCustom` propriedade de dependência. A classe implementa um construtor padrão que pode determinar a real classe derivada, tirando proveito de polimorfismo <xref:System.Windows.DependencyObjectType> valor sempre que esse construtor é usado como instantiator uma classe derivada.  
  
 `public DOClass() : base()`  
  
 `{`  
  
 `__customPropertyCache = (CustomDP)`  
  
 `CustomDPProperty.GetMetadata(DependencyObjectType).DefaultValue;`  
  
 `}`  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.GetMetadata(System.Type)" />
        <altmember cref="T:System.Windows.DependencyObjectType" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override sealed bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="dependencyObject.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">O <see cref="T:System.Windows.DependencyObject" /> a ser comparado com a instância atual.</param>
        <summary>Determina se um <see cref="T:System.Windows.DependencyObject" /> fornecido é equivalente ao <see cref="T:System.Windows.DependencyObject" /> atual.</summary>
        <returns><see langword="true" /> se as duas instâncias forem iguais; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa implementação é somente a igualdade de referência e não tenta avaliar a igualdade de valor das propriedades independentes.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>
            <see cref="T:System.Windows.DependencyObject" /> substitui e, em seguida, lacra basic duas <see cref="T:System.Object" /> métodos: <see cref="M:System.Windows.DependencyObject.Equals(System.Object)" /> e <see cref="M:System.Windows.DependencyObject.GetHashCode" />. A chamada de substituições de <see cref="T:System.Object" /> implementações, resultando em um comportamento de igualdade do objeto. A finalidade das substituições deliberadas é medidas que impeçam que classes derivadas definir a igualdade de valor para um <see cref="T:System.Windows.DependencyObject" />. Valor igualdades para <see cref="T:System.Windows.DependencyObject" /> nunca será preciso devido aos recursos inata propriedade alterando o valor de um <see cref="T:System.Windows.DependencyObject" /> e suas propriedades de dependência. Isso inclui fundamentais [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] recursos como associação de dados e o [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] sistema de propriedades.</para></block>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override sealed int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="dependencyObject.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtém o código hash para esse <see cref="T:System.Windows.DependencyObject" />.</summary>
        <returns>Um código hash do inteiro com sinal de 32 bits.</returns>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>
            <see cref="T:System.Windows.DependencyObject" /> substitui e, em seguida, lacra duas <see cref="T:System.Object" /> métodos: <see cref="M:System.Windows.DependencyObject.Equals(System.Object)" /> e <see cref="M:System.Windows.DependencyObject.GetHashCode" />. A chamada de substituições de <see cref="T:System.Object" /> implementações, resultando em um comportamento de igualdade do objeto. A finalidade das substituições deliberadas é medidas que impeçam que classes derivadas definir a igualdade de valor para um <see cref="T:System.Windows.DependencyObject" />. Valor igualdades para <see cref="T:System.Windows.DependencyObject" /> nunca será preciso devido aos recursos inata propriedade alterando o valor de um <see cref="T:System.Windows.DependencyObject" /> e suas propriedades de dependência. Isso inclui fundamentais [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] recursos como associação de dados e o [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] sistema de propriedades.</para></block>
      </Docs>
    </Member>
    <Member MemberName="GetLocalValueEnumerator">
      <MemberSignature Language="C#" Value="public System.Windows.LocalValueEnumerator GetLocalValueEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.LocalValueEnumerator GetLocalValueEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.GetLocalValueEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLocalValueEnumerator () As LocalValueEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::LocalValueEnumerator GetLocalValueEnumerator();" />
      <MemberSignature Language="F#" Value="member this.GetLocalValueEnumerator : unit -&gt; System.Windows.LocalValueEnumerator" Usage="dependencyObject.GetLocalValueEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.LocalValueEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cria um enumerador especializado para determinar quais propriedades de dependência têm valores definidos localmente nessa <see cref="T:System.Windows.DependencyObject" />.</summary>
        <returns>Um enumerador do valor de local especializado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um *valor local* é qualquer valor de propriedade de dependência que foi definido por <xref:System.Windows.DependencyObject.SetValue%2A>, em vez de outros aspectos do sistema de propriedades.  
  
 O <xref:System.Windows.LocalValueEnumerator> obtido chamando <xref:System.Windows.DependencyObject.GetLocalValueEnumerator%2A> pode ser usado para enumerar as propriedades que têm definido localmente de valor em um <xref:System.Windows.DependencyObject> instância. Cada uma dessas propriedades é representada no enumerador por um <xref:System.Windows.LocalValueEntry> objeto, que tem propriedades que fazem referência a específica <xref:System.Windows.DependencyProperty> e seus valores. Essa técnica de enumeração definido localmente valores podem ser usados para otimização ou para outro tratamento de valores de locais, por exemplo, para determinar quais valores de propriedade de um <xref:System.Windows.DependencyObject> alteraria se eles foram limpas.  
  
> [!IMPORTANT]
>  Retornado <xref:System.Windows.LocalValueEnumerator> pode conter <xref:System.Windows.LocalValueEntry> registros para as propriedades de dependência são somente leitura ou as propriedades de dependência em que os valores são calculados pelo sistema de propriedades. Por exemplo, um elemento de estrutura visual que tem uma largura estabelecida por meio do layout relatará um valor local para <xref:System.Windows.FrameworkElement.ActualWidth%2A>. Verifique se você estiver obtendo valores locais para redefini-las, o <xref:System.Windows.DependencyProperty.ReadOnly%2A> valor no identificador de propriedade de cada <xref:System.Windows.LocalValueEntry> para verificar se o <xref:System.Windows.DependencyProperty> em questão não é somente leitura.  
  
   
  
## Examples  
 O exemplo a seguir itera todas as propriedades que têm valores locais definidos em um objeto, em seguida, chama <xref:System.Windows.DependencyObject.ClearValue%2A> para limpar os valores de cada uma dessas propriedades.  
  
 [!code-csharp[DPClearValue#IterateLocalValuesAndClear](~/samples/snippets/csharp/VS_Snippets_Wpf/DPClearValue/CSharp/default.xaml.cs#iteratelocalvaluesandclear)]
 [!code-vb[DPClearValue#IterateLocalValuesAndClear](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DPClearValue/VisualBasic/default.xaml.vb#iteratelocalvaluesandclear)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.LocalValueEntry" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.GetValue(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (dp As DependencyProperty) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="member this.GetValue : System.Windows.DependencyProperty -&gt; obj" Usage="dependencyObject.GetValue dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">O identificador <see cref="T:System.Windows.DependencyProperty" /> da propriedade para o qual o valor será recuperado.</param>
        <summary>Retorna o valor efetivo atual de uma propriedade de dependência nessa instância de um <see cref="T:System.Windows.DependencyObject" />.</summary>
        <returns>Retorna o valor efetivo atual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O *valor efetivo* é o valor da propriedade que é retornado pelo sistema de propriedades para qualquer chamador que está solicitando o valor. O valor efetivo é o resultado de ter avaliado todas as entradas possíveis que participam da precedência de valor de sistema de propriedade de sistema de propriedades. Isso inclui a coerção e animação. Para obter mais informações, consulte [Precedência do valor da propriedade de dependência](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md).  
  
 Esse método nunca retornará <xref:System.Windows.DependencyProperty.UnsetValue>. O <xref:System.Windows.DependencyProperty.UnsetValue> é um valor de sentinela para o sistema de propriedade que é usado em várias capacidades internamente e, ocasionalmente, também expostas por meio de retornos de chamada de coerção.  
  
 Se você não tiver certeza de qual deve ser o tipo da propriedade, você pode consultar o identificador da propriedade de dependência solicitada para determinar se há um determinado mais <xref:System.Windows.DependencyProperty.PropertyType%2A> que o valor de retorno pode ser convertido em.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">O <paramref name="dp" /> especificado ou seu valor era inválido ou o <paramref name="dp" /> especificado não existe.</exception>
        <altmember cref="M:System.Windows.DependencyObject.InvalidateProperty(System.Windows.DependencyProperty)" />
        <altmember cref="M:System.Windows.DependencyObject.SetValue(System.Windows.DependencyProperty,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="InvalidateProperty">
      <MemberSignature Language="C#" Value="public void InvalidateProperty (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InvalidateProperty(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.InvalidateProperty(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Sub InvalidateProperty (dp As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InvalidateProperty(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="member this.InvalidateProperty : System.Windows.DependencyProperty -&gt; unit" Usage="dependencyObject.InvalidateProperty dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">O <see cref="T:System.Windows.DependencyProperty" /> identificador exclusivo da propriedade a invalidar.</param>
        <summary>Reavalia o valor efetivo para a propriedade de dependência especificada</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando você chama <xref:System.Windows.DependencyObject.InvalidateProperty%2A>, qualquer associado e aplicáveis <xref:System.Windows.CoerceValueCallback> ou <xref:System.Windows.PropertyChangedCallback> funções registrado para essa propriedade de dependência pode ser invocada.  
  
 Chamar <xref:System.Windows.DependencyObject.InvalidateProperty%2A> em uma propriedade que tem seu valor local definido não terá efeito, porque o valor local tem precedência sobre outras entradas de sistema de propriedade, exceto para animações. No entanto, você poderia chamar <xref:System.Windows.DependencyObject.ClearValue%2A>, em seguida, chame <xref:System.Windows.DependencyObject.InvalidateProperty%2A>. Para obter mais informações, consulte [Precedência do valor da propriedade de dependência](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md).  
  
 Chamar <xref:System.Windows.DependencyObject.InvalidateProperty%2A> não é necessariamente aplicável para muitos cenários de propriedade de dependência. Se uma propriedade de dependência se torna invalidada devido a alterações de valor em qualquer um dos constituintes, o sistema de propriedade invalida e reavalia a propriedade de dependência automaticamente. No entanto, ainda existem alguns cenários apropriados onde <xref:System.Windows.DependencyObject.InvalidateProperty%2A> é útil. Em particular, você pode usar <xref:System.Windows.DependencyObject.InvalidateProperty%2A> dentro do valor de retornos ou a propriedade alterou o retorno de chamada para uma propriedade de dependência diferentes. Você também pode usar <xref:System.Windows.DependencyObject.InvalidateProperty%2A> para forçar a reavaliação de uma associação em relação a uma fonte de dados que não é capaz de implementar o recomendado <xref:System.ComponentModel.INotifyPropertyChanged> mecanismo de notificação (talvez se consumindo classes de dados que não podem ser derivados, ou onde os dados são um estático membro).  
  
   
  
## Examples  
 A exemplo a seguir chama <xref:System.Windows.DependencyObject.InvalidateProperty%2A> em uma propriedade personalizada, sempre que as propriedades que estão envolvidas nos cálculos da propriedade invalidados alterar. Isso é uma técnica alternativa a chamar o <xref:System.Windows.DependencyObject.CoerceValue%2A> método, porque a invalidar a propriedade também irá chamar qualquer registrado <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A>.  
  
 [!code-csharp[PropertySystemEsoterics#InvalidateProperty](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/SDKSampleLibrary/class1.cs#invalidateproperty)]
 [!code-vb[PropertySystemEsoterics#InvalidateProperty](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/sdksamplelibrary/class1.vb#invalidateproperty)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Windows.DependencyProperty.UnsetValue" />
      </Docs>
    </Member>
    <Member MemberName="IsSealed">
      <MemberSignature Language="C#" Value="public bool IsSealed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSealed" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyObject.IsSealed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSealed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSealed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSealed : bool" Usage="System.Windows.DependencyObject.IsSealed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se essa instância está validada no momento (somente leitura).</summary>
        <value><see langword="true" /> se essa instância estiver selada; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse valor é definido internamente.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.FrameworkElementFactory" />
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnPropertyChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPropertyChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPropertyChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPropertyChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="abstract member OnPropertyChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit&#xA;override this.OnPropertyChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="dependencyObject.OnPropertyChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Os dados do evento conterão o identificador de propriedade de dependência de interesse, os metadados para o tipo de propriedade e valores novos e antigos.</param>
        <summary>Invocado sempre que o valor efetivo de qualquer propriedade de dependência nesse <see cref="T:System.Windows.DependencyObject" /> for atualizada. A propriedade de dependência específica que mudou é relatada os dados do evento.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método não deve geralmente detectará as alterações de propriedade individuais ou executar invalidações de propriedades em uma base por caso. <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> em vez disso, destina-se as modificações do padrão da invalidação geral, se determinadas informações são conhecidas sobre amplas classificações de propriedades. Por exemplo, alterações em um <xref:System.Windows.Freezable> alterações nos tipos de valor a <xref:System.Windows.Freezable>, ou pode ser subpropriedades, onde as alterações estão dentro de outros <xref:System.Windows.Freezable> referências. O <xref:System.Windows.Freezable> substituir a implementação de <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> usa informações internas para determinar se as propriedades são subpropriedades e fornece a lógica de classe base apropriada para ambos os casos.  
  
 <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> potencialmente é chamado várias vezes durante o ciclo de vida de um objeto. Portanto, você pode obter o melhor desempenho para o sistema de propriedade geral se você substituir os metadados de propriedades específicas e, em seguida, anexar <xref:System.Windows.CoerceValueCallback> ou <xref:System.Windows.PropertyChangedCallback> funções para as propriedades individuais. No entanto, você usaria esse método se um <xref:System.Windows.DependencyObject> inclui um número significativo de propriedades de dependência inter-relacionados de valor, ou se ele inclui a lógica, como o comportamento de renderização que deve ser executado novamente para vários casos de invalidações de propriedade de relacionados.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Sempre chame a implementação base. Se você não fizer isso significativamente desabilitará toda a [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] sistema de propriedade, fazendo com que valores incorretos a serem relatados.</para></block>
        <altmember cref="T:System.Windows.FrameworkElement" />
      </Docs>
    </Member>
    <Member MemberName="ReadLocalValue">
      <MemberSignature Language="C#" Value="public object ReadLocalValue (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object ReadLocalValue(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.ReadLocalValue(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadLocalValue (dp As DependencyProperty) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ ReadLocalValue(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="member this.ReadLocalValue : System.Windows.DependencyProperty -&gt; obj" Usage="dependencyObject.ReadLocalValue dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">O identificador <see cref="T:System.Windows.DependencyProperty" /> da propriedade para o qual o valor será recuperado.</param>
        <summary>Retorna o valor local de uma propriedade de dependência, local, se houver.</summary>
        <returns>Retorna o valor local ou o valor de sentinela <see cref="F:System.Windows.DependencyProperty.UnsetValue" /> se nenhum valor local é definido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você deve usar <xref:System.Windows.DependencyObject.GetValue%2A> para operações mais comuns de "get" para uma propriedade de dependência. <xref:System.Windows.DependencyObject.ReadLocalValue%2A> não retorna o valor efetivo para uma variedade de circunstâncias em que o valor localmente não foi definido.  
  
 Os valores que são definidos por estilos, temas, modelos, o valor padrão de metadados ou herança do valor da propriedade não são considerados valores locais. No entanto, as associações e outras expressões são considerados valores locais, depois de eles terem sido avaliados.  
  
 Quando nenhum valor local for definido, esse método retorna <xref:System.Windows.DependencyProperty.UnsetValue>.  
  
 Se o valor retornado for diferente de <xref:System.Windows.DependencyProperty.UnsetValue>, você pode consultar os metadados da propriedade de dependência solicitada para determinar se há um tipo mais específico que o valor de retorno pode ser convertido em.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyObject.GetLocalValueEnumerator" />
        <altmember cref="M:System.Windows.DependencyObject.GetValue(System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="SetCurrentValue">
      <MemberSignature Language="C#" Value="public void SetCurrentValue (System.Windows.DependencyProperty dp, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCurrentValue(class System.Windows.DependencyProperty dp, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.SetCurrentValue(System.Windows.DependencyProperty,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCurrentValue (dp As DependencyProperty, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCurrentValue(System::Windows::DependencyProperty ^ dp, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.SetCurrentValue : System.Windows.DependencyProperty * obj -&gt; unit" Usage="dependencyObject.SetCurrentValue (dp, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="value" Type="System.Object" Index="1" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="dp">O identificador da propriedade de dependência a ser definida.</param>
        <param name="value">O novo valor local.</param>
        <summary>Define o valor da propriedade de dependência sem alterar a origem do valor.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é usado por um componente que define programaticamente o valor de uma de suas próprias propriedades sem desabilitar o uso declarado de um aplicativo da propriedade. O <xref:System.Windows.DependencyObject.SetCurrentValue%2A> método altera o valor efetivo de propriedade, mas os gatilhos existentes, associações de dados e estilos continuarão a funcionar.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Houve uma tentativa de modificar uma propriedade de dependência somente leitura ou uma propriedade em um <see cref="T:System.Windows.DependencyObject" /> lacrado.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="value" /> não era do tipo correto conforme registrado para a propriedade <paramref name="dp" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetValue">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Define o valor local de uma propriedade de dependência.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (System.Windows.DependencyProperty dp, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(class System.Windows.DependencyProperty dp, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.SetValue(System.Windows.DependencyProperty,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (dp As DependencyProperty, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Windows::DependencyProperty ^ dp, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.SetValue : System.Windows.DependencyProperty * obj -&gt; unit" Usage="dependencyObject.SetValue (dp, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="dp">O identificador da propriedade de dependência a ser definida.</param>
        <param name="value">O novo valor local.</param>
        <summary>Define o valor local de uma propriedade de dependência, especificada pelo identificador da propriedade de dependência.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se o tipo fornecido não coincide com o tipo que é declarado para a propriedade de dependência conforme ela foi originalmente registrada, uma exceção é lançada. O `value` parâmetro sempre deve ser fornecido como o tipo apropriado.  
  
 As condições de exceção potencialmente são influenciadas pelo <xref:System.Windows.DependencyProperty.ValidateValueCallback%2A> retorno de chamada que existe no identificador de propriedade de dependência da propriedade de dependência que está sendo definido. Caso contrário, o valor fornecido pode estar apresentando falha gerais condições de verificação de tipo (por exemplo, passando uma cadeia de caracteres quando o tipo nativo é dupla).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Houve uma tentativa de modificar uma propriedade de dependência somente leitura ou uma propriedade em um <see cref="T:System.Windows.DependencyObject" /> lacrado.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="value" /> não era do tipo correto conforme registrado para a propriedade <paramref name="dp" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (System.Windows.DependencyPropertyKey key, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(class System.Windows.DependencyPropertyKey key, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.SetValue(System.Windows.DependencyPropertyKey,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (key As DependencyPropertyKey, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Windows::DependencyPropertyKey ^ key, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.SetValue : System.Windows.DependencyPropertyKey * obj -&gt; unit" Usage="dependencyObject.SetValue (key, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Windows.DependencyPropertyKey" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">O identificador <see cref="T:System.Windows.DependencyPropertyKey" /> da propriedade a ser definido.</param>
        <param name="value">O novo valor local.</param>
        <summary>Define o valor de uma propriedade de dependência somente leitura, especificada pelo identificador <see cref="T:System.Windows.DependencyPropertyKey" /> da propriedade de dependência.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa assinatura geralmente é usada quando você define valores para propriedades de dependência somente leitura que são definidos por suas classes personalizadas. Em geral, <xref:System.Windows.DependencyObject.SetValue%2A> é chamado apenas do tipo que registrou essa propriedade de dependência, que implementa a lógica interna que fornece o valor determinado para a propriedade de dependência. Para obter mais informações, consulte [Propriedades de dependência somente leitura](~/docs/framework/wpf/advanced/read-only-dependency-properties.md).  
  
 Se o tipo fornecido não coincide com o tipo que é declarado para a propriedade de dependência conforme ela foi originalmente registrada, uma exceção é lançada. O `value` parâmetro sempre deve ser fornecido como o tipo apropriado. As condições de exceção potencialmente são influenciadas pelo <xref:System.Windows.DependencyProperty.ValidateValueCallback%2A> retorno de chamada que existe no identificador de propriedade de dependência da propriedade de dependência que está sendo definido.  
  
   
  
## Examples  
 O exemplo a seguir define uma propriedade de dependência somente leitura, juntamente com uma `public static readonly` <xref:System.Windows.DependencyProperty> que fornece a exposição de somente leitura necessária para os consumidores de propriedade e o acessador get para o [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] wrapper.  
  
 [!code-csharp[WPFAquariumSln#RODP](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#rodp)]
 [!code-vb[WPFAquariumSln#RODP](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#rodp)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeProperty">
      <MemberSignature Language="C#" Value="protected internal virtual bool ShouldSerializeProperty (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance bool ShouldSerializeProperty(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.ShouldSerializeProperty(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function ShouldSerializeProperty (dp As DependencyProperty) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual bool ShouldSerializeProperty(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="abstract member ShouldSerializeProperty : System.Windows.DependencyProperty -&gt; bool&#xA;override this.ShouldSerializeProperty : System.Windows.DependencyProperty -&gt; bool" Usage="dependencyObject.ShouldSerializeProperty dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">O identificador da propriedade de dependência que deve ser serializado.</param>
        <summary>Retorna um valor que indica se os processos de serialização devem serializar o valor da propriedade de dependência fornecida.</summary>
        <returns><see langword="true" /> se a propriedade de dependência que é fornecida deve ser serializada por valor; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A implementação padrão retorna `true` para todos os casos em que uma propriedade de dependência tinha um valor local estabelecido no <xref:System.Windows.DependencyObject>.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Substituições para este método podem manipular propriedades de dependência específica de forma diferente.</para></block>
      </Docs>
    </Member>
  </Members>
</Type>