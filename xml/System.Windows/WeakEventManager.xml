<Type Name="WeakEventManager" FullName="System.Windows.WeakEventManager">
  <Metadata><Meta Name="ms.openlocfilehash" Value="7c50f8e21321e058314ffb0c59534252db4eb2aa" /><Meta Name="ms.sourcegitcommit" Value="9e06b87bcfa4347dbbaaa4b3cc36b43b93b5badb" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pt-BR" /><Meta Name="ms.lasthandoff" Value="11/20/2018" /><Meta Name="ms.locfileid" Value="52232390" /></Metadata><TypeSignature Language="C#" Value="public abstract class WeakEventManager : System.Windows.Threading.DispatcherObject" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract WeakEventManager extends System.Windows.Threading.DispatcherObject" />
  <TypeSignature Language="DocId" Value="T:System.Windows.WeakEventManager" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class WeakEventManager&#xA;Inherits DispatcherObject" />
  <TypeSignature Language="C++ CLI" Value="public ref class WeakEventManager abstract : System::Windows::Threading::DispatcherObject" />
  <TypeSignature Language="F#" Value="type WeakEventManager = class&#xA;    inherit DispatcherObject" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Threading.DispatcherObject</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Fornece uma classe base para o gerenciador de evento que é usado no *padrão de evento fraco*. O Gerenciador adiciona e remove os ouvintes de eventos (ou retornos de chamada) que também usam o padrão.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você normalmente usa o padrão de evento fraco quando a origem do evento tem um tempo de vida do objeto que é independente dos ouvintes de evento. Usando a central de eventos expedir a capacidade de um <xref:System.Windows.WeakEventManager> permite que os manipuladores do ouvinte para serem limpos mesmo se o objeto de origem persiste. Por outro lado, um vínculo de evento regular usando a `+=` operador faz com que a fonte potencialmente desconectada manter uma referência para os ouvintes. Isso impede que o receptor que está sendo limpos de forma oportuna.  
  
 Uma situação de comuns em que as relações de tempo de vida entre as origens e os ouvintes devem usar o padrão de evento fraco é a manipulação de eventos de atualização provenientes de associações de dados.  
  
 O padrão de evento fraco também pode ser usado para retornos de chamada e eventos regulares.  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides"><para>Para obter um exemplo de um personalizado <see cref="T:System.Windows.WeakEventManager" />, consulte [padrões de evento fraco](~/docs/framework/wpf/advanced/weak-event-patterns.md).</para></block>
    <altmember cref="T:System.Windows.IWeakEventListener" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected WeakEventManager ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; WeakEventManager();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa os valores da classe base quando é usado como o inicializador pelo construtor de uma classe derivada.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DeliverEvent">
      <MemberSignature Language="C#" Value="protected void DeliverEvent (object sender, EventArgs args);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void DeliverEvent(object sender, class System.EventArgs args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.DeliverEvent(System.Object,System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub DeliverEvent (sender As Object, args As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void DeliverEvent(System::Object ^ sender, EventArgs ^ args);" />
      <MemberSignature Language="F#" Value="member this.DeliverEvent : obj * EventArgs -&gt; unit" Usage="weakEventManager.DeliverEvent (sender, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sender" Type="System.Object" />
        <Parameter Name="args" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="sender">O objeto no qual o evento está sendo manipulado.</param>
        <param name="args">Um <see cref="T:System.EventArgs" /> que contém os dados do evento que o evento deve entregar.</param>
        <summary>Fornece o evento que está sendo gerenciado a cada ouvinte.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chame o <xref:System.Windows.WeakEventManager.DeliverEvent%2A> método de dentro de manipuladores de eventos que são adicionadas ou removidas com a <xref:System.Windows.WeakEventManager.StartListening%2A> e <xref:System.Windows.WeakEventManager.StopListening%2A> implementações das subclasses.  
  
 Se você chamar o <xref:System.Windows.WeakEventManager.ProtectedAddListener%2A> método no seu `AddListener` implementação de sua classe, a lista de ouvintes de receber o evento é mantida em uma coleção subjacente. (`AddListener` não faz parte de um contrato de interface ou classe. `AddListener` é o nome sugerido para o método de sua classe de Gerenciador que chama <xref:System.Windows.WeakEventManager.ProtectedAddListener%2A> e adiciona os ouvintes de padrão de evento fraco para o evento.)  
  
 <xref:System.Windows.WeakEventManager.ProtectedAddListener%2A> adiciona ouvintes a uma única lista. Se sua implementação manager mantém mais de uma lista de ouvintes por evento, não use <xref:System.Windows.WeakEventManager.DeliverEvent%2A> ou <xref:System.Windows.WeakEventManager.ProtectedAddListener%2A>. Em vez disso, sua implementação deve criar seu próprio <xref:System.Windows.WeakEventManager.ListenerList> instâncias, `AddListener` deve adicionar ouvintes à lista apropriada e eventos devem ser fornecidos para a lista de ouvinte apropriado ao chamar <xref:System.Windows.WeakEventManager.DeliverEventToList%2A>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
      </Docs>
    </Member>
    <Member MemberName="DeliverEventToList">
      <MemberSignature Language="C#" Value="protected void DeliverEventToList (object sender, EventArgs args, System.Windows.WeakEventManager.ListenerList list);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void DeliverEventToList(object sender, class System.EventArgs args, class System.Windows.WeakEventManager/ListenerList list) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.DeliverEventToList(System.Object,System.EventArgs,System.Windows.WeakEventManager.ListenerList)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub DeliverEventToList (sender As Object, args As EventArgs, list As WeakEventManager.ListenerList)" />
      <MemberSignature Language="F#" Value="member this.DeliverEventToList : obj * EventArgs * System.Windows.WeakEventManager.ListenerList -&gt; unit" Usage="weakEventManager.DeliverEventToList (sender, args, list)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void DeliverEventToList(System::Object ^ sender, EventArgs ^ args, System::Windows::WeakEventManager::ListenerList ^ list);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sender" Type="System.Object" />
        <Parameter Name="args" Type="System.EventArgs" />
        <Parameter Name="list" Type="System.Windows.WeakEventManager+ListenerList" />
      </Parameters>
      <Docs>
        <param name="sender">O objeto no qual o evento está sendo manipulado.</param>
        <param name="args">Um <see cref="T:System.EventArgs" /> que contém os dados do evento.</param>
        <param name="list">A <see cref="T:System.Windows.WeakEventManager.ListenerList" /> fornecida.</param>
        <summary>Entrega o evento que está sendo gerenciado a cada ouvinte na lista fornecida.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é necessário se a sua implementação de gerenciador mantém a lista de ouvintes separados com base nas informações que são capturadas nos dados do evento. Se você usar essa técnica avançada, você deve criar e manter as listas separadas como parte de sua implementação de Gerenciador, e você deve fornecer uma maneira para adicionar ouvintes a uma lista específica. Sua implementação do manipulador que escuta o evento bruto deve agir a condição que você use para diferenciar as listas e entregar o evento somente para a lista apropriada ou listas.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="M:System.Windows.WeakEventManager.DeliverEvent(System.Object,System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentManager">
      <MemberSignature Language="C#" Value="protected static System.Windows.WeakEventManager GetCurrentManager (Type managerType);" />
      <MemberSignature Language="ILAsm" Value=".method familystatic hidebysig class System.Windows.WeakEventManager GetCurrentManager(class System.Type managerType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.GetCurrentManager(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Protected Shared Function GetCurrentManager (managerType As Type) As WeakEventManager" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; static System::Windows::WeakEventManager ^ GetCurrentManager(Type ^ managerType);" />
      <MemberSignature Language="F#" Value="static member GetCurrentManager : Type -&gt; System.Windows.WeakEventManager" Usage="System.Windows.WeakEventManager.GetCurrentManager managerType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.WeakEventManager</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="managerType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="managerType">O tipo para o qual o <see cref="T:System.Windows.WeakEventManager" /> deve ser obtido.</param>
        <summary>Retorna a implementação de <see cref="T:System.Windows.WeakEventManager" /> que é usada para o tipo fornecido.</summary>
        <returns>A implementação de <see cref="T:System.Windows.WeakEventManager" /> correspondente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.IWeakEventListener.ReceiveWeakEvent%2A> implementações de chamar esse método usando seus passado `managerType`. Retornado <xref:System.Windows.WeakEventManager> , em seguida, é usado como o diferencial que determina qual evento foi recebido e quais manipulador de classe privada a ser invocado.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="M:System.Windows.WeakEventManager.SetCurrentManager(System.Type,System.Windows.WeakEventManager)" />
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="protected object this[object source] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Item(object)" />
      <MemberSignature Language="DocId" Value="P:System.Windows.WeakEventManager.Item(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Default Protected Property Item(source As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Object ^ default[System::Object ^] { System::Object ^ get(System::Object ^ source); void set(System::Object ^ source, System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Item(obj) : obj with get, set" Usage="System.Windows.WeakEventManager.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="source">O índice de base zero da origem solicitada.</param>
        <summary>Obtém ou define os dados que estão sendo armazenados para a origem especificada.</summary>
        <value>Dados que estão sendo armazenados pelo Gerenciador para esta fonte.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Classes derivadas podem escolher quais dados e o tipo para armazenar nesse indexador. Normalmente, isso é implementado como um <xref:System.Windows.WeakEventManager.ListenerList>, que é uma lista de referências fracas para ouvintes. Você só precisará alterar esse tipo se o <xref:System.Windows.WeakEventManager.ListenerList> tipo não pode conter as informações necessárias. Se assim, você precisará substituir o <xref:System.Windows.WeakEventManager.Purge%2A> método para que toda a limpeza do tipo subjacente seja executada corretamente.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="T:System.Windows.WeakEventManager.ListenerList" />
      </Docs>
    </Member>
    <Member MemberName="NewListenerList">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.WeakEventManager.ListenerList NewListenerList ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Windows.WeakEventManager/ListenerList NewListenerList() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.NewListenerList" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function NewListenerList () As WeakEventManager.ListenerList" />
      <MemberSignature Language="F#" Value="abstract member NewListenerList : unit -&gt; System.Windows.WeakEventManager.ListenerList&#xA;override this.NewListenerList : unit -&gt; System.Windows.WeakEventManager.ListenerList" Usage="weakEventManager.NewListenerList " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.WeakEventManager+ListenerList</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna um novo objeto para conter os ouvintes de um evento.</summary>
        <returns>Um novo objeto para conter os ouvintes de um evento.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ProtectedAddHandler">
      <MemberSignature Language="C#" Value="protected void ProtectedAddHandler (object source, Delegate handler);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ProtectedAddHandler(object source, class System.Delegate handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.ProtectedAddHandler(System.Object,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ProtectedAddHandler (source As Object, handler As Delegate)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ProtectedAddHandler(System::Object ^ source, Delegate ^ handler);" />
      <MemberSignature Language="F#" Value="member this.ProtectedAddHandler : obj * Delegate -&gt; unit" Usage="weakEventManager.ProtectedAddHandler (source, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
        <Parameter Name="handler" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="source">O objeto de origem que o representante do manipulador assina.</param>
        <param name="handler">O delegado que manipula o evento gerado por <paramref name="source" />.</param>
        <summary>Adiciona o delegado especificado como um manipulador de eventos de origem especificada.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ProtectedAddListener">
      <MemberSignature Language="C#" Value="protected void ProtectedAddListener (object source, System.Windows.IWeakEventListener listener);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ProtectedAddListener(object source, class System.Windows.IWeakEventListener listener) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.ProtectedAddListener(System.Object,System.Windows.IWeakEventListener)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ProtectedAddListener (source As Object, listener As IWeakEventListener)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ProtectedAddListener(System::Object ^ source, System::Windows::IWeakEventListener ^ listener);" />
      <MemberSignature Language="F#" Value="member this.ProtectedAddListener : obj * System.Windows.IWeakEventListener -&gt; unit" Usage="weakEventManager.ProtectedAddListener (source, listener)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
        <Parameter Name="listener" Type="System.Windows.IWeakEventListener" />
      </Parameters>
      <Docs>
        <param name="source">A origem à qual os ouvintes devem ser anexados.</param>
        <param name="listener">A classe de escuta (que deve implementar <see cref="T:System.Windows.IWeakEventListener" />).</param>
        <summary>Adiciona o ouvinte fornecido à origem fornecida para o evento que está sendo gerenciado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chame esse método em sua classe de Gerenciador `AddListener` métodos em <xref:System.Windows.WeakEventManager> implementações. `AddListener` é o nome sugerido para o método estático que você define em sua classe manager para habilitar outras classes adicionar um ouvinte para seu padrão de evento fraco. `AddListener` deve levar dois parâmetros: o `source` em que o ouvinte estiver anexado e o `listener` instância. Para seus `AddListener` implementação, chame o <xref:System.Windows.WeakEventManager.ProtectedAddListener%2A> método no Gerenciador atual e passe os mesmos dois parâmetros.  
  
 Se a lista de ouvintes estava anteriormente vazia, <xref:System.Windows.WeakEventManager.ProtectedAddListener%2A> chamadas a <xref:System.Windows.WeakEventManager.StartListening%2A> método internamente, que chamará seu específicas <xref:System.Windows.WeakEventManager.StartListening%2A> substituir por meio de polimorfismo.  
  
 <xref:System.Windows.WeakEventManager.ProtectedAddListener%2A> Adiciona os ouvintes para um único interno <xref:System.Windows.WeakEventManager.ListenerList> por `source`. Se sua implementação manager mantém mais de uma lista de ouvintes para cada combinação de origem do evento, não use <xref:System.Windows.WeakEventManager.ProtectedAddListener%2A>. Em vez disso, sua implementação deve criar seu próprio <xref:System.Windows.WeakEventManager.ListenerList> instâncias, `AddListener` deve adicionar ouvintes à lista apropriada e eventos devem ser fornecidos para a lista de ouvinte apropriado ao chamar o <xref:System.Windows.WeakEventManager.DeliverEventToList%2A> evento em vez de <xref:System.Windows.WeakEventManager.DeliverEvent%2A> método.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="M:System.Windows.WeakEventManager.ProtectedRemoveListener(System.Object,System.Windows.IWeakEventListener)" />
      </Docs>
    </Member>
    <Member MemberName="ProtectedRemoveHandler">
      <MemberSignature Language="C#" Value="protected void ProtectedRemoveHandler (object source, Delegate handler);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ProtectedRemoveHandler(object source, class System.Delegate handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.ProtectedRemoveHandler(System.Object,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ProtectedRemoveHandler (source As Object, handler As Delegate)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ProtectedRemoveHandler(System::Object ^ source, Delegate ^ handler);" />
      <MemberSignature Language="F#" Value="member this.ProtectedRemoveHandler : obj * Delegate -&gt; unit" Usage="weakEventManager.ProtectedRemoveHandler (source, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
        <Parameter Name="handler" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="source">A origem da qual o manipulador deve ser removido.</param>
        <param name="handler">O delegado a ser removido de <paramref name="source" />.</param>
        <summary>Remove o manipulador adicionado anteriormente da origem especificada.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ProtectedRemoveListener">
      <MemberSignature Language="C#" Value="protected void ProtectedRemoveListener (object source, System.Windows.IWeakEventListener listener);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ProtectedRemoveListener(object source, class System.Windows.IWeakEventListener listener) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.ProtectedRemoveListener(System.Object,System.Windows.IWeakEventListener)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ProtectedRemoveListener (source As Object, listener As IWeakEventListener)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ProtectedRemoveListener(System::Object ^ source, System::Windows::IWeakEventListener ^ listener);" />
      <MemberSignature Language="F#" Value="member this.ProtectedRemoveListener : obj * System.Windows.IWeakEventListener -&gt; unit" Usage="weakEventManager.ProtectedRemoveListener (source, listener)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
        <Parameter Name="listener" Type="System.Windows.IWeakEventListener" />
      </Parameters>
      <Docs>
        <param name="source">A origem da qual os ouvintes devem ser removidos.</param>
        <param name="listener">A classe de escuta (que deve implementar <see cref="T:System.Windows.IWeakEventListener" />).</param>
        <summary>Remove um ouvinte adicionado anteriormente da origem fornecida.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chame esse método em sua classe de Gerenciador `RemoveListener` métodos em <xref:System.Windows.WeakEventManager> implementações. `RemoveListener` é o nome sugerido para o método estático que você define em sua classe manager para habilitar outras classes remover um ouvinte para seu padrão de evento fraco. `RemoveListener` deve levar dois parâmetros: o `source` em que o ouvinte é removido e o `listener` classe. Para seus `RemoveListener` implementação, chame o <xref:System.Windows.WeakEventManager.ProtectedRemoveListener%2A> método no Gerenciador atual e passe os mesmos dois parâmetros.  
  
 Se uma chamada para <xref:System.Windows.WeakEventManager.ProtectedRemoveListener%2A> remove o último ouvinte na lista de <xref:System.Windows.WeakEventManager.ProtectedRemoveListener%2A> chamadas a <xref:System.Windows.WeakEventManager.StopListening%2A> método internamente, que chamará seu específicas <xref:System.Windows.WeakEventManager.StopListening%2A> substituir por meio de polimorfismo.  
  
 <xref:System.Windows.WeakEventManager.ProtectedRemoveListener%2A> Remove os ouvintes de um único interno <xref:System.Windows.WeakEventManager.ListenerList> por `source`. Se sua implementação manager mantém mais de uma lista de ouvintes para cada combinação de origem do evento, não use <xref:System.Windows.WeakEventManager.ProtectedRemoveListener%2A>. Em vez disso, sua implementação deve criar seu próprio <xref:System.Windows.WeakEventManager.ListenerList> instâncias, `RemoveListener` deve remover os ouvintes da lista apropriada e eventos devem ser fornecidos para a lista de ouvinte apropriado ao chamar o <xref:System.Windows.WeakEventManager.DeliverEventToList%2A> método em vez da <xref:System.Windows.WeakEventManager.DeliverEvent%2A> método.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="M:System.Windows.WeakEventManager.ProtectedAddListener(System.Object,System.Windows.IWeakEventListener)" />
      </Docs>
    </Member>
    <Member MemberName="Purge">
      <MemberSignature Language="C#" Value="protected virtual bool Purge (object source, object data, bool purgeAll);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool Purge(object source, object data, bool purgeAll) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.Purge(System.Object,System.Object,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function Purge (source As Object, data As Object, purgeAll As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool Purge(System::Object ^ source, System::Object ^ data, bool purgeAll);" />
      <MemberSignature Language="F#" Value="abstract member Purge : obj * obj * bool -&gt; bool&#xA;override this.Purge : obj * obj * bool -&gt; bool" Usage="weakEventManager.Purge (source, data, purgeAll)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
        <Parameter Name="data" Type="System.Object" />
        <Parameter Name="purgeAll" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="source">A origem de eventos que está sendo ouvida.</param>
        <param name="data">Os dados a serem verificados. Espera-se que este objeto seja uma implementação de <see cref="T:System.Windows.WeakEventManager.ListenerList" />.</param>
        <param name="purgeAll">O <see langword="true" /> para parar de escutar <paramref name="source" /> e remover completamente todas as entradas de <paramref name="data" />.</param>
        <summary>Remove entradas do ouvinte inativo da lista de dados para a origem fornecida. Retornará <see langword="true" /> se algumas entradas realmente tiverem sido removidas da lista.</summary>
        <returns><see langword="true" /> se algumas entradas foram removidas, caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Windows.WeakEventManager.Purge%2A> o método tem uma implementação padrão que removerá todas as entradas quando os dados são um <xref:System.Windows.WeakEventManager.ListenerList>.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Se subjacente tipo para o <see cref="P:System.Windows.WeakEventManager.Item(System.Object)" /> for algo diferente de <see cref="T:System.Windows.WeakEventManager.ListenerList" />, ou contém dados com mais de uma <see cref="T:System.Windows.WeakEventManager.ListenerList" />, você deve substituir o <see cref="M:System.Windows.WeakEventManager.Purge(System.Object,System.Object,System.Boolean)" /> método. A substituição deve fornecer um comportamento de limpeza para obter a lista de itens do tipo alternativo. Em geral, a substituição deve fornecer um comportamento sem chamar a implementação base. Se um determinado <see cref="T:System.Windows.WeakEventManager.ListenerList" /> ainda precisa limpar, chamada <see cref="M:System.Windows.WeakEventManager.ListenerList.Purge" />.</para></block>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="T:System.Windows.WeakEventManager.ListenerList" />
      </Docs>
    </Member>
    <Member MemberName="ReadLock">
      <MemberSignature Language="C#" Value="protected IDisposable ReadLock { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IDisposable ReadLock" />
      <MemberSignature Language="DocId" Value="P:System.Windows.WeakEventManager.ReadLock" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property ReadLock As IDisposable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property IDisposable ^ ReadLock { IDisposable ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReadLock : IDisposable" Usage="System.Windows.WeakEventManager.ReadLock" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IDisposable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Estabelece um bloqueio de leitura na tabela de dados subjacente e retorna um <see cref="T:System.IDisposable" />.</summary>
        <value>Um objeto que pode ser usado para estabelecer um bloqueio em membros de dados de tabela e, em seguida, ser descartado corretamente com um <see langword="using" /> construir.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Em classes derivadas, consultas à tabela contida no <xref:System.Windows.WeakEventManager.Item%2A> sempre devem ocorrer dentro de um `using (ReadLock) { ... }` cláusula, exceto para consultas que já estão dentro de um bloqueio de gravação. Essas consultas poderão ser necessárias se a sua classe oferece suporte a mais sofisticados `AddListener` implementação que requer mais dados, além do `source` e o `listener`e usa o <xref:System.Windows.WeakEventManager.Item%2A> coleção para armazenar as informações extras.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="T:System.Windows.WeakEventManager.ListenerList" />
        <altmember cref="P:System.Windows.WeakEventManager.WriteLock" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="protected void Remove (object source);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void Remove(object source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.Remove(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub Remove (source As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void Remove(System::Object ^ source);" />
      <MemberSignature Language="F#" Value="member this.Remove : obj -&gt; unit" Usage="weakEventManager.Remove source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="source">A origem da qual as informações de ouvinte devem ser removidas.</param>
        <summary>Remove todos os ouvintes da origem especificada.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="T:System.Windows.WeakEventManager.ListenerList" />
        <altmember cref="M:System.Windows.WeakEventManager.ProtectedRemoveListener(System.Object,System.Windows.IWeakEventListener)" />
      </Docs>
    </Member>
    <Member MemberName="ScheduleCleanup">
      <MemberSignature Language="C#" Value="protected void ScheduleCleanup ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ScheduleCleanup() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.ScheduleCleanup" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ScheduleCleanup ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ScheduleCleanup();" />
      <MemberSignature Language="F#" Value="member this.ScheduleCleanup : unit -&gt; unit" Usage="weakEventManager.ScheduleCleanup " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Solicita que uma limpeza de entradas não usadas na lista de ouvintes subjacente seja executada em um thread de prioridade mais baixa.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chamar o <xref:System.Windows.WeakEventManager.ScheduleCleanup%2A> método é semelhante a chamar o <xref:System.Windows.WeakEventManager.Purge%2A> método na lista do gerente, com prioridade mais baixa do thread, com o `purgeAll` parâmetro definido como `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="M:System.Windows.WeakEventManager.Purge(System.Object,System.Object,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="SetCurrentManager">
      <MemberSignature Language="C#" Value="protected static void SetCurrentManager (Type managerType, System.Windows.WeakEventManager manager);" />
      <MemberSignature Language="ILAsm" Value=".method familystatic hidebysig void SetCurrentManager(class System.Type managerType, class System.Windows.WeakEventManager manager) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.SetCurrentManager(System.Type,System.Windows.WeakEventManager)" />
      <MemberSignature Language="VB.NET" Value="Protected Shared Sub SetCurrentManager (managerType As Type, manager As WeakEventManager)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; static void SetCurrentManager(Type ^ managerType, System::Windows::WeakEventManager ^ manager);" />
      <MemberSignature Language="F#" Value="static member SetCurrentManager : Type * System.Windows.WeakEventManager -&gt; unit" Usage="System.Windows.WeakEventManager.SetCurrentManager (managerType, manager)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="managerType" Type="System.Type" />
        <Parameter Name="manager" Type="System.Windows.WeakEventManager" />
      </Parameters>
      <Docs>
        <param name="managerType">O tipo para definir o novo gerenciador de eventos.</param>
        <param name="manager">O novo gerenciador de eventos.</param>
        <summary>Define o gerenciador atual para o tipo de gerenciador especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chame o <xref:System.Windows.WeakEventManager.SetCurrentManager%2A> método para inicializar um gerente, se isso é necessário por uma chamada para seu `CurrentManager` propriedade em um <xref:System.Windows.WeakEventManager> implementação.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="M:System.Windows.WeakEventManager.GetCurrentManager(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="StartListening">
      <MemberSignature Language="C#" Value="protected abstract void StartListening (object source);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void StartListening(object source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.StartListening(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Sub StartListening (source As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void StartListening(System::Object ^ source);" />
      <MemberSignature Language="F#" Value="abstract member StartListening : obj -&gt; unit" Usage="weakEventManager.StartListening source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="source">A origem na qual a escuta deve ser iniciada.</param>
        <summary>Quando substituído em uma classe derivada, inicia a escuta para o evento que está sendo gerenciado. Depois que o método <see cref="M:System.Windows.WeakEventManager.StartListening(System.Object)" /> for chamado pela primeira vez, o gerenciador deverá estar no estado de chamada de <see cref="M:System.Windows.WeakEventManager.DeliverEvent(System.Object,System.EventArgs)" /> ou de <see cref="M:System.Windows.WeakEventManager.DeliverEventToList(System.Object,System.EventArgs,System.Windows.WeakEventManager.ListenerList)" /> sempre que o evento relevante da origem fornecida for manipulado.</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>
            <see cref="M:System.Windows.WeakEventManager.StartListening(System.Object)" /> substituições devem adicionar um manipulador a fornecido <paramref name="source" />. O manipulador é declarado pelo Gerenciador de si mesmo. O manipulador de classe não deve ser público e só deve ser chamado em resposta ao evento que está sendo gerenciado. O manipulador de classe deverá chamar o <see cref="M:System.Windows.WeakEventManager.DeliverEvent(System.Object,System.EventArgs)" /> método ou o <see cref="M:System.Windows.WeakEventManager.DeliverEventToList(System.Object,System.EventArgs,System.Windows.WeakEventManager.ListenerList)" /> método adequadamente.</para></block>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="M:System.Windows.WeakEventManager.GetCurrentManager(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="StopListening">
      <MemberSignature Language="C#" Value="protected abstract void StopListening (object source);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void StopListening(object source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.StopListening(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Sub StopListening (source As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void StopListening(System::Object ^ source);" />
      <MemberSignature Language="F#" Value="abstract member StopListening : obj -&gt; unit" Usage="weakEventManager.StopListening source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="source">A origem cuja escuta deve ser interrompida.</param>
        <summary>Quando substituído em uma classe derivada, interrompe a escuta da origem fornecida para o evento que está sendo gerenciado.</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>
            <see cref="M:System.Windows.WeakEventManager.StopListening(System.Object)" /> implementações devem remover o manipulador de classe como adicionado pelo <see cref="M:System.Windows.WeakEventManager.StartListening(System.Object)" /> método. Remover um ouvinte não deve limpar a lista de escuta. Em vez disso, ele só deve desconectar o manipulador de classe (talvez temporariamente). Outros métodos estão disponíveis para limpar a lista inteira, como o <see cref="M:System.Windows.WeakEventManager.Purge(System.Object,System.Object,System.Boolean)" /> método com o <paramref name="purgeAll" /> parâmetro definido como <see langword="true" />.</para></block>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="M:System.Windows.WeakEventManager.StartListening(System.Object)" />
        <altmember cref="M:System.Windows.WeakEventManager.Purge(System.Object,System.Object,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="WriteLock">
      <MemberSignature Language="C#" Value="protected IDisposable WriteLock { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IDisposable WriteLock" />
      <MemberSignature Language="DocId" Value="P:System.Windows.WeakEventManager.WriteLock" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property WriteLock As IDisposable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property IDisposable ^ WriteLock { IDisposable ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.WriteLock : IDisposable" Usage="System.Windows.WeakEventManager.WriteLock" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IDisposable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Estabelece um bloqueio de gravação na tabela de dados subjacente e retorna um <see cref="T:System.IDisposable" />.</summary>
        <value>Um objeto que pode ser usado para estabelecer um bloqueio em membros de dados de tabela e, em seguida, ser descartado corretamente com um <see langword="using" /> construir.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Em classes derivadas, todas as modificações na tabela de dados subjacente devem ocorrer dentro de um `using (WriteLock) { ... }` cláusula. Essas modificações podem ser necessárias se a sua classe oferece suporte a mais sofisticados `AddListener` implementação que requer mais dados, além do `source` e o `listener`e usa o <xref:System.Windows.WeakEventManager.Item%2A> coleção para armazenar as informações extras.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="T:System.Windows.WeakEventManager.ListenerList" />
        <altmember cref="P:System.Windows.WeakEventManager.ReadLock" />
      </Docs>
    </Member>
  </Members>
</Type>