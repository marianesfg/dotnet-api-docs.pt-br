<Type Name="PropertyMetadata" FullName="System.Windows.PropertyMetadata">
  <Metadata><Meta Name="ms.openlocfilehash" Value="423f853a60d99a5767f47d8a9e4d3ef0dce3cb15" /><Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="pt-BR" /><Meta Name="ms.lasthandoff" Value="08/25/2018" /><Meta Name="ms.locfileid" Value="39845052" /></Metadata><TypeSignature Language="C#" Value="public class PropertyMetadata" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit PropertyMetadata extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.PropertyMetadata" />
  <TypeSignature Language="VB.NET" Value="Public Class PropertyMetadata" />
  <TypeSignature Language="C++ CLI" Value="public ref class PropertyMetadata" />
  <TypeSignature Language="F#" Value="type PropertyMetadata = class" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary><span data-ttu-id="3dbab-101">Define alguns aspectos do comportamento de uma propriedade de dependência conforme ela é aplicada a um tipo específico, incluindo as condições com as quais ela foi registrada.</span><span class="sxs-lookup"><span data-stu-id="3dbab-101">Defines certain behavior aspects of a dependency property as it is applied to a specific type, including conditions it was registered with.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3dbab-102">Metadados de propriedade podem ser definidos e usados durante o registro de propriedade de dependência ao chamar o <xref:System.Windows.DependencyProperty.Register%2A> método (ou variações para propriedades anexadas ou propriedades de dependência somente leitura), ou após o registro de proprietário original ao chamar o <xref:System.Windows.DependencyPropertyKey.OverrideMetadata%2A> método.</span><span class="sxs-lookup"><span data-stu-id="3dbab-102">Property metadata can be defined and used during dependency property registration when calling the <xref:System.Windows.DependencyProperty.Register%2A> method (or variations for attached properties or read-only dependency properties), or after original owner registration when calling the <xref:System.Windows.DependencyPropertyKey.OverrideMetadata%2A> method.</span></span> <span data-ttu-id="3dbab-103"><xref:System.Windows.DependencyProperty.AddOwner%2A> também usa os metadados de propriedade.</span><span class="sxs-lookup"><span data-stu-id="3dbab-103"><xref:System.Windows.DependencyProperty.AddOwner%2A> also takes property metadata.</span></span>  
  
 <span data-ttu-id="3dbab-104">Essa classe é uma classe base concreta que pode ser usada em cada uma dessas chamadas.</span><span class="sxs-lookup"><span data-stu-id="3dbab-104">This class is a concrete base class that can be used in each of these calls.</span></span> <span data-ttu-id="3dbab-105">No entanto, é muito comum para especificar os metadados usando uma das classes derivadas como <xref:System.Windows.FrameworkPropertyMetadata>.</span><span class="sxs-lookup"><span data-stu-id="3dbab-105">However, it is very common to specify metadata using one of the derived classes such as <xref:System.Windows.FrameworkPropertyMetadata>.</span></span> <span data-ttu-id="3dbab-106">Essas classes derivadas de metadados mais detalhados transportado como valores de propriedade booliana, que são úteis para detectar ou para habilitar alguns comportamentos de layout e o sistema de propriedade que são implementados somente no dão suporte a [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] nível de estrutura.</span><span class="sxs-lookup"><span data-stu-id="3dbab-106">These derived classes support more detailed metadata carried as Boolean property values, which are useful for either detecting or enabling some property system and layout behaviors that are only implemented at the [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] framework level.</span></span>  
  
 <span data-ttu-id="3dbab-107">Várias propriedades dessa classe são leitura / gravação para o modelo de objeto, mas só podem ser gravados antes da instância que está sendo usada em uma operação de sistema de propriedade, como <xref:System.Windows.DependencyProperty.Register%2A> ou <xref:System.Windows.DependencyPropertyKey.OverrideMetadata%2A>.</span><span class="sxs-lookup"><span data-stu-id="3dbab-107">Several properties of this class are read-write to the object model, but can only be written prior to the instance being used in a property system operation such as <xref:System.Windows.DependencyProperty.Register%2A> or <xref:System.Windows.DependencyPropertyKey.OverrideMetadata%2A>.</span></span> <span data-ttu-id="3dbab-108">Cada uma dessas propriedades também poderia ter sido definida pelo construtor, mas são expostos para que <xref:System.Windows.PropertyMetadata.Merge%2A> implementações de método podem defini-las.</span><span class="sxs-lookup"><span data-stu-id="3dbab-108">Each of these properties could also have been set by the constructor but are exposed so that <xref:System.Windows.PropertyMetadata.Merge%2A> method implementations can set them.</span></span>  
  
<a name="xamlTextUsage_PropertyMetadata"></a>   
## <a name="xaml-text-usage"></a><span data-ttu-id="3dbab-109">Uso de texto XAML</span><span class="sxs-lookup"><span data-stu-id="3dbab-109">XAML Text Usage</span></span>  
 <span data-ttu-id="3dbab-110">Esse tipo e os membros desse tipo, não são usados normalmente em [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span><span class="sxs-lookup"><span data-stu-id="3dbab-110">This type, and members of this type, are not typically used in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span></span>  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="3dbab-111">Inicializa uma nova instância da classe <see cref="T:System.Windows.PropertyMetadata" />.</span><span class="sxs-lookup"><span data-stu-id="3dbab-111">Initializes a new instance of the <see cref="T:System.Windows.PropertyMetadata" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PropertyMetadata ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PropertyMetadata();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="3dbab-112">Inicializa uma nova instância da classe <see cref="T:System.Windows.PropertyMetadata" />.</span><span class="sxs-lookup"><span data-stu-id="3dbab-112">Initializes a new instance of the <see cref="T:System.Windows.PropertyMetadata" /> class.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PropertyMetadata (object defaultValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.#ctor(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (defaultValue As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PropertyMetadata(System::Object ^ defaultValue);" />
      <MemberSignature Language="F#" Value="new System.Windows.PropertyMetadata : obj -&gt; System.Windows.PropertyMetadata" Usage="new System.Windows.PropertyMetadata defaultValue" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="defaultValue"><span data-ttu-id="3dbab-113">O valor padrão a especificar para a propriedade de dependência, geralmente fornecido como um valor de um tipo específico.</span><span class="sxs-lookup"><span data-stu-id="3dbab-113">The default value to specify for a dependency property, usually provided as a value of some specific type.</span></span></param>
        <summary><span data-ttu-id="3dbab-114">Inicializa uma nova instância da classe <see cref="T:System.Windows.PropertyMetadata" /> com um valor padrão especificado para a propriedade de dependência à qual estes metadados serão aplicados.</span><span class="sxs-lookup"><span data-stu-id="3dbab-114">Initializes a new instance of the <see cref="T:System.Windows.PropertyMetadata" /> class with a specified default value for the dependency property that this metadata will be applied to.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3dbab-115">O tipo do valor fornecido para `defaultValue` deve ser correspondência ou estar relacionado ao tipo especificado no registro original da propriedade de dependência que serão aplicados a esses metadados.</span><span class="sxs-lookup"><span data-stu-id="3dbab-115">The type of the value provided for `defaultValue` must be match or be related to the type specified in the original registration of the dependency property that this metadata will be applied to.</span></span> <span data-ttu-id="3dbab-116">Incompatibilidades entre o tipo de valor padrão de metadados e o tipo da propriedade de dependência que ele está sendo aplicado podem ser difícil de depurar, porque a incompatibilidade não podem ser detectada durante a compilação (incompatibilidade irá gerar uma exceção de tempo de execução).</span><span class="sxs-lookup"><span data-stu-id="3dbab-116">Mismatches between metadata default value type and the type of the dependency property it is being applied to can be difficult to debug, because the mismatch is not detectable during compilation (the mismatch will raise a run-time exception).</span></span>  
  
 <span data-ttu-id="3dbab-117">Embora seja o padrão por um construtor sem parâmetros, uma `defaultValue` de <xref:System.Windows.DependencyProperty.UnsetValue> não pode ser especificado.</span><span class="sxs-lookup"><span data-stu-id="3dbab-117">Although it is the default per the parameterless constructor, a `defaultValue` of <xref:System.Windows.DependencyProperty.UnsetValue> cannot be specified.</span></span> <span data-ttu-id="3dbab-118">Tentar fazer isso irá gerar uma exceção.</span><span class="sxs-lookup"><span data-stu-id="3dbab-118">Attempting to do so will raise an exception.</span></span>  
  
   
  
## Examples  
 [!code-csharp[PropertyMetadataAPIs#Initpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initpm)]  
[!code-csharp[PropertyMetadataAPIs#PMCtor1param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#pmctor1param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="3dbab-119"><paramref name="defaultValue" /> não pode ser definido como o valor <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</span><span class="sxs-lookup"><span data-stu-id="3dbab-119"><paramref name="defaultValue" /> cannot be set to the value <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PropertyMetadata (System.Windows.PropertyChangedCallback propertyChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.PropertyChangedCallback propertyChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.#ctor(System.Windows.PropertyChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PropertyMetadata(System::Windows::PropertyChangedCallback ^ propertyChangedCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.PropertyMetadata : System.Windows.PropertyChangedCallback -&gt; System.Windows.PropertyMetadata" Usage="new System.Windows.PropertyMetadata propertyChangedCallback" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
      </Parameters>
      <Docs>
        <param name="propertyChangedCallback"><span data-ttu-id="3dbab-120">Referência a uma implementação do manipulador que será chamada pelo sistema de propriedades sempre que o valor efetivo da propriedade for alterado.</span><span class="sxs-lookup"><span data-stu-id="3dbab-120">Reference to a handler implementation that is to be called by the property system whenever the effective value of the property changes.</span></span></param>
        <summary><span data-ttu-id="3dbab-121">Inicializa uma nova instância da classe <see cref="T:System.Windows.PropertyMetadata" /> com a referência da implementação <see cref="T:System.Windows.PropertyChangedCallback" /> especificada.</span><span class="sxs-lookup"><span data-stu-id="3dbab-121">Initializes a new instance of the <see cref="T:System.Windows.PropertyMetadata" /> class with the specified <see cref="T:System.Windows.PropertyChangedCallback" /> implementation reference.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-csharp[PropertyMetadataAPIs#Initpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initpm)]  
[!code-csharp[PropertyMetadataAPIs#PMCtor1paramcallback](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#pmctor1paramcallback)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PropertyMetadata (object defaultValue, System.Windows.PropertyChangedCallback propertyChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, class System.Windows.PropertyChangedCallback propertyChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PropertyMetadata(System::Object ^ defaultValue, System::Windows::PropertyChangedCallback ^ propertyChangedCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.PropertyMetadata : obj * System.Windows.PropertyChangedCallback -&gt; System.Windows.PropertyMetadata" Usage="new System.Windows.PropertyMetadata (defaultValue, propertyChangedCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue"><span data-ttu-id="3dbab-122">O valor padrão da propriedade de dependência, geralmente fornecido como um valor de um tipo específico.</span><span class="sxs-lookup"><span data-stu-id="3dbab-122">The default value of the dependency property, usually provided as a value of some specific type.</span></span></param>
        <param name="propertyChangedCallback"><span data-ttu-id="3dbab-123">Referência a uma implementação do manipulador que será chamada pelo sistema de propriedades sempre que o valor efetivo da propriedade for alterado.</span><span class="sxs-lookup"><span data-stu-id="3dbab-123">Reference to a handler implementation that is to be called by the property system whenever the effective value of the property changes.</span></span></param>
        <summary><span data-ttu-id="3dbab-124">Inicializa uma nova instância da classe <see cref="T:System.Windows.PropertyMetadata" /> com o valor padrão especificado e a referência de implementação <see cref="T:System.Windows.PropertyChangedCallback" />.</span><span class="sxs-lookup"><span data-stu-id="3dbab-124">Initializes a new instance of the <see cref="T:System.Windows.PropertyMetadata" /> class with the specified default value and <see cref="T:System.Windows.PropertyChangedCallback" /> implementation reference.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3dbab-125">O tipo do valor fornecido `defaultValue` deve ser correspondência ou estar relacionado ao tipo especificado no registro original da propriedade de dependência que serão aplicados a esses metadados.</span><span class="sxs-lookup"><span data-stu-id="3dbab-125">The type of the value provided `defaultValue` must be match or be related to the type specified in the original registration of the dependency property that this metadata will be applied to.</span></span> <span data-ttu-id="3dbab-126">Incompatibilidades entre o tipo de valor padrão de metadados e o tipo da propriedade de dependência que ele está sendo aplicado podem ser difícil de depurar, porque a incompatibilidade não podem ser detectada durante a compilação (incompatibilidade irá gerar uma exceção de tempo de execução).</span><span class="sxs-lookup"><span data-stu-id="3dbab-126">Mismatches between metadata default value type and the type of the dependency property it is being applied to can be difficult to debug, because the mismatch is not detectable during compilation (the mismatch will raise a run-time exception).</span></span>  
  
 <span data-ttu-id="3dbab-127">Embora seja o padrão por um construtor sem parâmetros, uma `defaultValue` de <xref:System.Windows.DependencyProperty.UnsetValue> não pode ser especificado.</span><span class="sxs-lookup"><span data-stu-id="3dbab-127">Although it is the default per the parameterless constructor, a `defaultValue` of <xref:System.Windows.DependencyProperty.UnsetValue> cannot be specified.</span></span> <span data-ttu-id="3dbab-128">Tentar fazer isso irá gerar uma exceção.</span><span class="sxs-lookup"><span data-stu-id="3dbab-128">Attempting to do so will raise an exception.</span></span>  
  
   
  
## Examples  
 [!code-csharp[PropertyMetadataAPIs#Initpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initpm)]  
[!code-csharp[PropertyMetadataAPIs#PMCtor2param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#pmctor2param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="3dbab-129"><paramref name="defaultValue" /> não pode ser definido como o valor <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</span><span class="sxs-lookup"><span data-stu-id="3dbab-129"><paramref name="defaultValue" /> cannot be set to the value <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PropertyMetadata (object defaultValue, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PropertyMetadata(System::Object ^ defaultValue, System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.PropertyMetadata : obj * System.Windows.PropertyChangedCallback * System.Windows.CoerceValueCallback -&gt; System.Windows.PropertyMetadata" Usage="new System.Windows.PropertyMetadata (defaultValue, propertyChangedCallback, coerceValueCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue"><span data-ttu-id="3dbab-130">O valor padrão da propriedade de dependência, geralmente fornecido como um valor de um tipo específico.</span><span class="sxs-lookup"><span data-stu-id="3dbab-130">The default value of the dependency property, usually provided as a value of some specific type.</span></span></param>
        <param name="propertyChangedCallback"><span data-ttu-id="3dbab-131">Referência a uma implementação do manipulador que será chamada pelo sistema de propriedades sempre que o valor efetivo da propriedade for alterado.</span><span class="sxs-lookup"><span data-stu-id="3dbab-131">Reference to a handler implementation that is to be called by the property system whenever the effective value of the property changes.</span></span></param>
        <param name="coerceValueCallback"><span data-ttu-id="3dbab-132">Uma referência a uma implementação do manipulador que será chamada sempre que o sistema de propriedades chamar <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> nessa propriedade.</span><span class="sxs-lookup"><span data-stu-id="3dbab-132">Reference to a handler implementation that is to be called whenever the property system calls <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> against this property.</span></span></param>
        <summary><span data-ttu-id="3dbab-133">Inicializa uma nova instância da classe <see cref="T:System.Windows.PropertyMetadata" /> com o valor padrão especificado e retornos de chamadas especificados.</span><span class="sxs-lookup"><span data-stu-id="3dbab-133">Initializes a new instance of the <see cref="T:System.Windows.PropertyMetadata" /> class with the specified default value and callbacks.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3dbab-134">Se você quiser especificar uma <xref:System.Windows.CoerceValueCallback> , mas não uma <xref:System.Windows.PropertyChangedCallback>, você pode passar `null` para o `propertyChangedCallback` parâmetro.</span><span class="sxs-lookup"><span data-stu-id="3dbab-134">If you want to specify a <xref:System.Windows.CoerceValueCallback> but not a <xref:System.Windows.PropertyChangedCallback>, you can pass `null` for the `propertyChangedCallback` parameter.</span></span>  
  
 <span data-ttu-id="3dbab-135">O tipo do valor fornecido para `defaultValue` deve ser correspondência ou estar relacionado ao tipo especificado no registro original da propriedade de dependência que serão aplicados a esses metadados.</span><span class="sxs-lookup"><span data-stu-id="3dbab-135">The type of the value provided for `defaultValue` must be match or be related to the type specified in the original registration of the dependency property that this metadata will be applied to.</span></span> <span data-ttu-id="3dbab-136">Incompatibilidades entre o tipo de valor padrão de metadados e o tipo da propriedade de dependência que ele está sendo aplicado podem ser difícil de depurar, porque a incompatibilidade não podem ser detectada durante a compilação (incompatibilidade irá gerar uma exceção de tempo de execução).</span><span class="sxs-lookup"><span data-stu-id="3dbab-136">Mismatches between metadata default value type and the type of the dependency property it is being applied to can be difficult to debug, because the mismatch is not detectable during compilation (the mismatch will raise a run-time exception).</span></span>  
  
 <span data-ttu-id="3dbab-137">Embora seja o padrão por um construtor sem parâmetros, uma `defaultValue` de <xref:System.Windows.DependencyProperty.UnsetValue> não pode ser especificado.</span><span class="sxs-lookup"><span data-stu-id="3dbab-137">Although it is the default per the parameterless constructor, a `defaultValue` of <xref:System.Windows.DependencyProperty.UnsetValue> cannot be specified.</span></span> <span data-ttu-id="3dbab-138">Tentar fazer isso irá gerar uma exceção.</span><span class="sxs-lookup"><span data-stu-id="3dbab-138">Attempting to do so will raise an exception.</span></span>  
  
   
  
## Examples  
 [!code-csharp[PropertyMetadataAPIs#Initpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initpm)]  
[!code-csharp[PropertyMetadataAPIs#PMCtor3param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#pmctor3param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="3dbab-139"><paramref name="defaultValue" /> não pode ser definido como o valor <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</span><span class="sxs-lookup"><span data-stu-id="3dbab-139"><paramref name="defaultValue" /> cannot be set to the value <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="CoerceValueCallback">
      <MemberSignature Language="C#" Value="public System.Windows.CoerceValueCallback CoerceValueCallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.CoerceValueCallback CoerceValueCallback" />
      <MemberSignature Language="DocId" Value="P:System.Windows.PropertyMetadata.CoerceValueCallback" />
      <MemberSignature Language="VB.NET" Value="Public Property CoerceValueCallback As CoerceValueCallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::CoerceValueCallback ^ CoerceValueCallback { System::Windows::CoerceValueCallback ^ get(); void set(System::Windows::CoerceValueCallback ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CoerceValueCallback : System.Windows.CoerceValueCallback with get, set" Usage="System.Windows.PropertyMetadata.CoerceValueCallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.CoerceValueCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3dbab-140">Obtém ou define uma referência para uma implementação de <see cref="T:System.Windows.CoerceValueCallback" /> especificada nesses metadados.</span><span class="sxs-lookup"><span data-stu-id="3dbab-140">Gets or sets a reference to a <see cref="T:System.Windows.CoerceValueCallback" /> implementation specified in this metadata.</span></span></summary>
        <value><span data-ttu-id="3dbab-141">Uma referência de implantação de <see cref="T:System.Windows.CoerceValueCallback" />.</span><span class="sxs-lookup"><span data-stu-id="3dbab-141">A <see cref="T:System.Windows.CoerceValueCallback" /> implementation reference.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3dbab-142">Os retornos de chamada nos metadados de propriedade não são membros normalmente públicos no tipo recipiente, portanto, o valor dessa propriedade não é importante para a maioria dos cenários que consomem apenas os metadados da propriedade de dependência existente.</span><span class="sxs-lookup"><span data-stu-id="3dbab-142">The callbacks in property metadata are not typically public members on the containing type, so the value of this property is not important for most scenarios that just consume an existing dependency property's metadata.</span></span> <span data-ttu-id="3dbab-143">Um motivo para essa propriedade é exposta é para que as subclasses de metadados podem executar sua lógica de mesclagem desejado se especificam os metadados de base e os metadados substituindo/adicionando um <xref:System.Windows.CoerceValueCallback>.</span><span class="sxs-lookup"><span data-stu-id="3dbab-143">One reason this property is exposed is so that metadata subclasses can perform their desired merge logic if both base metadata and overriding/adding metadata specify a <xref:System.Windows.CoerceValueCallback>.</span></span> <span data-ttu-id="3dbab-144">No entanto, o padrão mesclar lógica para um <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> é substituir o anterior.</span><span class="sxs-lookup"><span data-stu-id="3dbab-144">However, the default merge logic for a <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> is to replace the previous one.</span></span>  
  
 <span data-ttu-id="3dbab-145"><xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> é definido no modelo de objeto como leitura-gravação.</span><span class="sxs-lookup"><span data-stu-id="3dbab-145"><xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> is defined in the object model as read-write.</span></span> <span data-ttu-id="3dbab-146">Isso ocorre <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> podem ser ajustadas após a inicialização do <xref:System.Windows.PropertyMetadata> objeto propriamente dito.</span><span class="sxs-lookup"><span data-stu-id="3dbab-146">This is so <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> can be adjusted after initialization of the <xref:System.Windows.PropertyMetadata> object itself.</span></span> <span data-ttu-id="3dbab-147">No entanto, depois que os metadados são consumidos como parte de uma chamada para <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, ou <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, o sistema de propriedades será lacrar essa instância de metadados e as propriedades agora são consideradas imutáveis.</span><span class="sxs-lookup"><span data-stu-id="3dbab-147">However, once the metadata is consumed as part of a call to <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, or <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, the property system will seal that metadata instance and the properties are now considered immutable.</span></span> <span data-ttu-id="3dbab-148">Tentativa de definir <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> após <xref:System.Windows.PropertyMetadata.IsSealed%2A> é `true` nesses metadados instância gerarão uma exceção.</span><span class="sxs-lookup"><span data-stu-id="3dbab-148">Attempting to set <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> once <xref:System.Windows.PropertyMetadata.IsSealed%2A> is `true` on this metadata instance will raise an exception.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="3dbab-149">Não é possível definir uma propriedade de metadados após sua aplicação a uma operação de propriedade de dependência.</span><span class="sxs-lookup"><span data-stu-id="3dbab-149">Cannot set a metadata property once it is applied to a dependency property operation.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DefaultValue">
      <MemberSignature Language="C#" Value="public object DefaultValue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object DefaultValue" />
      <MemberSignature Language="DocId" Value="P:System.Windows.PropertyMetadata.DefaultValue" />
      <MemberSignature Language="VB.NET" Value="Public Property DefaultValue As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ DefaultValue { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultValue : obj with get, set" Usage="System.Windows.PropertyMetadata.DefaultValue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3dbab-150">Obtém ou define um valor padrão da propriedade de dependência.</span><span class="sxs-lookup"><span data-stu-id="3dbab-150">Gets or sets the default value of the dependency property.</span></span></summary>
        <value><span data-ttu-id="3dbab-151">O valor padrão da propriedade.</span><span class="sxs-lookup"><span data-stu-id="3dbab-151">The default value of the property.</span></span> <span data-ttu-id="3dbab-152">O valor padrão em uma <see cref="T:System.Windows.PropertyMetadata" /> instância criada com o construtor sem parâmetros será <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</span><span class="sxs-lookup"><span data-stu-id="3dbab-152">The default value on a <see cref="T:System.Windows.PropertyMetadata" /> instance created with the parameterless constructor will be <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3dbab-153"><xref:System.Windows.PropertyMetadata.DefaultValue%2A> é definido no modelo de objeto como leitura-gravação.</span><span class="sxs-lookup"><span data-stu-id="3dbab-153"><xref:System.Windows.PropertyMetadata.DefaultValue%2A> is defined in the object model as read-write.</span></span> <span data-ttu-id="3dbab-154">Isso ocorre <xref:System.Windows.PropertyMetadata.DefaultValue%2A> podem ser ajustadas após a inicialização do <xref:System.Windows.PropertyMetadata> objeto propriamente dito.</span><span class="sxs-lookup"><span data-stu-id="3dbab-154">This is so <xref:System.Windows.PropertyMetadata.DefaultValue%2A> can be adjusted after initialization of the <xref:System.Windows.PropertyMetadata> object itself.</span></span> <span data-ttu-id="3dbab-155">No entanto, depois que os metadados são consumidos como parte de uma chamada para <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, ou <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, o sistema de propriedades será lacrar essa instância de metadados e as propriedades agora são consideradas imutáveis.</span><span class="sxs-lookup"><span data-stu-id="3dbab-155">However, once the metadata is consumed as part of a call to <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, or <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, the property system will seal that metadata instance and the properties are now considered immutable.</span></span> <span data-ttu-id="3dbab-156">Tentativa de definir <xref:System.Windows.PropertyMetadata.DefaultValue%2A> após <xref:System.Windows.PropertyMetadata.IsSealed%2A> é `true` nesses metadados instância gerarão uma exceção.</span><span class="sxs-lookup"><span data-stu-id="3dbab-156">Attempting to set <xref:System.Windows.PropertyMetadata.DefaultValue%2A> once <xref:System.Windows.PropertyMetadata.IsSealed%2A> is `true` on this metadata instance will raise an exception.</span></span>  
  
 <span data-ttu-id="3dbab-157">Embora seja o padrão por um construtor sem parâmetros, uma `defaultValue` dos <xref:System.Windows.DependencyProperty.UnsetValue> não pode ser definido usando um <xref:System.Windows.PropertyMetadata.DefaultValue%2A> ou o construtor.</span><span class="sxs-lookup"><span data-stu-id="3dbab-157">Although it is the default per the parameterless constructor, a `defaultValue` of <xref:System.Windows.DependencyProperty.UnsetValue> cannot be set using either <xref:System.Windows.PropertyMetadata.DefaultValue%2A> or the constructor.</span></span> <span data-ttu-id="3dbab-158">Tentar fazer isso irá gerar uma exceção.</span><span class="sxs-lookup"><span data-stu-id="3dbab-158">Attempting to do so will raise an exception.</span></span>  
  
<a name="xamlTextUsage_PropertyChangedCallback"></a>   
## <a name="xaml-text-usage"></a><span data-ttu-id="3dbab-159">Uso de texto XAML</span><span class="sxs-lookup"><span data-stu-id="3dbab-159">XAML Text Usage</span></span>  
 <span data-ttu-id="3dbab-160">Os membros desse tipo não são usados normalmente em [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span><span class="sxs-lookup"><span data-stu-id="3dbab-160">Members of this type are not typically used in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="3dbab-161">Não pode ser definido para o valor <see cref="F:System.Windows.DependencyProperty.UnsetValue" /> após a criação.</span><span class="sxs-lookup"><span data-stu-id="3dbab-161">Cannot be set to the value <see cref="F:System.Windows.DependencyProperty.UnsetValue" /> once created.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="3dbab-162">Não é possível definir uma propriedade de metadados após sua aplicação a uma operação de propriedade de dependência.</span><span class="sxs-lookup"><span data-stu-id="3dbab-162">Cannot set a metadata property once it is applied to a dependency property operation.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="IsSealed">
      <MemberSignature Language="C#" Value="protected bool IsSealed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSealed" />
      <MemberSignature Language="DocId" Value="P:System.Windows.PropertyMetadata.IsSealed" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property IsSealed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool IsSealed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSealed : bool" Usage="System.Windows.PropertyMetadata.IsSealed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3dbab-163">Obtém um valor que determina se os metadados foram aplicados a uma propriedade de alguma forma, resultando em um estado imutável daquela instância de metadados.</span><span class="sxs-lookup"><span data-stu-id="3dbab-163">Gets a value that determines whether the metadata has been applied to a property in some way, resulting in the immutable state of that metadata instance.</span></span></summary>
        <value><span data-ttu-id="3dbab-164"><see langword="true" /> Se a instância de metadados é imutável; Caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="3dbab-164"><see langword="true" /> if the metadata instance is immutable; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3dbab-165">Várias propriedades de <xref:System.Windows.PropertyMetadata>, tais como <xref:System.Windows.PropertyMetadata.DefaultValue%2A>, são definidos no modelo de objeto como leitura-gravação.</span><span class="sxs-lookup"><span data-stu-id="3dbab-165">Various properties of <xref:System.Windows.PropertyMetadata>, such as <xref:System.Windows.PropertyMetadata.DefaultValue%2A>, are defined in the object model as read-write.</span></span> <span data-ttu-id="3dbab-166">Isso é para que essas propriedades podem ser ajustadas após a inicialização do <xref:System.Windows.PropertyMetadata> objeto propriamente dito.</span><span class="sxs-lookup"><span data-stu-id="3dbab-166">This is so those properties can be adjusted after initialization of the <xref:System.Windows.PropertyMetadata> object itself.</span></span> <span data-ttu-id="3dbab-167">No entanto, depois que os metadados são aplicados a uma propriedade de dependência como parte de uma chamada para <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, ou <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, o sistema de propriedades será lacrar essa instância de metadados e as propriedades agora são consideradas imutáveis.</span><span class="sxs-lookup"><span data-stu-id="3dbab-167">However, once the metadata is applied to a dependency property as part of a call to <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, or <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, the property system will seal that metadata instance and the properties are now considered immutable.</span></span> <span data-ttu-id="3dbab-168">No momento de uma dessas chamadas <xref:System.Windows.PropertyMetadata.OnApply%2A> é chamado, e o valor dessa propriedade é definido como `true`.</span><span class="sxs-lookup"><span data-stu-id="3dbab-168">At the time of one of these calls, <xref:System.Windows.PropertyMetadata.OnApply%2A> is called, and the value of this property is set to `true`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3dbab-169">A exemplo a seguir verifica <xref:System.Windows.PropertyMetadata.IsSealed%2A> antes de uma operação de definição de uma propriedade de metadados personalizados.</span><span class="sxs-lookup"><span data-stu-id="3dbab-169">The following example  checks <xref:System.Windows.PropertyMetadata.IsSealed%2A> prior to a set operation of a custom metadata property.</span></span>  
  
 [!code-csharp[PropertyMetadataAPIs#MergeImpl](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#mergeimpl)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.PropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="protected virtual void Merge (System.Windows.PropertyMetadata baseMetadata, System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Merge(class System.Windows.PropertyMetadata baseMetadata, class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Merge (baseMetadata As PropertyMetadata, dp As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Merge(System::Windows::PropertyMetadata ^ baseMetadata, System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="abstract member Merge : System.Windows.PropertyMetadata * System.Windows.DependencyProperty -&gt; unit&#xA;override this.Merge : System.Windows.PropertyMetadata * System.Windows.DependencyProperty -&gt; unit" Usage="propertyMetadata.Merge (baseMetadata, dp)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="baseMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="baseMetadata"><span data-ttu-id="3dbab-170">Os metadados de base a mesclar com valores dessa instância.</span><span class="sxs-lookup"><span data-stu-id="3dbab-170">The base metadata to merge with this instance's values.</span></span></param>
        <param name="dp"><span data-ttu-id="3dbab-171">A propriedade de dependência à qual estes metadados estão sendo aplicados.</span><span class="sxs-lookup"><span data-stu-id="3dbab-171">The dependency property to which this metadata is being applied.</span></span></param>
        <summary><span data-ttu-id="3dbab-172">Mescla esses metadados com os metadados de base.</span><span class="sxs-lookup"><span data-stu-id="3dbab-172">Merges this metadata with the base metadata.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3dbab-173">Esse método é usado internamente quando metadados está sendo substituído (<xref:System.Windows.DependencyProperty.OverrideMetadata%2A> método).</span><span class="sxs-lookup"><span data-stu-id="3dbab-173">This method is used internally when metadata is being overridden (<xref:System.Windows.DependencyProperty.OverrideMetadata%2A> method).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3dbab-174">O exemplo a seguir implementa uma mesclagem para um tipo de metadados personalizados que adiciona uma propriedade adicional para os metadados de propriedade.</span><span class="sxs-lookup"><span data-stu-id="3dbab-174">The following example implements a merge for a custom metadata type that adds an additional property to the property metadata.</span></span>  
  
 [!code-csharp[PropertyMetadataAPIs#MergeImpl](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#mergeimpl)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><span data-ttu-id="3dbab-175"><para>Classe implementações que derivam de <see cref="T:System.Windows.PropertyMetadata" /> devem substituir este método para levar em conta as propriedades de metadados que ele adicionou suas implementações. Por exemplo, sua implementação pode ter adicionado um novo valor de enumeração sinalizadora e o <see cref="M:System.Windows.PropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" /> implementação deve ser capaz de combinar esses sinalizadores corretamente.  Sempre chamar a implementação base antes de seu código de implementação, porque a implementação base se encarrega da mesclagem de todas as propriedades já definidas no <see cref="T:System.Windows.PropertyMetadata" /> tipo.  O comportamento exato da mesclagem cabe a você. Você pode optar por ter valores combinados, reverter para valor de base se os metadados derivado foram deixados no padrão, ou muitos outros comportamentos com base nos tipos de propriedades que você adicionou à sua classe de metadados específico e seus significados.</para></span><span class="sxs-lookup"><span data-stu-id="3dbab-175"><para>Class implementations that derive from <see cref="T:System.Windows.PropertyMetadata" /> should override this method to account for any metadata properties they have added in their implementations. For instance, your implementation might have added a new flagwise enumeration value, and the <see cref="M:System.Windows.PropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" /> implementation should then be able to combine those flags correctly.  Always call the base implementation prior to your implementation code, because the base implementation takes care of merging all the properties already defined on the <see cref="T:System.Windows.PropertyMetadata" /> type.  The exact behavior of the merge is up to you. You could choose to have values combined, revert to base value if the derived metadata were left at the default, or many other behaviors based on the types of properties you have added to your particular metadata class, and their meanings.</para></span></span></block>
        <altmember cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="OnApply">
      <MemberSignature Language="C#" Value="protected virtual void OnApply (System.Windows.DependencyProperty dp, Type targetType);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnApply(class System.Windows.DependencyProperty dp, class System.Type targetType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnApply (dp As DependencyProperty, targetType As Type)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnApply(System::Windows::DependencyProperty ^ dp, Type ^ targetType);" />
      <MemberSignature Language="F#" Value="abstract member OnApply : System.Windows.DependencyProperty * Type -&gt; unit&#xA;override this.OnApply : System.Windows.DependencyProperty * Type -&gt; unit" Usage="propertyMetadata.OnApply (dp, targetType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="targetType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="dp"><span data-ttu-id="3dbab-176">A propriedade de dependência à qual os metadados foram aplicados.</span><span class="sxs-lookup"><span data-stu-id="3dbab-176">The dependency property to which the metadata has been applied.</span></span></param>
        <param name="targetType"><span data-ttu-id="3dbab-177">O tipo associado a esses metadados se eles forem metadados específicos do tipo.</span><span class="sxs-lookup"><span data-stu-id="3dbab-177">The type associated with this metadata if this is type-specific metadata.</span></span> <span data-ttu-id="3dbab-178">Se estes forem os metadados padrão, o valor será uma referência nula.</span><span class="sxs-lookup"><span data-stu-id="3dbab-178">If this is default metadata, this value is a null reference.</span></span></param>
        <summary><span data-ttu-id="3dbab-179">Chamado quando esses metadados foram aplicados a uma propriedade, o que indica que os metadados estão sendo selados.</span><span class="sxs-lookup"><span data-stu-id="3dbab-179">Called when this metadata has been applied to a property, which indicates that the metadata is being sealed.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3dbab-180">As subclasses devem garantir que qualquer Mutabilidade da estrutura de dados de um <xref:System.Windows.PropertyMetadata> subclasse deve ser marcada como imutável uma vez <xref:System.Windows.PropertyMetadata.OnApply%2A> é chamado.</span><span class="sxs-lookup"><span data-stu-id="3dbab-180">Subclasses should assure that any mutability of the data structure of a <xref:System.Windows.PropertyMetadata> subclass should be marked as immutable once <xref:System.Windows.PropertyMetadata.OnApply%2A> is called.</span></span> <span data-ttu-id="3dbab-181">Isso será chamado depois que os metadados é aplicado a uma operação de sistema de propriedade (registrar, adicionar proprietário, substituir metadados).</span><span class="sxs-lookup"><span data-stu-id="3dbab-181">This will be called once the metadata is applied to a property system operation (register, add owner, override metadata).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PropertyChangedCallback">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyChangedCallback PropertyChangedCallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.PropertyChangedCallback PropertyChangedCallback" />
      <MemberSignature Language="DocId" Value="P:System.Windows.PropertyMetadata.PropertyChangedCallback" />
      <MemberSignature Language="VB.NET" Value="Public Property PropertyChangedCallback As PropertyChangedCallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::PropertyChangedCallback ^ PropertyChangedCallback { System::Windows::PropertyChangedCallback ^ get(); void set(System::Windows::PropertyChangedCallback ^ value); };" />
      <MemberSignature Language="F#" Value="member this.PropertyChangedCallback : System.Windows.PropertyChangedCallback with get, set" Usage="System.Windows.PropertyMetadata.PropertyChangedCallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyChangedCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3dbab-182">Obtém ou define uma referência para uma implementação de <see cref="T:System.Windows.PropertyChangedCallback" /> especificada nesses metadados.</span><span class="sxs-lookup"><span data-stu-id="3dbab-182">Gets or sets a reference to a <see cref="T:System.Windows.PropertyChangedCallback" /> implementation specified in this metadata.</span></span></summary>
        <value><span data-ttu-id="3dbab-183">Uma referência de implantação de <see cref="T:System.Windows.PropertyChangedCallback" />.</span><span class="sxs-lookup"><span data-stu-id="3dbab-183">A <see cref="T:System.Windows.PropertyChangedCallback" /> implementation reference.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3dbab-184">Os retornos de chamada nos metadados de propriedade não são membros públicos normalmente na definição de tipo, o valor dessa propriedade não é importante para a maioria dos cenários que consomem apenas os metadados da propriedade de dependência existente.</span><span class="sxs-lookup"><span data-stu-id="3dbab-184">The callbacks in property metadata are not typically public members on the defining type, so the value of this property is not important for most scenarios that just consume an existing dependency property's metadata.</span></span> <span data-ttu-id="3dbab-185">Um motivo para essa propriedade é exposta é para que as classes de metadados podem executar sua lógica de mesclagem desejado se especificam os metadados de base e os metadados substituindo/adicionando um <xref:System.Windows.PropertyChangedCallback>.</span><span class="sxs-lookup"><span data-stu-id="3dbab-185">One reason this property is exposed is so that metadata classes can perform their desired merge logic if both base metadata and overriding/adding metadata specify a <xref:System.Windows.PropertyChangedCallback>.</span></span> <span data-ttu-id="3dbab-186">A lógica de mesclagem para o padrão é manter todos os <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> implementações em uma tabela e chamada deles, com retornos de chamada estabelecidos pela classe mais profundo na hierarquia em execução primeiro.</span><span class="sxs-lookup"><span data-stu-id="3dbab-186">The default merge logic for is to maintain all <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> implementations in a table and call each of them, with callbacks established by the deepest class in hierarchy running first.</span></span>  
  
 <span data-ttu-id="3dbab-187"><xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> é definido no modelo de objeto como leitura-gravação.</span><span class="sxs-lookup"><span data-stu-id="3dbab-187"><xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> is defined in the object model as read-write.</span></span> <span data-ttu-id="3dbab-188">Isso ocorre <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> podem ser ajustadas após a inicialização do <xref:System.Windows.PropertyMetadata> objeto propriamente dito.</span><span class="sxs-lookup"><span data-stu-id="3dbab-188">This is so <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> can be adjusted after initialization of the <xref:System.Windows.PropertyMetadata> object itself.</span></span> <span data-ttu-id="3dbab-189">No entanto, depois que os metadados são consumidos como parte de uma chamada para <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, ou <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, o sistema de propriedades será lacrar essa instância de metadados e as propriedades agora são consideradas imutáveis.</span><span class="sxs-lookup"><span data-stu-id="3dbab-189">However, once the metadata is consumed as part of a call to <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, or <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, the property system will seal that metadata instance and the properties are now considered immutable.</span></span> <span data-ttu-id="3dbab-190">Tentativa de definir <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> após <xref:System.Windows.PropertyMetadata.IsSealed%2A> é `true` nesses metadados instância gerarão uma exceção.</span><span class="sxs-lookup"><span data-stu-id="3dbab-190">Attempting to set <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> once <xref:System.Windows.PropertyMetadata.IsSealed%2A> is `true` on this metadata instance will raise an exception.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="3dbab-191">Não é possível definir uma propriedade de metadados após sua aplicação a uma operação de propriedade de dependência.</span><span class="sxs-lookup"><span data-stu-id="3dbab-191">Cannot set a metadata property once it is applied to a dependency property operation.</span></span></exception>
      </Docs>
    </Member>
  </Members>
</Type>