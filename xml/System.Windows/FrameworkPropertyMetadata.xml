<Type Name="FrameworkPropertyMetadata" FullName="System.Windows.FrameworkPropertyMetadata">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="50e37bc8286c8ba1961d7a1c298161a3c9e3100c" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="pt-BR" />
    <Meta Name="ms.lasthandoff" Value="08/24/2018" />
    <Meta Name="ms.locfileid" Value="37492922" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class FrameworkPropertyMetadata : System.Windows.UIPropertyMetadata" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit FrameworkPropertyMetadata extends System.Windows.UIPropertyMetadata" />
  <TypeSignature Language="DocId" Value="T:System.Windows.FrameworkPropertyMetadata" />
  <TypeSignature Language="VB.NET" Value="Public Class FrameworkPropertyMetadata&#xA;Inherits UIPropertyMetadata" />
  <TypeSignature Language="C++ CLI" Value="public ref class FrameworkPropertyMetadata : System::Windows::UIPropertyMetadata" />
  <TypeSignature Language="F#" Value="type FrameworkPropertyMetadata = class&#xA;    inherit UIPropertyMetadata" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.UIPropertyMetadata</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Relata ou aplica metadados para uma propriedade de dependência, especificamente adicionando características específicas de estrutura do sistema de propriedade.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa classe deriva <xref:System.Windows.PropertyMetadata> (por meio de <xref:System.Windows.UIPropertyMetadata>). Para a maioria dos fins de desenvolvimento de aplicativos de nível de framework WPF, <xref:System.Windows.FrameworkPropertyMetadata> é o tipo usado para metadados de propriedade de dependência, em vez dos tipos de metadados de base <xref:System.Windows.PropertyMetadata> ou <xref:System.Windows.UIPropertyMetadata>. Isso é verdadeiro para propriedades de dependência existentes e para a maioria dos cenários de propriedade de dependência personalizada.  
  
 Os membros declarados por esta classe esse suplemento a <xref:System.Windows.PropertyMetadata> classe base incluem várias propriedades Boolianas que especificam ou comportamento do sistema de propriedade de nível de framework WPF, como herança de propriedade, a associação de dados e layout de relatório.  
  
 Várias assinaturas de construtor para a criação de um <xref:System.Windows.FrameworkPropertyMetadata> instância take um <xref:System.Windows.FrameworkPropertyMetadataOptions> parâmetro. O <xref:System.Windows.FrameworkPropertyMetadataOptions> enumeração é usada apenas para especificar o comportamento inicial no construtor e caso contrário, não será exposta após <xref:System.Windows.FrameworkPropertyMetadata> é construído. De uma instância construída, você pode obter ou definir as informações correspondentes por meio de várias propriedades que compartilham o nome dos valores de enumeração usado na chamada do construtor.  
  
<a name="xamlTextUsage_FrameworkPropertyMetadata"></a>   
## <a name="xaml-text-usage"></a>Uso de texto XAML  
 Essa classe não é normalmente usada em [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
   
  
## Examples  
 O exemplo a seguir obtém metadados para uma propriedade de dependência em um proprietário específico como inicial base <xref:System.Windows.PropertyMetadata> tipo. Esses metadados são convertidos em <xref:System.Windows.FrameworkPropertyMetadata>. Se a conversão retornou válida <xref:System.Windows.FrameworkPropertyMetadata>, em seguida, vários <xref:System.Windows.FrameworkPropertyMetadata> valores de propriedade são relatados por meio de uma simple interface do usuário (não mostrado).  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.PropertyMetadata" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Windows.FrameworkPropertyMetadata" />.</summary>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Windows.FrameworkPropertyMetadata" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa assinatura inicializa todos os valores de <xref:System.Windows.FrameworkPropertyMetadata.%23ctor%2A> aos seus padrões de propriedade. <xref:System.Windows.PropertyMetadata.DefaultValue%2A> estará `null`e os vários <xref:System.Windows.FrameworkPropertyMetadata> propriedades Boolianas serão `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (defaultValue As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata defaultValue" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="defaultValue">O valor padrão da propriedade de dependência, geralmente, fornecido como um valor de um tipo específico.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Windows.FrameworkPropertyMetadata" /> com o valor padrão especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O tipo do valor fornecido para `defaultValue` deve corresponder ou ser relacionadas para o tipo especificado no registro original da propriedade de dependência que serão aplicados a esses metadados. Incompatibilidades entre o tipo de valor padrão de metadados e o tipo da propriedade de dependência que ele está sendo aplicado podem ser difícil de depurar, porque a incompatibilidade não podem ser detectada durante a compilação. O sistema de propriedades não avalia o valor efetivo de uma propriedade até o tempo de execução, portanto, o resultado de uma incompatibilidade de tipo de propriedade/tipo de valor padrão é um erro de tempo de execução.  
  
 O valor <xref:System.Windows.DependencyProperty.UnsetValue> tem um significado especial no sistema de propriedade e não pode ser usado como um valor de padrão de propriedade de dependência.  
  
   
  
## Examples  
 O exemplo a seguir chama essa assinatura de construtor:  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor1param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor1param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="defaultValue" /> é definido como <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (System.Windows.PropertyChangedCallback propertyChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.PropertyChangedCallback propertyChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Windows.PropertyChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Windows::PropertyChangedCallback ^ propertyChangedCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : System.Windows.PropertyChangedCallback -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata propertyChangedCallback" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
      </Parameters>
      <Docs>
        <param name="propertyChangedCallback">Uma referência a uma implementação do manipulador que será chamada pelo sistema de propriedades sempre que o valor efetivo da propriedade for alterado.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Windows.FrameworkPropertyMetadata" /> com o retorno de chamada <see cref="T:System.Windows.PropertyChangedCallback" /> especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir chama essa assinatura de construtor:  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor1paramcallback](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor1paramcallback)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, valuetype System.Windows.FrameworkPropertyMetadataOptions flags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (defaultValue As Object, flags As FrameworkPropertyMetadataOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::FrameworkPropertyMetadataOptions flags);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.FrameworkPropertyMetadataOptions -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, flags)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="flags" Type="System.Windows.FrameworkPropertyMetadataOptions" />
      </Parameters>
      <Docs>
        <param name="defaultValue">O valor padrão da propriedade de dependência, geralmente, fornecido como um valor de um tipo específico.</param>
        <param name="flags">Os sinalizadores de opção de metadados (uma combinação de valores <see cref="T:System.Windows.FrameworkPropertyMetadataOptions" />). Essas opções especificam características da propriedade de dependência que interagem com sistemas, como layout ou vinculação de dados.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Windows.FrameworkPropertyMetadata" /> com o valor padrão e as opções de metadados em nível da estrutura fornecidos.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O tipo do valor fornecido para `defaultValue` deve corresponder ou ser relacionadas para o tipo especificado no registro original da propriedade de dependência que serão aplicados a esses metadados. Incompatibilidades entre o tipo de valor padrão de metadados e o tipo da propriedade de dependência que ele está sendo aplicado podem ser difícil de depurar, porque a incompatibilidade não podem ser detectada durante a compilação. O sistema de propriedades não avalia o valor efetivo de uma propriedade até o tempo de execução, portanto, o resultado de uma incompatibilidade de tipo de propriedade/tipo de valor padrão é um erro de tempo de execução.  
  
 O valor <xref:System.Windows.DependencyProperty.UnsetValue> tem um significado especial no sistema de propriedade e não pode ser usado como um valor de padrão de propriedade de dependência.  
  
 Valores marcados como conjunto de sinalizadores na `flags` parâmetro definirá o valor booliano da <xref:System.Windows.FrameworkPropertyMetadata> propriedades que correspondem ao que <xref:System.Windows.FrameworkPropertyMetadataOptions> nome do sinalizador para `true`. Posteriormente, você pode alterar os valores das propriedades nos metadados, desde que os metadados ainda não foram aplicados a uma operação de sistema de propriedade específicos.  
  
   
  
## Examples  
 O exemplo a seguir chama essa assinatura de construtor:  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_DV_FPMO](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_dv_fpmo)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="defaultValue" /> é definido como <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.PropertyChangedCallback propertyChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, class System.Windows.PropertyChangedCallback propertyChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::PropertyChangedCallback ^ propertyChangedCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.PropertyChangedCallback -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, propertyChangedCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">O valor padrão da propriedade de dependência, geralmente, fornecido como um valor de um tipo específico.</param>
        <param name="propertyChangedCallback">Uma referência a uma implementação do manipulador que será chamada pelo sistema de propriedades sempre que o valor efetivo da propriedade for alterado.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Windows.FrameworkPropertyMetadata" /> com o valor padrão fornecido e o retorno de chamada <see cref="T:System.Windows.PropertyChangedCallback" /> especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O tipo do valor fornecido para `defaultValue` deve corresponder ou ser relacionadas para o tipo especificado no registro original da propriedade de dependência que serão aplicados a esses metadados. Incompatibilidades entre o tipo de valor padrão de metadados e o tipo da propriedade de dependência que ele está sendo aplicado podem ser difícil de depurar, porque a incompatibilidade não podem ser detectada durante a compilação. O sistema de propriedades não avalia o valor efetivo de uma propriedade até o tempo de execução, portanto, o resultado de uma incompatibilidade de tipo de propriedade/tipo de valor padrão é um erro de tempo de execução.  
  
 O valor <xref:System.Windows.DependencyProperty.UnsetValue> tem um significado especial no sistema de propriedade e não pode ser usado como um valor de padrão de propriedade de dependência.  
  
   
  
## Examples  
 O exemplo a seguir chama essa assinatura de construtor:  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor2param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor2param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="defaultValue" /> é definido como <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : System.Windows.PropertyChangedCallback * System.Windows.CoerceValueCallback -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (propertyChangedCallback, coerceValueCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
      </Parameters>
      <Docs>
        <param name="propertyChangedCallback">Uma referência a uma implementação do manipulador que será chamada pelo sistema de propriedades sempre que o valor efetivo da propriedade for alterado.</param>
        <param name="coerceValueCallback">Uma referência a uma implementação de manipulador será chamada sempre que o sistema de propriedades chamar <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> para essa propriedade de dependência.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Windows.FrameworkPropertyMetadata" /> com os retornos de chamada especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa implementação chama um inicializador de base e, em seguida, adiciona o `coerceValueCallback` , definindo a propriedade na instância de base.  
  
   
  
## Examples  
 O exemplo a seguir chama essa assinatura de construtor:  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_PCC_CVC](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_pcc_cvc)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags, System.Windows.PropertyChangedCallback propertyChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, valuetype System.Windows.FrameworkPropertyMetadataOptions flags, class System.Windows.PropertyChangedCallback propertyChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::FrameworkPropertyMetadataOptions flags, System::Windows::PropertyChangedCallback ^ propertyChangedCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.FrameworkPropertyMetadataOptions * System.Windows.PropertyChangedCallback -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, flags, propertyChangedCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="flags" Type="System.Windows.FrameworkPropertyMetadataOptions" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">O valor padrão da propriedade de dependência, geralmente, fornecido como um valor de um tipo específico.</param>
        <param name="flags">Os sinalizadores de opção de metadados (uma combinação de valores <see cref="T:System.Windows.FrameworkPropertyMetadataOptions" />). Essas opções especificam características da propriedade de dependência que interagem com sistemas, como layout ou vinculação de dados.</param>
        <param name="propertyChangedCallback">Uma referência a uma implementação do manipulador que será chamada pelo sistema de propriedades sempre que o valor efetivo da propriedade for alterado.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Windows.FrameworkPropertyMetadata" /> com o valor padrão e as opções de metadados da estrutura fornecidos, bem como o retorno de chamada <see cref="T:System.Windows.PropertyChangedCallback" /> especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O tipo do valor fornecido para `defaultValue` deve corresponder ou ser relacionadas para o tipo especificado no registro original da propriedade de dependência que serão aplicados a esses metadados. Incompatibilidades entre o tipo de valor padrão de metadados e o tipo da propriedade de dependência que ele está sendo aplicado podem ser difícil de depurar, porque a incompatibilidade não podem ser detectada durante a compilação. O sistema de propriedades não avalia o valor efetivo de uma propriedade até o tempo de execução, portanto, o resultado de uma incompatibilidade de tipo de propriedade/tipo de valor padrão é um erro de tempo de execução.  
  
 O valor <xref:System.Windows.DependencyProperty.UnsetValue> tem um significado especial no sistema de propriedade e não pode ser usado como um valor de padrão de propriedade de dependência.  
  
 Valores marcados como conjunto de sinalizadores na `flags` parâmetro definirá o valor booliano da <xref:System.Windows.FrameworkPropertyMetadata> propriedades que correspondem ao que <xref:System.Windows.FrameworkPropertyMetadataOptions> nome do sinalizador para `true`. Você ainda pode alterar os valores das propriedades nos metadados, desde que os metadados ainda não foram aplicados a uma operação de sistema de propriedade específicos.  
  
   
  
## Examples  
 O exemplo a seguir chama essa assinatura de construtor:  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_DV_FPMO_PCC](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_dv_fpmo_pcc)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="defaultValue" /> é definido como <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.PropertyChangedCallback * System.Windows.CoerceValueCallback -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, propertyChangedCallback, coerceValueCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">O valor padrão da propriedade de dependência, geralmente, fornecido como um tipo específico.</param>
        <param name="propertyChangedCallback">Uma referência a uma implementação do manipulador que será chamada pelo sistema de propriedades sempre que o valor efetivo da propriedade for alterado.</param>
        <param name="coerceValueCallback">Uma referência a uma implementação de manipulador será chamada sempre que o sistema de propriedades chamar <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> para essa propriedade de dependência.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Windows.FrameworkPropertyMetadata" /> com o valor padrão fornecido e os retornos de chamada especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O tipo do valor fornecido para `defaultValue` deve corresponder ou ser relacionadas para o tipo especificado no registro original da propriedade de dependência que serão aplicados a esses metadados. Incompatibilidades entre o tipo de valor padrão de metadados e o tipo da propriedade de dependência que ele está sendo aplicado podem ser difícil de depurar, porque a incompatibilidade não podem ser detectada durante a compilação. O sistema de propriedades não avalia o valor efetivo de uma propriedade até o tempo de execução, portanto, o resultado de uma incompatibilidade de tipo de propriedade/tipo de valor padrão é um erro de tempo de execução.  
  
 O valor <xref:System.Windows.DependencyProperty.UnsetValue> tem um significado especial no sistema de propriedade e não pode ser usado como um valor de padrão de propriedade de dependência.  
  
   
  
## Examples  
 O exemplo a seguir chama essa assinatura de construtor:  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor3param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor3param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="defaultValue" /> é definido como <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, valuetype System.Windows.FrameworkPropertyMetadataOptions flags, class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::FrameworkPropertyMetadataOptions flags, System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.FrameworkPropertyMetadataOptions * System.Windows.PropertyChangedCallback * System.Windows.CoerceValueCallback -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, flags, propertyChangedCallback, coerceValueCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="flags" Type="System.Windows.FrameworkPropertyMetadataOptions" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">O valor padrão da propriedade de dependência, geralmente, fornecido como um tipo específico.</param>
        <param name="flags">Os sinalizadores de opção de metadados (uma combinação de valores <see cref="T:System.Windows.FrameworkPropertyMetadataOptions" />). Essas opções especificam características da propriedade de dependência que interagem com sistemas, como layout ou vinculação de dados.</param>
        <param name="propertyChangedCallback">Uma referência a uma implementação do manipulador que será chamada pelo sistema de propriedades sempre que o valor efetivo da propriedade for alterado.</param>
        <param name="coerceValueCallback">Uma referência a uma implementação de manipulador que será chamada sempre que o sistema de propriedades chamar <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> nessa propriedade.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Windows.FrameworkPropertyMetadata" /> com o valor padrão e as opções de metadados da estrutura fornecidos, bem como os retornos de chamada especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O tipo do valor fornecido para `defaultValue` deve corresponder ou ser relacionadas para o tipo especificado no registro original da propriedade de dependência que serão aplicados a esses metadados. Incompatibilidades entre o tipo de valor padrão de metadados e o tipo da propriedade de dependência que ele está sendo aplicado podem ser difícil de depurar, porque a incompatibilidade não podem ser detectada durante a compilação. O sistema de propriedades não avalia o valor efetivo de uma propriedade até o tempo de execução, portanto, o resultado de uma incompatibilidade de tipo de propriedade/tipo de valor padrão é um erro de tempo de execução.  
  
 O valor <xref:System.Windows.DependencyProperty.UnsetValue> tem um significado especial no sistema de propriedade e não pode ser usado como um valor de padrão de propriedade de dependência.  
  
 Valores marcados como conjunto de sinalizadores na `flags` parâmetro definirá o valor booliano da <xref:System.Windows.FrameworkPropertyMetadata> propriedades que correspondem ao que <xref:System.Windows.FrameworkPropertyMetadataOptions> nome do sinalizador para `true`. Você ainda pode alterar os valores das propriedades nos metadados, desde que os metadados ainda não foram aplicados a uma operação de sistema de propriedade específicos.  
  
   
  
## Examples  
 O exemplo a seguir chama essa assinatura de construtor:  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_DV_FPMO_PCC_CVC](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_dv_fpmo_pcc_cvc)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="defaultValue" /> é definido como <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback, bool isAnimationProhibited);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, valuetype System.Windows.FrameworkPropertyMetadataOptions flags, class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback, bool isAnimationProhibited) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::FrameworkPropertyMetadataOptions flags, System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback, bool isAnimationProhibited);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.FrameworkPropertyMetadataOptions * System.Windows.PropertyChangedCallback * System.Windows.CoerceValueCallback * bool -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, flags, propertyChangedCallback, coerceValueCallback, isAnimationProhibited)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="flags" Type="System.Windows.FrameworkPropertyMetadataOptions" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
        <Parameter Name="isAnimationProhibited" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="defaultValue">O valor padrão da propriedade de dependência, geralmente, fornecido como um tipo específico.</param>
        <param name="flags">Os sinalizadores de opção de metadados (uma combinação de valores <see cref="T:System.Windows.FrameworkPropertyMetadataOptions" />). Essas opções especificam características da propriedade de dependência que interagem com sistemas, como layout ou vinculação de dados.</param>
        <param name="propertyChangedCallback">Uma referência a uma implementação do manipulador que será chamada pelo sistema de propriedades sempre que o valor efetivo da propriedade for alterado.</param>
        <param name="coerceValueCallback">Uma referência a uma implementação de manipulador será chamada sempre que o sistema de propriedades chamar <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> nessa propriedade de dependência.</param>
        <param name="isAnimationProhibited">
          <see langword="true" /> para impedir que o sistema de propriedades anime a propriedade à qual esses metadados foram aplicados. Propriedades desse tipo acionarão uma exceção de tempo de execução que provenientes do sistema de propriedades, em caso de tentativa de criar animações delas. <see langword="false" /> para permitir que a propriedade seja animada. O padrão é <see langword="false" />.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Windows.FrameworkPropertyMetadata" /> com o valor padrão e as opções de metadados da estrutura fornecidos, os retornos de chamada especificados e um booliano que pode ser usado para impedir a animação da propriedade.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O tipo do valor fornecido para `defaultValue` deve corresponder ou ser relacionadas para o tipo especificado no registro original da propriedade de dependência que serão aplicados a esses metadados. Incompatibilidades entre o tipo de valor padrão de metadados e o tipo da propriedade de dependência que ele está sendo aplicado podem ser difícil de depurar, porque a incompatibilidade não podem ser detectada durante a compilação. O sistema de propriedades não avalia o valor efetivo de uma propriedade até o tempo de execução, portanto, o resultado de uma incompatibilidade de tipo de propriedade/tipo de valor padrão é um erro de tempo de execução.  
  
 O valor <xref:System.Windows.DependencyProperty.UnsetValue> tem um significado especial no sistema de propriedade e não pode ser usado como um valor de padrão de propriedade de dependência.  
  
 O `isAnimationProhibited` parâmetro define o valor inicial do <xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A> propriedade declarada com a base imediata <xref:System.Windows.UIPropertyMetadata> classe.  
  
 Valores marcados como conjunto de sinalizadores na `flags` parâmetro definirá o valor booliano da <xref:System.Windows.FrameworkPropertyMetadata> propriedades que correspondem ao que <xref:System.Windows.FrameworkPropertyMetadataOptions> nome do sinalizador para `true`. Você ainda pode alterar os valores das propriedades nos metadados, desde que os metadados ainda não foram aplicados a uma operação de sistema de propriedade específicos.  
  
   
  
## Examples  
 O exemplo a seguir chama essa assinatura de construtor:  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_DV_FPMO_PCC_CVC_IAP](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_dv_fpmo_pcc_cvc_iap)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="defaultValue" /> é definido como <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback, bool isAnimationProhibited, System.Windows.Data.UpdateSourceTrigger defaultUpdateSourceTrigger);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, valuetype System.Windows.FrameworkPropertyMetadataOptions flags, class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback, bool isAnimationProhibited, valuetype System.Windows.Data.UpdateSourceTrigger defaultUpdateSourceTrigger) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean,System.Windows.Data.UpdateSourceTrigger)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::FrameworkPropertyMetadataOptions flags, System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback, bool isAnimationProhibited, System::Windows::Data::UpdateSourceTrigger defaultUpdateSourceTrigger);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.FrameworkPropertyMetadataOptions * System.Windows.PropertyChangedCallback * System.Windows.CoerceValueCallback * bool * System.Windows.Data.UpdateSourceTrigger -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, flags, propertyChangedCallback, coerceValueCallback, isAnimationProhibited, defaultUpdateSourceTrigger)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="flags" Type="System.Windows.FrameworkPropertyMetadataOptions" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
        <Parameter Name="isAnimationProhibited" Type="System.Boolean" />
        <Parameter Name="defaultUpdateSourceTrigger" Type="System.Windows.Data.UpdateSourceTrigger" />
      </Parameters>
      <Docs>
        <param name="defaultValue">O valor padrão da propriedade de dependência, geralmente, fornecido como um tipo específico.</param>
        <param name="flags">Os sinalizadores de opção de metadados (uma combinação de valores <see cref="T:System.Windows.FrameworkPropertyMetadataOptions" />). Essas opções especificam características da propriedade de dependência que interagem com sistemas, como layout ou vinculação de dados.</param>
        <param name="propertyChangedCallback">Uma referência a uma implementação do manipulador que será chamada pelo sistema de propriedades sempre que o valor efetivo da propriedade for alterado.</param>
        <param name="coerceValueCallback">Uma referência a uma implementação de manipulador que será chamada sempre que o sistema de propriedades chamar <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> nessa propriedade.</param>
        <param name="isAnimationProhibited">
          <see langword="true" /> para impedir que o sistema de propriedades anime a propriedade à qual esses metadados foram aplicados. Propriedades desse tipo acionarão uma exceção de tempo de execução que provenientes do sistema de propriedades, em caso de tentativa de criar animações delas. O padrão é <see langword="false" />.</param>
        <param name="defaultUpdateSourceTrigger">O <see cref="T:System.Windows.Data.UpdateSourceTrigger" /> a ser usado quando as associações dessa propriedade forem aplicadas com seu <see cref="T:System.Windows.Data.UpdateSourceTrigger" /> definido como <see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" />.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Windows.FrameworkPropertyMetadata" /> com o valor padrão e as opções de metadados da estrutura fornecidos, os retornos de chamada especificados, um booliano que pode ser usado para impedir a animação da propriedade e um padrão de gatilho de atualização com associação de dados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O tipo do valor fornecido para `defaultValue` deve corresponder ou ser relacionadas para o tipo especificado no registro original da propriedade de dependência que serão aplicados a esses metadados. Incompatibilidades entre o tipo de valor padrão de metadados e o tipo da propriedade de dependência que ele está sendo aplicado podem ser difícil de depurar, porque a incompatibilidade não podem ser detectada durante a compilação. O sistema de propriedades não avalia o valor efetivo de uma propriedade até o tempo de execução, portanto, o resultado de uma incompatibilidade de tipo de propriedade/tipo de valor padrão é um erro de tempo de execução.  
  
 O valor <xref:System.Windows.DependencyProperty.UnsetValue> tem um significado especial no sistema de propriedade e não pode ser usado como um valor de padrão de propriedade de dependência.  
  
 O `isAnimationProhibited` parâmetro define o valor inicial do <xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A> propriedade declarada com a base imediata <xref:System.Windows.UIPropertyMetadata> classe.  
  
 Para obter mais informações sobre o comportamento de origem de atualização para associações, consulte [visão geral de associação de dados](~/docs/framework/wpf/data/data-binding-overview.md).  
  
 Valores marcados como conjunto de sinalizadores na `flags` parâmetro definirá o valor booliano da <xref:System.Windows.FrameworkPropertyMetadata> propriedades que correspondem ao que <xref:System.Windows.FrameworkPropertyMetadataOptions> nome do sinalizador para `true`. Você ainda pode alterar os valores das propriedades nos metadados, desde que os metadados ainda não foram aplicados a uma operação de sistema de propriedade específicos.  
  
   
  
## Examples  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_DV_FPMO_PCC_CVC_IAP_DUST](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_dv_fpmo_pcc_cvc_iap_dust)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="defaultValue" /> é definido como <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName="AffectsArrange">
      <MemberSignature Language="C#" Value="public bool AffectsArrange { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AffectsArrange" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.AffectsArrange" />
      <MemberSignature Language="VB.NET" Value="Public Property AffectsArrange As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AffectsArrange { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AffectsArrange : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.AffectsArrange" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica se uma propriedade de dependência potencialmente afeta a passagem de organização durante operações de mecanismo de layout.</summary>
        <value>
          <see langword="true" /> Se a propriedade de dependência na qual esses metadados existem potencialmente afetar a passagem de organização; Caso contrário, <see langword="false" />. O padrão é <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement> e <xref:System.Windows.FrameworkContentElement> inclui uma implementação do <xref:System.Windows.FrameworkElement.OnPropertyChanged%2A> que monitora as alterações de valor efetivo para todas as propriedades de dependência que existe em um elemento. Como parte da lógica, as propriedades de dependência que alteram em vigor a partir de valor e tem metadados com <xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A> definido como `true` iniciará uma solicitação adiada para invalidar os visuais para esse elemento (uma chamada para <xref:System.Windows.UIElement.InvalidateArrange%2A>). Como essa implementação de nível de framework WPF já está em vigor, você normalmente não é necessário procurar por propriedades de dependência com <xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A> , a menos que você estiver substituindo ou modificando o comportamento de layout de nível de framework WPF substancialmente.  
  
 Custom <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> implementações poderá optar por ter um comportamento semelhante para alterações de propriedade de dependência em que <xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A> é `true`.  
  
 Propriedades em classes derivadas de <xref:System.Windows.PropertyMetadata> geralmente são definidos no modelo de objeto como leitura-gravação. Isso é para que eles podem ser ajustados após a inicialização da instância. No entanto, depois que os metadados são consumidos como parte de uma chamada para <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, ou <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, o sistema de propriedades será lacrar essa instância de metadados e propriedades que transmitem as especificidades dos metadados agora são consideradas imutáveis. Tentativa de definir essa propriedade após <xref:System.Windows.PropertyMetadata.IsSealed%2A> é `true` nesses metadados instância gerarão uma exceção.  
  
<a name="xamlTextUsage_AffectsArrange"></a>   
## <a name="xaml-text-usage"></a>Uso de texto XAML  
 Os membros dessa classe são usados normalmente não em [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
   
  
## Examples  
 O exemplo a seguir obtém os metadados padrão da dependência de vários campos de propriedade, consulta o valor de vários <xref:System.Windows.FrameworkPropertyMetadata> propriedades nele e usa as informações para preencher uma tabela para implementar um navegador de metadados"".  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Os metadados já foram aplicados à operação de propriedade de dependência, portanto os metadados estão selados e as propriedades dos metadados não podem ser definidas.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="AffectsMeasure">
      <MemberSignature Language="C#" Value="public bool AffectsMeasure { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AffectsMeasure" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.AffectsMeasure" />
      <MemberSignature Language="VB.NET" Value="Public Property AffectsMeasure As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AffectsMeasure { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AffectsMeasure : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.AffectsMeasure" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica se uma propriedade de dependência potencialmente afeta a passagem de medição durante operações de mecanismo de layout.</summary>
        <value>
          <see langword="true" /> se a propriedade de dependência na qual esses metadados existem potencialmente afetar a passagem de medida; caso contrário, <see langword="false" />. O padrão é <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement> e <xref:System.Windows.FrameworkContentElement> inclui uma implementação do <xref:System.Windows.FrameworkElement.OnPropertyChanged%2A> que monitora as alterações de valor efetivo para todas as propriedades de dependência que existe em um elemento. Como parte da lógica, as propriedades de dependência que alteram em vigor a partir de valor e tem metadados com <xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> definido como `true` iniciará uma solicitação adiada para invalidar os visuais para esse elemento. Como essa implementação de nível de framework WPF já está em vigor, você normalmente não é necessário procurar por propriedades de dependência com <xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> , a menos que você estiver substituindo ou modificando o comportamento de layout de nível de framework WPF substancialmente.  
  
 Custom <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> implementações poderá optar por ter um comportamento semelhante para alterações de propriedade de dependência em que <xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> é `true`.  
  
 Propriedades em classes derivadas de <xref:System.Windows.PropertyMetadata> geralmente são definidos no modelo de objeto como leitura-gravação. Isso é para que eles podem ser ajustados após a inicialização da instância. No entanto, depois que os metadados são consumidos como parte de uma chamada para <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, ou <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, o sistema de propriedades será lacrar essa instância de metadados e propriedades que transmitem as especificidades dos metadados agora são consideradas imutáveis. Tentativa de definir essa propriedade após <xref:System.Windows.PropertyMetadata.IsSealed%2A> é `true` nesses metadados instância gerarão uma exceção.  
  
<a name="xamlTextUsage_AffectsMeasure"></a>   
## <a name="xaml-text-usage"></a>Uso de texto XAML  
 Os membros dessa classe não são normalmente usados em [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
   
  
## Examples  
 O exemplo a seguir obtém os metadados padrão da dependência de vários campos de propriedade, consulta o valor de vários <xref:System.Windows.FrameworkPropertyMetadata> propriedades nele e usa as informações para preencher uma tabela para implementar um navegador de metadados"".  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Os metadados já foram aplicados à operação de propriedade de dependência, portanto os metadados estão selados e as propriedades dos metadados não podem ser definidas.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
        <altmember cref="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)" />
      </Docs>
    </Member>
    <Member MemberName="AffectsParentArrange">
      <MemberSignature Language="C#" Value="public bool AffectsParentArrange { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AffectsParentArrange" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange" />
      <MemberSignature Language="VB.NET" Value="Public Property AffectsParentArrange As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AffectsParentArrange { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AffectsParentArrange : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.AffectsParentArrange" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica se uma propriedade de dependência potencialmente afeta a passagem de organização do layout do respectivo elemento pai durante operações de mecanismo de layout.</summary>
        <value>
          <see langword="true" /> Se a propriedade de dependência na qual esses metadados existem potencialmente afetar a passagem de organização especificamente no seu elemento pai; Caso contrário, <see langword="false" />. O padrão é <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement> e <xref:System.Windows.FrameworkContentElement> inclui uma implementação do <xref:System.Windows.FrameworkElement.OnPropertyChanged%2A> que monitora as alterações de valor efetivo para todas as propriedades de dependência que existe em um elemento. Como parte da lógica, as propriedades de dependência que alteram em vigor a partir de valor e tem metadados com <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> definido como `true` iniciará uma solicitação adiada para invalidar os visuais para o elemento pai.  
  
 Em geral, você não precisa para relatar alterações de um <xref:System.Windows.FrameworkElement> propriedade para um elemento pai usando <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> porque o elemento em si já deve ter seu próprio <xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A> como `true`. Que normalmente é suficiente, como alterações no elemento filho geralmente iniciam um pai organizar quando apropriado. <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> às vezes é usado para um <xref:System.Windows.FrameworkContentElement> classe derivada. Nesse caso, os conjuntos de elemento filho, uma propriedade, mas um <xref:System.Windows.FrameworkContentElement> classe derivada não controla seu próprio processamento. O processamento é tratado por um <xref:System.Windows.FrameworkElement> elemento pai que serve como o host de conteúdo. Por exemplo, uma alteração no valor da <xref:System.Windows.Documents.FixedPage.Left%2A?displayProperty=nameWithType> invalida a propriedade anexada por um elemento filho organizar do pai, porque a posição do filho no pai deve ser alterada. Portanto, o <xref:System.Windows.Documents.FixedPage.Left%2A?displayProperty=nameWithType> propriedade anexada tem metadados em que <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> é `true`. Outro exemplo é <xref:System.Windows.Controls.Control.Padding%2A>; quando essa propriedade é alterada, o pai pode alterar o posicionamento do filho, dependendo do espaço disponível.  
  
 Como essa implementação de nível de framework WPF já está em vigor, você normalmente não é necessário procurar por propriedades de dependência com <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> , a menos que você estiver substituindo ou modificando o comportamento de layout de nível de framework WPF substancialmente.  
  
 Custom <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> implementações poderá optar por ter um comportamento semelhante para alterações de propriedade de dependência em que <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> é `true`.  
  
 Propriedades em qualquer classes derivadas de <xref:System.Windows.PropertyMetadata> geralmente são definidos no modelo de objeto como leitura-gravação. Isso é para que eles podem ser ajustados após a inicialização da instância. No entanto, depois que os metadados são consumidos como parte de uma chamada para <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, ou <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, o sistema de propriedades será lacrar essa instância de metadados e propriedades que transmitem as especificidades dos metadados agora são consideradas imutáveis. Tentativa de definir essa propriedade após <xref:System.Windows.PropertyMetadata.IsSealed%2A> é `true` nesses metadados instância gerarão uma exceção.  
  
<a name="xamlTextUsage_AffectsParentArrange"></a>   
## <a name="xaml-text-usage"></a>Uso de texto XAML  
 Os membros dessa classe não são normalmente usados em [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Os metadados já foram aplicados à operação de propriedade de dependência, portanto os metadados estão selados e as propriedades dos metadados não podem ser definidas.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="AffectsParentMeasure">
      <MemberSignature Language="C#" Value="public bool AffectsParentMeasure { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AffectsParentMeasure" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure" />
      <MemberSignature Language="VB.NET" Value="Public Property AffectsParentMeasure As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AffectsParentMeasure { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AffectsParentMeasure : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica se uma propriedade de dependência potencialmente afeta a passagem de medida do layout do respectivo elemento pai durante operações de mecanismo de layout.</summary>
        <value>
          <see langword="true" /> Se a propriedade de dependência na qual esses metadados existem potencialmente afetar a passagem de medida especificamente no seu elemento pai; Caso contrário, <see langword="false" />. O padrão é <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement> e <xref:System.Windows.FrameworkContentElement> inclui uma implementação do <xref:System.Windows.FrameworkElement.OnPropertyChanged%2A> que monitora as alterações de valor efetivo para todas as propriedades de dependência que existe em um elemento. Como parte da lógica, as propriedades de dependência que alteram em vigor a partir de valor e tem metadados com <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> definido como `true` iniciará uma solicitação adiada para invalidar os visuais para o elemento pai. Como essa implementação de nível de framework WPF já está em vigor, você normalmente não é necessário procurar por propriedades de dependência com <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> , a menos que você estiver substituindo ou modificando o comportamento de layout de nível de framework WPF substancialmente.  
  
 Em geral, você não precisa para relatar alterações de um <xref:System.Windows.FrameworkElement> propriedade para um elemento pai usando <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> porque o elemento em si já deve ter seu próprio <xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> como `true`. Que normalmente é suficiente, como alterações no elemento filho geralmente iniciam uma passagem de medida pai quando apropriado. <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> às vezes é usado para um <xref:System.Windows.FrameworkContentElement> classe derivada. Nesse caso, os conjuntos de elemento filho, uma propriedade, mas um <xref:System.Windows.FrameworkContentElement> classe derivada não controla seu próprio processamento. O processamento é tratado por um <xref:System.Windows.FrameworkElement> elemento pai que serve como o host de conteúdo. Por exemplo, uma alteração no valor da <xref:System.Windows.Documents.Paragraph.KeepWithNext%2A?displayProperty=nameWithType> propriedade por um elemento filho invalida a medida do pai, porque o espaçamento relativo entre parágrafos pode alterar e pode aumentar ou diminuir o tamanho do host de conteúdo. Portanto, o <xref:System.Windows.Documents.Paragraph.KeepWithNext%2A?displayProperty=nameWithType> propriedade tem metadados em que <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> é `true`.  
  
 Elementos de host de conteúdo também frequentemente procure as alterações nas propriedades de dependência em que <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> é `true`, como parte da lógica de processamento do host de conteúdo. Por exemplo, o <xref:System.Windows.Controls.TextBox> elemento deve responder a determinadas alterações dentro do texto que podem exigir que a caixa delimitadora do <xref:System.Windows.Controls.TextBox> em si ser alterado.  
  
 Custom <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> implementações poderá optar por ter um comportamento semelhante para alterações de propriedade de dependência em que <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> é `true`.  
  
 Propriedades em qualquer classes derivadas de <xref:System.Windows.PropertyMetadata> geralmente são definidos no modelo de objeto como leitura-gravação. Isso é para que eles podem ser ajustados após a inicialização da instância. No entanto, depois que os metadados são consumidos como parte de uma chamada para <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, ou <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, o sistema de propriedades será lacrar essa instância de metadados e propriedades que transmitem as especificidades dos metadados agora são consideradas imutáveis. Tentativa de definir essa propriedade após <xref:System.Windows.PropertyMetadata.IsSealed%2A> é `true` nesses metadados instância gerarão uma exceção.  
  
<a name="xamlTextUsage_AffectsParentMeasure"></a>   
## <a name="xaml-text-usage"></a>Uso de texto XAML  
 Os membros dessa classe não são normalmente usados em [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Os metadados já foram aplicados à operação de propriedade de dependência, portanto os metadados estão selados e as propriedades dos metadados não podem ser definidas.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="AffectsRender">
      <MemberSignature Language="C#" Value="public bool AffectsRender { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AffectsRender" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.AffectsRender" />
      <MemberSignature Language="VB.NET" Value="Public Property AffectsRender As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AffectsRender { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AffectsRender : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.AffectsRender" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica se uma propriedade de dependência pode afetar o layout geral de algum modo que não influencie especificamente a organização ou medida, mas que exigiria um redesenho.</summary>
        <value>
          <see langword="true" /> se a propriedade de dependência na qual esses metadados existem afeta a renderização; caso contrário, <see langword="false" />. O padrão é <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement> e <xref:System.Windows.FrameworkContentElement> inclui uma implementação do <xref:System.Windows.FrameworkElement.OnPropertyChanged%2A> que monitora as alterações de valor efetivo para todas as propriedades de dependência que existe em um elemento. Como parte da lógica, as propriedades de dependência que alteram em vigor a partir de valor e tem metadados com <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A> definido como `true` iniciará uma solicitação adiada para invalidar os visuais para esse elemento. Como essa implementação de nível de framework WPF já está em vigor, você normalmente não é necessário procurar por propriedades de dependência com <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A> , a menos que você estiver substituindo ou modificando o comportamento de layout de nível de framework WPF substancialmente.  
  
 Custom <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> implementações poderá optar por ter um comportamento semelhante para alterações de propriedade de dependência em que <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A> é `true`.  
  
 Propriedades em qualquer classes derivadas de <xref:System.Windows.PropertyMetadata> geralmente são definidos no modelo de objeto como leitura-gravação. Isso é para que eles podem ser ajustados após a inicialização da instância. No entanto, depois que os metadados são consumidos como parte de uma chamada para <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, ou <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, o sistema de propriedades será lacrar essa instância de metadados e propriedades que transmitem as especificidades dos metadados agora são consideradas imutáveis. Tentativa de definir essa propriedade após <xref:System.Windows.PropertyMetadata.IsSealed%2A> é `true` nesses metadados instância gerarão uma exceção.  
  
<a name="xamlTextUsage_AffectsRender"></a>   
## <a name="xaml-text-usage"></a>Uso de texto XAML  
 Os membros dessa classe não são normalmente usados em [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
   
  
## Examples  
 O exemplo a seguir obtém os metadados padrão da dependência de vários campos de propriedade, consulta o valor de vários <xref:System.Windows.FrameworkPropertyMetadata> propriedades nele e usa as informações para preencher uma tabela para implementar um navegador de metadados"".  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Os metadados já foram aplicados à operação de propriedade de dependência, portanto os metadados estão selados e as propriedades dos metadados não podem ser definidas.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="BindsTwoWayByDefault">
      <MemberSignature Language="C#" Value="public bool BindsTwoWayByDefault { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool BindsTwoWayByDefault" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault" />
      <MemberSignature Language="VB.NET" Value="Public Property BindsTwoWayByDefault As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool BindsTwoWayByDefault { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.BindsTwoWayByDefault : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica se a propriedade associa de forma bidirecional por padrão.</summary>
        <value>
          <see langword="true" /> se a propriedade de dependência na qual esses metadados existem associa de forma bidirecional por padrão. Caso contrário, <see langword="false" />. O padrão é <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Na ausência dessa propriedade está sendo `true`, as atualizações de vinculação são unidirecionais por padrão, com base no comportamento padrão do <xref:System.Windows.Data.Binding> construtores ou equivalente [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] sintaxe.  
  
 Os elementos existentes, você normalmente encontrará essa propriedade definida como `true` nos metadados para propriedades de dependência que ambos relatam o estado e são modificáveis por ação do usuário, por exemplo <xref:System.Windows.Controls.Primitives.Selector.IsSelected%2A?displayProperty=nameWithType>.  
  
 Essa propriedade só reporta as características de atualização de associação padrão da propriedade de dependência em geral. Qualquer associação definida para essa propriedade em uma instância localmente pode definir o <xref:System.Windows.Data.Binding.Mode%2A> propriedade da associação e alterar esse padrão.  
  
 Propriedades em qualquer classes derivadas de <xref:System.Windows.PropertyMetadata> geralmente são definidos no modelo de objeto como leitura-gravação. Isso é para que eles podem ser ajustados após a inicialização da instância. No entanto, depois que os metadados são consumidos como parte de uma chamada para <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, ou <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, o sistema de propriedades será lacrar essa instância de metadados e propriedades que transmitem as especificidades dos metadados agora são consideradas imutáveis. Tentativa de definir essa propriedade após <xref:System.Windows.PropertyMetadata.IsSealed%2A> é `true` nesses metadados instância gerarão uma exceção.  
  
<a name="xamlTextUsage_BindsTwoWayByDefault"></a>   
## <a name="xaml-text-usage"></a>Uso de texto XAML  
 Os membros dessa classe não são normalmente usados em [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
   
  
## Examples  
 O exemplo a seguir obtém os metadados padrão da dependência de vários campos de propriedade, consulta o valor de vários <xref:System.Windows.FrameworkPropertyMetadata> propriedades nele e usa as informações para preencher uma tabela para implementar um navegador de metadados"".  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Os metadados já foram aplicados à operação de propriedade de dependência, portanto os metadados estão selados e as propriedades dos metadados não podem ser definidas.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="DefaultUpdateSourceTrigger">
      <MemberSignature Language="C#" Value="public System.Windows.Data.UpdateSourceTrigger DefaultUpdateSourceTrigger { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Data.UpdateSourceTrigger DefaultUpdateSourceTrigger" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.DefaultUpdateSourceTrigger" />
      <MemberSignature Language="VB.NET" Value="Public Property DefaultUpdateSourceTrigger As UpdateSourceTrigger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Data::UpdateSourceTrigger DefaultUpdateSourceTrigger { System::Windows::Data::UpdateSourceTrigger get(); void set(System::Windows::Data::UpdateSourceTrigger value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultUpdateSourceTrigger : System.Windows.Data.UpdateSourceTrigger with get, set" Usage="System.Windows.FrameworkPropertyMetadata.DefaultUpdateSourceTrigger" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.UpdateSourceTrigger</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o padrão para <see cref="T:System.Windows.Data.UpdateSourceTrigger" /> a ser usado quando as associações para a propriedade com esses metadados forem aplicadas, que têm seus <see cref="T:System.Windows.Data.UpdateSourceTrigger" /> definidos como <see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" />.</summary>
        <value>Um valor da enumeração, diferente de <see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Propriedades em classes derivadas de <xref:System.Windows.PropertyMetadata> geralmente são definidos no modelo de objeto como leitura-gravação. Isso é para que eles podem ser ajustados após a inicialização da instância. No entanto, depois que os metadados são consumidos como parte de uma chamada para <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, ou <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, o sistema de propriedades será lacrar essa instância de metadados e propriedades que transmitem as especificidades dos metadados agora são consideradas imutáveis. Tentativa de definir essa propriedade após <xref:System.Windows.PropertyMetadata.IsSealed%2A> é `true` nesses metadados instância gerarão uma exceção.  
  
<a name="xamlTextUsage_DefaultUpdateSourceTrigger"></a>   
## <a name="xaml-text-usage"></a>Uso de texto XAML  
 Os membros dessa classe não são normalmente usados em [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Essa propriedade está definida como <see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" />; o valor definido deve se tornar o padrão quando solicitado por associações.</exception>
        <exception cref="T:System.InvalidOperationException">Os metadados já foram aplicados à operação de propriedade de dependência, portanto os metadados estão selados e as propriedades dos metadados não podem ser definidas.</exception>
      </Docs>
    </Member>
    <Member MemberName="Inherits">
      <MemberSignature Language="C#" Value="public bool Inherits { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Inherits" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.Inherits" />
      <MemberSignature Language="VB.NET" Value="Public Property Inherits As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Inherits { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Inherits : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.Inherits" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica se o valor da propriedade de dependência é herdável.</summary>
        <value>
          <see langword="true" /> se o valor da propriedade for herdável, caso contrário, <see langword="false" />. O padrão é <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Herança do valor da propriedade é um recurso do [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] sistema de propriedades no nível de framework WPF, no qual determinadas propriedades de dependência podem ser definidas localmente em um elemento em ou próximo à raiz de um [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] elemento de árvore e, em seguida, ter seu valor herdado por todos os elementos dentro da árvore lógica de elementos filho que também tenham essa propriedade. Herança do valor da propriedade não está habilitada por padrão e permitindo que ele tem algumas implicações de desempenho. Para obter detalhes, consulte [Herança do valor da propriedade](~/docs/framework/wpf/advanced/property-value-inheritance.md).  
  
> [!NOTE]
>  Embora a herança do valor da propriedade possa parecer funcionar para as propriedades de dependência, o comportamento da herança de uma propriedade não anexada por meio de determinados divisões de objeto do objeto na árvore de tempo de execução é indefinido. Sempre use <xref:System.Windows.DependencyProperty.RegisterAttached%2A> para registrar as propriedades em que você especificar <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> nos metadados.  
  
 Propriedades em classes derivadas de <xref:System.Windows.PropertyMetadata> geralmente são definidos no modelo de objeto como leitura-gravação. Isso é para que eles podem ser ajustados após a inicialização da instância. No entanto, depois que os metadados são consumidos como parte de uma chamada para <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, ou <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, o sistema de propriedades será lacrar essa instância de metadados e propriedades que transmitem as especificidades dos metadados agora são consideradas imutáveis. Tentativa de definir essa propriedade após <xref:System.Windows.PropertyMetadata.IsSealed%2A> é `true` nesses metadados instância gerarão uma exceção.  
  
<a name="xamlTextUsage_Inherits"></a>   
## <a name="xaml-text-usage"></a>Uso de texto XAML  
 Os membros dessa classe não são normalmente usados em [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
   
  
## Examples  
 O exemplo a seguir obtém os metadados padrão da dependência de vários campos de propriedade, consulta o valor de vários <xref:System.Windows.FrameworkPropertyMetadata> propriedades nele e usa as informações para preencher uma tabela para implementar um navegador de metadados"".  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Os metadados já foram aplicados à operação de propriedade de dependência, portanto os metadados estão selados e as propriedades dos metadados não podem ser definidas.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="IsDataBindingAllowed">
      <MemberSignature Language="C#" Value="public bool IsDataBindingAllowed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDataBindingAllowed" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsDataBindingAllowed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsDataBindingAllowed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDataBindingAllowed : bool" Usage="System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se a associação de dados é compatível com a propriedade de dependência.</summary>
        <value>
          <see langword="true" /> Se a associação de dados é compatível com a propriedade de dependência à qual esses metadados se aplica; Caso contrário, <see langword="false" />. O padrão é <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa propriedade informa `false` para uma das duas condições possíveis: qualquer associação de dados a uma propriedade de dependência não é permitida porque a propriedade de dependência é somente leitura (conforme relatado no identificador de propriedade de dependência, não os metadados), ou o valor de outra propriedade de metadados, <xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>, é definido como `true` nesses metadados. Essa propriedade é exposta como uma conveniência para que os chamadores não precise marque ambos <xref:System.Windows.DependencyProperty.ReadOnly%2A> e <xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>.  
  
 Se você estiver tentando criar os metadados que especifica que uma propriedade de leitura/gravação. caso contrário, não deve oferecer suporte a associação de dados, especifique o sinalizador <xref:System.Windows.FrameworkPropertyMetadataOptions.NotDataBindable> (Observe a diferença de convenção de nomenclatura pequena versus <xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>).  
  
<a name="xamlTextUsage_IsDataBindingAllowed"></a>   
## <a name="xaml-text-usage"></a>Uso de texto XAML  
 Os membros dessa classe não são normalmente usados em [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
   
  
## Examples  
 O exemplo a seguir obtém os metadados padrão da dependência de vários campos de propriedade, consulta o valor de vários <xref:System.Windows.FrameworkPropertyMetadata> propriedades nele e usa as informações para preencher uma tabela para implementar um navegador de metadados"".  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="IsNotDataBindable">
      <MemberSignature Language="C#" Value="public bool IsNotDataBindable { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNotDataBindable" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable" />
      <MemberSignature Language="VB.NET" Value="Public Property IsNotDataBindable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNotDataBindable { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsNotDataBindable : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.IsNotDataBindable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica se o valor da propriedade de dependência é compatível com a associação de dados.</summary>
        <value>
          <see langword="true" /> Se a propriedade não dá suporte a associação de dados; Caso contrário, <see langword="false" />. O padrão é <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Observe que essa propriedade de metadados é definida como `true` especificamente para as propriedades que não devem dar suporte a vinculação de dados, apesar de ser propriedades de leitura / gravação. A expectativa é que na maioria dos casos em que uma propriedade de dependência é declarada, vinculação de dados for desejada, como vinculação de dados é um dos principais cenários em que uma propriedade de dependência é útil. Ao contrário de <xref:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault%2A>, isso não altera simplesmente um padrão que pode ser alterado posteriormente em uma associação específica. A definição dessa propriedade `true` nos metadados para uma propriedade de dependência metadados desabilitará todas as associações da aplicação de seus valores por meio de expressões a essa propriedade de dependência.  
  
 Propriedades de dependência somente leitura não dão suporte para a associação de dados (porque eles têm nenhum setter que pode aplicar valores alterados), mas ainda será relatório `false` para <xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>. Isso ocorre porque as propriedades que correspondem a um <xref:System.Windows.FrameworkPropertyMetadataOptions> valores relatará paridade com como os metadados foi realmente estabelecido, em vez de emissão de relatórios sempre o comportamento do resultado final implicar a nomenclatura da propriedade. Para determinar se uma propriedade de dependência permite que a vinculação de dados, normalmente, você deve verificar <xref:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed%2A> em vez disso. <xref:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed%2A> é uma conveniência para a verificação de ambos <xref:System.Windows.DependencyProperty.ReadOnly%2A> e <xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A> como uma única operação, produzindo o resultado esperado.  
  
 Propriedades em classes derivadas de <xref:System.Windows.PropertyMetadata> geralmente são definidos no modelo de objeto como leitura-gravação. Isso é para que eles podem ser ajustados após a inicialização da instância. No entanto, depois que os metadados são consumidos como parte de uma chamada para <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, ou <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, o sistema de propriedades será lacrar essa instância de metadados e propriedades que transmitem as especificidades dos metadados agora são consideradas imutáveis. Tentativa de definir essa propriedade após <xref:System.Windows.PropertyMetadata.IsSealed%2A> é `true` nesses metadados instância gerarão uma exceção.  
  
<a name="xamlTextUsage_IsNotDataBindable"></a>   
## <a name="xaml-text-usage"></a>Uso de texto XAML  
 Os membros dessa classe não são normalmente usados em [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Os metadados já foram aplicados à operação de propriedade de dependência, portanto os metadados estão selados e as propriedades dos metadados não podem ser definidas.</exception>
        <altmember cref="P:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed" />
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="Journal">
      <MemberSignature Language="C#" Value="public bool Journal { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Journal" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.Journal" />
      <MemberSignature Language="VB.NET" Value="Public Property Journal As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Journal { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Journal : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.Journal" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica se esta propriedade contém informações de registro no diário que aplicativos podem ou devem armazenar como parte de uma implementação do registro no diário.</summary>
        <value>
          <see langword="true" /> Se o registro no diário deve ser executado na propriedade de dependência que esses metadados foram aplicados Caso contrário, <see langword="false" />. O padrão é <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Propriedades em classes derivadas de <xref:System.Windows.PropertyMetadata> geralmente são definidos no modelo de objeto como leitura-gravação. Isso é para que eles podem ser ajustados após a inicialização da instância. No entanto, depois que os metadados são consumidos como parte de uma chamada para <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, ou <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, o sistema de propriedades será lacrar essa instância de metadados e propriedades que transmitem as especificidades dos metadados agora são consideradas imutáveis. Tentativa de definir essa propriedade após <xref:System.Windows.PropertyMetadata.IsSealed%2A> é `true` nesses metadados instância gerarão uma exceção.  
  
<a name="xamlTextUsage_Journal"></a>   
## <a name="xaml-text-usage"></a>Uso de texto XAML  
 Os membros dessa classe não são normalmente usados em [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Os metadados já foram aplicados à operação de propriedade de dependência, portanto os metadados estão selados e as propriedades dos metadados não podem ser definidas.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
        <altmember cref="T:System.Windows.Navigation.JournalEntry" />
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="protected override void Merge (System.Windows.PropertyMetadata baseMetadata, System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Merge(class System.Windows.PropertyMetadata baseMetadata, class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Merge (baseMetadata As PropertyMetadata, dp As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Merge(System::Windows::PropertyMetadata ^ baseMetadata, System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="abstract member Merge : System.Windows.PropertyMetadata * System.Windows.DependencyProperty -&gt; unit&#xA;override this.Merge : System.Windows.PropertyMetadata * System.Windows.DependencyProperty -&gt; unit" Usage="frameworkPropertyMetadata.Merge (baseMetadata, dp)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="baseMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="baseMetadata">Os metadados de base a serem mesclados.</param>
        <param name="dp">A propriedade de dependência à qual esses metadados estão sendo aplicados.</param>
        <summary>Permite a mesclagem dos metadados de origem com metadados de base.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é usado internamente quando metadados está sendo substituído.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Classes que derivam de <see cref="T:System.Windows.PropertyMetadata" /> (ou esta classe particularmente) devem substituir este método para levar em conta as propriedades de metadados que ele adicionou suas implementações. Por exemplo, sua implementação pode ter adicionado um novo valor de enumeração sinalizadora e o <see cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" /> implementação deve ser capaz de combinar esses sinalizadores corretamente.  Sempre chame a implementação base antes da sua própria implementação, porque a implementação base se encarrega da mesclagem de todas as propriedades já definidas nos tipos anteriores na hierarquia.  O comportamento adicionado pelo <see cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" /> implementação no <see cref="T:System.Windows.FrameworkPropertyMetadata" /> é que propriedades específicas de nível de framework WPF nos metadados, como <see cref="P:System.Windows.FrameworkPropertyMetadata.AffectsRender" /> são combinados em um bit a bit ou operação.  O <see cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" /> comportamento também implementa o comportamento quando você substitui os metadados de propriedade em uma propriedade de dependência existente chamando <see cref="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)" />., usando os metadados de substituição é <see cref="T:System.Windows.FrameworkPropertyMetadata" />.</para>
        </block>
        <altmember cref="M:System.Windows.PropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />
        <altmember cref="P:System.Windows.PropertyMetadata.IsSealed" />
        <altmember cref="M:System.Windows.FrameworkPropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="OnApply">
      <MemberSignature Language="C#" Value="protected override void OnApply (System.Windows.DependencyProperty dp, Type targetType);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnApply(class System.Windows.DependencyProperty dp, class System.Type targetType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnApply (dp As DependencyProperty, targetType As Type)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnApply(System::Windows::DependencyProperty ^ dp, Type ^ targetType);" />
      <MemberSignature Language="F#" Value="abstract member OnApply : System.Windows.DependencyProperty * Type -&gt; unit&#xA;override this.OnApply : System.Windows.DependencyProperty * Type -&gt; unit" Usage="frameworkPropertyMetadata.OnApply (dp, targetType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="targetType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="dp">A propriedade de dependência à qual os metadados foram aplicados.</param>
        <param name="targetType">O tipo associado a esses metadados se eles forem metadados específicos do tipo. Se eles são metadados padrão, esse valor pode ser <see langword="null" />.</param>
        <summary>Chamado quando esses metadados foram aplicados a uma propriedade, o que indica que os metadados estão sendo selados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Qualquer Mutabilidade da estrutura de dados de um <xref:System.Windows.FrameworkPropertyMetadata> instância deve ser marcada como imutável quando este método é invocado.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>O <see cref="T:System.Windows.FrameworkPropertyMetadata" /> implementação deste método não faz nada além de chamar a implementação base.</para>
        </block>
        <altmember cref="M:System.Windows.PropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)" />
        <altmember cref="P:System.Windows.PropertyMetadata.IsSealed" />
        <altmember cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="OverridesInheritanceBehavior">
      <MemberSignature Language="C#" Value="public bool OverridesInheritanceBehavior { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool OverridesInheritanceBehavior" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior" />
      <MemberSignature Language="VB.NET" Value="Public Property OverridesInheritanceBehavior As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool OverridesInheritanceBehavior { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.OverridesInheritanceBehavior : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica se a avaliação de herança de valor da propriedade deve abranger além de certos limites conteúdo na árvore lógica de elementos.</summary>
        <value>
          <see langword="true" /> Se a herança do valor da propriedade deve abranger além de certos limites conteúdo; Caso contrário, <see langword="false" />. O padrão é <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esses metadados relata uma modificação raramente aplicado ao comportamento de herança de valor de propriedade entre limites de elemento filho do elemento pai especial. O exemplo canônico de tal limite é o conteúdo de um <xref:System.Windows.Controls.Frame>, em que o <xref:System.Windows.Controls.Frame> conteúdo pode obter recarregado independentemente da existência da <xref:System.Windows.Controls.Frame>. O comportamento do sistema de propriedade desejada é que herança do valor da propriedade não deve percorrer o conteúdo do <xref:System.Windows.Controls.Frame>, porque esses conteúdos podem ser elementos que o aplicativo que hospeda o quadro não possui ou controla. Especificação de metadados com <xref:System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior%2A> definido como `true`, bem como especificando <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> como `true`, fará com que a propriedade na qual os metadados é aplicado para se tornar herdável, mesmo no <xref:System.Windows.Controls.Frame> limites ou limites semelhantes.  
  
 Propriedades em classes derivadas de <xref:System.Windows.PropertyMetadata> geralmente são definidos no modelo de objeto como leitura-gravação. Isso é para que eles podem ser ajustados após a inicialização da instância. No entanto, depois que os metadados são consumidos como parte de uma chamada para <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, ou <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, o sistema de propriedades será lacrar essa instância de metadados e propriedades que transmitem as especificidades dos metadados agora são consideradas imutáveis. Tentativa de definir essa propriedade após <xref:System.Windows.PropertyMetadata.IsSealed%2A> é `true` nesses metadados instância gerarão uma exceção.  
  
<a name="xamlTextUsage_OverridesInheritanceBehavior"></a>   
## <a name="xaml-text-usage"></a>Uso de texto XAML  
 Os membros dessa classe não são normalmente usados em [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Os metadados já foram aplicados à operação de propriedade de dependência, portanto os metadados estão selados e as propriedades dos metadados não podem ser definidas.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="SubPropertiesDoNotAffectRender">
      <MemberSignature Language="C#" Value="public bool SubPropertiesDoNotAffectRender { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SubPropertiesDoNotAffectRender" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender" />
      <MemberSignature Language="VB.NET" Value="Public Property SubPropertiesDoNotAffectRender As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SubPropertiesDoNotAffectRender { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SubPropertiesDoNotAffectRender : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica se as subpropriedades da propriedade de dependência não afetam a renderização do objeto contentor.</summary>
        <value>
          <see langword="true" /> Se alterações nos valores da subpropriedade não afetam a renderização se alterado; Caso contrário, <see langword="false" />. O padrão é <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa opção de metadados é pertinente para propriedades de dependência que são tipos de referência, em que esse tipo tem valores de propriedade de seu próprio. Normalmente, a lógica do sistema de layout é assumir que qualquer propriedade de dependência com subpropriedades potencialmente afetará layout, como verificação de todas as subpropriedades de alterações é mais demorado do que realmente em execução outro renderizar pass. Definir essa opção como `true` é útil para otimizar o desempenho da implementação de sistema de layout de nível de framework WPF.  
  
 Propriedades em classes derivadas de <xref:System.Windows.PropertyMetadata> geralmente são definidos no modelo de objeto como leitura-gravação. Isso é para que eles podem ser ajustados após a inicialização da instância. No entanto, depois que os metadados são consumidos como parte de uma chamada para <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, ou <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, o sistema de propriedades será lacrar essa instância de metadados e propriedades que transmitem as especificidades dos metadados agora são consideradas imutáveis. Tentativa de definir essa propriedade após <xref:System.Windows.PropertyMetadata.IsSealed%2A> é `true` nesses metadados instância gerarão uma exceção.  
  
<a name="xamlTextUsage_SubPropertiesDoNotAffectRender"></a>   
## <a name="xaml-text-usage"></a>Uso de texto XAML  
 Os membros dessa classe não são normalmente usados em [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Os metadados já foram aplicados à operação de propriedade de dependência, portanto os metadados estão selados e as propriedades dos metadados não podem ser definidas.</exception>
        <altmember cref="T:System.Windows.Freezable" />
      </Docs>
    </Member>
  </Members>
</Type>