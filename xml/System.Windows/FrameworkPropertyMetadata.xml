<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="FrameworkPropertyMetadata.xml" source-language="en-US" target-language="pt-BR">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5c70304d7b52b8f4e76c37fd1e35de0928f9619c7.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">c70304d7b52b8f4e76c37fd1e35de0928f9619c7</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Windows.FrameworkPropertyMetadata">
          <source>Reports or applies metadata for a dependency property, specifically adding framework-specific property system characteristics.</source>
          <target state="translated">Relata ou aplica metadados para uma propriedade de dependência, especificamente adicionando características específicas de estrutura do sistema de propriedade.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.FrameworkPropertyMetadata">
          <source>This class derives from <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> (through <ph id="ph2">&lt;xref:System.Windows.UIPropertyMetadata&gt;</ph>) .</source>
          <target state="translated">Essa classe é derivada de <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> (por meio de <ph id="ph2">&lt;xref:System.Windows.UIPropertyMetadata&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.FrameworkPropertyMetadata">
          <source>For most WPF framework-level application development purposes, <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph> is the type used for dependency property metadata, rather than the base metadata types <ph id="ph2">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> or <ph id="ph3">&lt;xref:System.Windows.UIPropertyMetadata&gt;</ph>.</source>
          <target state="translated">Para fins de desenvolvimento de aplicativo de nível da estrutura de maioria dos WPF, <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph> é o tipo usado para metadados de propriedade de dependência, em vez de tipos de metadados de base <ph id="ph2">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> ou <ph id="ph3">&lt;xref:System.Windows.UIPropertyMetadata&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.FrameworkPropertyMetadata">
          <source>This is true both for existing dependency properties and for most custom dependency property scenarios.</source>
          <target state="translated">Isso é verdadeiro para as propriedades de dependência existente e na maioria dos cenários de propriedade de dependência personalizada.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.FrameworkPropertyMetadata">
          <source>The members declared by this class that supplement the <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> base class include various Boolean properties that specify or report WPF framework-level property system behavior such as property inheritance, data binding, and layout.</source>
          <target state="translated">Os membros declarados por esta classe esse suplemento a <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> classe base inclui várias propriedades Boolianas que especifique ou comportamento do sistema de propriedade de nível de framework WPF como herança de propriedade, associação de dados e layout de relatório.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.FrameworkPropertyMetadata">
          <source>Several constructor signatures for creating a <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph> instance take a <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadataOptions&gt;</ph> parameter.</source>
          <target state="translated">Várias assinaturas de construtor para criar um <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph> instância tirar uma <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadataOptions&gt;</ph> parâmetro.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.FrameworkPropertyMetadata">
          <source>The <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadataOptions&gt;</ph> enumeration is used only to specify initial behavior in the constructor, and is not otherwise exposed after <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph> is constructed.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadataOptions&gt;</ph> enumeração é usada somente para especificar o comportamento inicial no construtor e caso contrário, não será exposta após <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph> é construído.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.FrameworkPropertyMetadata">
          <source>From a constructed instance, you can get or set the corresponding information through various properties that share the name of the enumeration values used in the constructor call.</source>
          <target state="translated">Em uma instância criada, você pode obter ou definir as informações correspondentes por meio de várias propriedades que compartilham o nome dos valores de enumeração usado na chamada de construtor.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.FrameworkPropertyMetadata">
          <source>XAML Text Usage</source>
          <target state="translated">Uso de texto XAML</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.FrameworkPropertyMetadata">
          <source>This class is not typically used in <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</source>
          <target state="translated">Essa classe não é usada normalmente em <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.FrameworkPropertyMetadata">
          <source>The following example gets metadata for a dependency property on a particular owner as the initial base <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> type.</source>
          <target state="translated">O exemplo a seguir obtém os metadados para uma propriedade de dependência em um proprietário específico como inicial base <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> tipo.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.FrameworkPropertyMetadata">
          <source>That metadata is cast to <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph>.</source>
          <target state="translated">Esses metadados são convertidos em <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.FrameworkPropertyMetadata">
          <source>If the cast returned a valid <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph>, then various <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph> property values are reported through a simple UI (not shown).</source>
          <target state="translated">Se a conversão retornou um válido <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph>, em seguida, vários <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph> valores de propriedade são relatados por meio de uma interface do usuário simple (não mostrado).</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" uid="T:System.Windows.FrameworkPropertyMetadata">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadata" /&gt;</ph> class.</source>
          <target state="translated">Inicializa uma nova instância da classe <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadata" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadata" /&gt;</ph> class.</source>
          <target state="translated">Inicializa uma nova instância da classe <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadata" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor">
          <source>This signature initializes all values of <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.%23ctor%2A&gt;</ph> to their property defaults.</source>
          <target state="translated">Esta assinatura inicializa todos os valores de <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.%23ctor%2A&gt;</ph> para seus padrões de propriedade.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor">
          <source><ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.DefaultValue%2A&gt;</ph> will be <ph id="ph2">`null`</ph>, and the various <ph id="ph3">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph> Boolean properties will be <ph id="ph4">`false`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.DefaultValue%2A&gt;</ph> será <ph id="ph2">`null`</ph>e os diversos <ph id="ph3">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph> propriedades Boolianas serão <ph id="ph4">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object)">
          <source>The default value of the dependency property, usually provided as a value of a specific type.</source>
          <target state="translated">O valor padrão da propriedade de dependência, geralmente, fornecido como um valor de um tipo específico.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadata" /&gt;</ph> class with the specified default value.</source>
          <target state="translated">Inicializa uma nova instância da classe <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadata" /&gt;</ph> com o valor padrão especificado.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object)">
          <source>The type of the value provided for <ph id="ph1">`defaultValue`</ph> must match or be related to the type specified in the original registration of the dependency property that this metadata will be applied to.</source>
          <target state="translated">O tipo do valor fornecido para <ph id="ph1">`defaultValue`</ph> devem coincidir ou ser relacionadas ao tipo especificado no registro original da propriedade de dependência que serão aplicados a esses metadados.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object)">
          <source>Mismatches between metadata default value type and the type of the dependency property it is being applied to can be difficult to debug, because the mismatch is not detectable during compilation.</source>
          <target state="translated">Incompatibilidade entre o tipo de valor padrão de metadados e o tipo da propriedade de dependência que está sendo aplicada ao pode ser difícil de depurar, porque a incompatibilidade não podem ser detectada durante a compilação.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object)">
          <source>The property system does not evaluate the effective value of a property until run time, so the result of a default value type/property type mismatch is a run-time error.</source>
          <target state="translated">O sistema de propriedade não avalia o valor efetivo de uma propriedade até que o tempo de execução, portanto, o resultado de uma incompatibilidade de tipo de propriedade do tipo de valor padrão é um erro de tempo de execução.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object)">
          <source>The value <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> has special meaning in the property system, and cannot be used as a dependency property default value.</source>
          <target state="translated">O valor <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> tem um significado especial no sistema de propriedade e não pode ser usado como um valor de padrão de propriedade de dependência.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object)">
          <source>The following example calls this constructor signature:</source>
          <target state="translated">O exemplo a seguir chama essa assinatura de construtor:</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object)">
          <source><ph id="ph1">&lt;paramref name="defaultValue" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="F:System.Windows.DependencyProperty.UnsetValue" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="defaultValue" /&gt;</ph> é definido como <ph id="ph2">&lt;see cref="F:System.Windows.DependencyProperty.UnsetValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Windows.PropertyChangedCallback)">
          <source>A reference to a handler implementation that the property system will call whenever the effective value of the property changes.</source>
          <target state="translated">Uma referência a uma implementação do manipulador que será chamada pelo sistema de propriedades sempre que o valor efetivo da propriedade for alterado.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Windows.PropertyChangedCallback)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadata" /&gt;</ph> class with the specified <ph id="ph2">&lt;see cref="T:System.Windows.PropertyChangedCallback" /&gt;</ph> callback.</source>
          <target state="translated">Inicializa uma nova instância da classe <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadata" /&gt;</ph> com o retorno de chamada <ph id="ph2">&lt;see cref="T:System.Windows.PropertyChangedCallback" /&gt;</ph> especificado.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Windows.PropertyChangedCallback)">
          <source>The following example calls this constructor signature:</source>
          <target state="translated">O exemplo a seguir chama essa assinatura de construtor:</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions)">
          <source>The default value of the dependency property, usually provided as a value of a specific type.</source>
          <target state="translated">O valor padrão da propriedade de dependência, geralmente, fornecido como um valor de um tipo específico.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions)">
          <source>The metadata option flags (a combination of <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /&gt;</ph> values).</source>
          <target state="translated">Os sinalizadores de opção de metadados (uma combinação de valores <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions)">
          <source>These options specify characteristics of the dependency property that interact with systems such as layout or data binding.</source>
          <target state="translated">Essas opções especificam características da propriedade de dependência que interagem com sistemas, como layout ou vinculação de dados.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadata" /&gt;</ph> class with the provided default value and framework-level metadata options.</source>
          <target state="translated">Inicializa uma nova instância da classe <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadata" /&gt;</ph> com o valor padrão e as opções de metadados em nível da estrutura fornecidos.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions)">
          <source>The type of the value provided for <ph id="ph1">`defaultValue`</ph> must match or be related to the type specified in the original registration of the dependency property that this metadata will be applied to.</source>
          <target state="translated">O tipo do valor fornecido para <ph id="ph1">`defaultValue`</ph> devem coincidir ou ser relacionadas ao tipo especificado no registro original da propriedade de dependência que serão aplicados a esses metadados.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions)">
          <source>Mismatches between metadata default value type and the type of the dependency property it is being applied to can be difficult to debug, because the mismatch is not detectable during compilation.</source>
          <target state="translated">Incompatibilidade entre o tipo de valor padrão de metadados e o tipo da propriedade de dependência que está sendo aplicada ao pode ser difícil de depurar, porque a incompatibilidade não podem ser detectada durante a compilação.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions)">
          <source>The property system does not evaluate the effective value of a property until run time, so the result of a default value type/property type mismatch is a run-time error.</source>
          <target state="translated">O sistema de propriedade não avalia o valor efetivo de uma propriedade até que o tempo de execução, portanto, o resultado de uma incompatibilidade de tipo de propriedade do tipo de valor padrão é um erro de tempo de execução.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions)">
          <source>The value <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> has special meaning in the property system, and cannot be used as a dependency property default value.</source>
          <target state="translated">O valor <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> tem um significado especial no sistema de propriedade e não pode ser usado como um valor de padrão de propriedade de dependência.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions)">
          <source>Values marked as set flags in the <ph id="ph1">`flags`</ph> parameter will set the Boolean value of <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph> properties that match that <ph id="ph3">&lt;xref:System.Windows.FrameworkPropertyMetadataOptions&gt;</ph> flag's name to <ph id="ph4">`true`</ph>.</source>
          <target state="translated">Valores marcados como definir sinalizadores no <ph id="ph1">`flags`</ph> parâmetro definirá o valor booliano de <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph> propriedades que correspondem que <ph id="ph3">&lt;xref:System.Windows.FrameworkPropertyMetadataOptions&gt;</ph> nome do sinalizador para <ph id="ph4">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions)">
          <source>You can subsequently change the values of the properties in the metadata, as long as the metadata has not yet been applied to a specific property system operation.</source>
          <target state="translated">Posteriormente, você pode alterar os valores das propriedades nos metadados, como os metadados ainda não foram aplicados a uma operação de sistema de propriedade específica.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions)">
          <source>The following example calls this constructor signature:</source>
          <target state="translated">O exemplo a seguir chama essa assinatura de construtor:</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions)">
          <source><ph id="ph1">&lt;paramref name="defaultValue" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="F:System.Windows.DependencyProperty.UnsetValue" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="defaultValue" /&gt;</ph> é definido como <ph id="ph2">&lt;see cref="F:System.Windows.DependencyProperty.UnsetValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback)">
          <source>The default value of the dependency property, usually provided as a value of a specific type.</source>
          <target state="translated">O valor padrão da propriedade de dependência, geralmente, fornecido como um valor de um tipo específico.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback)">
          <source>A reference to a handler implementation that the property system will call whenever the effective value of the property changes.</source>
          <target state="translated">Uma referência a uma implementação do manipulador que será chamada pelo sistema de propriedades sempre que o valor efetivo da propriedade for alterado.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadata" /&gt;</ph> class with the provided default value and specified <ph id="ph2">&lt;see cref="T:System.Windows.PropertyChangedCallback" /&gt;</ph> callback.</source>
          <target state="translated">Inicializa uma nova instância da classe <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadata" /&gt;</ph> com o valor padrão fornecido e o retorno de chamada <ph id="ph2">&lt;see cref="T:System.Windows.PropertyChangedCallback" /&gt;</ph> especificado.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback)">
          <source>The type of the value provided for <ph id="ph1">`defaultValue`</ph> must match or be related to the type specified in the original registration of the dependency property that this metadata will be applied to.</source>
          <target state="translated">O tipo do valor fornecido para <ph id="ph1">`defaultValue`</ph> devem coincidir ou ser relacionadas ao tipo especificado no registro original da propriedade de dependência que serão aplicados a esses metadados.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback)">
          <source>Mismatches between metadata default value type and the type of the dependency property it is being applied to can be difficult to debug, because the mismatch is not detectable during compilation.</source>
          <target state="translated">Incompatibilidade entre o tipo de valor padrão de metadados e o tipo da propriedade de dependência que está sendo aplicada ao pode ser difícil de depurar, porque a incompatibilidade não podem ser detectada durante a compilação.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback)">
          <source>The property system does not evaluate the effective value of a property until run time, so the result of a default value type/property type mismatch is a run-time error.</source>
          <target state="translated">O sistema de propriedade não avalia o valor efetivo de uma propriedade até que o tempo de execução, portanto, o resultado de uma incompatibilidade de tipo de propriedade do tipo de valor padrão é um erro de tempo de execução.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback)">
          <source>The value <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> has special meaning in the property system, and cannot be used as a dependency property default value.</source>
          <target state="translated">O valor <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> tem um significado especial no sistema de propriedade e não pode ser usado como um valor de padrão de propriedade de dependência.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback)">
          <source>The following example calls this constructor signature:</source>
          <target state="translated">O exemplo a seguir chama essa assinatura de construtor:</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback)">
          <source><ph id="ph1">&lt;paramref name="defaultValue" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="F:System.Windows.DependencyProperty.UnsetValue" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="defaultValue" /&gt;</ph> é definido como <ph id="ph2">&lt;see cref="F:System.Windows.DependencyProperty.UnsetValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)">
          <source>A reference to a handler implementation that the property system will call whenever the effective value of the property changes.</source>
          <target state="translated">Uma referência a uma implementação do manipulador que será chamada pelo sistema de propriedades sempre que o valor efetivo da propriedade for alterado.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)">
          <source>A reference to a handler implementation will be called whenever the property system calls <ph id="ph1">&lt;see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /&gt;</ph> for this dependency property.</source>
          <target state="translated">Uma referência a uma implementação de manipulador será chamada sempre que o sistema de propriedades chamar <ph id="ph1">&lt;see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /&gt;</ph> para essa propriedade de dependência.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadata" /&gt;</ph> class with the specified callbacks.</source>
          <target state="translated">Inicializa uma nova instância da classe <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadata" /&gt;</ph> com os retornos de chamada especificados.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)">
          <source>This implementation calls a base initializer and then adds the <ph id="ph1">`coerceValueCallback`</ph> by setting the property on the base instance.</source>
          <target state="translated">Essa implementação chama um inicializador de base e, em seguida, adiciona o <ph id="ph1">`coerceValueCallback`</ph> , definindo a propriedade na instância de base.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)">
          <source>The following example calls this constructor signature:</source>
          <target state="translated">O exemplo a seguir chama essa assinatura de construtor:</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback)">
          <source>The default value of the dependency property, usually provided as a value of a specific type.</source>
          <target state="translated">O valor padrão da propriedade de dependência, geralmente, fornecido como um valor de um tipo específico.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback)">
          <source>The metadata option flags (a combination of <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /&gt;</ph> values).</source>
          <target state="translated">Os sinalizadores de opção de metadados (uma combinação de valores <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback)">
          <source>These options specify characteristics of the dependency property that interact with systems such as layout or data binding.</source>
          <target state="translated">Essas opções especificam características da propriedade de dependência que interagem com sistemas, como layout ou vinculação de dados.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback)">
          <source>A reference to a handler implementation that the property system will call whenever the effective value of the property changes.</source>
          <target state="translated">Uma referência a uma implementação do manipulador que será chamada pelo sistema de propriedades sempre que o valor efetivo da propriedade for alterado.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadata" /&gt;</ph> class with the provided default value and framework metadata options, and specified <ph id="ph2">&lt;see cref="T:System.Windows.PropertyChangedCallback" /&gt;</ph> callback.</source>
          <target state="translated">Inicializa uma nova instância da classe <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadata" /&gt;</ph> com o valor padrão e as opções de metadados da estrutura fornecidos, bem como o retorno de chamada <ph id="ph2">&lt;see cref="T:System.Windows.PropertyChangedCallback" /&gt;</ph> especificado.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback)">
          <source>The type of the value provided for <ph id="ph1">`defaultValue`</ph> must match or be related to the type specified in the original registration of the dependency property that this metadata will be applied to.</source>
          <target state="translated">O tipo do valor fornecido para <ph id="ph1">`defaultValue`</ph> devem coincidir ou ser relacionadas ao tipo especificado no registro original da propriedade de dependência que serão aplicados a esses metadados.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback)">
          <source>Mismatches between metadata default value type and the type of the dependency property it is being applied to can be difficult to debug, because the mismatch is not detectable during compilation.</source>
          <target state="translated">Incompatibilidade entre o tipo de valor padrão de metadados e o tipo da propriedade de dependência que está sendo aplicada ao pode ser difícil de depurar, porque a incompatibilidade não podem ser detectada durante a compilação.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback)">
          <source>The property system does not evaluate the effective value of a property until run time, so the result of a default value type/property type mismatch is a run-time error.</source>
          <target state="translated">O sistema de propriedade não avalia o valor efetivo de uma propriedade até que o tempo de execução, portanto, o resultado de uma incompatibilidade de tipo de propriedade do tipo de valor padrão é um erro de tempo de execução.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback)">
          <source>The value <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> has special meaning in the property system, and cannot be used as a dependency property default value.</source>
          <target state="translated">O valor <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> tem um significado especial no sistema de propriedade e não pode ser usado como um valor de padrão de propriedade de dependência.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback)">
          <source>Values marked as set flags in the <ph id="ph1">`flags`</ph> parameter will set the Boolean value of <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph> properties that match that <ph id="ph3">&lt;xref:System.Windows.FrameworkPropertyMetadataOptions&gt;</ph> flag's name to <ph id="ph4">`true`</ph>.</source>
          <target state="translated">Valores marcados como definir sinalizadores no <ph id="ph1">`flags`</ph> parâmetro definirá o valor booliano de <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph> propriedades que correspondem que <ph id="ph3">&lt;xref:System.Windows.FrameworkPropertyMetadataOptions&gt;</ph> nome do sinalizador para <ph id="ph4">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback)">
          <source>You can still change the values of the properties in the metadata, as long as the metadata has not yet been applied to a specific property system operation.</source>
          <target state="translated">Você ainda pode alterar os valores das propriedades nos metadados, como os metadados ainda não foram aplicados a uma operação de sistema de propriedade específica.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback)">
          <source>The following example calls this constructor signature:</source>
          <target state="translated">O exemplo a seguir chama essa assinatura de construtor:</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback)">
          <source><ph id="ph1">&lt;paramref name="defaultValue" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="F:System.Windows.DependencyProperty.UnsetValue" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="defaultValue" /&gt;</ph> é definido como <ph id="ph2">&lt;see cref="F:System.Windows.DependencyProperty.UnsetValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)">
          <source>The default value of the dependency property, usually provided as a specific type.</source>
          <target state="translated">O valor padrão da propriedade de dependência, geralmente, fornecido como um tipo específico.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)">
          <source>A reference to a handler implementation that the property system will call whenever the effective value of the property changes.</source>
          <target state="translated">Uma referência a uma implementação do manipulador que será chamada pelo sistema de propriedades sempre que o valor efetivo da propriedade for alterado.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)">
          <source>A reference to a handler implementation that will be called whenever the property system calls <ph id="ph1">&lt;see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /&gt;</ph> for this dependency property.</source>
          <target state="translated">Uma referência a uma implementação de manipulador será chamada sempre que o sistema de propriedades chamar <ph id="ph1">&lt;see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /&gt;</ph> para essa propriedade de dependência.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadata" /&gt;</ph> class with the provided default value and specified callbacks.</source>
          <target state="translated">Inicializa uma nova instância da classe <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadata" /&gt;</ph> com o valor padrão fornecido e os retornos de chamada especificados.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)">
          <source>The type of the value provided for <ph id="ph1">`defaultValue`</ph> must match or be related to the type specified in the original registration of the dependency property that this metadata will be applied to.</source>
          <target state="translated">O tipo do valor fornecido para <ph id="ph1">`defaultValue`</ph> devem coincidir ou ser relacionadas ao tipo especificado no registro original da propriedade de dependência que serão aplicados a esses metadados.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)">
          <source>Mismatches between metadata default value type and the type of the dependency property it is being applied to can be difficult to debug, because the mismatch is not detectable during compilation.</source>
          <target state="translated">Incompatibilidade entre o tipo de valor padrão de metadados e o tipo da propriedade de dependência que está sendo aplicada ao pode ser difícil de depurar, porque a incompatibilidade não podem ser detectada durante a compilação.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)">
          <source>The property system does not evaluate the effective value of a property until run time, so the result of a default value type/property type mismatch is a run-time error.</source>
          <target state="translated">O sistema de propriedade não avalia o valor efetivo de uma propriedade até que o tempo de execução, portanto, o resultado de uma incompatibilidade de tipo de propriedade do tipo de valor padrão é um erro de tempo de execução.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)">
          <source>The value <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> has special meaning in the property system, and cannot be used as a dependency property default value.</source>
          <target state="translated">O valor <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> tem um significado especial no sistema de propriedade e não pode ser usado como um valor de padrão de propriedade de dependência.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)">
          <source>The following example calls this constructor signature:</source>
          <target state="translated">O exemplo a seguir chama essa assinatura de construtor:</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)">
          <source><ph id="ph1">&lt;paramref name="defaultValue" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="F:System.Windows.DependencyProperty.UnsetValue" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="defaultValue" /&gt;</ph> é definido como <ph id="ph2">&lt;see cref="F:System.Windows.DependencyProperty.UnsetValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)">
          <source>The default value of the dependency property, usually provided as a specific type.</source>
          <target state="translated">O valor padrão da propriedade de dependência, geralmente, fornecido como um tipo específico.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)">
          <source>The metadata option flags (a combination of <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /&gt;</ph> values).</source>
          <target state="translated">Os sinalizadores de opção de metadados (uma combinação de valores <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)">
          <source>These options specify characteristics of the dependency property that interact with systems such as layout or data binding.</source>
          <target state="translated">Essas opções especificam características da propriedade de dependência que interagem com sistemas, como layout ou vinculação de dados.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)">
          <source>A reference to a handler implementation that the property system will call whenever the effective value of the property changes.</source>
          <target state="translated">Uma referência a uma implementação do manipulador que será chamada pelo sistema de propriedades sempre que o valor efetivo da propriedade for alterado.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)">
          <source>A reference to a handler implementation that will be called whenever the property system calls <ph id="ph1">&lt;see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /&gt;</ph> against this property.</source>
          <target state="translated">Uma referência a uma implementação de manipulador que será chamada sempre que o sistema de propriedades chamar <ph id="ph1">&lt;see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /&gt;</ph> nessa propriedade.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadata" /&gt;</ph> class with the provided default value and framework metadata options, and specified callbacks.</source>
          <target state="translated">Inicializa uma nova instância da classe <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadata" /&gt;</ph> com o valor padrão e as opções de metadados da estrutura fornecidos, bem como os retornos de chamada especificados.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)">
          <source>The type of the value provided for <ph id="ph1">`defaultValue`</ph> must match or be related to the type specified in the original registration of the dependency property that this metadata will be applied to.</source>
          <target state="translated">O tipo do valor fornecido para <ph id="ph1">`defaultValue`</ph> devem coincidir ou ser relacionadas ao tipo especificado no registro original da propriedade de dependência que serão aplicados a esses metadados.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)">
          <source>Mismatches between metadata default value type and the type of the dependency property it is being applied to can be difficult to debug, because the mismatch is not detectable during compilation.</source>
          <target state="translated">Incompatibilidade entre o tipo de valor padrão de metadados e o tipo da propriedade de dependência que está sendo aplicada ao pode ser difícil de depurar, porque a incompatibilidade não podem ser detectada durante a compilação.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)">
          <source>The property system does not evaluate the effective value of a property until run time, so the result of a default value type/property type mismatch is a run-time error.</source>
          <target state="translated">O sistema de propriedade não avalia o valor efetivo de uma propriedade até que o tempo de execução, portanto, o resultado de uma incompatibilidade de tipo de propriedade do tipo de valor padrão é um erro de tempo de execução.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)">
          <source>The value <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> has special meaning in the property system, and cannot be used as a dependency property default value.</source>
          <target state="translated">O valor <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> tem um significado especial no sistema de propriedade e não pode ser usado como um valor de padrão de propriedade de dependência.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)">
          <source>Values marked as set flags in the <ph id="ph1">`flags`</ph> parameter will set the Boolean value of <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph> properties that match that <ph id="ph3">&lt;xref:System.Windows.FrameworkPropertyMetadataOptions&gt;</ph> flag's name to <ph id="ph4">`true`</ph>.</source>
          <target state="translated">Valores marcados como definir sinalizadores no <ph id="ph1">`flags`</ph> parâmetro definirá o valor booliano de <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph> propriedades que correspondem que <ph id="ph3">&lt;xref:System.Windows.FrameworkPropertyMetadataOptions&gt;</ph> nome do sinalizador para <ph id="ph4">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)">
          <source>You can still change the values of the properties in the metadata, as long as the metadata has not yet been applied to a specific property system operation.</source>
          <target state="translated">Você ainda pode alterar os valores das propriedades nos metadados, como os metadados ainda não foram aplicados a uma operação de sistema de propriedade específica.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)">
          <source>The following example calls this constructor signature:</source>
          <target state="translated">O exemplo a seguir chama essa assinatura de construtor:</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)">
          <source><ph id="ph1">&lt;paramref name="defaultValue" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="F:System.Windows.DependencyProperty.UnsetValue" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="defaultValue" /&gt;</ph> é definido como <ph id="ph2">&lt;see cref="F:System.Windows.DependencyProperty.UnsetValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean)">
          <source>The default value of the dependency property, usually provided as a specific type.</source>
          <target state="translated">O valor padrão da propriedade de dependência, geralmente, fornecido como um tipo específico.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean)">
          <source>The metadata option flags (a combination of <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /&gt;</ph> values).</source>
          <target state="translated">Os sinalizadores de opção de metadados (uma combinação de valores <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean)">
          <source>These options specify characteristics of the dependency property that interact with systems such as layout or data binding.</source>
          <target state="translated">Essas opções especificam características da propriedade de dependência que interagem com sistemas, como layout ou vinculação de dados.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean)">
          <source>A reference to a handler implementation that the property system will call whenever the effective value of the property changes.</source>
          <target state="translated">Uma referência a uma implementação do manipulador que será chamada pelo sistema de propriedades sempre que o valor efetivo da propriedade for alterado.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean)">
          <source>A reference to a handler implementation that will be called whenever the property system calls <ph id="ph1">&lt;see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /&gt;</ph> on this dependency property.</source>
          <target state="translated">Uma referência a uma implementação de manipulador será chamada sempre que o sistema de propriedades chamar <ph id="ph1">&lt;see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /&gt;</ph> nessa propriedade de dependência.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to prevent the property system from animating the property that this metadata is applied to.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> para impedir que o sistema de propriedades anime a propriedade à qual esses metadados foram aplicados.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean)">
          <source>Such properties will raise a run-time exception originating from the property system if animations of them are attempted.</source>
          <target state="translated">Propriedades desse tipo acionarão uma exceção de tempo de execução que provenientes do sistema de propriedades, em caso de tentativa de criar animações delas.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="false" /&gt;</ph> to permit animating the property.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="false" /&gt;</ph> para permitir que a propriedade seja animada.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean)">
          <source>The default is <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">O padrão é <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadata" /&gt;</ph> class with the provided default value and framework metadata options, specified callbacks, and a Boolean that can be used to prevent animation of the property.</source>
          <target state="translated">Inicializa uma nova instância da classe <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadata" /&gt;</ph> com o valor padrão e as opções de metadados da estrutura fornecidos, os retornos de chamada especificados e um booliano que pode ser usado para impedir a animação da propriedade.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean)">
          <source>The type of the value provided for <ph id="ph1">`defaultValue`</ph> must match or be related to the type specified in the original registration of the dependency property that this metadata will be applied to.</source>
          <target state="translated">O tipo do valor fornecido para <ph id="ph1">`defaultValue`</ph> devem coincidir ou ser relacionadas ao tipo especificado no registro original da propriedade de dependência que serão aplicados a esses metadados.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean)">
          <source>Mismatches between metadata default value type and the type of the dependency property it is being applied to can be difficult to debug, because the mismatch is not detectable during compilation.</source>
          <target state="translated">Incompatibilidade entre o tipo de valor padrão de metadados e o tipo da propriedade de dependência que está sendo aplicada ao pode ser difícil de depurar, porque a incompatibilidade não podem ser detectada durante a compilação.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean)">
          <source>The property system does not evaluate the effective value of a property until run time, so the result of a default value type/property type mismatch is a run-time error.</source>
          <target state="translated">O sistema de propriedade não avalia o valor efetivo de uma propriedade até que o tempo de execução, portanto, o resultado de uma incompatibilidade de tipo de propriedade do tipo de valor padrão é um erro de tempo de execução.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean)">
          <source>The value <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> has special meaning in the property system, and cannot be used as a dependency property default value.</source>
          <target state="translated">O valor <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> tem um significado especial no sistema de propriedade e não pode ser usado como um valor de padrão de propriedade de dependência.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean)">
          <source>The <ph id="ph1">`isAnimationProhibited`</ph> parameter sets the initial value of the <ph id="ph2">&lt;xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A&gt;</ph> property declared by the immediate base <ph id="ph3">&lt;xref:System.Windows.UIPropertyMetadata&gt;</ph> class.</source>
          <target state="translated">O <ph id="ph1">`isAnimationProhibited`</ph> parâmetro define o valor inicial de <ph id="ph2">&lt;xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A&gt;</ph> propriedade declarada com a base de imediata <ph id="ph3">&lt;xref:System.Windows.UIPropertyMetadata&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean)">
          <source>Values marked as set flags in the <ph id="ph1">`flags`</ph> parameter will set the Boolean value of <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph> properties that match that <ph id="ph3">&lt;xref:System.Windows.FrameworkPropertyMetadataOptions&gt;</ph> flag's name to <ph id="ph4">`true`</ph>.</source>
          <target state="translated">Valores marcados como definir sinalizadores no <ph id="ph1">`flags`</ph> parâmetro definirá o valor booliano de <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph> propriedades que correspondem que <ph id="ph3">&lt;xref:System.Windows.FrameworkPropertyMetadataOptions&gt;</ph> nome do sinalizador para <ph id="ph4">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean)">
          <source>You can still change the values of the properties in the metadata, as long as the metadata has not yet been applied to a specific property system operation.</source>
          <target state="translated">Você ainda pode alterar os valores das propriedades nos metadados, como os metadados ainda não foram aplicados a uma operação de sistema de propriedade específica.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean)">
          <source>The following example calls this constructor signature:</source>
          <target state="translated">O exemplo a seguir chama essa assinatura de construtor:</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="defaultValue" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="F:System.Windows.DependencyProperty.UnsetValue" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="defaultValue" /&gt;</ph> é definido como <ph id="ph2">&lt;see cref="F:System.Windows.DependencyProperty.UnsetValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean,System.Windows.Data.UpdateSourceTrigger)">
          <source>The default value of the dependency property, usually provided as a specific type.</source>
          <target state="translated">O valor padrão da propriedade de dependência, geralmente, fornecido como um tipo específico.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean,System.Windows.Data.UpdateSourceTrigger)">
          <source>The metadata option flags (a combination of <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /&gt;</ph> values).</source>
          <target state="translated">Os sinalizadores de opção de metadados (uma combinação de valores <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean,System.Windows.Data.UpdateSourceTrigger)">
          <source>These options specify characteristics of the dependency property that interact with systems such as layout or data binding.</source>
          <target state="translated">Essas opções especificam características da propriedade de dependência que interagem com sistemas, como layout ou vinculação de dados.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean,System.Windows.Data.UpdateSourceTrigger)">
          <source>A reference to a handler implementation that the property system will call whenever the effective value of the property changes.</source>
          <target state="translated">Uma referência a uma implementação do manipulador que será chamada pelo sistema de propriedades sempre que o valor efetivo da propriedade for alterado.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean,System.Windows.Data.UpdateSourceTrigger)">
          <source>A reference to a handler implementation that will be called whenever the property system calls <ph id="ph1">&lt;see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /&gt;</ph> against this property.</source>
          <target state="translated">Uma referência a uma implementação de manipulador que será chamada sempre que o sistema de propriedades chamar <ph id="ph1">&lt;see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /&gt;</ph> nessa propriedade.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean,System.Windows.Data.UpdateSourceTrigger)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to prevent the property system from animating the property that this metadata is applied to.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> para impedir que o sistema de propriedades anime a propriedade à qual esses metadados foram aplicados.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean,System.Windows.Data.UpdateSourceTrigger)">
          <source>Such properties will raise a run-time exception originating from the property system if animations of them are attempted.</source>
          <target state="translated">Propriedades desse tipo acionarão uma exceção de tempo de execução que provenientes do sistema de propriedades, em caso de tentativa de criar animações delas.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean,System.Windows.Data.UpdateSourceTrigger)">
          <source>The default is <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">O padrão é <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean,System.Windows.Data.UpdateSourceTrigger)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Windows.Data.UpdateSourceTrigger" /&gt;</ph> to use when bindings for this property are applied that have their <ph id="ph2">&lt;see cref="T:System.Windows.Data.UpdateSourceTrigger" /&gt;</ph> set to <ph id="ph3">&lt;see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" /&gt;</ph>.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Windows.Data.UpdateSourceTrigger" /&gt;</ph> a ser usado quando as associações dessa propriedade forem aplicadas com seu <ph id="ph2">&lt;see cref="T:System.Windows.Data.UpdateSourceTrigger" /&gt;</ph> definido como <ph id="ph3">&lt;see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean,System.Windows.Data.UpdateSourceTrigger)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadata" /&gt;</ph> class with the provided default value and framework metadata options, specified callbacks, a Boolean that can be used to prevent animation of the property, and a data-binding update trigger default.</source>
          <target state="translated">Inicializa uma nova instância da classe <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadata" /&gt;</ph> com o valor padrão e as opções de metadados da estrutura fornecidos, os retornos de chamada especificados, um booliano que pode ser usado para impedir a animação da propriedade e um padrão de gatilho de atualização com associação de dados.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean,System.Windows.Data.UpdateSourceTrigger)">
          <source>The type of the value provided for <ph id="ph1">`defaultValue`</ph> must match or be related to the type specified in the original registration of the dependency property that this metadata will be applied to.</source>
          <target state="translated">O tipo do valor fornecido para <ph id="ph1">`defaultValue`</ph> devem coincidir ou ser relacionadas ao tipo especificado no registro original da propriedade de dependência que serão aplicados a esses metadados.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean,System.Windows.Data.UpdateSourceTrigger)">
          <source>Mismatches between metadata default value type and the type of the dependency property it is being applied to can be difficult to debug, because the mismatch is not detectable during compilation.</source>
          <target state="translated">Incompatibilidade entre o tipo de valor padrão de metadados e o tipo da propriedade de dependência que está sendo aplicada ao pode ser difícil de depurar, porque a incompatibilidade não podem ser detectada durante a compilação.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean,System.Windows.Data.UpdateSourceTrigger)">
          <source>The property system does not evaluate the effective value of a property until run time, so the result of a default value type/property type mismatch is a run-time error.</source>
          <target state="translated">O sistema de propriedade não avalia o valor efetivo de uma propriedade até que o tempo de execução, portanto, o resultado de uma incompatibilidade de tipo de propriedade do tipo de valor padrão é um erro de tempo de execução.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean,System.Windows.Data.UpdateSourceTrigger)">
          <source>The value <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> has special meaning in the property system, and cannot be used as a dependency property default value.</source>
          <target state="translated">O valor <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> tem um significado especial no sistema de propriedade e não pode ser usado como um valor de padrão de propriedade de dependência.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean,System.Windows.Data.UpdateSourceTrigger)">
          <source>The <ph id="ph1">`isAnimationProhibited`</ph> parameter sets the initial value of the <ph id="ph2">&lt;xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A&gt;</ph> property declared by the immediate base <ph id="ph3">&lt;xref:System.Windows.UIPropertyMetadata&gt;</ph> class.</source>
          <target state="translated">O <ph id="ph1">`isAnimationProhibited`</ph> parâmetro define o valor inicial de <ph id="ph2">&lt;xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A&gt;</ph> propriedade declarada com a base de imediata <ph id="ph3">&lt;xref:System.Windows.UIPropertyMetadata&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean,System.Windows.Data.UpdateSourceTrigger)">
          <source>For more information about the update source behavior for bindings, see <bpt id="p1">[</bpt>Data Binding Overview<ept id="p1">](~/docs/framework/wpf/data/data-binding-overview.md)</ept>.</source>
          <target state="translated">Para obter mais informações sobre o comportamento de origem de atualização para associações, consulte <bpt id="p1">[</bpt>visão geral de associação de dados<ept id="p1">](~/docs/framework/wpf/data/data-binding-overview.md)</ept>.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean,System.Windows.Data.UpdateSourceTrigger)">
          <source>Values marked as set flags in the <ph id="ph1">`flags`</ph> parameter will set the Boolean value of <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph> properties that match that <ph id="ph3">&lt;xref:System.Windows.FrameworkPropertyMetadataOptions&gt;</ph> flag's name to <ph id="ph4">`true`</ph>.</source>
          <target state="translated">Valores marcados como definir sinalizadores no <ph id="ph1">`flags`</ph> parâmetro definirá o valor booliano de <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph> propriedades que correspondem que <ph id="ph3">&lt;xref:System.Windows.FrameworkPropertyMetadataOptions&gt;</ph> nome do sinalizador para <ph id="ph4">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean,System.Windows.Data.UpdateSourceTrigger)">
          <source>You can still change the values of the properties in the metadata, as long as the metadata has not yet been applied to a specific property system operation.</source>
          <target state="translated">Você ainda pode alterar os valores das propriedades nos metadados, como os metadados ainda não foram aplicados a uma operação de sistema de propriedade específica.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean,System.Windows.Data.UpdateSourceTrigger)">
          <source><ph id="ph1">&lt;paramref name="defaultValue" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="F:System.Windows.DependencyProperty.UnsetValue" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="defaultValue" /&gt;</ph> é definido como <ph id="ph2">&lt;see cref="F:System.Windows.DependencyProperty.UnsetValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsArrange">
          <source>Gets or sets a value that indicates whether a dependency property potentially affects the arrange pass during layout engine operations.</source>
          <target state="translated">Obtém ou define um valor que indica se uma propriedade de dependência potencialmente afeta a passagem de organização durante operações de mecanismo de layout.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsArrange">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the dependency property on which this metadata exists potentially affects the arrange pass; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> Se a propriedade de dependência na qual esses metadados existem potencialmente afeta a etapa de organização; Caso contrário, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsArrange">
          <source>The default is <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">O padrão é <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsArrange">
          <source><ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> and <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> include an implementation of <ph id="ph3">&lt;xref:System.Windows.FrameworkElement.OnPropertyChanged%2A&gt;</ph> that monitors effective value changes to all dependency properties that exist on an element.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> e <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> inclui uma implementação do <ph id="ph3">&lt;xref:System.Windows.FrameworkElement.OnPropertyChanged%2A&gt;</ph> que monitora as alterações de valor efetivo para todas as propriedades de dependência que existem em um elemento.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsArrange">
          <source>As part of that logic, dependency properties that change effective value and have metadata with <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A&gt;</ph> set to <ph id="ph2">`true`</ph> will initiate a deferred request to invalidate the visuals for that element (a call to <ph id="ph3">&lt;xref:System.Windows.UIElement.InvalidateArrange%2A&gt;</ph>).</source>
          <target state="translated">Como parte dessa lógica, propriedades de dependência que alteram a partir de valor e têm metadados com <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A&gt;</ph> definida como <ph id="ph2">`true`</ph> iniciará uma solicitação adiada para invalidar os visuais para esse elemento (uma chamada para <ph id="ph3">&lt;xref:System.Windows.UIElement.InvalidateArrange%2A&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsArrange">
          <source>Because this WPF framework-level implementation is already in place, you typically do not need to look for dependency properties with <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A&gt;</ph> unless you are substantially replacing or modifying the WPF framework-level layout behavior.</source>
          <target state="translated">Como essa implementação de nível de framework WPF já está em vigor, você normalmente não é necessário procurar por propriedades de dependência com <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A&gt;</ph> , a menos que você é substancialmente substituir ou modificar o comportamento de layout de nível de framework do WPF.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsArrange">
          <source>Custom <ph id="ph1">&lt;xref:System.Windows.DependencyObject.OnPropertyChanged%2A&gt;</ph> implementations might choose to have similar behavior for dependency property changes where <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A&gt;</ph> is <ph id="ph3">`true`</ph>.</source>
          <target state="translated">Personalizar <ph id="ph1">&lt;xref:System.Windows.DependencyObject.OnPropertyChanged%2A&gt;</ph> implementações podem optar por ter um comportamento semelhante para as alterações de propriedade de dependência onde <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A&gt;</ph> é <ph id="ph3">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsArrange">
          <source>Properties on derived classes of <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> are typically defined in the object model as read-write.</source>
          <target state="translated">Propriedades em classes derivadas de <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> geralmente são definidas no modelo de objeto como leitura-gravação.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsArrange">
          <source>This is so they can be adjusted after initialization of the instance.</source>
          <target state="translated">Isso é possível ajustá-los após a inicialização da instância.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsArrange">
          <source>However, after the metadata is consumed as part of a call to <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>, or <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph>, the property system will seal that metadata instance and properties that convey the specifics of the metadata are now considered immutable.</source>
          <target state="translated">No entanto, depois que os metadados são consumidos como parte de uma chamada para <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>, ou <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph>, o sistema de propriedade será lacrar essa instância de metadados e propriedades que transmitem as especificações de metadados são consideradas imutáveis.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsArrange">
          <source>Attempting to set this property after <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;</ph> is <ph id="ph2">`true`</ph> on this metadata instance will raise an exception.</source>
          <target state="translated">Tentativa de definir esta propriedade após <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;</ph> é <ph id="ph2">`true`</ph> nesses metadados instância gerará uma exceção.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsArrange">
          <source>XAML Text Usage</source>
          <target state="translated">Uso de texto XAML</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsArrange">
          <source>Members of this class are either not typically used in <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</source>
          <target state="translated">Membros dessa classe ou não são geralmente usados em <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsArrange">
          <source>The following example obtains the default metadata from various dependency property fields, queries the value of various <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph> properties on it, and uses the information to populate a table to implement a "metadata browser".</source>
          <target state="translated">O exemplo a seguir obtém os metadados padrão da dependência de vários campos de propriedade, consulta o valor de vários <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph> propriedades nele e usa as informações para popular uma tabela para implementar um navegador de metadados"".</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsArrange">
          <source>The metadata has already been applied to a dependency property operation, so that metadata is sealed and properties of the metadata cannot be set.</source>
          <target state="translated">Os metadados já foram aplicados à operação de propriedade de dependência, portanto os metadados estão selados e as propriedades dos metadados não podem ser definidas.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsMeasure">
          <source>Gets or sets a value that indicates whether a dependency property potentially affects the measure pass during layout engine operations.</source>
          <target state="translated">Obtém ou define um valor que indica se uma propriedade de dependência potencialmente afeta a passagem de medição durante operações de mecanismo de layout.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsMeasure">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the dependency property on which this metadata exists potentially affects the measure pass; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se a propriedade de dependência na qual esses metadados existem potencialmente afetar a passagem de medida; caso contrário, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsMeasure">
          <source>The default is <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">O padrão é <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsMeasure">
          <source><ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> and <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> include an implementation of <ph id="ph3">&lt;xref:System.Windows.FrameworkElement.OnPropertyChanged%2A&gt;</ph> that monitors effective value changes to all dependency properties that exist on an element.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> e <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> inclui uma implementação do <ph id="ph3">&lt;xref:System.Windows.FrameworkElement.OnPropertyChanged%2A&gt;</ph> que monitora as alterações de valor efetivo para todas as propriedades de dependência que existem em um elemento.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsMeasure">
          <source>As part of that logic, dependency properties that change effective value and have metadata with <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A&gt;</ph> set to <ph id="ph2">`true`</ph> will initiate a deferred request to invalidate the visuals for that element.</source>
          <target state="translated">Como parte dessa lógica, propriedades de dependência que alteram a partir de valor e têm metadados com <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A&gt;</ph> definida como <ph id="ph2">`true`</ph> iniciará uma solicitação adiada para invalidar os visuais para esse elemento.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsMeasure">
          <source>Because this WPF framework-level implementation is already in place, you typically do not need to look for dependency properties with <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A&gt;</ph> unless you are substantially replacing or modifying the WPF framework-level layout behavior.</source>
          <target state="translated">Como essa implementação de nível de framework WPF já está em vigor, você normalmente não é necessário procurar por propriedades de dependência com <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A&gt;</ph> , a menos que você é substancialmente substituir ou modificar o comportamento de layout de nível de framework do WPF.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsMeasure">
          <source>Custom <ph id="ph1">&lt;xref:System.Windows.DependencyObject.OnPropertyChanged%2A&gt;</ph> implementations might choose to have similar behavior for dependency property changes where <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A&gt;</ph> is <ph id="ph3">`true`</ph>.</source>
          <target state="translated">Personalizar <ph id="ph1">&lt;xref:System.Windows.DependencyObject.OnPropertyChanged%2A&gt;</ph> implementações podem optar por ter um comportamento semelhante para as alterações de propriedade de dependência onde <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A&gt;</ph> é <ph id="ph3">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsMeasure">
          <source>Properties on derived classes of <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> are typically defined in the object model as read-write.</source>
          <target state="translated">Propriedades em classes derivadas de <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> geralmente são definidas no modelo de objeto como leitura-gravação.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsMeasure">
          <source>This is so they can be adjusted after initialization of the instance.</source>
          <target state="translated">Isso é possível ajustá-los após a inicialização da instância.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsMeasure">
          <source>However, after the metadata is consumed as part of a call to <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>, or <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph>, the property system will seal that metadata instance and properties that convey the specifics of the metadata are now considered immutable.</source>
          <target state="translated">No entanto, depois que os metadados são consumidos como parte de uma chamada para <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>, ou <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph>, o sistema de propriedade será lacrar essa instância de metadados e propriedades que transmitem as especificações de metadados são consideradas imutáveis.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsMeasure">
          <source>Attempting to set this property after <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;</ph> is <ph id="ph2">`true`</ph> on this metadata instance will raise an exception.</source>
          <target state="translated">Tentativa de definir esta propriedade após <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;</ph> é <ph id="ph2">`true`</ph> nesses metadados instância gerará uma exceção.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsMeasure">
          <source>XAML Text Usage</source>
          <target state="translated">Uso de texto XAML</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsMeasure">
          <source>Members of this class are not typically used in <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</source>
          <target state="translated">Membros dessa classe não são normalmente usados no <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsMeasure">
          <source>The following example obtains the default metadata from various dependency property fields, queries the value of various <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph> properties on it, and uses the information to populate a table to implement a "metadata browser".</source>
          <target state="translated">O exemplo a seguir obtém os metadados padrão da dependência de vários campos de propriedade, consulta o valor de vários <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph> propriedades nele e usa as informações para popular uma tabela para implementar um navegador de metadados"".</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsMeasure">
          <source>The metadata has already been applied to a dependency property operation, so that metadata is sealed and properties of the metadata cannot be set.</source>
          <target state="translated">Os metadados já foram aplicados à operação de propriedade de dependência, portanto os metadados estão selados e as propriedades dos metadados não podem ser definidas.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange">
          <source>Gets or sets a value that indicates whether a dependency property potentially affects the arrange pass of its parent element's layout during layout engine operations.</source>
          <target state="translated">Obtém ou define um valor que indica se uma propriedade de dependência potencialmente afeta a passagem de organização do layout do respectivo elemento pai durante operações de mecanismo de layout.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the dependency property on which this metadata exists potentially affects the arrange pass specifically on its parent element; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> Se a propriedade de dependência na qual esses metadados existem potencialmente afeta a passagem de organizar especificamente em seu elemento pai. Caso contrário, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange">
          <source>The default is <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">O padrão é <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange">
          <source><ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> and <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> include an implementation of <ph id="ph3">&lt;xref:System.Windows.FrameworkElement.OnPropertyChanged%2A&gt;</ph> that monitors effective value changes to all dependency properties that exist on an element.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> e <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> inclui uma implementação do <ph id="ph3">&lt;xref:System.Windows.FrameworkElement.OnPropertyChanged%2A&gt;</ph> que monitora as alterações de valor efetivo para todas as propriedades de dependência que existem em um elemento.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange">
          <source>As part of that logic, dependency properties that change effective value and have metadata with <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A&gt;</ph> set to <ph id="ph2">`true`</ph> will initiate a deferred request to invalidate the visuals for the parent element.</source>
          <target state="translated">Como parte dessa lógica, propriedades de dependência que alteram a partir de valor e têm metadados com <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A&gt;</ph> definida como <ph id="ph2">`true`</ph> iniciará uma solicitação adiada para invalidar os visuais para o elemento pai.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange">
          <source>Generally, you do not need to report changes of a <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> property to a parent element using <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A&gt;</ph> because the element itself would already have its own <ph id="ph3">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A&gt;</ph> as <ph id="ph4">`true`</ph>.</source>
          <target state="translated">Em geral, você não precisa alterações de relatório de um <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> propriedade para um elemento pai usando <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A&gt;</ph> porque o elemento em si já deve ter seu próprio <ph id="ph3">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A&gt;</ph> como <ph id="ph4">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange">
          <source>That is usually sufficient, because changes in the child element generally initiate a parent arrange when appropriate.</source>
          <target state="translated">É geralmente suficiente, como as alterações no elemento filho geralmente iniciam um pai organizar quando apropriado.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange">
          <source><ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A&gt;</ph> is sometimes used for a <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> derived class.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A&gt;</ph> às vezes, é usado para um <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> classe derivada.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange">
          <source>In this case, the child element sets a property, but a <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> derived class does not control its own rendering.</source>
          <target state="translated">Nesse caso, os conjuntos de elemento filho, uma propriedade, mas um <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> classe derivada não controla seu próprio processamento.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange">
          <source>The rendering is handled by a <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> parent element that serves as the content host.</source>
          <target state="translated">O processamento é tratado por um <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> elemento pai que serve como o host de conteúdo.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange">
          <source>For instance, a change to the value of the <ph id="ph1">&lt;xref:System.Windows.Documents.FixedPage.Left%2A?displayProperty=nameWithType&gt;</ph> attached property by a child element invalidates arrange of the parent, because the position of the child in the parent must be changed.</source>
          <target state="translated">Por exemplo, uma alteração no valor da <ph id="ph1">&lt;xref:System.Windows.Documents.FixedPage.Left%2A?displayProperty=nameWithType&gt;</ph> propriedade anexada por um elemento filho invalida organizar do pai, porque a posição do filho no pai deve ser alterada.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange">
          <source>Therefore, the <ph id="ph1">&lt;xref:System.Windows.Documents.FixedPage.Left%2A?displayProperty=nameWithType&gt;</ph> attached property has metadata where <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A&gt;</ph> is <ph id="ph3">`true`</ph>.</source>
          <target state="translated">Portanto, o <ph id="ph1">&lt;xref:System.Windows.Documents.FixedPage.Left%2A?displayProperty=nameWithType&gt;</ph> propriedade anexada tem metadados onde <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A&gt;</ph> é <ph id="ph3">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange">
          <source>Another example is <ph id="ph1">&lt;xref:System.Windows.Controls.Control.Padding%2A&gt;</ph>; when this property changes, the parent might change the positioning of the child, depending on available space.</source>
          <target state="translated">Outro exemplo é <ph id="ph1">&lt;xref:System.Windows.Controls.Control.Padding%2A&gt;</ph>; quando alterações de propriedade, o pai pode alterar o posicionamento do filho, dependendo do espaço disponível.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange">
          <source>Because this WPF framework-level implementation is already in place, you typically do not need to look for dependency properties with <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A&gt;</ph> unless you are substantially replacing or modifying the WPF framework-level layout behavior.</source>
          <target state="translated">Como essa implementação de nível de framework WPF já está em vigor, você normalmente não é necessário procurar por propriedades de dependência com <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A&gt;</ph> , a menos que você é substancialmente substituir ou modificar o comportamento de layout de nível de framework do WPF.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange">
          <source>Custom <ph id="ph1">&lt;xref:System.Windows.DependencyObject.OnPropertyChanged%2A&gt;</ph> implementations might choose to have similar behavior for dependency property changes where <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A&gt;</ph> is <ph id="ph3">`true`</ph>.</source>
          <target state="translated">Personalizar <ph id="ph1">&lt;xref:System.Windows.DependencyObject.OnPropertyChanged%2A&gt;</ph> implementações podem optar por ter um comportamento semelhante para as alterações de propriedade de dependência onde <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A&gt;</ph> é <ph id="ph3">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange">
          <source>Properties on any derived classes of <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> are typically defined in the object model as read-write.</source>
          <target state="translated">Propriedades em qualquer classes derivadas de <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> geralmente são definidas no modelo de objeto como leitura-gravação.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange">
          <source>This is so they can be adjusted after initialization of the instance.</source>
          <target state="translated">Isso é possível ajustá-los após a inicialização da instância.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange">
          <source>However, after the metadata is consumed as part of a call to <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>, or <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph>, the property system will seal that metadata instance and properties that convey the specifics of the metadata are now considered immutable.</source>
          <target state="translated">No entanto, depois que os metadados são consumidos como parte de uma chamada para <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>, ou <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph>, o sistema de propriedade será lacrar essa instância de metadados e propriedades que transmitem as especificações de metadados são consideradas imutáveis.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange">
          <source>Attempting to set this property after <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;</ph> is <ph id="ph2">`true`</ph> on this metadata instance will raise an exception.</source>
          <target state="translated">Tentativa de definir esta propriedade após <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;</ph> é <ph id="ph2">`true`</ph> nesses metadados instância gerará uma exceção.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange">
          <source>XAML Text Usage</source>
          <target state="translated">Uso de texto XAML</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange">
          <source>Members of this class are not typically used in <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</source>
          <target state="translated">Membros dessa classe não são normalmente usados no <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange">
          <source>The metadata has already been applied to a dependency property operation, so that metadata is sealed and properties of the metadata cannot be set.</source>
          <target state="translated">Os metadados já foram aplicados à operação de propriedade de dependência, portanto os metadados estão selados e as propriedades dos metadados não podem ser definidas.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure">
          <source>Gets or sets a value that indicates whether a dependency property potentially affects the measure pass of its parent element's layout during layout engine operations.</source>
          <target state="translated">Obtém ou define um valor que indica se uma propriedade de dependência potencialmente afeta a passagem de medida do layout do respectivo elemento pai durante operações de mecanismo de layout.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the dependency property on which this metadata exists potentially affects the measure pass specifically on its parent element; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.The default is <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> Se a propriedade de dependência na qual esses metadados existem potencialmente afeta a passagem de medição especificamente em seu elemento pai. Caso contrário, <ph id="ph2">&lt;see langword="false" /&gt;</ph>. O padrão é <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure">
          <source><ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> and <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> include an implementation of <ph id="ph3">&lt;xref:System.Windows.FrameworkElement.OnPropertyChanged%2A&gt;</ph> that monitors effective value changes to all dependency properties that exist on an element.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> e <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> inclui uma implementação do <ph id="ph3">&lt;xref:System.Windows.FrameworkElement.OnPropertyChanged%2A&gt;</ph> que monitora as alterações de valor efetivo para todas as propriedades de dependência que existem em um elemento.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure">
          <source>As part of that logic, dependency properties that change effective value and have metadata with <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A&gt;</ph> set to <ph id="ph2">`true`</ph> will initiate a deferred request to invalidate the visuals for the parent element.</source>
          <target state="translated">Como parte dessa lógica, propriedades de dependência que alteram a partir de valor e têm metadados com <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A&gt;</ph> definida como <ph id="ph2">`true`</ph> iniciará uma solicitação adiada para invalidar os visuais para o elemento pai.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure">
          <source>Because this WPF framework-level implementation is already in place, you typically do not need to look for dependency properties with <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A&gt;</ph> unless you are substantially replacing or modifying the WPF framework-level layout behavior.</source>
          <target state="translated">Como essa implementação de nível de framework WPF já está em vigor, você normalmente não é necessário procurar por propriedades de dependência com <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A&gt;</ph> , a menos que você é substancialmente substituir ou modificar o comportamento de layout de nível de framework do WPF.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure">
          <source>Generally, you do not need to report changes of a <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> property to a parent element using <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A&gt;</ph> because the element itself would already have its own <ph id="ph3">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A&gt;</ph> as <ph id="ph4">`true`</ph>.</source>
          <target state="translated">Em geral, você não precisa alterações de relatório de um <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> propriedade para um elemento pai usando <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A&gt;</ph> porque o elemento em si já deve ter seu próprio <ph id="ph3">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A&gt;</ph> como <ph id="ph4">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure">
          <source>That is usually sufficient, because changes in the child element generally initiate a parent measure pass when appropriate.</source>
          <target state="translated">Que é geralmente suficiente, como as alterações no elemento filho geralmente iniciam uma passagem de medidas pai quando apropriado.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure">
          <source><ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A&gt;</ph> is sometimes used for a <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> derived class.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A&gt;</ph> às vezes, é usado para um <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> classe derivada.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure">
          <source>In this case, the child element sets a property, but a <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> derived class does not control its own rendering.</source>
          <target state="translated">Nesse caso, os conjuntos de elemento filho, uma propriedade, mas um <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> classe derivada não controla seu próprio processamento.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure">
          <source>The rendering is handled by a <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> parent element that serves as the content host.</source>
          <target state="translated">O processamento é tratado por um <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> elemento pai que serve como o host de conteúdo.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure">
          <source>For instance, a change to the value of the <ph id="ph1">&lt;xref:System.Windows.Documents.Paragraph.KeepWithNext%2A?displayProperty=nameWithType&gt;</ph> property by a child element invalidates measure of the parent, because the relative spacing of paragraphs might change and might increase or decrease the content host size.</source>
          <target state="translated">Por exemplo, uma alteração no valor da <ph id="ph1">&lt;xref:System.Windows.Documents.Paragraph.KeepWithNext%2A?displayProperty=nameWithType&gt;</ph> propriedade por um elemento filho invalida a medida do pai, pois o espaçamento relativo dos parágrafos pode alterar e pode aumentar ou diminuir o tamanho do host de conteúdo.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure">
          <source>Therefore, the <ph id="ph1">&lt;xref:System.Windows.Documents.Paragraph.KeepWithNext%2A?displayProperty=nameWithType&gt;</ph> property has metadata where <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A&gt;</ph> is <ph id="ph3">`true`</ph>.</source>
          <target state="translated">Portanto, o <ph id="ph1">&lt;xref:System.Windows.Documents.Paragraph.KeepWithNext%2A?displayProperty=nameWithType&gt;</ph> propriedade tem metadados onde <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A&gt;</ph> é <ph id="ph3">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure">
          <source>Content host elements also frequently look for changes in dependency properties where <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A&gt;</ph> is <ph id="ph2">`true`</ph>, as part of content host rendering logic.</source>
          <target state="translated">Elementos de host de conteúdo também frequentemente procure alterações nas propriedades de dependência onde <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A&gt;</ph> é <ph id="ph2">`true`</ph>, como parte da lógica de processamento do host de conteúdo.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure">
          <source>For instance, the <ph id="ph1">&lt;xref:System.Windows.Controls.TextBox&gt;</ph> element must respond to certain changes within text that might require that the bounding box of the <ph id="ph2">&lt;xref:System.Windows.Controls.TextBox&gt;</ph> itself be changed.</source>
          <target state="translated">Por exemplo, o <ph id="ph1">&lt;xref:System.Windows.Controls.TextBox&gt;</ph> elemento deve responder a determinadas alterações em texto que podem exigir que a caixa delimitadora do <ph id="ph2">&lt;xref:System.Windows.Controls.TextBox&gt;</ph> próprio ser alterado.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure">
          <source>Custom <ph id="ph1">&lt;xref:System.Windows.DependencyObject.OnPropertyChanged%2A&gt;</ph> implementations might choose to have similar behavior for dependency property changes where <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A&gt;</ph> is <ph id="ph3">`true`</ph>.</source>
          <target state="translated">Personalizar <ph id="ph1">&lt;xref:System.Windows.DependencyObject.OnPropertyChanged%2A&gt;</ph> implementações podem optar por ter um comportamento semelhante para as alterações de propriedade de dependência onde <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A&gt;</ph> é <ph id="ph3">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure">
          <source>Properties on any derived classes of <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> are typically defined in the object model as read-write.</source>
          <target state="translated">Propriedades em qualquer classes derivadas de <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> geralmente são definidas no modelo de objeto como leitura-gravação.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure">
          <source>This is so they can be adjusted after initialization of the instance.</source>
          <target state="translated">Isso é possível ajustá-los após a inicialização da instância.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure">
          <source>However, after the metadata is consumed as part of a call to <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>, or <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph>, the property system will seal that metadata instance and properties that convey the specifics of the metadata are now considered immutable.</source>
          <target state="translated">No entanto, depois que os metadados são consumidos como parte de uma chamada para <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>, ou <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph>, o sistema de propriedade será lacrar essa instância de metadados e propriedades que transmitem as especificações de metadados são consideradas imutáveis.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure">
          <source>Attempting to set this property after <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;</ph> is <ph id="ph2">`true`</ph> on this metadata instance will raise an exception.</source>
          <target state="translated">Tentativa de definir esta propriedade após <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;</ph> é <ph id="ph2">`true`</ph> nesses metadados instância gerará uma exceção.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure">
          <source>XAML Text Usage</source>
          <target state="translated">Uso de texto XAML</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure">
          <source>Members of this class are not typically used in <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</source>
          <target state="translated">Membros dessa classe não são normalmente usados no <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure">
          <source>The metadata has already been applied to a dependency property operation, so that metadata is sealed and properties of the metadata cannot be set.</source>
          <target state="translated">Os metadados já foram aplicados à operação de propriedade de dependência, portanto os metadados estão selados e as propriedades dos metadados não podem ser definidas.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsRender">
          <source>Gets or sets a value that indicates whether a dependency property potentially affects the general layout in some way that does not specifically influence arrangement or measurement, but would require a redraw.</source>
          <target state="translated">Obtém ou define um valor que indica se uma propriedade de dependência pode afetar o layout geral de algum modo que não influencie especificamente a organização ou medida, mas que exigiria um redesenho.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsRender">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the dependency property on which this metadata exists affects rendering; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se a propriedade de dependência na qual esses metadados existem afeta a renderização; caso contrário, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsRender">
          <source>The default is <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">O padrão é <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsRender">
          <source><ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> and <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> include an implementation of <ph id="ph3">&lt;xref:System.Windows.FrameworkElement.OnPropertyChanged%2A&gt;</ph> that monitors effective value changes to all dependency properties that exist on an element.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> e <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> inclui uma implementação do <ph id="ph3">&lt;xref:System.Windows.FrameworkElement.OnPropertyChanged%2A&gt;</ph> que monitora as alterações de valor efetivo para todas as propriedades de dependência que existem em um elemento.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsRender">
          <source>As part of that logic, dependency properties that change effective value and have metadata with <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A&gt;</ph> set to <ph id="ph2">`true`</ph> will initiate a deferred request to invalidate the visuals for that element.</source>
          <target state="translated">Como parte dessa lógica, propriedades de dependência que alteram a partir de valor e têm metadados com <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A&gt;</ph> definida como <ph id="ph2">`true`</ph> iniciará uma solicitação adiada para invalidar os visuais para esse elemento.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsRender">
          <source>Because this WPF framework-level implementation is already in place, you typically do not need to look for dependency properties with <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A&gt;</ph> unless you are substantially replacing or modifying the WPF framework-level layout behavior.</source>
          <target state="translated">Como essa implementação de nível de framework WPF já está em vigor, você normalmente não é necessário procurar por propriedades de dependência com <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A&gt;</ph> , a menos que você é substancialmente substituir ou modificar o comportamento de layout de nível de framework do WPF.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsRender">
          <source>Custom <ph id="ph1">&lt;xref:System.Windows.DependencyObject.OnPropertyChanged%2A&gt;</ph> implementations might choose to have similar behavior for dependency property changes where <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A&gt;</ph> is <ph id="ph3">`true`</ph>.</source>
          <target state="translated">Personalizar <ph id="ph1">&lt;xref:System.Windows.DependencyObject.OnPropertyChanged%2A&gt;</ph> implementações podem optar por ter um comportamento semelhante para as alterações de propriedade de dependência onde <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A&gt;</ph> é <ph id="ph3">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsRender">
          <source>Properties on any derived classes of <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> are typically defined in the object model as read-write.</source>
          <target state="translated">Propriedades em qualquer classes derivadas de <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> geralmente são definidas no modelo de objeto como leitura-gravação.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsRender">
          <source>This is so they can be adjusted after initialization of the instance.</source>
          <target state="translated">Isso é possível ajustá-los após a inicialização da instância.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsRender">
          <source>However, after the metadata is consumed as part of a call to <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>, or <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph>, the property system will seal that metadata instance and properties that convey the specifics of the metadata are now considered immutable.</source>
          <target state="translated">No entanto, depois que os metadados são consumidos como parte de uma chamada para <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>, ou <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph>, o sistema de propriedade será lacrar essa instância de metadados e propriedades que transmitem as especificações de metadados são consideradas imutáveis.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsRender">
          <source>Attempting to set this property after <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;</ph> is <ph id="ph2">`true`</ph> on this metadata instance will raise an exception.</source>
          <target state="translated">Tentativa de definir esta propriedade após <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;</ph> é <ph id="ph2">`true`</ph> nesses metadados instância gerará uma exceção.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsRender">
          <source>XAML Text Usage</source>
          <target state="translated">Uso de texto XAML</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsRender">
          <source>Members of this class are not typically used in <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</source>
          <target state="translated">Membros dessa classe não são normalmente usados no <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsRender">
          <source>The following example obtains the default metadata from various dependency property fields, queries the value of various <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph> properties on it, and uses the information to populate a table to implement a "metadata browser".</source>
          <target state="translated">O exemplo a seguir obtém os metadados padrão da dependência de vários campos de propriedade, consulta o valor de vários <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph> propriedades nele e usa as informações para popular uma tabela para implementar um navegador de metadados"".</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsRender">
          <source>The metadata has already been applied to a dependency property operation, so that metadata is sealed and properties of the metadata cannot be set.</source>
          <target state="translated">Os metadados já foram aplicados à operação de propriedade de dependência, portanto os metadados estão selados e as propriedades dos metadados não podem ser definidas.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault">
          <source>Gets or sets a value that indicates whether the property binds two-way by default.</source>
          <target state="translated">Obtém ou define um valor que indica se a propriedade associa de forma bidirecional por padrão.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the dependency property on which this metadata exists binds two-way by default; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se a propriedade de dependência na qual esses metadados existem associa de forma bidirecional por padrão. Caso contrário, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault">
          <source>The default is <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">O padrão é <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault">
          <source>In absence of this property being <ph id="ph1">`true`</ph>, binding updates are one-way by default, based on the default behavior of the <ph id="ph2">&lt;xref:System.Windows.Data.Binding&gt;</ph> constructors or equivalent <ph id="ph3">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> syntax.</source>
          <target state="translated">Na ausência dessa propriedade está sendo <ph id="ph1">`true`</ph>, as atualizações de vinculação são unidirecionais por padrão, com base no comportamento padrão do <ph id="ph2">&lt;xref:System.Windows.Data.Binding&gt;</ph> construtores ou equivalente <ph id="ph3">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> sintaxe.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault">
          <source>In existing elements, you will usually find this property set to <ph id="ph1">`true`</ph> in metadata for dependency properties that both report state and are modifiable by user action, for example <ph id="ph2">&lt;xref:System.Windows.Controls.Primitives.Selector.IsSelected%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Elementos existentes, você encontrará esta propriedade definida como <ph id="ph1">`true`</ph> nos metadados de propriedade de dependência que ambas relatam o estado e são modificáveis por ação do usuário, por exemplo <ph id="ph2">&lt;xref:System.Windows.Controls.Primitives.Selector.IsSelected%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault">
          <source>This property only reports the default binding update characteristics of the dependency property in general.</source>
          <target state="translated">Essa propriedade só reporta as características de atualização de associação padrão da propriedade de dependência em geral.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault">
          <source>Any binding set to this property on an instance can locally set the <ph id="ph1">&lt;xref:System.Windows.Data.Binding.Mode%2A&gt;</ph> property of the binding and change this default.</source>
          <target state="translated">Nenhuma associação de conjunto para essa propriedade em uma instância local pode definir o <ph id="ph1">&lt;xref:System.Windows.Data.Binding.Mode%2A&gt;</ph> propriedade da associação e alterar esse padrão.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault">
          <source>Properties on any derived classes of <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> are typically defined in the object model as read-write.</source>
          <target state="translated">Propriedades em qualquer classes derivadas de <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> geralmente são definidas no modelo de objeto como leitura-gravação.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault">
          <source>This is so they can be adjusted after initialization of the instance.</source>
          <target state="translated">Isso é possível ajustá-los após a inicialização da instância.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault">
          <source>However, after the metadata is consumed as part of a call to <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>, or <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph>, the property system will seal that metadata instance and properties that convey the specifics of the metadata are now considered immutable.</source>
          <target state="translated">No entanto, depois que os metadados são consumidos como parte de uma chamada para <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>, ou <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph>, o sistema de propriedade será lacrar essa instância de metadados e propriedades que transmitem as especificações de metadados são consideradas imutáveis.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault">
          <source>Attempting to set this property after <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;</ph> is <ph id="ph2">`true`</ph> on this metadata instance will raise an exception.</source>
          <target state="translated">Tentativa de definir esta propriedade após <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;</ph> é <ph id="ph2">`true`</ph> nesses metadados instância gerará uma exceção.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault">
          <source>XAML Text Usage</source>
          <target state="translated">Uso de texto XAML</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault">
          <source>Members of this class are not typically used in <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</source>
          <target state="translated">Membros dessa classe não são normalmente usados no <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault">
          <source>The following example obtains the default metadata from various dependency property fields, queries the value of various <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph> properties on it, and uses the information to populate a table to implement a "metadata browser".</source>
          <target state="translated">O exemplo a seguir obtém os metadados padrão da dependência de vários campos de propriedade, consulta o valor de vários <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph> propriedades nele e usa as informações para popular uma tabela para implementar um navegador de metadados"".</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault">
          <source>The metadata has already been applied to a dependency property operation, so that metadata is sealed and properties of the metadata cannot be set.</source>
          <target state="translated">Os metadados já foram aplicados à operação de propriedade de dependência, portanto os metadados estão selados e as propriedades dos metadados não podem ser definidas.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkPropertyMetadata.DefaultUpdateSourceTrigger">
          <source>Gets or sets the default for <ph id="ph1">&lt;see cref="T:System.Windows.Data.UpdateSourceTrigger" /&gt;</ph> to use when bindings for the property with this metadata are applied, which have their <ph id="ph2">&lt;see cref="T:System.Windows.Data.UpdateSourceTrigger" /&gt;</ph> set to <ph id="ph3">&lt;see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" /&gt;</ph>.</source>
          <target state="translated">Obtém ou define o padrão para <ph id="ph1">&lt;see cref="T:System.Windows.Data.UpdateSourceTrigger" /&gt;</ph> a ser usado quando as associações para a propriedade com esses metadados forem aplicadas, que têm seus <ph id="ph2">&lt;see cref="T:System.Windows.Data.UpdateSourceTrigger" /&gt;</ph> definidos como <ph id="ph3">&lt;see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.DefaultUpdateSourceTrigger">
          <source>A value of the enumeration, other than <ph id="ph1">&lt;see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" /&gt;</ph>.</source>
          <target state="translated">Um valor da enumeração, diferente de <ph id="ph1">&lt;see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.DefaultUpdateSourceTrigger">
          <source>Properties on derived classes of <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> are typically defined in the object model as read-write.</source>
          <target state="translated">Propriedades em classes derivadas de <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> geralmente são definidas no modelo de objeto como leitura-gravação.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.DefaultUpdateSourceTrigger">
          <source>This is so they can be adjusted after initialization of the instance.</source>
          <target state="translated">Isso é possível ajustá-los após a inicialização da instância.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.DefaultUpdateSourceTrigger">
          <source>However, after the metadata is consumed as part of a call to <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>, or <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph>, the property system will seal that metadata instance and properties that convey the specifics of the metadata are now considered immutable.</source>
          <target state="translated">No entanto, depois que os metadados são consumidos como parte de uma chamada para <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>, ou <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph>, o sistema de propriedade será lacrar essa instância de metadados e propriedades que transmitem as especificações de metadados são consideradas imutáveis.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.DefaultUpdateSourceTrigger">
          <source>Attempting to set this property after <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;</ph> is <ph id="ph2">`true`</ph> on this metadata instance will raise an exception.</source>
          <target state="translated">Tentativa de definir esta propriedade após <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;</ph> é <ph id="ph2">`true`</ph> nesses metadados instância gerará uma exceção.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.DefaultUpdateSourceTrigger">
          <source>XAML Text Usage</source>
          <target state="translated">Uso de texto XAML</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.DefaultUpdateSourceTrigger">
          <source>Members of this class are not typically used in <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</source>
          <target state="translated">Membros dessa classe não são normalmente usados no <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkPropertyMetadata.DefaultUpdateSourceTrigger">
          <source>This property is set to <ph id="ph1">&lt;see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" /&gt;</ph>; the value you set is supposed to become the default when requested by bindings.</source>
          <target state="translated">Essa propriedade está definida como <ph id="ph1">&lt;see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" /&gt;</ph>; o valor definido deve se tornar o padrão quando solicitado por associações.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkPropertyMetadata.DefaultUpdateSourceTrigger">
          <source>The metadata has already been applied to a dependency property operation, so that metadata is sealed and properties of the metadata cannot be set.</source>
          <target state="translated">Os metadados já foram aplicados à operação de propriedade de dependência, portanto os metadados estão selados e as propriedades dos metadados não podem ser definidas.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkPropertyMetadata.Inherits">
          <source>Gets or sets a value that indicates whether the value of the dependency property is inheritable.</source>
          <target state="translated">Obtém ou define um valor que indica se o valor da propriedade de dependência é herdável.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.Inherits">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the property value is inheritable; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se o valor da propriedade for herdável, caso contrário, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.Inherits">
          <source>The default is <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">O padrão é <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.Inherits">
          <source>Property value inheritance is a feature of the <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> property system at the WPF framework level, whereby certain dependency properties can be locally set on an element at or near the root of a <ph id="ph2">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> element tree and then have their value inherited by all elements within the logical tree of child elements that also possess that property.</source>
          <target state="translated">Herança de valor de propriedade é um recurso do <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> sistema de propriedade no nível de framework do WPF, na qual determinadas propriedades de dependência podem ser definidas localmente em um elemento ou próximo a raiz de um <ph id="ph2">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> elemento árvore e, em seguida, tem seu valor herdado por todos os elementos dentro da árvore lógica de elementos filho que também possuem essa propriedade.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.Inherits">
          <source>Property value inheritance is not enabled by default, and enabling it does have some performance implications.</source>
          <target state="translated">Herança de valor de propriedade não está habilitada por padrão, e permitindo que ele tem algumas implicações de desempenho.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.Inherits">
          <source>For details, see <bpt id="p1">[</bpt>Property Value Inheritance<ept id="p1">](~/docs/framework/wpf/advanced/property-value-inheritance.md)</ept>.</source>
          <target state="translated">Para obter detalhes, consulte <bpt id="p1">[</bpt>Herança do valor da propriedade<ept id="p1">](~/docs/framework/wpf/advanced/property-value-inheritance.md)</ept>.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.Inherits">
          <source>Although property value inheritance might appear to work for nonattached dependency properties, the inheritance behavior for a nonattached property through certain object-object divisions in the runtime tree is undefined.</source>
          <target state="translated">Embora a herança de valor de propriedade pode parecer funcionar para as propriedades de dependência, o comportamento de herança de uma propriedade não anexada por certos divisões de objeto do objeto na árvore de tempo de execução é indefinido.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.Inherits">
          <source>Always use <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> to register properties where you specify <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A&gt;</ph> in the metadata.</source>
          <target state="translated">Sempre use <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> para registrar as propriedades em que você especificar <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A&gt;</ph> nos metadados.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.Inherits">
          <source>Properties on derived classes of <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> are typically defined in the object model as read-write.</source>
          <target state="translated">Propriedades em classes derivadas de <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> geralmente são definidas no modelo de objeto como leitura-gravação.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.Inherits">
          <source>This is so they can be adjusted after initialization of the instance.</source>
          <target state="translated">Isso é possível ajustá-los após a inicialização da instância.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.Inherits">
          <source>However, after the metadata is consumed as part of a call to <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>, or <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph>, the property system will seal that metadata instance and properties that convey the specifics of the metadata are now considered immutable.</source>
          <target state="translated">No entanto, depois que os metadados são consumidos como parte de uma chamada para <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>, ou <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph>, o sistema de propriedade será lacrar essa instância de metadados e propriedades que transmitem as especificações de metadados são consideradas imutáveis.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.Inherits">
          <source>Attempting to set this property after <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;</ph> is <ph id="ph2">`true`</ph> on this metadata instance will raise an exception.</source>
          <target state="translated">Tentativa de definir esta propriedade após <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;</ph> é <ph id="ph2">`true`</ph> nesses metadados instância gerará uma exceção.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.Inherits">
          <source>XAML Text Usage</source>
          <target state="translated">Uso de texto XAML</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.Inherits">
          <source>Members of this class are not typically used in <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</source>
          <target state="translated">Membros dessa classe não são normalmente usados no <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.Inherits">
          <source>The following example obtains the default metadata from various dependency property fields, queries the value of various <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph> properties on it, and uses the information to populate a table to implement a "metadata browser".</source>
          <target state="translated">O exemplo a seguir obtém os metadados padrão da dependência de vários campos de propriedade, consulta o valor de vários <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph> propriedades nele e usa as informações para popular uma tabela para implementar um navegador de metadados"".</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkPropertyMetadata.Inherits">
          <source>The metadata has already been applied to a dependency property operation, so that metadata is sealed and properties of the metadata cannot be set.</source>
          <target state="translated">Os metadados já foram aplicados à operação de propriedade de dependência, portanto os metadados estão selados e as propriedades dos metadados não podem ser definidas.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed">
          <source>Gets a value that indicates whether data binding is supported for the dependency property.</source>
          <target state="translated">Obtém um valor que indica se a associação de dados é compatível com a propriedade de dependência.</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if data binding is supported on the dependency property to which this metadata applies; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> Se a associação de dados é suportada na propriedade de dependência ao qual se aplica a esses metadados; Caso contrário, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed">
          <source>The default is <ph id="ph1">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">O padrão é <ph id="ph1">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed">
          <source>This property reports <ph id="ph1">`false`</ph> for one of two possible conditions: either data binding to a dependency property is not allowed because the dependency property is read-only (as reported in the dependency property identifier, not the metadata), or the value of another metadata property, <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A&gt;</ph>, is set to <ph id="ph3">`true`</ph> in this metadata.</source>
          <target state="translated">Essa propriedade reporta <ph id="ph1">`false`</ph> para uma das duas condições possíveis: a associação de dados para uma propriedade de dependência não é permitida porque a propriedade de dependência é somente leitura (como relatado no identificador de propriedade de dependência, não os metadados), ou o valor de outra propriedade de metadados, <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A&gt;</ph>, é definido como <ph id="ph3">`true`</ph> em metadados.</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed">
          <source>This property is exposed as a convenience so that callers do not have to check both <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.ReadOnly%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A&gt;</ph>.</source>
          <target state="translated">Essa propriedade é exposta como uma conveniência para que os chamadores não precisa verificar ambos <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.ReadOnly%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed">
          <source>If you are attempting to create metadata that specifies that an otherwise read/write property should not support data binding, specify the flag <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadataOptions.NotDataBindable&gt;</ph> (note the slight naming convention difference versus <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A&gt;</ph>).</source>
          <target state="translated">Se você estiver tentando criar os metadados que especifica que uma propriedade de leitura/gravação deve não oferecem suporte à associação de dados, especifique o sinalizador <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadataOptions.NotDataBindable&gt;</ph> (Observe a diferença de convenção de nomenclatura pequena versus <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed">
          <source>XAML Text Usage</source>
          <target state="translated">Uso de texto XAML</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed">
          <source>Members of this class are not typically used in <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</source>
          <target state="translated">Membros dessa classe não são normalmente usados no <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed">
          <source>The following example obtains the default metadata from various dependency property fields, queries the value of various <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph> properties on it, and uses the information to populate a table to implement a "metadata browser".</source>
          <target state="translated">O exemplo a seguir obtém os metadados padrão da dependência de vários campos de propriedade, consulta o valor de vários <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph> propriedades nele e usa as informações para popular uma tabela para implementar um navegador de metadados"".</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable">
          <source>Gets or sets a value that indicates whether the dependency property supports data binding.</source>
          <target state="translated">Obtém ou define um valor que indica se o valor da propriedade de dependência é compatível com a associação de dados.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the property does not support data binding; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> Se a propriedade não dá suporte à associação de dados; Caso contrário, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable">
          <source>The default is <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">O padrão é <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable">
          <source>Note that this metadata property is set to <ph id="ph1">`true`</ph> specifically for properties that should not support data binding, despite being read-write properties.</source>
          <target state="translated">Observe que essa propriedade de metadados é definida como <ph id="ph1">`true`</ph> especificamente para propriedades que não devem dar suporte a associação de dados, apesar de ser propriedades de leitura-gravação.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable">
          <source>The expectation is that in most cases where a dependency property is declared, data binding is desired, because data binding is one of the key scenarios where a dependency property is useful.</source>
          <target state="translated">A expectativa é que na maioria dos casos em que uma propriedade de dependência é declarada, associação de dados é desejada, como associação de dados é um dos principais cenários em que uma propriedade de dependência é útil.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable">
          <source>Unlike <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault%2A&gt;</ph>, this does not merely change a default that can later be changed on a specific binding.</source>
          <target state="translated">Ao contrário de <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault%2A&gt;</ph>, isso não altera simplesmente um padrão que pode ser alterado posteriormente em uma associação específica.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable">
          <source>Setting this property <ph id="ph1">`true`</ph> in the metadata for a dependency property metadata will disable all bindings from applying their values through expressions to that dependency property.</source>
          <target state="translated">A definição dessa propriedade <ph id="ph1">`true`</ph> nos metadados para uma propriedade de dependência metadados desabilitará todas as associações da aplicação de seus valores por meio de expressões de propriedade de dependência.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable">
          <source>Read-only dependency properties do not support data binding (because they have no setter that can apply changed values), but will still report <ph id="ph1">`false`</ph> for <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A&gt;</ph>.</source>
          <target state="translated">Propriedades de dependência somente leitura não dão suporte à associação de dados (porque eles têm nenhum setter que pode aplicar valores alterados), mas ainda será relatório <ph id="ph1">`false`</ph> para <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable">
          <source>This is because properties that correspond to a <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadataOptions&gt;</ph> values will report parity with how the metadata was actually established, rather than always reporting the end result behavior that the naming of the property might imply.</source>
          <target state="translated">Isso ocorre porque as propriedades que correspondem a um <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadataOptions&gt;</ph> valores relatará paridade com como os metadados foi realmente estabelecido, em vez de relatórios sempre o comportamento do resultado final implicar o nome da propriedade.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable">
          <source>To determine whether a given dependency property permits data binding, you should usually check <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed%2A&gt;</ph> instead.</source>
          <target state="translated">Para determinar se uma propriedade de dependência permite associação de dados, você normalmente deve verificar <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed%2A&gt;</ph> em vez disso.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable">
          <source><ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed%2A&gt;</ph> is a convenience for checking both <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.ReadOnly%2A&gt;</ph> and <ph id="ph3">&lt;xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A&gt;</ph> as a single operation, yielding the expected result.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed%2A&gt;</ph> é uma conveniência para a verificação de ambos <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.ReadOnly%2A&gt;</ph> e <ph id="ph3">&lt;xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A&gt;</ph> como uma única operação, produzindo o resultado esperado.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable">
          <source>Properties on derived classes of <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> are typically defined in the object model as read-write.</source>
          <target state="translated">Propriedades em classes derivadas de <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> geralmente são definidas no modelo de objeto como leitura-gravação.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable">
          <source>This is so they can be adjusted after initialization of the instance.</source>
          <target state="translated">Isso é possível ajustá-los após a inicialização da instância.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable">
          <source>However, after the metadata is consumed as part of a call to <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>, or <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph>, the property system will seal that metadata instance and properties that convey the specifics of the metadata are now considered immutable.</source>
          <target state="translated">No entanto, depois que os metadados são consumidos como parte de uma chamada para <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>, ou <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph>, o sistema de propriedade será lacrar essa instância de metadados e propriedades que transmitem as especificações de metadados são consideradas imutáveis.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable">
          <source>Attempting to set this property after <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;</ph> is <ph id="ph2">`true`</ph> on this metadata instance will raise an exception.</source>
          <target state="translated">Tentativa de definir esta propriedade após <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;</ph> é <ph id="ph2">`true`</ph> nesses metadados instância gerará uma exceção.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable">
          <source>XAML Text Usage</source>
          <target state="translated">Uso de texto XAML</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable">
          <source>Members of this class are not typically used in <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</source>
          <target state="translated">Membros dessa classe não são normalmente usados no <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable">
          <source>The metadata has already been applied to a dependency property operation, so that metadata is sealed and properties of the metadata cannot be set.</source>
          <target state="translated">Os metadados já foram aplicados à operação de propriedade de dependência, portanto os metadados estão selados e as propriedades dos metadados não podem ser definidas.</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkPropertyMetadata.Journal">
          <source>Gets or sets a value that indicates whether this property contains journaling information that applications can or should store as part of a journaling implementation.</source>
          <target state="translated">Obtém ou define um valor que indica se esta propriedade contém informações de registro no diário que aplicativos podem ou devem armazenar como parte de uma implementação do registro no diário.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.Journal">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if journaling should be performed on the dependency property that this metadata is applied to; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> Se o diário deve ser executado na propriedade de dependência que esses metadados é aplicado a; Caso contrário, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.Journal">
          <source>The default is <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">O padrão é <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.Journal">
          <source>Properties on derived classes of <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> are typically defined in the object model as read-write.</source>
          <target state="translated">Propriedades em classes derivadas de <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> geralmente são definidas no modelo de objeto como leitura-gravação.</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.Journal">
          <source>This is so they can be adjusted after initialization of the instance.</source>
          <target state="translated">Isso é possível ajustá-los após a inicialização da instância.</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.Journal">
          <source>However, after the metadata is consumed as part of a call to <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>, or <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph>, the property system will seal that metadata instance and properties that convey the specifics of the metadata are now considered immutable.</source>
          <target state="translated">No entanto, depois que os metadados são consumidos como parte de uma chamada para <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>, ou <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph>, o sistema de propriedade será lacrar essa instância de metadados e propriedades que transmitem as especificações de metadados são consideradas imutáveis.</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.Journal">
          <source>Attempting to set this property after <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;</ph> is <ph id="ph2">`true`</ph> on this metadata instance will raise an exception.</source>
          <target state="translated">Tentativa de definir esta propriedade após <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;</ph> é <ph id="ph2">`true`</ph> nesses metadados instância gerará uma exceção.</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.Journal">
          <source>XAML Text Usage</source>
          <target state="translated">Uso de texto XAML</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.Journal">
          <source>Members of this class are not typically used in <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</source>
          <target state="translated">Membros dessa classe não são normalmente usados no <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkPropertyMetadata.Journal">
          <source>The metadata has already been applied to a dependency property operation, so that metadata is sealed and properties of the metadata cannot be set.</source>
          <target state="translated">Os metadados já foram aplicados à operação de propriedade de dependência, portanto os metadados estão selados e as propriedades dos metadados não podem ser definidas.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)">
          <source>The base metadata to merge.</source>
          <target state="translated">Os metadados de base a serem mesclados.</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)">
          <source>The dependency property this metadata is being applied to.</source>
          <target state="translated">A propriedade de dependência à qual esses metadados estão sendo aplicados.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)">
          <source>Enables a merge of the source metadata with base metadata.</source>
          <target state="translated">Permite a mesclagem dos metadados de origem com metadados de base.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)">
          <source>This method is used internally when metadata is being overridden.</source>
          <target state="translated">Esse método é usado internamente quando metadados estão sendo substituído.</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)">
          <source>Classes that derive from <ph id="ph1">&lt;see cref="T:System.Windows.PropertyMetadata" /&gt;</ph> (or this class particularly) should override this method to account for any metadata properties they have added in their implementations.</source>
          <target state="translated">Classes que derivam de <ph id="ph1">&lt;see cref="T:System.Windows.PropertyMetadata" /&gt;</ph> (ou esta classe particularmente) devem substituir este método para quaisquer propriedades de metadados que tem adicionado em suas implementações.</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)">
          <source>For instance, your implementation might have added a new flagwise enumeration value, and the <ph id="ph1">&lt;see cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" /&gt;</ph> implementation should then be able to combine those flags correctly.</source>
          <target state="translated">Por exemplo, sua implementação pode ter adicionado um novo valor de enumeração sinalizadora e o <ph id="ph1">&lt;see cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" /&gt;</ph> implementação poderá combinar esses sinalizadores corretamente.</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)">
          <source>Always call the base implementation prior to your own implementation, because the base implementation takes care of merging all the properties already defined on previous types in the hierarchy.</source>
          <target state="translated">Sempre chame a implementação base antes de sua própria implementação, porque a implementação base cuida da mesclagem de todas as propriedades já definidas em tipos anteriores da hierarquia.</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)">
          <source>The behavior added by the <ph id="ph1">&lt;see cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" /&gt;</ph> implementation in <ph id="ph2">&lt;see cref="T:System.Windows.FrameworkPropertyMetadata" /&gt;</ph> is that specific WPF framework-level properties in the metadata such as <ph id="ph3">&lt;see cref="P:System.Windows.FrameworkPropertyMetadata.AffectsRender" /&gt;</ph> are combined in a bitwise or operation.</source>
          <target state="translated">O comportamento adicionado pelo <ph id="ph1">&lt;see cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" /&gt;</ph> implementação em <ph id="ph2">&lt;see cref="T:System.Windows.FrameworkPropertyMetadata" /&gt;</ph> é que propriedades específicas de nível de framework WPF nos metadados, como <ph id="ph3">&lt;see cref="P:System.Windows.FrameworkPropertyMetadata.AffectsRender" /&gt;</ph> são combinados em um bit a bit ou operação.</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)">
          <source>The <ph id="ph1">&lt;see cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" /&gt;</ph> behavior also implements the behavior when you override the property metadata on an existing dependency property by calling <ph id="ph2">&lt;see cref="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)" /&gt;</ph>., using override metadata that is <ph id="ph3">&lt;see cref="T:System.Windows.FrameworkPropertyMetadata" /&gt;</ph>.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" /&gt;</ph> comportamento também implementa o comportamento quando você substituir os metadados de propriedade em uma propriedade de dependência existente chamando <ph id="ph2">&lt;see cref="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)" /&gt;</ph>., usando metadados de substituição é <ph id="ph3">&lt;see cref="T:System.Windows.FrameworkPropertyMetadata" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)">
          <source>The dependency property to which the metadata has been applied.</source>
          <target state="translated">A propriedade de dependência à qual os metadados foram aplicados.</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)">
          <source>The type associated with this metadata if this is type-specific metadata.</source>
          <target state="translated">O tipo associado a esses metadados se eles forem metadados específicos do tipo.</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)">
          <source>If this is default metadata, this value can be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Se eles são metadados padrão, esse valor pode ser <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)">
          <source>Called when this metadata has been applied to a property, which indicates that the metadata is being sealed.</source>
          <target state="translated">Chamado quando esses metadados foram aplicados a uma propriedade, o que indica que os metadados estão sendo selados.</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)">
          <source>Any mutability of the data structure of a <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph> instance should be marked as immutable when this method is invoked.</source>
          <target state="translated">Qualquer Mutabilidade da estrutura de dados de um <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph> instância deve ser marcada como imutável quando esse método é chamado.</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadata" /&gt;</ph> implementation of this method does nothing beyond calling the base implementation.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadata" /&gt;</ph> implementação deste método não faz nada além de chamar a implementação base.</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior">
          <source>Gets or sets a value that indicates whether the property value inheritance evaluation should span across certain content boundaries in the logical tree of elements.</source>
          <target state="translated">Obtém ou define um valor que indica se a avaliação de herança de valor da propriedade deve abranger além de certos limites conteúdo na árvore lógica de elementos.</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the property value inheritance should span across certain content boundaries; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> Se a herança de valor de propriedade deve abranger em determinados limites de conteúdo; Caso contrário, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior">
          <source>The default is <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">O padrão é <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior">
          <source>This metadata reports a seldom-applied modification to property value inheritance behavior across special parent element-child element boundaries.</source>
          <target state="translated">Esses metadados informa uma modificação raramente aplicado ao comportamento de herança de valor de propriedade nos limites do elemento filho do elemento pai especial.</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior">
          <source>The canonical example of such a boundary is the contents of a <ph id="ph1">&lt;xref:System.Windows.Controls.Frame&gt;</ph>, where the <ph id="ph2">&lt;xref:System.Windows.Controls.Frame&gt;</ph> content might get reloaded independently of the existence of the <ph id="ph3">&lt;xref:System.Windows.Controls.Frame&gt;</ph>.</source>
          <target state="translated">O exemplo canônico de tal um limite é o conteúdo de um <ph id="ph1">&lt;xref:System.Windows.Controls.Frame&gt;</ph>, onde o <ph id="ph2">&lt;xref:System.Windows.Controls.Frame&gt;</ph> conteúdo pode obter recarregado independentemente da existência da <ph id="ph3">&lt;xref:System.Windows.Controls.Frame&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior">
          <source>The desired property system behavior is that property value inheritance should not traverse into the contents of the <ph id="ph1">&lt;xref:System.Windows.Controls.Frame&gt;</ph>, because these contents might be elements that the application hosting the frame does not own or control.</source>
          <target state="translated">O comportamento do sistema de propriedade desejada é que herança de valor de propriedade não deve percorrer o conteúdo do <ph id="ph1">&lt;xref:System.Windows.Controls.Frame&gt;</ph>, pois esses conteúdos podem ser elementos que o aplicativo que hospeda o quadro não possui ou controla.</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior">
          <source>Specifying metadata with <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior%2A&gt;</ph> set to <ph id="ph2">`true`</ph>, as well as specifying <ph id="ph3">&lt;xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A&gt;</ph> as <ph id="ph4">`true`</ph>, will cause the property on which the metadata is applied to be inheritable even across the <ph id="ph5">&lt;xref:System.Windows.Controls.Frame&gt;</ph> boundary or similar boundaries.</source>
          <target state="translated">Especificar metadados com <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior%2A&gt;</ph> definida como <ph id="ph2">`true`</ph>, bem como especificando <ph id="ph3">&lt;xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A&gt;</ph> como <ph id="ph4">`true`</ph>, fará com que a propriedade na qual os metadados é aplicado para ser herdável mesmo no <ph id="ph5">&lt;xref:System.Windows.Controls.Frame&gt;</ph> limite ou limites semelhantes.</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior">
          <source>Properties on derived classes of <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> are typically defined in the object model as read-write.</source>
          <target state="translated">Propriedades em classes derivadas de <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> geralmente são definidas no modelo de objeto como leitura-gravação.</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior">
          <source>This is so they can be adjusted after initialization of the instance.</source>
          <target state="translated">Isso é possível ajustá-los após a inicialização da instância.</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior">
          <source>However, after the metadata is consumed as part of a call to <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>, or <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph>, the property system will seal that metadata instance and properties that convey the specifics of the metadata are now considered immutable.</source>
          <target state="translated">No entanto, depois que os metadados são consumidos como parte de uma chamada para <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>, ou <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph>, o sistema de propriedade será lacrar essa instância de metadados e propriedades que transmitem as especificações de metadados são consideradas imutáveis.</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior">
          <source>Attempting to set this property after <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;</ph> is <ph id="ph2">`true`</ph> on this metadata instance will raise an exception.</source>
          <target state="translated">Tentativa de definir esta propriedade após <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;</ph> é <ph id="ph2">`true`</ph> nesses metadados instância gerará uma exceção.</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior">
          <source>XAML Text Usage</source>
          <target state="translated">Uso de texto XAML</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior">
          <source>Members of this class are not typically used in <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</source>
          <target state="translated">Membros dessa classe não são normalmente usados no <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior">
          <source>The metadata has already been applied to a dependency property operation, so that metadata is sealed and properties of the metadata cannot be set.</source>
          <target state="translated">Os metadados já foram aplicados à operação de propriedade de dependência, portanto os metadados estão selados e as propriedades dos metadados não podem ser definidas.</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender">
          <source>Gets or sets a value that indicates whether sub-properties of the dependency property do not affect the rendering of the containing object.</source>
          <target state="translated">Obtém ou define um valor que indica se as subpropriedades da propriedade de dependência não afetam a renderização do objeto contentor.</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if changes to sub-property values do not affect rendering if changed; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> Se as alterações nos valores de propriedade sub não afetam a renderização se alterada; Caso contrário, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender">
          <source>The default is <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">O padrão é <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender">
          <source>This metadata option is pertinent for dependency properties that are reference types, where that type has property values of its own.</source>
          <target state="translated">Essa opção de metadados é pertinente para propriedades de dependência que são tipos de referência, em que esse tipo tem valores de propriedade de seu próprio.</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender">
          <source>Typically, the layout system logic is to assume that any dependency property with sub-properties potentially will affect layout, because checking all sub-properties for changes is more time consuming than actually running another render pass.</source>
          <target state="translated">Normalmente, a lógica do sistema de layout é supõem que qualquer propriedade de dependência com subpropriedades potencialmente afetará layout, porque a verificação de todas as subpropriedades de alterações é mais demorado do que realmente em execução outro renderizar passagem.</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender">
          <source>Setting this option to <ph id="ph1">`true`</ph> is useful for optimizing performance of the WPF framework level layout system implementation.</source>
          <target state="translated">Definir essa opção como <ph id="ph1">`true`</ph> é útil para otimizar o desempenho da implementação de sistema de layout de nível de framework WPF.</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender">
          <source>Properties on derived classes of <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> are typically defined in the object model as read-write.</source>
          <target state="translated">Propriedades em classes derivadas de <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> geralmente são definidas no modelo de objeto como leitura-gravação.</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender">
          <source>This is so they can be adjusted after initialization of the instance.</source>
          <target state="translated">Isso é possível ajustá-los após a inicialização da instância.</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender">
          <source>However, once the metadata is consumed as part of a call to <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>, or <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph>, the property system will seal that metadata instance and properties that convey the specifics of the metadata are now considered immutable.</source>
          <target state="translated">No entanto, quando os metadados são consumidos como parte de uma chamada para <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>, ou <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph>, o sistema de propriedade será lacrar essa instância de metadados e propriedades que transmitem as especificações de metadados são consideradas imutáveis.</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender">
          <source>Attempting to set this property after <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;</ph> is <ph id="ph2">`true`</ph> on this metadata instance will raise an exception.</source>
          <target state="translated">Tentativa de definir esta propriedade após <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;</ph> é <ph id="ph2">`true`</ph> nesses metadados instância gerará uma exceção.</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender">
          <source>XAML Text Usage</source>
          <target state="translated">Uso de texto XAML</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender">
          <source>Members of this class are not typically used in <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</source>
          <target state="translated">Membros dessa classe não são normalmente usados no <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender">
          <source>The metadata has already been applied to a dependency property operation, so that metadata is sealed and properties of the metadata cannot be set.</source>
          <target state="translated">Os metadados já foram aplicados à operação de propriedade de dependência, portanto os metadados estão selados e as propriedades dos metadados não podem ser definidas.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>