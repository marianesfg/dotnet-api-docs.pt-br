<Type Name="FrameworkPropertyMetadata" FullName="System.Windows.FrameworkPropertyMetadata">
  <Metadata><Meta Name="ms.openlocfilehash" Value="b1e91c552a9f1092824655c7f0620903bf1542f2" /><Meta Name="ms.sourcegitcommit" Value="42a3c35677e9d87eeb503607ae50c9d39827d414" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pt-BR" /><Meta Name="ms.lasthandoff" Value="12/17/2018" /><Meta Name="ms.locfileid" Value="53474418" /></Metadata><TypeSignature Language="C#" Value="public class FrameworkPropertyMetadata : System.Windows.UIPropertyMetadata" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit FrameworkPropertyMetadata extends System.Windows.UIPropertyMetadata" />
  <TypeSignature Language="DocId" Value="T:System.Windows.FrameworkPropertyMetadata" />
  <TypeSignature Language="VB.NET" Value="Public Class FrameworkPropertyMetadata&#xA;Inherits UIPropertyMetadata" />
  <TypeSignature Language="C++ CLI" Value="public ref class FrameworkPropertyMetadata : System::Windows::UIPropertyMetadata" />
  <TypeSignature Language="F#" Value="type FrameworkPropertyMetadata = class&#xA;    inherit UIPropertyMetadata" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.UIPropertyMetadata</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary><span data-ttu-id="9b023-101">Relata ou aplica metadados para uma propriedade de dependência, especificamente adicionando características específicas de estrutura do sistema de propriedade.</span><span class="sxs-lookup"><span data-stu-id="9b023-101">Reports or applies metadata for a dependency property, specifically adding framework-specific property system characteristics.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9b023-102">Essa classe deriva <xref:System.Windows.PropertyMetadata> (por meio de <xref:System.Windows.UIPropertyMetadata>).</span><span class="sxs-lookup"><span data-stu-id="9b023-102">This class derives from <xref:System.Windows.PropertyMetadata> (through <xref:System.Windows.UIPropertyMetadata>) .</span></span> <span data-ttu-id="9b023-103">Para a maioria dos fins de desenvolvimento de aplicativos de nível de framework WPF, <xref:System.Windows.FrameworkPropertyMetadata> é o tipo usado para metadados de propriedade de dependência, em vez dos tipos de metadados de base <xref:System.Windows.PropertyMetadata> ou <xref:System.Windows.UIPropertyMetadata>.</span><span class="sxs-lookup"><span data-stu-id="9b023-103">For most WPF framework-level application development purposes, <xref:System.Windows.FrameworkPropertyMetadata> is the type used for dependency property metadata, rather than the base metadata types <xref:System.Windows.PropertyMetadata> or <xref:System.Windows.UIPropertyMetadata>.</span></span> <span data-ttu-id="9b023-104">Isso é verdadeiro para propriedades de dependência existentes e para a maioria dos cenários de propriedade de dependência personalizada.</span><span class="sxs-lookup"><span data-stu-id="9b023-104">This is true both for existing dependency properties and for most custom dependency property scenarios.</span></span>  
  
 <span data-ttu-id="9b023-105">Os membros declarados por esta classe esse suplemento a <xref:System.Windows.PropertyMetadata> classe base incluem várias propriedades Boolianas que especificam ou comportamento do sistema de propriedade de nível de framework WPF, como herança de propriedade, a associação de dados e layout de relatório.</span><span class="sxs-lookup"><span data-stu-id="9b023-105">The members declared by this class that supplement the <xref:System.Windows.PropertyMetadata> base class include various Boolean properties that specify or report WPF framework-level property system behavior such as property inheritance, data binding, and layout.</span></span>  
  
 <span data-ttu-id="9b023-106">Várias assinaturas de construtor para a criação de um <xref:System.Windows.FrameworkPropertyMetadata> instância take um <xref:System.Windows.FrameworkPropertyMetadataOptions> parâmetro.</span><span class="sxs-lookup"><span data-stu-id="9b023-106">Several constructor signatures for creating a <xref:System.Windows.FrameworkPropertyMetadata> instance take a <xref:System.Windows.FrameworkPropertyMetadataOptions> parameter.</span></span> <span data-ttu-id="9b023-107">O <xref:System.Windows.FrameworkPropertyMetadataOptions> enumeração é usada apenas para especificar o comportamento inicial no construtor e caso contrário, não será exposta após <xref:System.Windows.FrameworkPropertyMetadata> é construído.</span><span class="sxs-lookup"><span data-stu-id="9b023-107">The <xref:System.Windows.FrameworkPropertyMetadataOptions> enumeration is used only to specify initial behavior in the constructor, and is not otherwise exposed after <xref:System.Windows.FrameworkPropertyMetadata> is constructed.</span></span> <span data-ttu-id="9b023-108">De uma instância construída, você pode obter ou definir as informações correspondentes por meio de várias propriedades que compartilham o nome dos valores de enumeração usado na chamada do construtor.</span><span class="sxs-lookup"><span data-stu-id="9b023-108">From a constructed instance, you can get or set the corresponding information through various properties that share the name of the enumeration values used in the constructor call.</span></span>  
  
<a name="xamlTextUsage_FrameworkPropertyMetadata"></a>   
## <a name="xaml-text-usage"></a><span data-ttu-id="9b023-109">Uso de texto XAML</span><span class="sxs-lookup"><span data-stu-id="9b023-109">XAML Text Usage</span></span>  
 <span data-ttu-id="9b023-110">Essa classe não é normalmente usada em [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span><span class="sxs-lookup"><span data-stu-id="9b023-110">This class is not typically used in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9b023-111">O exemplo a seguir obtém metadados para uma propriedade de dependência em um proprietário específico como inicial base <xref:System.Windows.PropertyMetadata> tipo.</span><span class="sxs-lookup"><span data-stu-id="9b023-111">The following example gets metadata for a dependency property on a particular owner as the initial base <xref:System.Windows.PropertyMetadata> type.</span></span> <span data-ttu-id="9b023-112">Esses metadados são convertidos em <xref:System.Windows.FrameworkPropertyMetadata>.</span><span class="sxs-lookup"><span data-stu-id="9b023-112">That metadata is cast to <xref:System.Windows.FrameworkPropertyMetadata>.</span></span> <span data-ttu-id="9b023-113">Se a conversão retornou válida <xref:System.Windows.FrameworkPropertyMetadata>, em seguida, vários <xref:System.Windows.FrameworkPropertyMetadata> valores de propriedade são relatados por meio de uma simple interface do usuário (não mostrado).</span><span class="sxs-lookup"><span data-stu-id="9b023-113">If the cast returned a valid <xref:System.Windows.FrameworkPropertyMetadata>, then various <xref:System.Windows.FrameworkPropertyMetadata> property values are reported through a simple UI (not shown).</span></span>  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.PropertyMetadata" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="9b023-114">Inicializa uma nova instância da classe <see cref="T:System.Windows.FrameworkPropertyMetadata" />.</span><span class="sxs-lookup"><span data-stu-id="9b023-114">Initializes a new instance of the <see cref="T:System.Windows.FrameworkPropertyMetadata" /> class.</span></span></summary>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="9b023-115">Inicializa uma nova instância da classe <see cref="T:System.Windows.FrameworkPropertyMetadata" />.</span><span class="sxs-lookup"><span data-stu-id="9b023-115">Initializes a new instance of the <see cref="T:System.Windows.FrameworkPropertyMetadata" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9b023-116">Essa assinatura inicializa todos os valores de <xref:System.Windows.FrameworkPropertyMetadata.%23ctor%2A> aos seus padrões de propriedade.</span><span class="sxs-lookup"><span data-stu-id="9b023-116">This signature initializes all values of <xref:System.Windows.FrameworkPropertyMetadata.%23ctor%2A> to their property defaults.</span></span> <span data-ttu-id="9b023-117"><xref:System.Windows.PropertyMetadata.DefaultValue%2A> estará `null`e os vários <xref:System.Windows.FrameworkPropertyMetadata> propriedades Boolianas serão `false`.</span><span class="sxs-lookup"><span data-stu-id="9b023-117"><xref:System.Windows.PropertyMetadata.DefaultValue%2A> will be `null`, and the various <xref:System.Windows.FrameworkPropertyMetadata> Boolean properties will be `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (defaultValue As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata defaultValue" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="defaultValue"><span data-ttu-id="9b023-118">O valor padrão da propriedade de dependência, geralmente, fornecido como um valor de um tipo específico.</span><span class="sxs-lookup"><span data-stu-id="9b023-118">The default value of the dependency property, usually provided as a value of a specific type.</span></span></param>
        <summary><span data-ttu-id="9b023-119">Inicializa uma nova instância da classe <see cref="T:System.Windows.FrameworkPropertyMetadata" /> com o valor padrão especificado.</span><span class="sxs-lookup"><span data-stu-id="9b023-119">Initializes a new instance of the <see cref="T:System.Windows.FrameworkPropertyMetadata" /> class with the specified default value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9b023-120">O tipo do valor fornecido para `defaultValue` deve corresponder ou ser relacionadas para o tipo especificado no registro original da propriedade de dependência que serão aplicados a esses metadados.</span><span class="sxs-lookup"><span data-stu-id="9b023-120">The type of the value provided for `defaultValue` must match or be related to the type specified in the original registration of the dependency property that this metadata will be applied to.</span></span> <span data-ttu-id="9b023-121">Incompatibilidades entre o tipo de valor padrão de metadados e o tipo da propriedade de dependência que ele está sendo aplicado podem ser difícil de depurar, porque a incompatibilidade não podem ser detectada durante a compilação.</span><span class="sxs-lookup"><span data-stu-id="9b023-121">Mismatches between metadata default value type and the type of the dependency property it is being applied to can be difficult to debug, because the mismatch is not detectable during compilation.</span></span> <span data-ttu-id="9b023-122">O sistema de propriedades não avalia o valor efetivo de uma propriedade até o tempo de execução, portanto, o resultado de uma incompatibilidade de tipo de propriedade/tipo de valor padrão é um erro de tempo de execução.</span><span class="sxs-lookup"><span data-stu-id="9b023-122">The property system does not evaluate the effective value of a property until run time, so the result of a default value type/property type mismatch is a run-time error.</span></span>  
  
 <span data-ttu-id="9b023-123">O valor <xref:System.Windows.DependencyProperty.UnsetValue> tem um significado especial no sistema de propriedade e não pode ser usado como um valor de padrão de propriedade de dependência.</span><span class="sxs-lookup"><span data-stu-id="9b023-123">The value <xref:System.Windows.DependencyProperty.UnsetValue> has special meaning in the property system, and cannot be used as a dependency property default value.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9b023-124">O exemplo a seguir chama essa assinatura de construtor:</span><span class="sxs-lookup"><span data-stu-id="9b023-124">The following example calls this constructor signature:</span></span>  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor1param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor1param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="9b023-125"><paramref name="defaultValue" /> é definido como <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</span><span class="sxs-lookup"><span data-stu-id="9b023-125"><paramref name="defaultValue" /> is set to <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</span></span></exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (System.Windows.PropertyChangedCallback propertyChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.PropertyChangedCallback propertyChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Windows.PropertyChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Windows::PropertyChangedCallback ^ propertyChangedCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : System.Windows.PropertyChangedCallback -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata propertyChangedCallback" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
      </Parameters>
      <Docs>
        <param name="propertyChangedCallback"><span data-ttu-id="9b023-126">Uma referência a uma implementação do manipulador que será chamada pelo sistema de propriedades sempre que o valor efetivo da propriedade for alterado.</span><span class="sxs-lookup"><span data-stu-id="9b023-126">A reference to a handler implementation that the property system will call whenever the effective value of the property changes.</span></span></param>
        <summary><span data-ttu-id="9b023-127">Inicializa uma nova instância da classe <see cref="T:System.Windows.FrameworkPropertyMetadata" /> com o retorno de chamada <see cref="T:System.Windows.PropertyChangedCallback" /> especificado.</span><span class="sxs-lookup"><span data-stu-id="9b023-127">Initializes a new instance of the <see cref="T:System.Windows.FrameworkPropertyMetadata" /> class with the specified <see cref="T:System.Windows.PropertyChangedCallback" /> callback.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="9b023-128">O exemplo a seguir chama essa assinatura de construtor:</span><span class="sxs-lookup"><span data-stu-id="9b023-128">The following example calls this constructor signature:</span></span>  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor1paramcallback](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor1paramcallback)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, valuetype System.Windows.FrameworkPropertyMetadataOptions flags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (defaultValue As Object, flags As FrameworkPropertyMetadataOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::FrameworkPropertyMetadataOptions flags);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.FrameworkPropertyMetadataOptions -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, flags)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="flags" Type="System.Windows.FrameworkPropertyMetadataOptions" />
      </Parameters>
      <Docs>
        <param name="defaultValue"><span data-ttu-id="9b023-129">O valor padrão da propriedade de dependência, geralmente, fornecido como um valor de um tipo específico.</span><span class="sxs-lookup"><span data-stu-id="9b023-129">The default value of the dependency property, usually provided as a value of a specific type.</span></span></param>
        <param name="flags"><span data-ttu-id="9b023-130">Os sinalizadores de opção de metadados (uma combinação de valores <see cref="T:System.Windows.FrameworkPropertyMetadataOptions" />).</span><span class="sxs-lookup"><span data-stu-id="9b023-130">The metadata option flags (a combination of <see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /> values).</span></span> <span data-ttu-id="9b023-131">Essas opções especificam características da propriedade de dependência que interagem com sistemas, como layout ou vinculação de dados.</span><span class="sxs-lookup"><span data-stu-id="9b023-131">These options specify characteristics of the dependency property that interact with systems such as layout or data binding.</span></span></param>
        <summary><span data-ttu-id="9b023-132">Inicializa uma nova instância da classe <see cref="T:System.Windows.FrameworkPropertyMetadata" /> com o valor padrão e as opções de metadados em nível da estrutura fornecidos.</span><span class="sxs-lookup"><span data-stu-id="9b023-132">Initializes a new instance of the <see cref="T:System.Windows.FrameworkPropertyMetadata" /> class with the provided default value and framework-level metadata options.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9b023-133">O tipo do valor fornecido para `defaultValue` deve corresponder ou ser relacionadas para o tipo especificado no registro original da propriedade de dependência que serão aplicados a esses metadados.</span><span class="sxs-lookup"><span data-stu-id="9b023-133">The type of the value provided for `defaultValue` must match or be related to the type specified in the original registration of the dependency property that this metadata will be applied to.</span></span> <span data-ttu-id="9b023-134">Incompatibilidades entre o tipo de valor padrão de metadados e o tipo da propriedade de dependência que ele está sendo aplicado podem ser difícil de depurar, porque a incompatibilidade não podem ser detectada durante a compilação.</span><span class="sxs-lookup"><span data-stu-id="9b023-134">Mismatches between metadata default value type and the type of the dependency property it is being applied to can be difficult to debug, because the mismatch is not detectable during compilation.</span></span> <span data-ttu-id="9b023-135">O sistema de propriedades não avalia o valor efetivo de uma propriedade até o tempo de execução, portanto, o resultado de uma incompatibilidade de tipo de propriedade/tipo de valor padrão é um erro de tempo de execução.</span><span class="sxs-lookup"><span data-stu-id="9b023-135">The property system does not evaluate the effective value of a property until run time, so the result of a default value type/property type mismatch is a run-time error.</span></span>  
  
 <span data-ttu-id="9b023-136">O valor <xref:System.Windows.DependencyProperty.UnsetValue> tem um significado especial no sistema de propriedade e não pode ser usado como um valor de padrão de propriedade de dependência.</span><span class="sxs-lookup"><span data-stu-id="9b023-136">The value <xref:System.Windows.DependencyProperty.UnsetValue> has special meaning in the property system, and cannot be used as a dependency property default value.</span></span>  
  
 <span data-ttu-id="9b023-137">Valores marcados como conjunto de sinalizadores na `flags` parâmetro definirá o valor booliano da <xref:System.Windows.FrameworkPropertyMetadata> propriedades que correspondem ao que <xref:System.Windows.FrameworkPropertyMetadataOptions> nome do sinalizador para `true`.</span><span class="sxs-lookup"><span data-stu-id="9b023-137">Values marked as set flags in the `flags` parameter will set the Boolean value of <xref:System.Windows.FrameworkPropertyMetadata> properties that match that <xref:System.Windows.FrameworkPropertyMetadataOptions> flag's name to `true`.</span></span> <span data-ttu-id="9b023-138">Posteriormente, você pode alterar os valores das propriedades nos metadados, desde que os metadados ainda não foram aplicados a uma operação de sistema de propriedade específicos.</span><span class="sxs-lookup"><span data-stu-id="9b023-138">You can subsequently change the values of the properties in the metadata, as long as the metadata has not yet been applied to a specific property system operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9b023-139">O exemplo a seguir chama essa assinatura de construtor:</span><span class="sxs-lookup"><span data-stu-id="9b023-139">The following example calls this constructor signature:</span></span>  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_DV_FPMO](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_dv_fpmo)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="9b023-140"><paramref name="defaultValue" /> é definido como <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</span><span class="sxs-lookup"><span data-stu-id="9b023-140"><paramref name="defaultValue" /> is set to <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</span></span></exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.PropertyChangedCallback propertyChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, class System.Windows.PropertyChangedCallback propertyChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::PropertyChangedCallback ^ propertyChangedCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.PropertyChangedCallback -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, propertyChangedCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue"><span data-ttu-id="9b023-141">O valor padrão da propriedade de dependência, geralmente, fornecido como um valor de um tipo específico.</span><span class="sxs-lookup"><span data-stu-id="9b023-141">The default value of the dependency property, usually provided as a value of a specific type.</span></span></param>
        <param name="propertyChangedCallback"><span data-ttu-id="9b023-142">Uma referência a uma implementação do manipulador que será chamada pelo sistema de propriedades sempre que o valor efetivo da propriedade for alterado.</span><span class="sxs-lookup"><span data-stu-id="9b023-142">A reference to a handler implementation that the property system will call whenever the effective value of the property changes.</span></span></param>
        <summary><span data-ttu-id="9b023-143">Inicializa uma nova instância da classe <see cref="T:System.Windows.FrameworkPropertyMetadata" /> com o valor padrão fornecido e o retorno de chamada <see cref="T:System.Windows.PropertyChangedCallback" /> especificado.</span><span class="sxs-lookup"><span data-stu-id="9b023-143">Initializes a new instance of the <see cref="T:System.Windows.FrameworkPropertyMetadata" /> class with the provided default value and specified <see cref="T:System.Windows.PropertyChangedCallback" /> callback.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9b023-144">O tipo do valor fornecido para `defaultValue` deve corresponder ou ser relacionadas para o tipo especificado no registro original da propriedade de dependência que serão aplicados a esses metadados.</span><span class="sxs-lookup"><span data-stu-id="9b023-144">The type of the value provided for `defaultValue` must match or be related to the type specified in the original registration of the dependency property that this metadata will be applied to.</span></span> <span data-ttu-id="9b023-145">Incompatibilidades entre o tipo de valor padrão de metadados e o tipo da propriedade de dependência que ele está sendo aplicado podem ser difícil de depurar, porque a incompatibilidade não podem ser detectada durante a compilação.</span><span class="sxs-lookup"><span data-stu-id="9b023-145">Mismatches between metadata default value type and the type of the dependency property it is being applied to can be difficult to debug, because the mismatch is not detectable during compilation.</span></span> <span data-ttu-id="9b023-146">O sistema de propriedades não avalia o valor efetivo de uma propriedade até o tempo de execução, portanto, o resultado de uma incompatibilidade de tipo de propriedade/tipo de valor padrão é um erro de tempo de execução.</span><span class="sxs-lookup"><span data-stu-id="9b023-146">The property system does not evaluate the effective value of a property until run time, so the result of a default value type/property type mismatch is a run-time error.</span></span>  
  
 <span data-ttu-id="9b023-147">O valor <xref:System.Windows.DependencyProperty.UnsetValue> tem um significado especial no sistema de propriedade e não pode ser usado como um valor de padrão de propriedade de dependência.</span><span class="sxs-lookup"><span data-stu-id="9b023-147">The value <xref:System.Windows.DependencyProperty.UnsetValue> has special meaning in the property system, and cannot be used as a dependency property default value.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9b023-148">O exemplo a seguir chama essa assinatura de construtor:</span><span class="sxs-lookup"><span data-stu-id="9b023-148">The following example calls this constructor signature:</span></span>  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor2param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor2param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="9b023-149"><paramref name="defaultValue" /> é definido como <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</span><span class="sxs-lookup"><span data-stu-id="9b023-149"><paramref name="defaultValue" /> is set to <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</span></span></exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : System.Windows.PropertyChangedCallback * System.Windows.CoerceValueCallback -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (propertyChangedCallback, coerceValueCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
      </Parameters>
      <Docs>
        <param name="propertyChangedCallback"><span data-ttu-id="9b023-150">Uma referência a uma implementação do manipulador que será chamada pelo sistema de propriedades sempre que o valor efetivo da propriedade for alterado.</span><span class="sxs-lookup"><span data-stu-id="9b023-150">A reference to a handler implementation that the property system will call whenever the effective value of the property changes.</span></span></param>
        <param name="coerceValueCallback"><span data-ttu-id="9b023-151">Uma referência a uma implementação de manipulador será chamada sempre que o sistema de propriedades chamar <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> para essa propriedade de dependência.</span><span class="sxs-lookup"><span data-stu-id="9b023-151">A reference to a handler implementation will be called whenever the property system calls <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> for this dependency property.</span></span></param>
        <summary><span data-ttu-id="9b023-152">Inicializa uma nova instância da classe <see cref="T:System.Windows.FrameworkPropertyMetadata" /> com os retornos de chamada especificados.</span><span class="sxs-lookup"><span data-stu-id="9b023-152">Initializes a new instance of the <see cref="T:System.Windows.FrameworkPropertyMetadata" /> class with the specified callbacks.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9b023-153">Essa implementação chama um inicializador de base e, em seguida, adiciona o `coerceValueCallback` , definindo a propriedade na instância de base.</span><span class="sxs-lookup"><span data-stu-id="9b023-153">This implementation calls a base initializer and then adds the `coerceValueCallback` by setting the property on the base instance.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9b023-154">O exemplo a seguir chama essa assinatura de construtor:</span><span class="sxs-lookup"><span data-stu-id="9b023-154">The following example calls this constructor signature:</span></span>  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_PCC_CVC](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_pcc_cvc)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags, System.Windows.PropertyChangedCallback propertyChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, valuetype System.Windows.FrameworkPropertyMetadataOptions flags, class System.Windows.PropertyChangedCallback propertyChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::FrameworkPropertyMetadataOptions flags, System::Windows::PropertyChangedCallback ^ propertyChangedCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.FrameworkPropertyMetadataOptions * System.Windows.PropertyChangedCallback -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, flags, propertyChangedCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="flags" Type="System.Windows.FrameworkPropertyMetadataOptions" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue"><span data-ttu-id="9b023-155">O valor padrão da propriedade de dependência, geralmente, fornecido como um valor de um tipo específico.</span><span class="sxs-lookup"><span data-stu-id="9b023-155">The default value of the dependency property, usually provided as a value of a specific type.</span></span></param>
        <param name="flags"><span data-ttu-id="9b023-156">Os sinalizadores de opção de metadados (uma combinação de valores <see cref="T:System.Windows.FrameworkPropertyMetadataOptions" />).</span><span class="sxs-lookup"><span data-stu-id="9b023-156">The metadata option flags (a combination of <see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /> values).</span></span> <span data-ttu-id="9b023-157">Essas opções especificam características da propriedade de dependência que interagem com sistemas, como layout ou vinculação de dados.</span><span class="sxs-lookup"><span data-stu-id="9b023-157">These options specify characteristics of the dependency property that interact with systems such as layout or data binding.</span></span></param>
        <param name="propertyChangedCallback"><span data-ttu-id="9b023-158">Uma referência a uma implementação do manipulador que será chamada pelo sistema de propriedades sempre que o valor efetivo da propriedade for alterado.</span><span class="sxs-lookup"><span data-stu-id="9b023-158">A reference to a handler implementation that the property system will call whenever the effective value of the property changes.</span></span></param>
        <summary><span data-ttu-id="9b023-159">Inicializa uma nova instância da classe <see cref="T:System.Windows.FrameworkPropertyMetadata" /> com o valor padrão e as opções de metadados da estrutura fornecidos, bem como o retorno de chamada <see cref="T:System.Windows.PropertyChangedCallback" /> especificado.</span><span class="sxs-lookup"><span data-stu-id="9b023-159">Initializes a new instance of the <see cref="T:System.Windows.FrameworkPropertyMetadata" /> class with the provided default value and framework metadata options, and specified <see cref="T:System.Windows.PropertyChangedCallback" /> callback.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9b023-160">O tipo do valor fornecido para `defaultValue` deve corresponder ou ser relacionadas para o tipo especificado no registro original da propriedade de dependência que serão aplicados a esses metadados.</span><span class="sxs-lookup"><span data-stu-id="9b023-160">The type of the value provided for `defaultValue` must match or be related to the type specified in the original registration of the dependency property that this metadata will be applied to.</span></span> <span data-ttu-id="9b023-161">Incompatibilidades entre o tipo de valor padrão de metadados e o tipo da propriedade de dependência que ele está sendo aplicado podem ser difícil de depurar, porque a incompatibilidade não podem ser detectada durante a compilação.</span><span class="sxs-lookup"><span data-stu-id="9b023-161">Mismatches between metadata default value type and the type of the dependency property it is being applied to can be difficult to debug, because the mismatch is not detectable during compilation.</span></span> <span data-ttu-id="9b023-162">O sistema de propriedades não avalia o valor efetivo de uma propriedade até o tempo de execução, portanto, o resultado de uma incompatibilidade de tipo de propriedade/tipo de valor padrão é um erro de tempo de execução.</span><span class="sxs-lookup"><span data-stu-id="9b023-162">The property system does not evaluate the effective value of a property until run time, so the result of a default value type/property type mismatch is a run-time error.</span></span>  
  
 <span data-ttu-id="9b023-163">O valor <xref:System.Windows.DependencyProperty.UnsetValue> tem um significado especial no sistema de propriedade e não pode ser usado como um valor de padrão de propriedade de dependência.</span><span class="sxs-lookup"><span data-stu-id="9b023-163">The value <xref:System.Windows.DependencyProperty.UnsetValue> has special meaning in the property system, and cannot be used as a dependency property default value.</span></span>  
  
 <span data-ttu-id="9b023-164">Valores marcados como conjunto de sinalizadores na `flags` parâmetro definirá o valor booliano da <xref:System.Windows.FrameworkPropertyMetadata> propriedades que correspondem ao que <xref:System.Windows.FrameworkPropertyMetadataOptions> nome do sinalizador para `true`.</span><span class="sxs-lookup"><span data-stu-id="9b023-164">Values marked as set flags in the `flags` parameter will set the Boolean value of <xref:System.Windows.FrameworkPropertyMetadata> properties that match that <xref:System.Windows.FrameworkPropertyMetadataOptions> flag's name to `true`.</span></span> <span data-ttu-id="9b023-165">Você ainda pode alterar os valores das propriedades nos metadados, desde que os metadados ainda não foram aplicados a uma operação de sistema de propriedade específicos.</span><span class="sxs-lookup"><span data-stu-id="9b023-165">You can still change the values of the properties in the metadata, as long as the metadata has not yet been applied to a specific property system operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9b023-166">O exemplo a seguir chama essa assinatura de construtor:</span><span class="sxs-lookup"><span data-stu-id="9b023-166">The following example calls this constructor signature:</span></span>  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_DV_FPMO_PCC](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_dv_fpmo_pcc)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="9b023-167"><paramref name="defaultValue" /> é definido como <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</span><span class="sxs-lookup"><span data-stu-id="9b023-167"><paramref name="defaultValue" /> is set to <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</span></span></exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.PropertyChangedCallback * System.Windows.CoerceValueCallback -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, propertyChangedCallback, coerceValueCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue"><span data-ttu-id="9b023-168">O valor padrão da propriedade de dependência, geralmente, fornecido como um tipo específico.</span><span class="sxs-lookup"><span data-stu-id="9b023-168">The default value of the dependency property, usually provided as a specific type.</span></span></param>
        <param name="propertyChangedCallback"><span data-ttu-id="9b023-169">Uma referência a uma implementação do manipulador que será chamada pelo sistema de propriedades sempre que o valor efetivo da propriedade for alterado.</span><span class="sxs-lookup"><span data-stu-id="9b023-169">A reference to a handler implementation that the property system will call whenever the effective value of the property changes.</span></span></param>
        <param name="coerceValueCallback"><span data-ttu-id="9b023-170">Uma referência a uma implementação de manipulador será chamada sempre que o sistema de propriedades chamar <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> para essa propriedade de dependência.</span><span class="sxs-lookup"><span data-stu-id="9b023-170">A reference to a handler implementation that will be called whenever the property system calls <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> for this dependency property.</span></span></param>
        <summary><span data-ttu-id="9b023-171">Inicializa uma nova instância da classe <see cref="T:System.Windows.FrameworkPropertyMetadata" /> com o valor padrão fornecido e os retornos de chamada especificados.</span><span class="sxs-lookup"><span data-stu-id="9b023-171">Initializes a new instance of the <see cref="T:System.Windows.FrameworkPropertyMetadata" /> class with the provided default value and specified callbacks.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9b023-172">O tipo do valor fornecido para `defaultValue` deve corresponder ou ser relacionadas para o tipo especificado no registro original da propriedade de dependência que serão aplicados a esses metadados.</span><span class="sxs-lookup"><span data-stu-id="9b023-172">The type of the value provided for `defaultValue` must match or be related to the type specified in the original registration of the dependency property that this metadata will be applied to.</span></span> <span data-ttu-id="9b023-173">Incompatibilidades entre o tipo de valor padrão de metadados e o tipo da propriedade de dependência que ele está sendo aplicado podem ser difícil de depurar, porque a incompatibilidade não podem ser detectada durante a compilação.</span><span class="sxs-lookup"><span data-stu-id="9b023-173">Mismatches between metadata default value type and the type of the dependency property it is being applied to can be difficult to debug, because the mismatch is not detectable during compilation.</span></span> <span data-ttu-id="9b023-174">O sistema de propriedades não avalia o valor efetivo de uma propriedade até o tempo de execução, portanto, o resultado de uma incompatibilidade de tipo de propriedade/tipo de valor padrão é um erro de tempo de execução.</span><span class="sxs-lookup"><span data-stu-id="9b023-174">The property system does not evaluate the effective value of a property until run time, so the result of a default value type/property type mismatch is a run-time error.</span></span>  
  
 <span data-ttu-id="9b023-175">O valor <xref:System.Windows.DependencyProperty.UnsetValue> tem um significado especial no sistema de propriedade e não pode ser usado como um valor de padrão de propriedade de dependência.</span><span class="sxs-lookup"><span data-stu-id="9b023-175">The value <xref:System.Windows.DependencyProperty.UnsetValue> has special meaning in the property system, and cannot be used as a dependency property default value.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9b023-176">O exemplo a seguir chama essa assinatura de construtor:</span><span class="sxs-lookup"><span data-stu-id="9b023-176">The following example calls this constructor signature:</span></span>  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor3param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor3param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="9b023-177"><paramref name="defaultValue" /> é definido como <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</span><span class="sxs-lookup"><span data-stu-id="9b023-177"><paramref name="defaultValue" /> is set to <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</span></span></exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, valuetype System.Windows.FrameworkPropertyMetadataOptions flags, class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::FrameworkPropertyMetadataOptions flags, System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.FrameworkPropertyMetadataOptions * System.Windows.PropertyChangedCallback * System.Windows.CoerceValueCallback -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, flags, propertyChangedCallback, coerceValueCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="flags" Type="System.Windows.FrameworkPropertyMetadataOptions" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue"><span data-ttu-id="9b023-178">O valor padrão da propriedade de dependência, geralmente, fornecido como um tipo específico.</span><span class="sxs-lookup"><span data-stu-id="9b023-178">The default value of the dependency property, usually provided as a specific type.</span></span></param>
        <param name="flags"><span data-ttu-id="9b023-179">Os sinalizadores de opção de metadados (uma combinação de valores <see cref="T:System.Windows.FrameworkPropertyMetadataOptions" />).</span><span class="sxs-lookup"><span data-stu-id="9b023-179">The metadata option flags (a combination of <see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /> values).</span></span> <span data-ttu-id="9b023-180">Essas opções especificam características da propriedade de dependência que interagem com sistemas, como layout ou vinculação de dados.</span><span class="sxs-lookup"><span data-stu-id="9b023-180">These options specify characteristics of the dependency property that interact with systems such as layout or data binding.</span></span></param>
        <param name="propertyChangedCallback"><span data-ttu-id="9b023-181">Uma referência a uma implementação do manipulador que será chamada pelo sistema de propriedades sempre que o valor efetivo da propriedade for alterado.</span><span class="sxs-lookup"><span data-stu-id="9b023-181">A reference to a handler implementation that the property system will call whenever the effective value of the property changes.</span></span></param>
        <param name="coerceValueCallback"><span data-ttu-id="9b023-182">Uma referência a uma implementação de manipulador que será chamada sempre que o sistema de propriedades chamar <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> nessa propriedade.</span><span class="sxs-lookup"><span data-stu-id="9b023-182">A reference to a handler implementation that will be called whenever the property system calls <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> against this property.</span></span></param>
        <summary><span data-ttu-id="9b023-183">Inicializa uma nova instância da classe <see cref="T:System.Windows.FrameworkPropertyMetadata" /> com o valor padrão e as opções de metadados da estrutura fornecidos, bem como os retornos de chamada especificados.</span><span class="sxs-lookup"><span data-stu-id="9b023-183">Initializes a new instance of the <see cref="T:System.Windows.FrameworkPropertyMetadata" /> class with the provided default value and framework metadata options, and specified callbacks.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9b023-184">O tipo do valor fornecido para `defaultValue` deve corresponder ou ser relacionadas para o tipo especificado no registro original da propriedade de dependência que serão aplicados a esses metadados.</span><span class="sxs-lookup"><span data-stu-id="9b023-184">The type of the value provided for `defaultValue` must match or be related to the type specified in the original registration of the dependency property that this metadata will be applied to.</span></span> <span data-ttu-id="9b023-185">Incompatibilidades entre o tipo de valor padrão de metadados e o tipo da propriedade de dependência que ele está sendo aplicado podem ser difícil de depurar, porque a incompatibilidade não podem ser detectada durante a compilação.</span><span class="sxs-lookup"><span data-stu-id="9b023-185">Mismatches between metadata default value type and the type of the dependency property it is being applied to can be difficult to debug, because the mismatch is not detectable during compilation.</span></span> <span data-ttu-id="9b023-186">O sistema de propriedades não avalia o valor efetivo de uma propriedade até o tempo de execução, portanto, o resultado de uma incompatibilidade de tipo de propriedade/tipo de valor padrão é um erro de tempo de execução.</span><span class="sxs-lookup"><span data-stu-id="9b023-186">The property system does not evaluate the effective value of a property until run time, so the result of a default value type/property type mismatch is a run-time error.</span></span>  
  
 <span data-ttu-id="9b023-187">O valor <xref:System.Windows.DependencyProperty.UnsetValue> tem um significado especial no sistema de propriedade e não pode ser usado como um valor de padrão de propriedade de dependência.</span><span class="sxs-lookup"><span data-stu-id="9b023-187">The value <xref:System.Windows.DependencyProperty.UnsetValue> has special meaning in the property system, and cannot be used as a dependency property default value.</span></span>  
  
 <span data-ttu-id="9b023-188">Valores marcados como conjunto de sinalizadores na `flags` parâmetro definirá o valor booliano da <xref:System.Windows.FrameworkPropertyMetadata> propriedades que correspondem ao que <xref:System.Windows.FrameworkPropertyMetadataOptions> nome do sinalizador para `true`.</span><span class="sxs-lookup"><span data-stu-id="9b023-188">Values marked as set flags in the `flags` parameter will set the Boolean value of <xref:System.Windows.FrameworkPropertyMetadata> properties that match that <xref:System.Windows.FrameworkPropertyMetadataOptions> flag's name to `true`.</span></span> <span data-ttu-id="9b023-189">Você ainda pode alterar os valores das propriedades nos metadados, desde que os metadados ainda não foram aplicados a uma operação de sistema de propriedade específicos.</span><span class="sxs-lookup"><span data-stu-id="9b023-189">You can still change the values of the properties in the metadata, as long as the metadata has not yet been applied to a specific property system operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9b023-190">O exemplo a seguir chama essa assinatura de construtor:</span><span class="sxs-lookup"><span data-stu-id="9b023-190">The following example calls this constructor signature:</span></span>  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_DV_FPMO_PCC_CVC](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_dv_fpmo_pcc_cvc)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="9b023-191"><paramref name="defaultValue" /> é definido como <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</span><span class="sxs-lookup"><span data-stu-id="9b023-191"><paramref name="defaultValue" /> is set to <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</span></span></exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback, bool isAnimationProhibited);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, valuetype System.Windows.FrameworkPropertyMetadataOptions flags, class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback, bool isAnimationProhibited) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::FrameworkPropertyMetadataOptions flags, System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback, bool isAnimationProhibited);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.FrameworkPropertyMetadataOptions * System.Windows.PropertyChangedCallback * System.Windows.CoerceValueCallback * bool -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, flags, propertyChangedCallback, coerceValueCallback, isAnimationProhibited)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="flags" Type="System.Windows.FrameworkPropertyMetadataOptions" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
        <Parameter Name="isAnimationProhibited" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="defaultValue"><span data-ttu-id="9b023-192">O valor padrão da propriedade de dependência, geralmente, fornecido como um tipo específico.</span><span class="sxs-lookup"><span data-stu-id="9b023-192">The default value of the dependency property, usually provided as a specific type.</span></span></param>
        <param name="flags"><span data-ttu-id="9b023-193">Os sinalizadores de opção de metadados (uma combinação de valores <see cref="T:System.Windows.FrameworkPropertyMetadataOptions" />).</span><span class="sxs-lookup"><span data-stu-id="9b023-193">The metadata option flags (a combination of <see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /> values).</span></span> <span data-ttu-id="9b023-194">Essas opções especificam características da propriedade de dependência que interagem com sistemas, como layout ou vinculação de dados.</span><span class="sxs-lookup"><span data-stu-id="9b023-194">These options specify characteristics of the dependency property that interact with systems such as layout or data binding.</span></span></param>
        <param name="propertyChangedCallback"><span data-ttu-id="9b023-195">Uma referência a uma implementação do manipulador que será chamada pelo sistema de propriedades sempre que o valor efetivo da propriedade for alterado.</span><span class="sxs-lookup"><span data-stu-id="9b023-195">A reference to a handler implementation that the property system will call whenever the effective value of the property changes.</span></span></param>
        <param name="coerceValueCallback"><span data-ttu-id="9b023-196">Uma referência a uma implementação de manipulador será chamada sempre que o sistema de propriedades chamar <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> nessa propriedade de dependência.</span><span class="sxs-lookup"><span data-stu-id="9b023-196">A reference to a handler implementation that will be called whenever the property system calls <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> on this dependency property.</span></span></param>
        <param name="isAnimationProhibited"><span data-ttu-id="9b023-197"><see langword="true" /> para impedir que o sistema de propriedades anime a propriedade à qual esses metadados foram aplicados.</span><span class="sxs-lookup"><span data-stu-id="9b023-197"><see langword="true" /> to prevent the property system from animating the property that this metadata is applied to.</span></span> <span data-ttu-id="9b023-198">Propriedades desse tipo acionarão uma exceção de tempo de execução que provenientes do sistema de propriedades, em caso de tentativa de criar animações delas.</span><span class="sxs-lookup"><span data-stu-id="9b023-198">Such properties will raise a run-time exception originating from the property system if animations of them are attempted.</span></span> <span data-ttu-id="9b023-199"><see langword="false" /> para permitir que a propriedade seja animada.</span><span class="sxs-lookup"><span data-stu-id="9b023-199"><see langword="false" /> to permit animating the property.</span></span> <span data-ttu-id="9b023-200">O padrão é <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="9b023-200">The default is <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="9b023-201">Inicializa uma nova instância da classe <see cref="T:System.Windows.FrameworkPropertyMetadata" /> com o valor padrão e as opções de metadados da estrutura fornecidos, os retornos de chamada especificados e um booliano que pode ser usado para impedir a animação da propriedade.</span><span class="sxs-lookup"><span data-stu-id="9b023-201">Initializes a new instance of the <see cref="T:System.Windows.FrameworkPropertyMetadata" /> class with the provided default value and framework metadata options, specified callbacks, and a Boolean that can be used to prevent animation of the property.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9b023-202">O tipo do valor fornecido para `defaultValue` deve corresponder ou ser relacionadas para o tipo especificado no registro original da propriedade de dependência que serão aplicados a esses metadados.</span><span class="sxs-lookup"><span data-stu-id="9b023-202">The type of the value provided for `defaultValue` must match or be related to the type specified in the original registration of the dependency property that this metadata will be applied to.</span></span> <span data-ttu-id="9b023-203">Incompatibilidades entre o tipo de valor padrão de metadados e o tipo da propriedade de dependência que ele está sendo aplicado podem ser difícil de depurar, porque a incompatibilidade não podem ser detectada durante a compilação.</span><span class="sxs-lookup"><span data-stu-id="9b023-203">Mismatches between metadata default value type and the type of the dependency property it is being applied to can be difficult to debug, because the mismatch is not detectable during compilation.</span></span> <span data-ttu-id="9b023-204">O sistema de propriedades não avalia o valor efetivo de uma propriedade até o tempo de execução, portanto, o resultado de uma incompatibilidade de tipo de propriedade/tipo de valor padrão é um erro de tempo de execução.</span><span class="sxs-lookup"><span data-stu-id="9b023-204">The property system does not evaluate the effective value of a property until run time, so the result of a default value type/property type mismatch is a run-time error.</span></span>  
  
 <span data-ttu-id="9b023-205">O valor <xref:System.Windows.DependencyProperty.UnsetValue> tem um significado especial no sistema de propriedade e não pode ser usado como um valor de padrão de propriedade de dependência.</span><span class="sxs-lookup"><span data-stu-id="9b023-205">The value <xref:System.Windows.DependencyProperty.UnsetValue> has special meaning in the property system, and cannot be used as a dependency property default value.</span></span>  
  
 <span data-ttu-id="9b023-206">O `isAnimationProhibited` parâmetro define o valor inicial do <xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A> propriedade declarada com a base imediata <xref:System.Windows.UIPropertyMetadata> classe.</span><span class="sxs-lookup"><span data-stu-id="9b023-206">The `isAnimationProhibited` parameter sets the initial value of the <xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A> property declared by the immediate base <xref:System.Windows.UIPropertyMetadata> class.</span></span>  
  
 <span data-ttu-id="9b023-207">Valores marcados como conjunto de sinalizadores na `flags` parâmetro definirá o valor booliano da <xref:System.Windows.FrameworkPropertyMetadata> propriedades que correspondem ao que <xref:System.Windows.FrameworkPropertyMetadataOptions> nome do sinalizador para `true`.</span><span class="sxs-lookup"><span data-stu-id="9b023-207">Values marked as set flags in the `flags` parameter will set the Boolean value of <xref:System.Windows.FrameworkPropertyMetadata> properties that match that <xref:System.Windows.FrameworkPropertyMetadataOptions> flag's name to `true`.</span></span> <span data-ttu-id="9b023-208">Você ainda pode alterar os valores das propriedades nos metadados, desde que os metadados ainda não foram aplicados a uma operação de sistema de propriedade específicos.</span><span class="sxs-lookup"><span data-stu-id="9b023-208">You can still change the values of the properties in the metadata, as long as the metadata has not yet been applied to a specific property system operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9b023-209">O exemplo a seguir chama essa assinatura de construtor:</span><span class="sxs-lookup"><span data-stu-id="9b023-209">The following example calls this constructor signature:</span></span>  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_DV_FPMO_PCC_CVC_IAP](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_dv_fpmo_pcc_cvc_iap)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="9b023-210"><paramref name="defaultValue" /> é definido como <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</span><span class="sxs-lookup"><span data-stu-id="9b023-210"><paramref name="defaultValue" /> is set to <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</span></span></exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback, bool isAnimationProhibited, System.Windows.Data.UpdateSourceTrigger defaultUpdateSourceTrigger);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, valuetype System.Windows.FrameworkPropertyMetadataOptions flags, class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback, bool isAnimationProhibited, valuetype System.Windows.Data.UpdateSourceTrigger defaultUpdateSourceTrigger) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean,System.Windows.Data.UpdateSourceTrigger)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::FrameworkPropertyMetadataOptions flags, System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback, bool isAnimationProhibited, System::Windows::Data::UpdateSourceTrigger defaultUpdateSourceTrigger);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.FrameworkPropertyMetadataOptions * System.Windows.PropertyChangedCallback * System.Windows.CoerceValueCallback * bool * System.Windows.Data.UpdateSourceTrigger -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, flags, propertyChangedCallback, coerceValueCallback, isAnimationProhibited, defaultUpdateSourceTrigger)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="flags" Type="System.Windows.FrameworkPropertyMetadataOptions" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
        <Parameter Name="isAnimationProhibited" Type="System.Boolean" />
        <Parameter Name="defaultUpdateSourceTrigger" Type="System.Windows.Data.UpdateSourceTrigger" />
      </Parameters>
      <Docs>
        <param name="defaultValue"><span data-ttu-id="9b023-211">O valor padrão da propriedade de dependência, geralmente, fornecido como um tipo específico.</span><span class="sxs-lookup"><span data-stu-id="9b023-211">The default value of the dependency property, usually provided as a specific type.</span></span></param>
        <param name="flags"><span data-ttu-id="9b023-212">Os sinalizadores de opção de metadados (uma combinação de valores <see cref="T:System.Windows.FrameworkPropertyMetadataOptions" />).</span><span class="sxs-lookup"><span data-stu-id="9b023-212">The metadata option flags (a combination of <see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /> values).</span></span> <span data-ttu-id="9b023-213">Essas opções especificam características da propriedade de dependência que interagem com sistemas, como layout ou vinculação de dados.</span><span class="sxs-lookup"><span data-stu-id="9b023-213">These options specify characteristics of the dependency property that interact with systems such as layout or data binding.</span></span></param>
        <param name="propertyChangedCallback"><span data-ttu-id="9b023-214">Uma referência a uma implementação do manipulador que será chamada pelo sistema de propriedades sempre que o valor efetivo da propriedade for alterado.</span><span class="sxs-lookup"><span data-stu-id="9b023-214">A reference to a handler implementation that the property system will call whenever the effective value of the property changes.</span></span></param>
        <param name="coerceValueCallback"><span data-ttu-id="9b023-215">Uma referência a uma implementação de manipulador que será chamada sempre que o sistema de propriedades chamar <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> nessa propriedade.</span><span class="sxs-lookup"><span data-stu-id="9b023-215">A reference to a handler implementation that will be called whenever the property system calls <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> against this property.</span></span></param>
        <param name="isAnimationProhibited"><span data-ttu-id="9b023-216"><see langword="true" /> para impedir que o sistema de propriedades anime a propriedade à qual esses metadados foram aplicados.</span><span class="sxs-lookup"><span data-stu-id="9b023-216"><see langword="true" /> to prevent the property system from animating the property that this metadata is applied to.</span></span> <span data-ttu-id="9b023-217">Propriedades desse tipo acionarão uma exceção de tempo de execução que provenientes do sistema de propriedades, em caso de tentativa de criar animações delas.</span><span class="sxs-lookup"><span data-stu-id="9b023-217">Such properties will raise a run-time exception originating from the property system if animations of them are attempted.</span></span> <span data-ttu-id="9b023-218">O padrão é <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="9b023-218">The default is <see langword="false" />.</span></span></param>
        <param name="defaultUpdateSourceTrigger"><span data-ttu-id="9b023-219">O <see cref="T:System.Windows.Data.UpdateSourceTrigger" /> a ser usado quando as associações dessa propriedade forem aplicadas com seu <see cref="T:System.Windows.Data.UpdateSourceTrigger" /> definido como <see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" />.</span><span class="sxs-lookup"><span data-stu-id="9b023-219">The <see cref="T:System.Windows.Data.UpdateSourceTrigger" /> to use when bindings for this property are applied that have their <see cref="T:System.Windows.Data.UpdateSourceTrigger" /> set to <see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" />.</span></span></param>
        <summary><span data-ttu-id="9b023-220">Inicializa uma nova instância da classe <see cref="T:System.Windows.FrameworkPropertyMetadata" /> com o valor padrão e as opções de metadados da estrutura fornecidos, os retornos de chamada especificados, um booliano que pode ser usado para impedir a animação da propriedade e um padrão de gatilho de atualização com associação de dados.</span><span class="sxs-lookup"><span data-stu-id="9b023-220">Initializes a new instance of the <see cref="T:System.Windows.FrameworkPropertyMetadata" /> class with the provided default value and framework metadata options, specified callbacks, a Boolean that can be used to prevent animation of the property, and a data-binding update trigger default.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9b023-221">O tipo do valor fornecido para `defaultValue` deve corresponder ou ser relacionadas para o tipo especificado no registro original da propriedade de dependência que serão aplicados a esses metadados.</span><span class="sxs-lookup"><span data-stu-id="9b023-221">The type of the value provided for `defaultValue` must match or be related to the type specified in the original registration of the dependency property that this metadata will be applied to.</span></span> <span data-ttu-id="9b023-222">Incompatibilidades entre o tipo de valor padrão de metadados e o tipo da propriedade de dependência que ele está sendo aplicado podem ser difícil de depurar, porque a incompatibilidade não podem ser detectada durante a compilação.</span><span class="sxs-lookup"><span data-stu-id="9b023-222">Mismatches between metadata default value type and the type of the dependency property it is being applied to can be difficult to debug, because the mismatch is not detectable during compilation.</span></span> <span data-ttu-id="9b023-223">O sistema de propriedades não avalia o valor efetivo de uma propriedade até o tempo de execução, portanto, o resultado de uma incompatibilidade de tipo de propriedade/tipo de valor padrão é um erro de tempo de execução.</span><span class="sxs-lookup"><span data-stu-id="9b023-223">The property system does not evaluate the effective value of a property until run time, so the result of a default value type/property type mismatch is a run-time error.</span></span>  
  
 <span data-ttu-id="9b023-224">O valor <xref:System.Windows.DependencyProperty.UnsetValue> tem um significado especial no sistema de propriedade e não pode ser usado como um valor de padrão de propriedade de dependência.</span><span class="sxs-lookup"><span data-stu-id="9b023-224">The value <xref:System.Windows.DependencyProperty.UnsetValue> has special meaning in the property system, and cannot be used as a dependency property default value.</span></span>  
  
 <span data-ttu-id="9b023-225">O `isAnimationProhibited` parâmetro define o valor inicial do <xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A> propriedade declarada com a base imediata <xref:System.Windows.UIPropertyMetadata> classe.</span><span class="sxs-lookup"><span data-stu-id="9b023-225">The `isAnimationProhibited` parameter sets the initial value of the <xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A> property declared by the immediate base <xref:System.Windows.UIPropertyMetadata> class.</span></span>  
  
 <span data-ttu-id="9b023-226">Para obter mais informações sobre o comportamento de origem de atualização para associações, consulte [visão geral de associação de dados](~/docs/framework/wpf/data/data-binding-overview.md).</span><span class="sxs-lookup"><span data-stu-id="9b023-226">For more information about the update source behavior for bindings, see [Data Binding Overview](~/docs/framework/wpf/data/data-binding-overview.md).</span></span>  
  
 <span data-ttu-id="9b023-227">Valores marcados como conjunto de sinalizadores na `flags` parâmetro definirá o valor booliano da <xref:System.Windows.FrameworkPropertyMetadata> propriedades que correspondem ao que <xref:System.Windows.FrameworkPropertyMetadataOptions> nome do sinalizador para `true`.</span><span class="sxs-lookup"><span data-stu-id="9b023-227">Values marked as set flags in the `flags` parameter will set the Boolean value of <xref:System.Windows.FrameworkPropertyMetadata> properties that match that <xref:System.Windows.FrameworkPropertyMetadataOptions> flag's name to `true`.</span></span> <span data-ttu-id="9b023-228">Você ainda pode alterar os valores das propriedades nos metadados, desde que os metadados ainda não foram aplicados a uma operação de sistema de propriedade específicos.</span><span class="sxs-lookup"><span data-stu-id="9b023-228">You can still change the values of the properties in the metadata, as long as the metadata has not yet been applied to a specific property system operation.</span></span>  
  
   
  
## Examples  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_DV_FPMO_PCC_CVC_IAP_DUST](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_dv_fpmo_pcc_cvc_iap_dust)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="9b023-229"><paramref name="defaultValue" /> é definido como <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</span><span class="sxs-lookup"><span data-stu-id="9b023-229"><paramref name="defaultValue" /> is set to <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</span></span></exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName="AffectsArrange">
      <MemberSignature Language="C#" Value="public bool AffectsArrange { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AffectsArrange" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.AffectsArrange" />
      <MemberSignature Language="VB.NET" Value="Public Property AffectsArrange As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AffectsArrange { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AffectsArrange : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.AffectsArrange" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9b023-230">Obtém ou define um valor que indica se uma propriedade de dependência potencialmente afeta a passagem de organização durante operações de mecanismo de layout.</span><span class="sxs-lookup"><span data-stu-id="9b023-230">Gets or sets a value that indicates whether a dependency property potentially affects the arrange pass during layout engine operations.</span></span></summary>
        <value><span data-ttu-id="9b023-231"><see langword="true" /> Se a propriedade de dependência na qual esses metadados existem potencialmente afetar a passagem de organização; Caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="9b023-231"><see langword="true" /> if the dependency property on which this metadata exists potentially affects the arrange pass; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="9b023-232">O padrão é <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="9b023-232">The default is <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9b023-233"><xref:System.Windows.FrameworkElement> e <xref:System.Windows.FrameworkContentElement> inclui uma implementação do <xref:System.Windows.FrameworkElement.OnPropertyChanged%2A> que monitora as alterações de valor efetivo para todas as propriedades de dependência que existe em um elemento.</span><span class="sxs-lookup"><span data-stu-id="9b023-233"><xref:System.Windows.FrameworkElement> and <xref:System.Windows.FrameworkContentElement> include an implementation of <xref:System.Windows.FrameworkElement.OnPropertyChanged%2A> that monitors effective value changes to all dependency properties that exist on an element.</span></span> <span data-ttu-id="9b023-234">Como parte da lógica, as propriedades de dependência que alteram em vigor a partir de valor e tem metadados com <xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A> definido como `true` iniciará uma solicitação adiada para invalidar os visuais para esse elemento (uma chamada para <xref:System.Windows.UIElement.InvalidateArrange%2A>).</span><span class="sxs-lookup"><span data-stu-id="9b023-234">As part of that logic, dependency properties that change effective value and have metadata with <xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A> set to `true` will initiate a deferred request to invalidate the visuals for that element (a call to <xref:System.Windows.UIElement.InvalidateArrange%2A>).</span></span> <span data-ttu-id="9b023-235">Como essa implementação de nível de framework WPF já está em vigor, você normalmente não é necessário procurar por propriedades de dependência com <xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A> , a menos que você estiver substituindo ou modificando o comportamento de layout de nível de framework WPF substancialmente.</span><span class="sxs-lookup"><span data-stu-id="9b023-235">Because this WPF framework-level implementation is already in place, you typically do not need to look for dependency properties with <xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A> unless you are substantially replacing or modifying the WPF framework-level layout behavior.</span></span>  
  
 <span data-ttu-id="9b023-236">Custom <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> implementações poderá optar por ter um comportamento semelhante para alterações de propriedade de dependência em que <xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A> é `true`.</span><span class="sxs-lookup"><span data-stu-id="9b023-236">Custom <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> implementations might choose to have similar behavior for dependency property changes where <xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A> is `true`.</span></span>  
  
 <span data-ttu-id="9b023-237">Propriedades em classes derivadas de <xref:System.Windows.PropertyMetadata> geralmente são definidos no modelo de objeto como leitura-gravação.</span><span class="sxs-lookup"><span data-stu-id="9b023-237">Properties on derived classes of <xref:System.Windows.PropertyMetadata> are typically defined in the object model as read-write.</span></span> <span data-ttu-id="9b023-238">Isso é para que eles podem ser ajustados após a inicialização da instância.</span><span class="sxs-lookup"><span data-stu-id="9b023-238">This is so they can be adjusted after initialization of the instance.</span></span> <span data-ttu-id="9b023-239">No entanto, depois que os metadados são consumidos como parte de uma chamada para <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, ou <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, o sistema de propriedades será lacrar essa instância de metadados e propriedades que transmitem as especificidades dos metadados agora são consideradas imutáveis.</span><span class="sxs-lookup"><span data-stu-id="9b023-239">However, after the metadata is consumed as part of a call to <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, or <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, the property system will seal that metadata instance and properties that convey the specifics of the metadata are now considered immutable.</span></span> <span data-ttu-id="9b023-240">Tentativa de definir essa propriedade após <xref:System.Windows.PropertyMetadata.IsSealed%2A> é `true` nesses metadados instância gerarão uma exceção.</span><span class="sxs-lookup"><span data-stu-id="9b023-240">Attempting to set this property after <xref:System.Windows.PropertyMetadata.IsSealed%2A> is `true` on this metadata instance will raise an exception.</span></span>  
  
<a name="xamlTextUsage_AffectsArrange"></a>   
## <a name="xaml-text-usage"></a><span data-ttu-id="9b023-241">Uso de texto XAML</span><span class="sxs-lookup"><span data-stu-id="9b023-241">XAML Text Usage</span></span>  
 <span data-ttu-id="9b023-242">Os membros dessa classe são usados normalmente não em [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span><span class="sxs-lookup"><span data-stu-id="9b023-242">Members of this class are either not typically used in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9b023-243">O exemplo a seguir obtém os metadados padrão da dependência de vários campos de propriedade, consulta o valor de vários <xref:System.Windows.FrameworkPropertyMetadata> propriedades nele e usa as informações para preencher uma tabela para implementar um navegador de metadados"".</span><span class="sxs-lookup"><span data-stu-id="9b023-243">The following example obtains the default metadata from various dependency property fields, queries the value of various <xref:System.Windows.FrameworkPropertyMetadata> properties on it, and uses the information to populate a table to implement a "metadata browser".</span></span>  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="9b023-244">Os metadados já foram aplicados à operação de propriedade de dependência, portanto os metadados estão selados e as propriedades dos metadados não podem ser definidas.</span><span class="sxs-lookup"><span data-stu-id="9b023-244">The metadata has already been applied to a dependency property operation, so that metadata is sealed and properties of the metadata cannot be set.</span></span></exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="AffectsMeasure">
      <MemberSignature Language="C#" Value="public bool AffectsMeasure { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AffectsMeasure" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.AffectsMeasure" />
      <MemberSignature Language="VB.NET" Value="Public Property AffectsMeasure As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AffectsMeasure { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AffectsMeasure : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.AffectsMeasure" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9b023-245">Obtém ou define um valor que indica se uma propriedade de dependência potencialmente afeta a passagem de medição durante operações de mecanismo de layout.</span><span class="sxs-lookup"><span data-stu-id="9b023-245">Gets or sets a value that indicates whether a dependency property potentially affects the measure pass during layout engine operations.</span></span></summary>
        <value><span data-ttu-id="9b023-246"><see langword="true" /> se a propriedade de dependência na qual esses metadados existem potencialmente afetar a passagem de medida; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="9b023-246"><see langword="true" /> if the dependency property on which this metadata exists potentially affects the measure pass; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="9b023-247">O padrão é <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="9b023-247">The default is <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9b023-248"><xref:System.Windows.FrameworkElement> e <xref:System.Windows.FrameworkContentElement> inclui uma implementação do <xref:System.Windows.FrameworkElement.OnPropertyChanged%2A> que monitora as alterações de valor efetivo para todas as propriedades de dependência que existe em um elemento.</span><span class="sxs-lookup"><span data-stu-id="9b023-248"><xref:System.Windows.FrameworkElement> and <xref:System.Windows.FrameworkContentElement> include an implementation of <xref:System.Windows.FrameworkElement.OnPropertyChanged%2A> that monitors effective value changes to all dependency properties that exist on an element.</span></span> <span data-ttu-id="9b023-249">Como parte da lógica, as propriedades de dependência que alteram em vigor a partir de valor e tem metadados com <xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> definido como `true` iniciará uma solicitação adiada para invalidar os visuais para esse elemento.</span><span class="sxs-lookup"><span data-stu-id="9b023-249">As part of that logic, dependency properties that change effective value and have metadata with <xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> set to `true` will initiate a deferred request to invalidate the visuals for that element.</span></span> <span data-ttu-id="9b023-250">Como essa implementação de nível de framework WPF já está em vigor, você normalmente não é necessário procurar por propriedades de dependência com <xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> , a menos que você estiver substituindo ou modificando o comportamento de layout de nível de framework WPF substancialmente.</span><span class="sxs-lookup"><span data-stu-id="9b023-250">Because this WPF framework-level implementation is already in place, you typically do not need to look for dependency properties with <xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> unless you are substantially replacing or modifying the WPF framework-level layout behavior.</span></span>  
  
 <span data-ttu-id="9b023-251">Custom <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> implementações poderá optar por ter um comportamento semelhante para alterações de propriedade de dependência em que <xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> é `true`.</span><span class="sxs-lookup"><span data-stu-id="9b023-251">Custom <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> implementations might choose to have similar behavior for dependency property changes where <xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> is `true`.</span></span>  
  
 <span data-ttu-id="9b023-252">Propriedades em classes derivadas de <xref:System.Windows.PropertyMetadata> geralmente são definidos no modelo de objeto como leitura-gravação.</span><span class="sxs-lookup"><span data-stu-id="9b023-252">Properties on derived classes of <xref:System.Windows.PropertyMetadata> are typically defined in the object model as read-write.</span></span> <span data-ttu-id="9b023-253">Isso é para que eles podem ser ajustados após a inicialização da instância.</span><span class="sxs-lookup"><span data-stu-id="9b023-253">This is so they can be adjusted after initialization of the instance.</span></span> <span data-ttu-id="9b023-254">No entanto, depois que os metadados são consumidos como parte de uma chamada para <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, ou <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, o sistema de propriedades será lacrar essa instância de metadados e propriedades que transmitem as especificidades dos metadados agora são consideradas imutáveis.</span><span class="sxs-lookup"><span data-stu-id="9b023-254">However, after the metadata is consumed as part of a call to <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, or <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, the property system will seal that metadata instance and properties that convey the specifics of the metadata are now considered immutable.</span></span> <span data-ttu-id="9b023-255">Tentativa de definir essa propriedade após <xref:System.Windows.PropertyMetadata.IsSealed%2A> é `true` nesses metadados instância gerarão uma exceção.</span><span class="sxs-lookup"><span data-stu-id="9b023-255">Attempting to set this property after <xref:System.Windows.PropertyMetadata.IsSealed%2A> is `true` on this metadata instance will raise an exception.</span></span>  
  
<a name="xamlTextUsage_AffectsMeasure"></a>   
## <a name="xaml-text-usage"></a><span data-ttu-id="9b023-256">Uso de texto XAML</span><span class="sxs-lookup"><span data-stu-id="9b023-256">XAML Text Usage</span></span>  
 <span data-ttu-id="9b023-257">Os membros dessa classe não são normalmente usados em [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span><span class="sxs-lookup"><span data-stu-id="9b023-257">Members of this class are not typically used in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9b023-258">O exemplo a seguir obtém os metadados padrão da dependência de vários campos de propriedade, consulta o valor de vários <xref:System.Windows.FrameworkPropertyMetadata> propriedades nele e usa as informações para preencher uma tabela para implementar um navegador de metadados"".</span><span class="sxs-lookup"><span data-stu-id="9b023-258">The following example obtains the default metadata from various dependency property fields, queries the value of various <xref:System.Windows.FrameworkPropertyMetadata> properties on it, and uses the information to populate a table to implement a "metadata browser".</span></span>  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="9b023-259">Os metadados já foram aplicados à operação de propriedade de dependência, portanto os metadados estão selados e as propriedades dos metadados não podem ser definidas.</span><span class="sxs-lookup"><span data-stu-id="9b023-259">The metadata has already been applied to a dependency property operation, so that metadata is sealed and properties of the metadata cannot be set.</span></span></exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
        <altmember cref="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)" />
      </Docs>
    </Member>
    <Member MemberName="AffectsParentArrange">
      <MemberSignature Language="C#" Value="public bool AffectsParentArrange { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AffectsParentArrange" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange" />
      <MemberSignature Language="VB.NET" Value="Public Property AffectsParentArrange As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AffectsParentArrange { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AffectsParentArrange : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.AffectsParentArrange" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9b023-260">Obtém ou define um valor que indica se uma propriedade de dependência potencialmente afeta a passagem de organização do layout do respectivo elemento pai durante operações de mecanismo de layout.</span><span class="sxs-lookup"><span data-stu-id="9b023-260">Gets or sets a value that indicates whether a dependency property potentially affects the arrange pass of its parent element's layout during layout engine operations.</span></span></summary>
        <value><span data-ttu-id="9b023-261"><see langword="true" /> Se a propriedade de dependência na qual esses metadados existem potencialmente afetar a passagem de organização especificamente no seu elemento pai; Caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="9b023-261"><see langword="true" /> if the dependency property on which this metadata exists potentially affects the arrange pass specifically on its parent element; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="9b023-262">O padrão é <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="9b023-262">The default is <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9b023-263"><xref:System.Windows.FrameworkElement> e <xref:System.Windows.FrameworkContentElement> inclui uma implementação do <xref:System.Windows.FrameworkElement.OnPropertyChanged%2A> que monitora as alterações de valor efetivo para todas as propriedades de dependência que existe em um elemento.</span><span class="sxs-lookup"><span data-stu-id="9b023-263"><xref:System.Windows.FrameworkElement> and <xref:System.Windows.FrameworkContentElement> include an implementation of <xref:System.Windows.FrameworkElement.OnPropertyChanged%2A> that monitors effective value changes to all dependency properties that exist on an element.</span></span> <span data-ttu-id="9b023-264">Como parte da lógica, as propriedades de dependência que alteram em vigor a partir de valor e tem metadados com <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> definido como `true` iniciará uma solicitação adiada para invalidar os visuais para o elemento pai.</span><span class="sxs-lookup"><span data-stu-id="9b023-264">As part of that logic, dependency properties that change effective value and have metadata with <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> set to `true` will initiate a deferred request to invalidate the visuals for the parent element.</span></span>  
  
 <span data-ttu-id="9b023-265">Em geral, você não precisa para relatar alterações de um <xref:System.Windows.FrameworkElement> propriedade para um elemento pai usando <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> porque o elemento em si já deve ter seu próprio <xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A> como `true`.</span><span class="sxs-lookup"><span data-stu-id="9b023-265">Generally, you do not need to report changes of a <xref:System.Windows.FrameworkElement> property to a parent element using <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> because the element itself would already have its own <xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A> as `true`.</span></span> <span data-ttu-id="9b023-266">Que normalmente é suficiente, como alterações no elemento filho geralmente iniciam um pai organizar quando apropriado.</span><span class="sxs-lookup"><span data-stu-id="9b023-266">That is usually sufficient, because changes in the child element generally initiate a parent arrange when appropriate.</span></span> <span data-ttu-id="9b023-267"><xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> às vezes é usado para um <xref:System.Windows.FrameworkContentElement> classe derivada.</span><span class="sxs-lookup"><span data-stu-id="9b023-267"><xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> is sometimes used for a <xref:System.Windows.FrameworkContentElement> derived class.</span></span> <span data-ttu-id="9b023-268">Nesse caso, os conjuntos de elemento filho, uma propriedade, mas um <xref:System.Windows.FrameworkContentElement> classe derivada não controla seu próprio processamento.</span><span class="sxs-lookup"><span data-stu-id="9b023-268">In this case, the child element sets a property, but a <xref:System.Windows.FrameworkContentElement> derived class does not control its own rendering.</span></span> <span data-ttu-id="9b023-269">O processamento é tratado por um <xref:System.Windows.FrameworkElement> elemento pai que serve como o host de conteúdo.</span><span class="sxs-lookup"><span data-stu-id="9b023-269">The rendering is handled by a <xref:System.Windows.FrameworkElement> parent element that serves as the content host.</span></span> <span data-ttu-id="9b023-270">Por exemplo, uma alteração no valor da <xref:System.Windows.Documents.FixedPage.Left%2A?displayProperty=nameWithType> invalida a propriedade anexada por um elemento filho organizar do pai, porque a posição do filho no pai deve ser alterada.</span><span class="sxs-lookup"><span data-stu-id="9b023-270">For instance, a change to the value of the <xref:System.Windows.Documents.FixedPage.Left%2A?displayProperty=nameWithType> attached property by a child element invalidates arrange of the parent, because the position of the child in the parent must be changed.</span></span> <span data-ttu-id="9b023-271">Portanto, o <xref:System.Windows.Documents.FixedPage.Left%2A?displayProperty=nameWithType> propriedade anexada tem metadados em que <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> é `true`.</span><span class="sxs-lookup"><span data-stu-id="9b023-271">Therefore, the <xref:System.Windows.Documents.FixedPage.Left%2A?displayProperty=nameWithType> attached property has metadata where <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> is `true`.</span></span> <span data-ttu-id="9b023-272">Outro exemplo é <xref:System.Windows.Controls.Control.Padding%2A>; quando essa propriedade é alterada, o pai pode alterar o posicionamento do filho, dependendo do espaço disponível.</span><span class="sxs-lookup"><span data-stu-id="9b023-272">Another example is <xref:System.Windows.Controls.Control.Padding%2A>; when this property changes, the parent might change the positioning of the child, depending on available space.</span></span>  
  
 <span data-ttu-id="9b023-273">Como essa implementação de nível de framework WPF já está em vigor, você normalmente não é necessário procurar por propriedades de dependência com <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> , a menos que você estiver substituindo ou modificando o comportamento de layout de nível de framework WPF substancialmente.</span><span class="sxs-lookup"><span data-stu-id="9b023-273">Because this WPF framework-level implementation is already in place, you typically do not need to look for dependency properties with <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> unless you are substantially replacing or modifying the WPF framework-level layout behavior.</span></span>  
  
 <span data-ttu-id="9b023-274">Custom <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> implementações poderá optar por ter um comportamento semelhante para alterações de propriedade de dependência em que <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> é `true`.</span><span class="sxs-lookup"><span data-stu-id="9b023-274">Custom <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> implementations might choose to have similar behavior for dependency property changes where <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> is `true`.</span></span>  
  
 <span data-ttu-id="9b023-275">Propriedades em qualquer classes derivadas de <xref:System.Windows.PropertyMetadata> geralmente são definidos no modelo de objeto como leitura-gravação.</span><span class="sxs-lookup"><span data-stu-id="9b023-275">Properties on any derived classes of <xref:System.Windows.PropertyMetadata> are typically defined in the object model as read-write.</span></span> <span data-ttu-id="9b023-276">Isso é para que eles podem ser ajustados após a inicialização da instância.</span><span class="sxs-lookup"><span data-stu-id="9b023-276">This is so they can be adjusted after initialization of the instance.</span></span> <span data-ttu-id="9b023-277">No entanto, depois que os metadados são consumidos como parte de uma chamada para <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, ou <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, o sistema de propriedades será lacrar essa instância de metadados e propriedades que transmitem as especificidades dos metadados agora são consideradas imutáveis.</span><span class="sxs-lookup"><span data-stu-id="9b023-277">However, after the metadata is consumed as part of a call to <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, or <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, the property system will seal that metadata instance and properties that convey the specifics of the metadata are now considered immutable.</span></span> <span data-ttu-id="9b023-278">Tentativa de definir essa propriedade após <xref:System.Windows.PropertyMetadata.IsSealed%2A> é `true` nesses metadados instância gerarão uma exceção.</span><span class="sxs-lookup"><span data-stu-id="9b023-278">Attempting to set this property after <xref:System.Windows.PropertyMetadata.IsSealed%2A> is `true` on this metadata instance will raise an exception.</span></span>  
  
<a name="xamlTextUsage_AffectsParentArrange"></a>   
## <a name="xaml-text-usage"></a><span data-ttu-id="9b023-279">Uso de texto XAML</span><span class="sxs-lookup"><span data-stu-id="9b023-279">XAML Text Usage</span></span>  
 <span data-ttu-id="9b023-280">Os membros dessa classe não são normalmente usados em [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span><span class="sxs-lookup"><span data-stu-id="9b023-280">Members of this class are not typically used in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="9b023-281">Os metadados já foram aplicados à operação de propriedade de dependência, portanto os metadados estão selados e as propriedades dos metadados não podem ser definidas.</span><span class="sxs-lookup"><span data-stu-id="9b023-281">The metadata has already been applied to a dependency property operation, so that metadata is sealed and properties of the metadata cannot be set.</span></span></exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="AffectsParentMeasure">
      <MemberSignature Language="C#" Value="public bool AffectsParentMeasure { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AffectsParentMeasure" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure" />
      <MemberSignature Language="VB.NET" Value="Public Property AffectsParentMeasure As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AffectsParentMeasure { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AffectsParentMeasure : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9b023-282">Obtém ou define um valor que indica se uma propriedade de dependência potencialmente afeta a passagem de medida do layout do respectivo elemento pai durante operações de mecanismo de layout.</span><span class="sxs-lookup"><span data-stu-id="9b023-282">Gets or sets a value that indicates whether a dependency property potentially affects the measure pass of its parent element's layout during layout engine operations.</span></span></summary>
        <value><span data-ttu-id="9b023-283"><see langword="true" /> Se a propriedade de dependência na qual esses metadados existem potencialmente afetar a passagem de medida especificamente no seu elemento pai; Caso contrário, <see langword="false" />. O padrão é <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="9b023-283"><see langword="true" /> if the dependency property on which this metadata exists potentially affects the measure pass specifically on its parent element; otherwise, <see langword="false" />.The default is <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9b023-284"><xref:System.Windows.FrameworkElement> e <xref:System.Windows.FrameworkContentElement> inclui uma implementação do <xref:System.Windows.FrameworkElement.OnPropertyChanged%2A> que monitora as alterações de valor efetivo para todas as propriedades de dependência que existe em um elemento.</span><span class="sxs-lookup"><span data-stu-id="9b023-284"><xref:System.Windows.FrameworkElement> and <xref:System.Windows.FrameworkContentElement> include an implementation of <xref:System.Windows.FrameworkElement.OnPropertyChanged%2A> that monitors effective value changes to all dependency properties that exist on an element.</span></span> <span data-ttu-id="9b023-285">Como parte da lógica, as propriedades de dependência que alteram em vigor a partir de valor e tem metadados com <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> definido como `true` iniciará uma solicitação adiada para invalidar os visuais para o elemento pai.</span><span class="sxs-lookup"><span data-stu-id="9b023-285">As part of that logic, dependency properties that change effective value and have metadata with <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> set to `true` will initiate a deferred request to invalidate the visuals for the parent element.</span></span> <span data-ttu-id="9b023-286">Como essa implementação de nível de framework WPF já está em vigor, você normalmente não é necessário procurar por propriedades de dependência com <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> , a menos que você estiver substituindo ou modificando o comportamento de layout de nível de framework WPF substancialmente.</span><span class="sxs-lookup"><span data-stu-id="9b023-286">Because this WPF framework-level implementation is already in place, you typically do not need to look for dependency properties with <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> unless you are substantially replacing or modifying the WPF framework-level layout behavior.</span></span>  
  
 <span data-ttu-id="9b023-287">Em geral, você não precisa para relatar alterações de um <xref:System.Windows.FrameworkElement> propriedade para um elemento pai usando <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> porque o elemento em si já deve ter seu próprio <xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> como `true`.</span><span class="sxs-lookup"><span data-stu-id="9b023-287">Generally, you do not need to report changes of a <xref:System.Windows.FrameworkElement> property to a parent element using <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> because the element itself would already have its own <xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> as `true`.</span></span> <span data-ttu-id="9b023-288">Que normalmente é suficiente, como alterações no elemento filho geralmente iniciam uma passagem de medida pai quando apropriado.</span><span class="sxs-lookup"><span data-stu-id="9b023-288">That is usually sufficient, because changes in the child element generally initiate a parent measure pass when appropriate.</span></span> <span data-ttu-id="9b023-289"><xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> às vezes é usado para um <xref:System.Windows.FrameworkContentElement> classe derivada.</span><span class="sxs-lookup"><span data-stu-id="9b023-289"><xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> is sometimes used for a <xref:System.Windows.FrameworkContentElement> derived class.</span></span> <span data-ttu-id="9b023-290">Nesse caso, os conjuntos de elemento filho, uma propriedade, mas um <xref:System.Windows.FrameworkContentElement> classe derivada não controla seu próprio processamento.</span><span class="sxs-lookup"><span data-stu-id="9b023-290">In this case, the child element sets a property, but a <xref:System.Windows.FrameworkContentElement> derived class does not control its own rendering.</span></span> <span data-ttu-id="9b023-291">O processamento é tratado por um <xref:System.Windows.FrameworkElement> elemento pai que serve como o host de conteúdo.</span><span class="sxs-lookup"><span data-stu-id="9b023-291">The rendering is handled by a <xref:System.Windows.FrameworkElement> parent element that serves as the content host.</span></span> <span data-ttu-id="9b023-292">Por exemplo, uma alteração no valor da <xref:System.Windows.Documents.Paragraph.KeepWithNext%2A?displayProperty=nameWithType> propriedade por um elemento filho invalida a medida do pai, porque o espaçamento relativo entre parágrafos pode alterar e pode aumentar ou diminuir o tamanho do host de conteúdo.</span><span class="sxs-lookup"><span data-stu-id="9b023-292">For instance, a change to the value of the <xref:System.Windows.Documents.Paragraph.KeepWithNext%2A?displayProperty=nameWithType> property by a child element invalidates measure of the parent, because the relative spacing of paragraphs might change and might increase or decrease the content host size.</span></span> <span data-ttu-id="9b023-293">Portanto, o <xref:System.Windows.Documents.Paragraph.KeepWithNext%2A?displayProperty=nameWithType> propriedade tem metadados em que <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> é `true`.</span><span class="sxs-lookup"><span data-stu-id="9b023-293">Therefore, the <xref:System.Windows.Documents.Paragraph.KeepWithNext%2A?displayProperty=nameWithType> property has metadata where <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> is `true`.</span></span>  
  
 <span data-ttu-id="9b023-294">Elementos de host de conteúdo também frequentemente procure as alterações nas propriedades de dependência em que <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> é `true`, como parte da lógica de processamento do host de conteúdo.</span><span class="sxs-lookup"><span data-stu-id="9b023-294">Content host elements also frequently look for changes in dependency properties where <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> is `true`, as part of content host rendering logic.</span></span> <span data-ttu-id="9b023-295">Por exemplo, o <xref:System.Windows.Controls.TextBox> elemento deve responder a determinadas alterações dentro do texto que podem exigir que a caixa delimitadora do <xref:System.Windows.Controls.TextBox> em si ser alterado.</span><span class="sxs-lookup"><span data-stu-id="9b023-295">For instance, the <xref:System.Windows.Controls.TextBox> element must respond to certain changes within text that might require that the bounding box of the <xref:System.Windows.Controls.TextBox> itself be changed.</span></span>  
  
 <span data-ttu-id="9b023-296">Custom <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> implementações poderá optar por ter um comportamento semelhante para alterações de propriedade de dependência em que <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> é `true`.</span><span class="sxs-lookup"><span data-stu-id="9b023-296">Custom <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> implementations might choose to have similar behavior for dependency property changes where <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> is `true`.</span></span>  
  
 <span data-ttu-id="9b023-297">Propriedades em qualquer classes derivadas de <xref:System.Windows.PropertyMetadata> geralmente são definidos no modelo de objeto como leitura-gravação.</span><span class="sxs-lookup"><span data-stu-id="9b023-297">Properties on any derived classes of <xref:System.Windows.PropertyMetadata> are typically defined in the object model as read-write.</span></span> <span data-ttu-id="9b023-298">Isso é para que eles podem ser ajustados após a inicialização da instância.</span><span class="sxs-lookup"><span data-stu-id="9b023-298">This is so they can be adjusted after initialization of the instance.</span></span> <span data-ttu-id="9b023-299">No entanto, depois que os metadados são consumidos como parte de uma chamada para <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, ou <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, o sistema de propriedades será lacrar essa instância de metadados e propriedades que transmitem as especificidades dos metadados agora são consideradas imutáveis.</span><span class="sxs-lookup"><span data-stu-id="9b023-299">However, after the metadata is consumed as part of a call to <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, or <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, the property system will seal that metadata instance and properties that convey the specifics of the metadata are now considered immutable.</span></span> <span data-ttu-id="9b023-300">Tentativa de definir essa propriedade após <xref:System.Windows.PropertyMetadata.IsSealed%2A> é `true` nesses metadados instância gerarão uma exceção.</span><span class="sxs-lookup"><span data-stu-id="9b023-300">Attempting to set this property after <xref:System.Windows.PropertyMetadata.IsSealed%2A> is `true` on this metadata instance will raise an exception.</span></span>  
  
<a name="xamlTextUsage_AffectsParentMeasure"></a>   
## <a name="xaml-text-usage"></a><span data-ttu-id="9b023-301">Uso de texto XAML</span><span class="sxs-lookup"><span data-stu-id="9b023-301">XAML Text Usage</span></span>  
 <span data-ttu-id="9b023-302">Os membros dessa classe não são normalmente usados em [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span><span class="sxs-lookup"><span data-stu-id="9b023-302">Members of this class are not typically used in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="9b023-303">Os metadados já foram aplicados à operação de propriedade de dependência, portanto os metadados estão selados e as propriedades dos metadados não podem ser definidas.</span><span class="sxs-lookup"><span data-stu-id="9b023-303">The metadata has already been applied to a dependency property operation, so that metadata is sealed and properties of the metadata cannot be set.</span></span></exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="AffectsRender">
      <MemberSignature Language="C#" Value="public bool AffectsRender { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AffectsRender" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.AffectsRender" />
      <MemberSignature Language="VB.NET" Value="Public Property AffectsRender As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AffectsRender { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AffectsRender : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.AffectsRender" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9b023-304">Obtém ou define um valor que indica se uma propriedade de dependência pode afetar o layout geral de algum modo que não influencie especificamente a organização ou medida, mas que exigiria um redesenho.</span><span class="sxs-lookup"><span data-stu-id="9b023-304">Gets or sets a value that indicates whether a dependency property potentially affects the general layout in some way that does not specifically influence arrangement or measurement, but would require a redraw.</span></span></summary>
        <value><span data-ttu-id="9b023-305"><see langword="true" /> se a propriedade de dependência na qual esses metadados existem afeta a renderização; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="9b023-305"><see langword="true" /> if the dependency property on which this metadata exists affects rendering; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="9b023-306">O padrão é <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="9b023-306">The default is <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9b023-307"><xref:System.Windows.FrameworkElement> e <xref:System.Windows.FrameworkContentElement> inclui uma implementação do <xref:System.Windows.FrameworkElement.OnPropertyChanged%2A> que monitora as alterações de valor efetivo para todas as propriedades de dependência que existe em um elemento.</span><span class="sxs-lookup"><span data-stu-id="9b023-307"><xref:System.Windows.FrameworkElement> and <xref:System.Windows.FrameworkContentElement> include an implementation of <xref:System.Windows.FrameworkElement.OnPropertyChanged%2A> that monitors effective value changes to all dependency properties that exist on an element.</span></span> <span data-ttu-id="9b023-308">Como parte da lógica, as propriedades de dependência que alteram em vigor a partir de valor e tem metadados com <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A> definido como `true` iniciará uma solicitação adiada para invalidar os visuais para esse elemento.</span><span class="sxs-lookup"><span data-stu-id="9b023-308">As part of that logic, dependency properties that change effective value and have metadata with <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A> set to `true` will initiate a deferred request to invalidate the visuals for that element.</span></span> <span data-ttu-id="9b023-309">Como essa implementação de nível de framework WPF já está em vigor, você normalmente não é necessário procurar por propriedades de dependência com <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A> , a menos que você estiver substituindo ou modificando o comportamento de layout de nível de framework WPF substancialmente.</span><span class="sxs-lookup"><span data-stu-id="9b023-309">Because this WPF framework-level implementation is already in place, you typically do not need to look for dependency properties with <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A> unless you are substantially replacing or modifying the WPF framework-level layout behavior.</span></span>  
  
 <span data-ttu-id="9b023-310">Custom <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> implementações poderá optar por ter um comportamento semelhante para alterações de propriedade de dependência em que <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A> é `true`.</span><span class="sxs-lookup"><span data-stu-id="9b023-310">Custom <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> implementations might choose to have similar behavior for dependency property changes where <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A> is `true`.</span></span>  
  
 <span data-ttu-id="9b023-311">Propriedades em qualquer classes derivadas de <xref:System.Windows.PropertyMetadata> geralmente são definidos no modelo de objeto como leitura-gravação.</span><span class="sxs-lookup"><span data-stu-id="9b023-311">Properties on any derived classes of <xref:System.Windows.PropertyMetadata> are typically defined in the object model as read-write.</span></span> <span data-ttu-id="9b023-312">Isso é para que eles podem ser ajustados após a inicialização da instância.</span><span class="sxs-lookup"><span data-stu-id="9b023-312">This is so they can be adjusted after initialization of the instance.</span></span> <span data-ttu-id="9b023-313">No entanto, depois que os metadados são consumidos como parte de uma chamada para <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, ou <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, o sistema de propriedades será lacrar essa instância de metadados e propriedades que transmitem as especificidades dos metadados agora são consideradas imutáveis.</span><span class="sxs-lookup"><span data-stu-id="9b023-313">However, after the metadata is consumed as part of a call to <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, or <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, the property system will seal that metadata instance and properties that convey the specifics of the metadata are now considered immutable.</span></span> <span data-ttu-id="9b023-314">Tentativa de definir essa propriedade após <xref:System.Windows.PropertyMetadata.IsSealed%2A> é `true` nesses metadados instância gerarão uma exceção.</span><span class="sxs-lookup"><span data-stu-id="9b023-314">Attempting to set this property after <xref:System.Windows.PropertyMetadata.IsSealed%2A> is `true` on this metadata instance will raise an exception.</span></span>  
  
<a name="xamlTextUsage_AffectsRender"></a>   
## <a name="xaml-text-usage"></a><span data-ttu-id="9b023-315">Uso de texto XAML</span><span class="sxs-lookup"><span data-stu-id="9b023-315">XAML Text Usage</span></span>  
 <span data-ttu-id="9b023-316">Os membros dessa classe não são normalmente usados em [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span><span class="sxs-lookup"><span data-stu-id="9b023-316">Members of this class are not typically used in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9b023-317">O exemplo a seguir obtém os metadados padrão da dependência de vários campos de propriedade, consulta o valor de vários <xref:System.Windows.FrameworkPropertyMetadata> propriedades nele e usa as informações para preencher uma tabela para implementar um navegador de metadados"".</span><span class="sxs-lookup"><span data-stu-id="9b023-317">The following example obtains the default metadata from various dependency property fields, queries the value of various <xref:System.Windows.FrameworkPropertyMetadata> properties on it, and uses the information to populate a table to implement a "metadata browser".</span></span>  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="9b023-318">Os metadados já foram aplicados à operação de propriedade de dependência, portanto os metadados estão selados e as propriedades dos metadados não podem ser definidas.</span><span class="sxs-lookup"><span data-stu-id="9b023-318">The metadata has already been applied to a dependency property operation, so that metadata is sealed and properties of the metadata cannot be set.</span></span></exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="BindsTwoWayByDefault">
      <MemberSignature Language="C#" Value="public bool BindsTwoWayByDefault { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool BindsTwoWayByDefault" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault" />
      <MemberSignature Language="VB.NET" Value="Public Property BindsTwoWayByDefault As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool BindsTwoWayByDefault { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.BindsTwoWayByDefault : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9b023-319">Obtém ou define um valor que indica se a propriedade associa de forma bidirecional por padrão.</span><span class="sxs-lookup"><span data-stu-id="9b023-319">Gets or sets a value that indicates whether the property binds two-way by default.</span></span></summary>
        <value><span data-ttu-id="9b023-320"><see langword="true" /> se a propriedade de dependência na qual esses metadados existem associa de forma bidirecional por padrão. Caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="9b023-320"><see langword="true" /> if the dependency property on which this metadata exists binds two-way by default; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="9b023-321">O padrão é <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="9b023-321">The default is <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9b023-322">Na ausência dessa propriedade está sendo `true`, as atualizações de vinculação são unidirecionais por padrão, com base no comportamento padrão do <xref:System.Windows.Data.Binding> construtores ou equivalente [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] sintaxe.</span><span class="sxs-lookup"><span data-stu-id="9b023-322">In absence of this property being `true`, binding updates are one-way by default, based on the default behavior of the <xref:System.Windows.Data.Binding> constructors or equivalent [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] syntax.</span></span>  
  
 <span data-ttu-id="9b023-323">Os elementos existentes, você normalmente encontrará essa propriedade definida como `true` nos metadados para propriedades de dependência que ambos relatam o estado e são modificáveis por ação do usuário, por exemplo <xref:System.Windows.Controls.Primitives.Selector.IsSelected%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="9b023-323">In existing elements, you will usually find this property set to `true` in metadata for dependency properties that both report state and are modifiable by user action, for example <xref:System.Windows.Controls.Primitives.Selector.IsSelected%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="9b023-324">Essa propriedade só reporta as características de atualização de associação padrão da propriedade de dependência em geral.</span><span class="sxs-lookup"><span data-stu-id="9b023-324">This property only reports the default binding update characteristics of the dependency property in general.</span></span> <span data-ttu-id="9b023-325">Qualquer associação definida para essa propriedade em uma instância localmente pode definir o <xref:System.Windows.Data.Binding.Mode%2A> propriedade da associação e alterar esse padrão.</span><span class="sxs-lookup"><span data-stu-id="9b023-325">Any binding set to this property on an instance can locally set the <xref:System.Windows.Data.Binding.Mode%2A> property of the binding and change this default.</span></span>  
  
 <span data-ttu-id="9b023-326">Propriedades em qualquer classes derivadas de <xref:System.Windows.PropertyMetadata> geralmente são definidos no modelo de objeto como leitura-gravação.</span><span class="sxs-lookup"><span data-stu-id="9b023-326">Properties on any derived classes of <xref:System.Windows.PropertyMetadata> are typically defined in the object model as read-write.</span></span> <span data-ttu-id="9b023-327">Isso é para que eles podem ser ajustados após a inicialização da instância.</span><span class="sxs-lookup"><span data-stu-id="9b023-327">This is so they can be adjusted after initialization of the instance.</span></span> <span data-ttu-id="9b023-328">No entanto, depois que os metadados são consumidos como parte de uma chamada para <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, ou <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, o sistema de propriedades será lacrar essa instância de metadados e propriedades que transmitem as especificidades dos metadados agora são consideradas imutáveis.</span><span class="sxs-lookup"><span data-stu-id="9b023-328">However, after the metadata is consumed as part of a call to <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, or <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, the property system will seal that metadata instance and properties that convey the specifics of the metadata are now considered immutable.</span></span> <span data-ttu-id="9b023-329">Tentativa de definir essa propriedade após <xref:System.Windows.PropertyMetadata.IsSealed%2A> é `true` nesses metadados instância gerarão uma exceção.</span><span class="sxs-lookup"><span data-stu-id="9b023-329">Attempting to set this property after <xref:System.Windows.PropertyMetadata.IsSealed%2A> is `true` on this metadata instance will raise an exception.</span></span>  
  
<a name="xamlTextUsage_BindsTwoWayByDefault"></a>   
## <a name="xaml-text-usage"></a><span data-ttu-id="9b023-330">Uso de texto XAML</span><span class="sxs-lookup"><span data-stu-id="9b023-330">XAML Text Usage</span></span>  
 <span data-ttu-id="9b023-331">Os membros dessa classe não são normalmente usados em [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span><span class="sxs-lookup"><span data-stu-id="9b023-331">Members of this class are not typically used in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9b023-332">O exemplo a seguir obtém os metadados padrão da dependência de vários campos de propriedade, consulta o valor de vários <xref:System.Windows.FrameworkPropertyMetadata> propriedades nele e usa as informações para preencher uma tabela para implementar um navegador de metadados"".</span><span class="sxs-lookup"><span data-stu-id="9b023-332">The following example obtains the default metadata from various dependency property fields, queries the value of various <xref:System.Windows.FrameworkPropertyMetadata> properties on it, and uses the information to populate a table to implement a "metadata browser".</span></span>  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="9b023-333">Os metadados já foram aplicados à operação de propriedade de dependência, portanto os metadados estão selados e as propriedades dos metadados não podem ser definidas.</span><span class="sxs-lookup"><span data-stu-id="9b023-333">The metadata has already been applied to a dependency property operation, so that metadata is sealed and properties of the metadata cannot be set.</span></span></exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="DefaultUpdateSourceTrigger">
      <MemberSignature Language="C#" Value="public System.Windows.Data.UpdateSourceTrigger DefaultUpdateSourceTrigger { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Data.UpdateSourceTrigger DefaultUpdateSourceTrigger" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.DefaultUpdateSourceTrigger" />
      <MemberSignature Language="VB.NET" Value="Public Property DefaultUpdateSourceTrigger As UpdateSourceTrigger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Data::UpdateSourceTrigger DefaultUpdateSourceTrigger { System::Windows::Data::UpdateSourceTrigger get(); void set(System::Windows::Data::UpdateSourceTrigger value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultUpdateSourceTrigger : System.Windows.Data.UpdateSourceTrigger with get, set" Usage="System.Windows.FrameworkPropertyMetadata.DefaultUpdateSourceTrigger" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.UpdateSourceTrigger</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9b023-334">Obtém ou define o padrão para <see cref="T:System.Windows.Data.UpdateSourceTrigger" /> a ser usado quando as associações para a propriedade com esses metadados forem aplicadas, que têm seus <see cref="T:System.Windows.Data.UpdateSourceTrigger" /> definidos como <see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" />.</span><span class="sxs-lookup"><span data-stu-id="9b023-334">Gets or sets the default for <see cref="T:System.Windows.Data.UpdateSourceTrigger" /> to use when bindings for the property with this metadata are applied, which have their <see cref="T:System.Windows.Data.UpdateSourceTrigger" /> set to <see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" />.</span></span></summary>
        <value><span data-ttu-id="9b023-335">Um valor da enumeração, diferente de <see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" />.</span><span class="sxs-lookup"><span data-stu-id="9b023-335">A value of the enumeration, other than <see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9b023-336">Propriedades em classes derivadas de <xref:System.Windows.PropertyMetadata> geralmente são definidos no modelo de objeto como leitura-gravação.</span><span class="sxs-lookup"><span data-stu-id="9b023-336">Properties on derived classes of <xref:System.Windows.PropertyMetadata> are typically defined in the object model as read-write.</span></span> <span data-ttu-id="9b023-337">Isso é para que eles podem ser ajustados após a inicialização da instância.</span><span class="sxs-lookup"><span data-stu-id="9b023-337">This is so they can be adjusted after initialization of the instance.</span></span> <span data-ttu-id="9b023-338">No entanto, depois que os metadados são consumidos como parte de uma chamada para <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, ou <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, o sistema de propriedades será lacrar essa instância de metadados e propriedades que transmitem as especificidades dos metadados agora são consideradas imutáveis.</span><span class="sxs-lookup"><span data-stu-id="9b023-338">However, after the metadata is consumed as part of a call to <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, or <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, the property system will seal that metadata instance and properties that convey the specifics of the metadata are now considered immutable.</span></span> <span data-ttu-id="9b023-339">Tentativa de definir essa propriedade após <xref:System.Windows.PropertyMetadata.IsSealed%2A> é `true` nesses metadados instância gerarão uma exceção.</span><span class="sxs-lookup"><span data-stu-id="9b023-339">Attempting to set this property after <xref:System.Windows.PropertyMetadata.IsSealed%2A> is `true` on this metadata instance will raise an exception.</span></span>  
  
<a name="xamlTextUsage_DefaultUpdateSourceTrigger"></a>   
## <a name="xaml-text-usage"></a><span data-ttu-id="9b023-340">Uso de texto XAML</span><span class="sxs-lookup"><span data-stu-id="9b023-340">XAML Text Usage</span></span>  
 <span data-ttu-id="9b023-341">Os membros dessa classe não são normalmente usados em [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span><span class="sxs-lookup"><span data-stu-id="9b023-341">Members of this class are not typically used in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="9b023-342">Essa propriedade está definida como <see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" />; o valor definido deve se tornar o padrão quando solicitado por associações.</span><span class="sxs-lookup"><span data-stu-id="9b023-342">This property is set to <see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" />; the value you set is supposed to become the default when requested by bindings.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="9b023-343">Os metadados já foram aplicados à operação de propriedade de dependência, portanto os metadados estão selados e as propriedades dos metadados não podem ser definidas.</span><span class="sxs-lookup"><span data-stu-id="9b023-343">The metadata has already been applied to a dependency property operation, so that metadata is sealed and properties of the metadata cannot be set.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Inherits">
      <MemberSignature Language="C#" Value="public bool Inherits { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Inherits" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.Inherits" />
      <MemberSignature Language="VB.NET" Value="Public Property Inherits As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Inherits { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Inherits : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.Inherits" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9b023-344">Obtém ou define um valor que indica se o valor da propriedade de dependência é herdável.</span><span class="sxs-lookup"><span data-stu-id="9b023-344">Gets or sets a value that indicates whether the value of the dependency property is inheritable.</span></span></summary>
        <value><span data-ttu-id="9b023-345"><see langword="true" /> se o valor da propriedade for herdável, caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="9b023-345"><see langword="true" /> if the property value is inheritable; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="9b023-346">O padrão é <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="9b023-346">The default is <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9b023-347">Herança do valor da propriedade é um recurso do [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] sistema de propriedades no nível de framework WPF, no qual determinadas propriedades de dependência podem ser definidas localmente em um elemento em ou próximo à raiz de um [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] elemento de árvore e, em seguida, ter seu valor herdado por todos os elementos dentro da árvore lógica de elementos filho que também tenham essa propriedade.</span><span class="sxs-lookup"><span data-stu-id="9b023-347">Property value inheritance is a feature of the [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] property system at the WPF framework level, whereby certain dependency properties can be locally set on an element at or near the root of a [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] element tree and then have their value inherited by all elements within the logical tree of child elements that also possess that property.</span></span> <span data-ttu-id="9b023-348">Herança do valor da propriedade não está habilitada por padrão e permitindo que ele tem algumas implicações de desempenho.</span><span class="sxs-lookup"><span data-stu-id="9b023-348">Property value inheritance is not enabled by default, and enabling it does have some performance implications.</span></span> <span data-ttu-id="9b023-349">Para obter detalhes, consulte [Herança do valor da propriedade](~/docs/framework/wpf/advanced/property-value-inheritance.md).</span><span class="sxs-lookup"><span data-stu-id="9b023-349">For details, see [Property Value Inheritance](~/docs/framework/wpf/advanced/property-value-inheritance.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9b023-350">Embora a herança do valor da propriedade possa parecer funcionar para as propriedades de dependência, o comportamento da herança de uma propriedade não anexada por meio de determinados divisões de objeto do objeto na árvore de tempo de execução é indefinido.</span><span class="sxs-lookup"><span data-stu-id="9b023-350">Although property value inheritance might appear to work for nonattached dependency properties, the inheritance behavior for a nonattached property through certain object-object divisions in the runtime tree is undefined.</span></span> <span data-ttu-id="9b023-351">Sempre use <xref:System.Windows.DependencyProperty.RegisterAttached%2A> para registrar as propriedades em que você especificar <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> nos metadados.</span><span class="sxs-lookup"><span data-stu-id="9b023-351">Always use <xref:System.Windows.DependencyProperty.RegisterAttached%2A> to register properties where you specify <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> in the metadata.</span></span>  
  
 <span data-ttu-id="9b023-352">Propriedades em classes derivadas de <xref:System.Windows.PropertyMetadata> geralmente são definidos no modelo de objeto como leitura-gravação.</span><span class="sxs-lookup"><span data-stu-id="9b023-352">Properties on derived classes of <xref:System.Windows.PropertyMetadata> are typically defined in the object model as read-write.</span></span> <span data-ttu-id="9b023-353">Isso é para que eles podem ser ajustados após a inicialização da instância.</span><span class="sxs-lookup"><span data-stu-id="9b023-353">This is so they can be adjusted after initialization of the instance.</span></span> <span data-ttu-id="9b023-354">No entanto, depois que os metadados são consumidos como parte de uma chamada para <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, ou <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, o sistema de propriedades será lacrar essa instância de metadados e propriedades que transmitem as especificidades dos metadados agora são consideradas imutáveis.</span><span class="sxs-lookup"><span data-stu-id="9b023-354">However, after the metadata is consumed as part of a call to <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, or <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, the property system will seal that metadata instance and properties that convey the specifics of the metadata are now considered immutable.</span></span> <span data-ttu-id="9b023-355">Tentativa de definir essa propriedade após <xref:System.Windows.PropertyMetadata.IsSealed%2A> é `true` nesses metadados instância gerarão uma exceção.</span><span class="sxs-lookup"><span data-stu-id="9b023-355">Attempting to set this property after <xref:System.Windows.PropertyMetadata.IsSealed%2A> is `true` on this metadata instance will raise an exception.</span></span>  
  
<a name="xamlTextUsage_Inherits"></a>   
## <a name="xaml-text-usage"></a><span data-ttu-id="9b023-356">Uso de texto XAML</span><span class="sxs-lookup"><span data-stu-id="9b023-356">XAML Text Usage</span></span>  
 <span data-ttu-id="9b023-357">Os membros dessa classe não são normalmente usados em [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span><span class="sxs-lookup"><span data-stu-id="9b023-357">Members of this class are not typically used in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9b023-358">O exemplo a seguir obtém os metadados padrão da dependência de vários campos de propriedade, consulta o valor de vários <xref:System.Windows.FrameworkPropertyMetadata> propriedades nele e usa as informações para preencher uma tabela para implementar um navegador de metadados"".</span><span class="sxs-lookup"><span data-stu-id="9b023-358">The following example obtains the default metadata from various dependency property fields, queries the value of various <xref:System.Windows.FrameworkPropertyMetadata> properties on it, and uses the information to populate a table to implement a "metadata browser".</span></span>  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="9b023-359">Os metadados já foram aplicados à operação de propriedade de dependência, portanto os metadados estão selados e as propriedades dos metadados não podem ser definidas.</span><span class="sxs-lookup"><span data-stu-id="9b023-359">The metadata has already been applied to a dependency property operation, so that metadata is sealed and properties of the metadata cannot be set.</span></span></exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="IsDataBindingAllowed">
      <MemberSignature Language="C#" Value="public bool IsDataBindingAllowed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDataBindingAllowed" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsDataBindingAllowed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsDataBindingAllowed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDataBindingAllowed : bool" Usage="System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9b023-360">Obtém um valor que indica se a associação de dados é compatível com a propriedade de dependência.</span><span class="sxs-lookup"><span data-stu-id="9b023-360">Gets a value that indicates whether data binding is supported for the dependency property.</span></span></summary>
        <value><span data-ttu-id="9b023-361"><see langword="true" /> Se a associação de dados é compatível com a propriedade de dependência à qual esses metadados se aplica; Caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="9b023-361"><see langword="true" /> if data binding is supported on the dependency property to which this metadata applies; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="9b023-362">O padrão é <see langword="true" />.</span><span class="sxs-lookup"><span data-stu-id="9b023-362">The default is <see langword="true" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9b023-363">Essa propriedade informa `false` para uma das duas condições possíveis: qualquer associação de dados a uma propriedade de dependência não é permitida porque a propriedade de dependência é somente leitura (conforme relatado no identificador de propriedade de dependência, não os metadados), ou o valor de outra propriedade de metadados, <xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>, é definido como `true` nesses metadados.</span><span class="sxs-lookup"><span data-stu-id="9b023-363">This property reports `false` for one of two possible conditions: either data binding to a dependency property is not allowed because the dependency property is read-only (as reported in the dependency property identifier, not the metadata), or the value of another metadata property, <xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>, is set to `true` in this metadata.</span></span> <span data-ttu-id="9b023-364">Essa propriedade é exposta como uma conveniência para que os chamadores não precise marque ambos <xref:System.Windows.DependencyProperty.ReadOnly%2A> e <xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>.</span><span class="sxs-lookup"><span data-stu-id="9b023-364">This property is exposed as a convenience so that callers do not have to check both <xref:System.Windows.DependencyProperty.ReadOnly%2A> and <xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>.</span></span>  
  
 <span data-ttu-id="9b023-365">Se você estiver tentando criar os metadados que especifica que uma propriedade de leitura/gravação. caso contrário, não deve oferecer suporte a associação de dados, especifique o sinalizador <xref:System.Windows.FrameworkPropertyMetadataOptions.NotDataBindable> (Observe a diferença de convenção de nomenclatura pequena versus <xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>).</span><span class="sxs-lookup"><span data-stu-id="9b023-365">If you are attempting to create metadata that specifies that an otherwise read/write property should not support data binding, specify the flag <xref:System.Windows.FrameworkPropertyMetadataOptions.NotDataBindable> (note the slight naming convention difference versus <xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>).</span></span>  
  
<a name="xamlTextUsage_IsDataBindingAllowed"></a>   
## <a name="xaml-text-usage"></a><span data-ttu-id="9b023-366">Uso de texto XAML</span><span class="sxs-lookup"><span data-stu-id="9b023-366">XAML Text Usage</span></span>  
 <span data-ttu-id="9b023-367">Os membros dessa classe não são normalmente usados em [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span><span class="sxs-lookup"><span data-stu-id="9b023-367">Members of this class are not typically used in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9b023-368">O exemplo a seguir obtém os metadados padrão da dependência de vários campos de propriedade, consulta o valor de vários <xref:System.Windows.FrameworkPropertyMetadata> propriedades nele e usa as informações para preencher uma tabela para implementar um navegador de metadados"".</span><span class="sxs-lookup"><span data-stu-id="9b023-368">The following example obtains the default metadata from various dependency property fields, queries the value of various <xref:System.Windows.FrameworkPropertyMetadata> properties on it, and uses the information to populate a table to implement a "metadata browser".</span></span>  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="IsNotDataBindable">
      <MemberSignature Language="C#" Value="public bool IsNotDataBindable { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNotDataBindable" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable" />
      <MemberSignature Language="VB.NET" Value="Public Property IsNotDataBindable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNotDataBindable { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsNotDataBindable : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.IsNotDataBindable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9b023-369">Obtém ou define um valor que indica se o valor da propriedade de dependência é compatível com a associação de dados.</span><span class="sxs-lookup"><span data-stu-id="9b023-369">Gets or sets a value that indicates whether the dependency property supports data binding.</span></span></summary>
        <value><span data-ttu-id="9b023-370"><see langword="true" /> Se a propriedade não dá suporte a associação de dados; Caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="9b023-370"><see langword="true" /> if the property does not support data binding; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="9b023-371">O padrão é <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="9b023-371">The default is <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9b023-372">Observe que essa propriedade de metadados é definida como `true` especificamente para as propriedades que não devem dar suporte a vinculação de dados, apesar de ser propriedades de leitura / gravação.</span><span class="sxs-lookup"><span data-stu-id="9b023-372">Note that this metadata property is set to `true` specifically for properties that should not support data binding, despite being read-write properties.</span></span> <span data-ttu-id="9b023-373">A expectativa é que na maioria dos casos em que uma propriedade de dependência é declarada, vinculação de dados for desejada, como vinculação de dados é um dos principais cenários em que uma propriedade de dependência é útil.</span><span class="sxs-lookup"><span data-stu-id="9b023-373">The expectation is that in most cases where a dependency property is declared, data binding is desired, because data binding is one of the key scenarios where a dependency property is useful.</span></span> <span data-ttu-id="9b023-374">Ao contrário de <xref:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault%2A>, isso não altera simplesmente um padrão que pode ser alterado posteriormente em uma associação específica.</span><span class="sxs-lookup"><span data-stu-id="9b023-374">Unlike <xref:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault%2A>, this does not merely change a default that can later be changed on a specific binding.</span></span> <span data-ttu-id="9b023-375">A definição dessa propriedade `true` nos metadados para uma propriedade de dependência metadados desabilitará todas as associações da aplicação de seus valores por meio de expressões a essa propriedade de dependência.</span><span class="sxs-lookup"><span data-stu-id="9b023-375">Setting this property `true` in the metadata for a dependency property metadata will disable all bindings from applying their values through expressions to that dependency property.</span></span>  
  
 <span data-ttu-id="9b023-376">Propriedades de dependência somente leitura não dão suporte para a associação de dados (porque eles têm nenhum setter que pode aplicar valores alterados), mas ainda será relatório `false` para <xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>.</span><span class="sxs-lookup"><span data-stu-id="9b023-376">Read-only dependency properties do not support data binding (because they have no setter that can apply changed values), but will still report `false` for <xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>.</span></span> <span data-ttu-id="9b023-377">Isso ocorre porque as propriedades que correspondem a um <xref:System.Windows.FrameworkPropertyMetadataOptions> valores relatará paridade com como os metadados foi realmente estabelecido, em vez de emissão de relatórios sempre o comportamento do resultado final implicar a nomenclatura da propriedade.</span><span class="sxs-lookup"><span data-stu-id="9b023-377">This is because properties that correspond to a <xref:System.Windows.FrameworkPropertyMetadataOptions> values will report parity with how the metadata was actually established, rather than always reporting the end result behavior that the naming of the property might imply.</span></span> <span data-ttu-id="9b023-378">Para determinar se uma propriedade de dependência permite que a vinculação de dados, normalmente, você deve verificar <xref:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed%2A> em vez disso.</span><span class="sxs-lookup"><span data-stu-id="9b023-378">To determine whether a given dependency property permits data binding, you should usually check <xref:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed%2A> instead.</span></span> <span data-ttu-id="9b023-379"><xref:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed%2A> é uma conveniência para a verificação de ambos <xref:System.Windows.DependencyProperty.ReadOnly%2A> e <xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A> como uma única operação, produzindo o resultado esperado.</span><span class="sxs-lookup"><span data-stu-id="9b023-379"><xref:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed%2A> is a convenience for checking both <xref:System.Windows.DependencyProperty.ReadOnly%2A> and <xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A> as a single operation, yielding the expected result.</span></span>  
  
 <span data-ttu-id="9b023-380">Propriedades em classes derivadas de <xref:System.Windows.PropertyMetadata> geralmente são definidos no modelo de objeto como leitura-gravação.</span><span class="sxs-lookup"><span data-stu-id="9b023-380">Properties on derived classes of <xref:System.Windows.PropertyMetadata> are typically defined in the object model as read-write.</span></span> <span data-ttu-id="9b023-381">Isso é para que eles podem ser ajustados após a inicialização da instância.</span><span class="sxs-lookup"><span data-stu-id="9b023-381">This is so they can be adjusted after initialization of the instance.</span></span> <span data-ttu-id="9b023-382">No entanto, depois que os metadados são consumidos como parte de uma chamada para <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, ou <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, o sistema de propriedades será lacrar essa instância de metadados e propriedades que transmitem as especificidades dos metadados agora são consideradas imutáveis.</span><span class="sxs-lookup"><span data-stu-id="9b023-382">However, after the metadata is consumed as part of a call to <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, or <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, the property system will seal that metadata instance and properties that convey the specifics of the metadata are now considered immutable.</span></span> <span data-ttu-id="9b023-383">Tentativa de definir essa propriedade após <xref:System.Windows.PropertyMetadata.IsSealed%2A> é `true` nesses metadados instância gerarão uma exceção.</span><span class="sxs-lookup"><span data-stu-id="9b023-383">Attempting to set this property after <xref:System.Windows.PropertyMetadata.IsSealed%2A> is `true` on this metadata instance will raise an exception.</span></span>  
  
<a name="xamlTextUsage_IsNotDataBindable"></a>   
## <a name="xaml-text-usage"></a><span data-ttu-id="9b023-384">Uso de texto XAML</span><span class="sxs-lookup"><span data-stu-id="9b023-384">XAML Text Usage</span></span>  
 <span data-ttu-id="9b023-385">Os membros dessa classe não são normalmente usados em [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span><span class="sxs-lookup"><span data-stu-id="9b023-385">Members of this class are not typically used in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="9b023-386">Os metadados já foram aplicados à operação de propriedade de dependência, portanto os metadados estão selados e as propriedades dos metadados não podem ser definidas.</span><span class="sxs-lookup"><span data-stu-id="9b023-386">The metadata has already been applied to a dependency property operation, so that metadata is sealed and properties of the metadata cannot be set.</span></span></exception>
        <altmember cref="P:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed" />
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="Journal">
      <MemberSignature Language="C#" Value="public bool Journal { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Journal" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.Journal" />
      <MemberSignature Language="VB.NET" Value="Public Property Journal As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Journal { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Journal : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.Journal" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9b023-387">Obtém ou define um valor que indica se esta propriedade contém informações de registro no diário que aplicativos podem ou devem armazenar como parte de uma implementação do registro no diário.</span><span class="sxs-lookup"><span data-stu-id="9b023-387">Gets or sets a value that indicates whether this property contains journaling information that applications can or should store as part of a journaling implementation.</span></span></summary>
        <value><span data-ttu-id="9b023-388"><see langword="true" /> Se o registro no diário deve ser executado na propriedade de dependência que esses metadados foram aplicados Caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="9b023-388"><see langword="true" /> if journaling should be performed on the dependency property that this metadata is applied to; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="9b023-389">O padrão é <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="9b023-389">The default is <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9b023-390">Propriedades em classes derivadas de <xref:System.Windows.PropertyMetadata> geralmente são definidos no modelo de objeto como leitura-gravação.</span><span class="sxs-lookup"><span data-stu-id="9b023-390">Properties on derived classes of <xref:System.Windows.PropertyMetadata> are typically defined in the object model as read-write.</span></span> <span data-ttu-id="9b023-391">Isso é para que eles podem ser ajustados após a inicialização da instância.</span><span class="sxs-lookup"><span data-stu-id="9b023-391">This is so they can be adjusted after initialization of the instance.</span></span> <span data-ttu-id="9b023-392">No entanto, depois que os metadados são consumidos como parte de uma chamada para <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, ou <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, o sistema de propriedades será lacrar essa instância de metadados e propriedades que transmitem as especificidades dos metadados agora são consideradas imutáveis.</span><span class="sxs-lookup"><span data-stu-id="9b023-392">However, after the metadata is consumed as part of a call to <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, or <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, the property system will seal that metadata instance and properties that convey the specifics of the metadata are now considered immutable.</span></span> <span data-ttu-id="9b023-393">Tentativa de definir essa propriedade após <xref:System.Windows.PropertyMetadata.IsSealed%2A> é `true` nesses metadados instância gerarão uma exceção.</span><span class="sxs-lookup"><span data-stu-id="9b023-393">Attempting to set this property after <xref:System.Windows.PropertyMetadata.IsSealed%2A> is `true` on this metadata instance will raise an exception.</span></span>  
  
<a name="xamlTextUsage_Journal"></a>   
## <a name="xaml-text-usage"></a><span data-ttu-id="9b023-394">Uso de texto XAML</span><span class="sxs-lookup"><span data-stu-id="9b023-394">XAML Text Usage</span></span>  
 <span data-ttu-id="9b023-395">Os membros dessa classe não são normalmente usados em [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span><span class="sxs-lookup"><span data-stu-id="9b023-395">Members of this class are not typically used in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="9b023-396">Os metadados já foram aplicados à operação de propriedade de dependência, portanto os metadados estão selados e as propriedades dos metadados não podem ser definidas.</span><span class="sxs-lookup"><span data-stu-id="9b023-396">The metadata has already been applied to a dependency property operation, so that metadata is sealed and properties of the metadata cannot be set.</span></span></exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
        <altmember cref="T:System.Windows.Navigation.JournalEntry" />
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="protected override void Merge (System.Windows.PropertyMetadata baseMetadata, System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Merge(class System.Windows.PropertyMetadata baseMetadata, class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Merge (baseMetadata As PropertyMetadata, dp As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Merge(System::Windows::PropertyMetadata ^ baseMetadata, System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="override this.Merge : System.Windows.PropertyMetadata * System.Windows.DependencyProperty -&gt; unit" Usage="frameworkPropertyMetadata.Merge (baseMetadata, dp)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="baseMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="baseMetadata"><span data-ttu-id="9b023-397">Os metadados de base a serem mesclados.</span><span class="sxs-lookup"><span data-stu-id="9b023-397">The base metadata to merge.</span></span></param>
        <param name="dp"><span data-ttu-id="9b023-398">A propriedade de dependência à qual esses metadados estão sendo aplicados.</span><span class="sxs-lookup"><span data-stu-id="9b023-398">The dependency property this metadata is being applied to.</span></span></param>
        <summary><span data-ttu-id="9b023-399">Permite a mesclagem dos metadados de origem com metadados de base.</span><span class="sxs-lookup"><span data-stu-id="9b023-399">Enables a merge of the source metadata with base metadata.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9b023-400">Esse método é usado internamente quando metadados está sendo substituído.</span><span class="sxs-lookup"><span data-stu-id="9b023-400">This method is used internally when metadata is being overridden.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="9b023-401">Classes que derivam de <see cref="T:System.Windows.PropertyMetadata" /> (ou esta classe particularmente) devem substituir este método para levar em conta as propriedades de metadados que ele adicionou suas implementações.</span><span class="sxs-lookup"><span data-stu-id="9b023-401">Classes that derive from <see cref="T:System.Windows.PropertyMetadata" /> (or this class particularly) should override this method to account for any metadata properties they have added in their implementations.</span></span> <span data-ttu-id="9b023-402">Por exemplo, sua implementação pode ter adicionado um novo valor de enumeração sinalizadora e o <see cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" /> implementação deve ser capaz de combinar esses sinalizadores corretamente.</span><span class="sxs-lookup"><span data-stu-id="9b023-402">For instance, your implementation might have added a new flagwise enumeration value, and the <see cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" /> implementation should then be able to combine those flags correctly.</span></span>  
  
<span data-ttu-id="9b023-403">Sempre chame a implementação base antes da sua própria implementação, porque a implementação base se encarrega da mesclagem de todas as propriedades já definidas nos tipos anteriores na hierarquia.</span><span class="sxs-lookup"><span data-stu-id="9b023-403">Always call the base implementation prior to your own implementation, because the base implementation takes care of merging all the properties already defined on previous types in the hierarchy.</span></span>  
  
<span data-ttu-id="9b023-404">O comportamento adicionado pelo <see cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" /> implementação no <see cref="T:System.Windows.FrameworkPropertyMetadata" /> é que propriedades específicas de nível de framework WPF nos metadados, como <see cref="P:System.Windows.FrameworkPropertyMetadata.AffectsRender" /> são combinados em um bit a bit ou operação.</span><span class="sxs-lookup"><span data-stu-id="9b023-404">The behavior added by the <see cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" /> implementation in <see cref="T:System.Windows.FrameworkPropertyMetadata" /> is that specific WPF framework-level properties in the metadata such as <see cref="P:System.Windows.FrameworkPropertyMetadata.AffectsRender" /> are combined in a bitwise or operation.</span></span>  
  
<span data-ttu-id="9b023-405">O <see cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" /> comportamento também implementa o comportamento quando você substitui os metadados de propriedade em uma propriedade de dependência existente chamando <see cref="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)" />, usando os metadados de substituição é <see cref="T:System.Windows.FrameworkPropertyMetadata" />.</span><span class="sxs-lookup"><span data-stu-id="9b023-405">The <see cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" /> behavior also implements the behavior when you override the property metadata on an existing dependency property by calling <see cref="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)" />, using override metadata that is <see cref="T:System.Windows.FrameworkPropertyMetadata" />.</span></span></para></block>
        <altmember cref="M:System.Windows.PropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />
        <altmember cref="P:System.Windows.PropertyMetadata.IsSealed" />
        <altmember cref="M:System.Windows.FrameworkPropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="OnApply">
      <MemberSignature Language="C#" Value="protected override void OnApply (System.Windows.DependencyProperty dp, Type targetType);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnApply(class System.Windows.DependencyProperty dp, class System.Type targetType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnApply (dp As DependencyProperty, targetType As Type)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnApply(System::Windows::DependencyProperty ^ dp, Type ^ targetType);" />
      <MemberSignature Language="F#" Value="override this.OnApply : System.Windows.DependencyProperty * Type -&gt; unit" Usage="frameworkPropertyMetadata.OnApply (dp, targetType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="targetType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="dp"><span data-ttu-id="9b023-406">A propriedade de dependência à qual os metadados foram aplicados.</span><span class="sxs-lookup"><span data-stu-id="9b023-406">The dependency property to which the metadata has been applied.</span></span></param>
        <param name="targetType"><span data-ttu-id="9b023-407">O tipo associado a esses metadados se eles forem metadados específicos do tipo.</span><span class="sxs-lookup"><span data-stu-id="9b023-407">The type associated with this metadata if this is type-specific metadata.</span></span> <span data-ttu-id="9b023-408">Se eles são metadados padrão, esse valor pode ser <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9b023-408">If this is default metadata, this value can be <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="9b023-409">Chamado quando esses metadados foram aplicados a uma propriedade, o que indica que os metadados estão sendo selados.</span><span class="sxs-lookup"><span data-stu-id="9b023-409">Called when this metadata has been applied to a property, which indicates that the metadata is being sealed.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9b023-410">Qualquer Mutabilidade da estrutura de dados de um <xref:System.Windows.FrameworkPropertyMetadata> instância deve ser marcada como imutável quando este método é invocado.</span><span class="sxs-lookup"><span data-stu-id="9b023-410">Any mutability of the data structure of a <xref:System.Windows.FrameworkPropertyMetadata> instance should be marked as immutable when this method is invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="9b023-411">O <see cref="T:System.Windows.FrameworkPropertyMetadata" /> implementação deste método não faz nada além de chamar a implementação base.</span><span class="sxs-lookup"><span data-stu-id="9b023-411">The <see cref="T:System.Windows.FrameworkPropertyMetadata" /> implementation of this method does nothing beyond calling the base implementation.</span></span></para></block>
        <altmember cref="M:System.Windows.PropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)" />
        <altmember cref="P:System.Windows.PropertyMetadata.IsSealed" />
        <altmember cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="OverridesInheritanceBehavior">
      <MemberSignature Language="C#" Value="public bool OverridesInheritanceBehavior { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool OverridesInheritanceBehavior" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior" />
      <MemberSignature Language="VB.NET" Value="Public Property OverridesInheritanceBehavior As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool OverridesInheritanceBehavior { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.OverridesInheritanceBehavior : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9b023-412">Obtém ou define um valor que indica se a avaliação de herança de valor da propriedade deve abranger além de certos limites conteúdo na árvore lógica de elementos.</span><span class="sxs-lookup"><span data-stu-id="9b023-412">Gets or sets a value that indicates whether the property value inheritance evaluation should span across certain content boundaries in the logical tree of elements.</span></span></summary>
        <value><span data-ttu-id="9b023-413"><see langword="true" /> Se a herança do valor da propriedade deve abranger além de certos limites conteúdo; Caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="9b023-413"><see langword="true" /> if the property value inheritance should span across certain content boundaries; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="9b023-414">O padrão é <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="9b023-414">The default is <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9b023-415">Esses metadados relata uma modificação raramente aplicado ao comportamento de herança de valor de propriedade entre limites de elemento filho do elemento pai especial.</span><span class="sxs-lookup"><span data-stu-id="9b023-415">This metadata reports a seldom-applied modification to property value inheritance behavior across special parent element-child element boundaries.</span></span> <span data-ttu-id="9b023-416">O exemplo canônico de tal limite é o conteúdo de um <xref:System.Windows.Controls.Frame>, em que o <xref:System.Windows.Controls.Frame> conteúdo pode obter recarregado independentemente da existência da <xref:System.Windows.Controls.Frame>.</span><span class="sxs-lookup"><span data-stu-id="9b023-416">The canonical example of such a boundary is the contents of a <xref:System.Windows.Controls.Frame>, where the <xref:System.Windows.Controls.Frame> content might get reloaded independently of the existence of the <xref:System.Windows.Controls.Frame>.</span></span> <span data-ttu-id="9b023-417">O comportamento do sistema de propriedade desejada é que herança do valor da propriedade não deve percorrer o conteúdo do <xref:System.Windows.Controls.Frame>, porque esses conteúdos podem ser elementos que o aplicativo que hospeda o quadro não possui ou controla.</span><span class="sxs-lookup"><span data-stu-id="9b023-417">The desired property system behavior is that property value inheritance should not traverse into the contents of the <xref:System.Windows.Controls.Frame>, because these contents might be elements that the application hosting the frame does not own or control.</span></span> <span data-ttu-id="9b023-418">Especificação de metadados com <xref:System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior%2A> definido como `true`, bem como especificando <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> como `true`, fará com que a propriedade na qual os metadados é aplicado para se tornar herdável, mesmo no <xref:System.Windows.Controls.Frame> limites ou limites semelhantes.</span><span class="sxs-lookup"><span data-stu-id="9b023-418">Specifying metadata with <xref:System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior%2A> set to `true`, as well as specifying <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> as `true`, will cause the property on which the metadata is applied to be inheritable even across the <xref:System.Windows.Controls.Frame> boundary or similar boundaries.</span></span>  
  
 <span data-ttu-id="9b023-419">Propriedades em classes derivadas de <xref:System.Windows.PropertyMetadata> geralmente são definidos no modelo de objeto como leitura-gravação.</span><span class="sxs-lookup"><span data-stu-id="9b023-419">Properties on derived classes of <xref:System.Windows.PropertyMetadata> are typically defined in the object model as read-write.</span></span> <span data-ttu-id="9b023-420">Isso é para que eles podem ser ajustados após a inicialização da instância.</span><span class="sxs-lookup"><span data-stu-id="9b023-420">This is so they can be adjusted after initialization of the instance.</span></span> <span data-ttu-id="9b023-421">No entanto, depois que os metadados são consumidos como parte de uma chamada para <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, ou <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, o sistema de propriedades será lacrar essa instância de metadados e propriedades que transmitem as especificidades dos metadados agora são consideradas imutáveis.</span><span class="sxs-lookup"><span data-stu-id="9b023-421">However, after the metadata is consumed as part of a call to <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, or <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, the property system will seal that metadata instance and properties that convey the specifics of the metadata are now considered immutable.</span></span> <span data-ttu-id="9b023-422">Tentativa de definir essa propriedade após <xref:System.Windows.PropertyMetadata.IsSealed%2A> é `true` nesses metadados instância gerarão uma exceção.</span><span class="sxs-lookup"><span data-stu-id="9b023-422">Attempting to set this property after <xref:System.Windows.PropertyMetadata.IsSealed%2A> is `true` on this metadata instance will raise an exception.</span></span>  
  
<a name="xamlTextUsage_OverridesInheritanceBehavior"></a>   
## <a name="xaml-text-usage"></a><span data-ttu-id="9b023-423">Uso de texto XAML</span><span class="sxs-lookup"><span data-stu-id="9b023-423">XAML Text Usage</span></span>  
 <span data-ttu-id="9b023-424">Os membros dessa classe não são normalmente usados em [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span><span class="sxs-lookup"><span data-stu-id="9b023-424">Members of this class are not typically used in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="9b023-425">Os metadados já foram aplicados à operação de propriedade de dependência, portanto os metadados estão selados e as propriedades dos metadados não podem ser definidas.</span><span class="sxs-lookup"><span data-stu-id="9b023-425">The metadata has already been applied to a dependency property operation, so that metadata is sealed and properties of the metadata cannot be set.</span></span></exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="SubPropertiesDoNotAffectRender">
      <MemberSignature Language="C#" Value="public bool SubPropertiesDoNotAffectRender { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SubPropertiesDoNotAffectRender" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender" />
      <MemberSignature Language="VB.NET" Value="Public Property SubPropertiesDoNotAffectRender As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SubPropertiesDoNotAffectRender { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SubPropertiesDoNotAffectRender : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9b023-426">Obtém ou define um valor que indica se as subpropriedades da propriedade de dependência não afetam a renderização do objeto contentor.</span><span class="sxs-lookup"><span data-stu-id="9b023-426">Gets or sets a value that indicates whether sub-properties of the dependency property do not affect the rendering of the containing object.</span></span></summary>
        <value><span data-ttu-id="9b023-427"><see langword="true" /> Se alterações nos valores da subpropriedade não afetam a renderização se alterado; Caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="9b023-427"><see langword="true" /> if changes to sub-property values do not affect rendering if changed; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="9b023-428">O padrão é <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="9b023-428">The default is <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9b023-429">Essa opção de metadados é pertinente para propriedades de dependência que são tipos de referência, em que esse tipo tem valores de propriedade de seu próprio.</span><span class="sxs-lookup"><span data-stu-id="9b023-429">This metadata option is pertinent for dependency properties that are reference types, where that type has property values of its own.</span></span> <span data-ttu-id="9b023-430">Normalmente, a lógica do sistema de layout é assumir que qualquer propriedade de dependência com subpropriedades potencialmente afetará layout, como verificação de todas as subpropriedades de alterações é mais demorado do que realmente em execução outro renderizar pass.</span><span class="sxs-lookup"><span data-stu-id="9b023-430">Typically, the layout system logic is to assume that any dependency property with sub-properties potentially will affect layout, because checking all sub-properties for changes is more time consuming than actually running another render pass.</span></span> <span data-ttu-id="9b023-431">Definir essa opção como `true` é útil para otimizar o desempenho da implementação de sistema de layout de nível de framework WPF.</span><span class="sxs-lookup"><span data-stu-id="9b023-431">Setting this option to `true` is useful for optimizing performance of the WPF framework level layout system implementation.</span></span>  
  
 <span data-ttu-id="9b023-432">Propriedades em classes derivadas de <xref:System.Windows.PropertyMetadata> geralmente são definidos no modelo de objeto como leitura-gravação.</span><span class="sxs-lookup"><span data-stu-id="9b023-432">Properties on derived classes of <xref:System.Windows.PropertyMetadata> are typically defined in the object model as read-write.</span></span> <span data-ttu-id="9b023-433">Isso é para que eles podem ser ajustados após a inicialização da instância.</span><span class="sxs-lookup"><span data-stu-id="9b023-433">This is so they can be adjusted after initialization of the instance.</span></span> <span data-ttu-id="9b023-434">No entanto, depois que os metadados são consumidos como parte de uma chamada para <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, ou <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, o sistema de propriedades será lacrar essa instância de metadados e propriedades que transmitem as especificidades dos metadados agora são consideradas imutáveis.</span><span class="sxs-lookup"><span data-stu-id="9b023-434">However, once the metadata is consumed as part of a call to <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, or <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, the property system will seal that metadata instance and properties that convey the specifics of the metadata are now considered immutable.</span></span> <span data-ttu-id="9b023-435">Tentativa de definir essa propriedade após <xref:System.Windows.PropertyMetadata.IsSealed%2A> é `true` nesses metadados instância gerarão uma exceção.</span><span class="sxs-lookup"><span data-stu-id="9b023-435">Attempting to set this property after <xref:System.Windows.PropertyMetadata.IsSealed%2A> is `true` on this metadata instance will raise an exception.</span></span>  
  
<a name="xamlTextUsage_SubPropertiesDoNotAffectRender"></a>   
## <a name="xaml-text-usage"></a><span data-ttu-id="9b023-436">Uso de texto XAML</span><span class="sxs-lookup"><span data-stu-id="9b023-436">XAML Text Usage</span></span>  
 <span data-ttu-id="9b023-437">Os membros dessa classe não são normalmente usados em [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span><span class="sxs-lookup"><span data-stu-id="9b023-437">Members of this class are not typically used in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="9b023-438">Os metadados já foram aplicados à operação de propriedade de dependência, portanto os metadados estão selados e as propriedades dos metadados não podem ser definidas.</span><span class="sxs-lookup"><span data-stu-id="9b023-438">The metadata has already been applied to a dependency property operation, so that metadata is sealed and properties of the metadata cannot be set.</span></span></exception>
        <altmember cref="T:System.Windows.Freezable" />
      </Docs>
    </Member>
  </Members>
</Type>