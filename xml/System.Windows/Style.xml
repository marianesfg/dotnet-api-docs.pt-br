<Type Name="Style" FullName="System.Windows.Style">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="873428afd511ecbdaa7abbe601a6447792e4b9a4" />
    <Meta Name="ms.sourcegitcommit" Value="16d2d159872fd213cae4b8f371d7ae9c8b027c89" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="pt-BR" />
    <Meta Name="ms.lasthandoff" Value="11/17/2018" />
    <Meta Name="ms.locfileid" Value="51939194" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Style : System.Windows.Threading.DispatcherObject, System.Windows.ISealable, System.Windows.Markup.IAddChild, System.Windows.Markup.INameScope, System.Windows.Markup.IQueryAmbient" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi Style extends System.Windows.Threading.DispatcherObject implements class System.Windows.ISealable, class System.Windows.Markup.IAddChild, class System.Windows.Markup.INameScope, class System.Windows.Markup.IQueryAmbient" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Style" />
  <TypeSignature Language="VB.NET" Value="Public Class Style&#xA;Inherits DispatcherObject&#xA;Implements IAddChild, INameScope, IQueryAmbient, ISealable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Style : System::Windows::Threading::DispatcherObject, System::Windows::ISealable, System::Windows::Markup::IAddChild, System::Windows::Markup::INameScope, System::Windows::Markup::IQueryAmbient" />
  <TypeSignature Language="F#" Value="type Style = class&#xA;    inherit DispatcherObject&#xA;    interface INameScope&#xA;    interface IAddChild&#xA;    interface ISealable&#xA;    interface IQueryAmbient" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Threading.DispatcherObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Windows.ISealable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.Markup.IAddChild</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.Markup.INameScope</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.Markup.IQueryAmbient</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.Ignore)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Windows.Markup.ContentProperty("Setters")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Windows.Markup.DictionaryKeyProperty("TargetType")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Permite o compartilhamento de propriedades, recursos e manipuladores de eventos entre instâncias de um tipo.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você pode definir um <xref:System.Windows.Style> em qualquer elemento que é derivada de <xref:System.Windows.FrameworkElement> ou <xref:System.Windows.FrameworkContentElement>. Um estilo mais comumente é declarado como um recurso dentro do <xref:System.Windows.Application.Resources%2A> seção. Como os estilos são recursos, eles obedecem às mesmas regras de escopo que se aplicam a todos os recursos, caso em que você declara um estilo afeta onde ele pode ser aplicado. Se, por exemplo, você declarar o estilo no elemento raiz de sua definição de aplicativo [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] arquivo, o estilo pode ser usado em qualquer lugar em seu aplicativo. Se você estiver criando um aplicativo de navegação e declarar o estilo em do aplicativo [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] arquivos, o estilo que podem ser usados somente em tal [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] arquivo. Para obter mais informações sobre regras de escopo para recursos, consulte [recursos XAML](~/docs/framework/wpf/advanced/xaml-resources.md).  
  
 O estilo de declaração consiste em uma <xref:System.Windows.Style> objeto que contém uma coleção de um ou mais <xref:System.Windows.Setter> objetos. Cada <xref:System.Windows.Setter> consiste em um <xref:System.Windows.Setter.Property%2A> e um <xref:System.Windows.Setter.Value%2A>. A propriedade é que o nome da propriedade do elemento de estilo é aplicar a. Depois que o estilo é declarado como um recurso, ele pode ser referenciado apenas como qualquer outro recurso.  
  
> [!NOTE]
>  Se houver mais de um setter na coleção setter com o mesmo <xref:System.Windows.Setter.Property%2A> valor da propriedade, o setter que é declarado pela última vez é usado. Da mesma forma, se você definir um valor para a mesma propriedade em um estilo e em um elemento diretamente, o valor definido no elemento diretamente terá precedência.  
  
 O [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] modelo de estilo e modelagem permite que a manutenção e o compartilhamento de uma aparência bem como a separação da apresentação e lógica. O modelo de estilo e modelagem inclui um pacote de recursos que permitem que você personalize sua [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]. Este pacote de recursos inclui o <xref:System.Windows.Style> de classe, bem como o seguinte:  
  
-   <xref:System.Windows.Trigger>  
  
-   <xref:System.Windows.EventTrigger> e <xref:System.Windows.Media.Animation.Storyboard>  
  
-   <xref:System.Windows.Controls.ControlTemplate>  
  
-   <xref:System.Windows.DataTemplate>  
  
 Para obter mais informações, consulte [Estilo e modelagem](~/docs/framework/wpf/controls/styling-and-templating.md).  
  
   
  
## Examples  
 O exemplo a seguir mostra uma declaração de estilo que afetarão a <xref:System.Windows.Controls.Control.Background%2A> propriedade de um <xref:System.Windows.Controls.Control>.  
  
 [!code-xaml[StyleOvw01#StyleSimple](~/samples/snippets/csharp/VS_Snippets_Wpf/StyleOvw01/CS/Page1.xaml#stylesimple)]   
  
 Para aplicar o estilo acima, faça o seguinte:  
  
 [!code-xaml[StyleOvw01#StyleSimpleApplied](~/samples/snippets/csharp/VS_Snippets_Wpf/StyleOvw01/CS/Page1.xaml#stylesimpleapplied)]
  
 Você também pode aplicar estilos a todos os elementos de um determinado tipo usando o <xref:System.Windows.Style.TargetType%2A> propriedade. Adicionar o tipo de destino para o estilo significa que você não precise qualificar totalmente a propriedade que você está configurando com o `ClassName.PropertyName` sintaxe. O exemplo a seguir define um estilo que será aplicado a cada <xref:System.Windows.Controls.TextBlock> elemento.  
  
 [!code-xaml[PhotoStoreDemoStyled#1](~/samples/snippets/csharp/VS_Snippets_Wpf/PhotoStoreDemoStyled/CS/window1.xaml#1)]   
  
> [!NOTE]
>  Muitas [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] controles consistem em uma combinação de outros [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] controles, portanto, a criação de um estilo que se aplica a todos os controles de um tipo podem ter grande impacto. Por exemplo, se você criar um estilo que se destina a <xref:System.Windows.Controls.TextBlock> controles em um <xref:System.Windows.Controls.Canvas>, o estilo é aplicado a todos os <xref:System.Windows.Controls.TextBlock> controles na tela, mesmo se o <xref:System.Windows.Controls.TextBlock> faz parte de outro controle, como um <xref:System.Windows.Controls.ListBox>.  
  
 Para obter informações sobre como estender ou herdar de um estilo definido, consulte o <xref:System.Windows.Style.BasedOn%2A> página.  
  
 ]]></format>
    </remarks>
    <related type="Article" href="https://msdn.microsoft.com/library/1985cd45-f197-42d5-b75e-886add64b248">Atributo X:Key</related>
    <related type="Article" href="https://msdn.microsoft.com/library/e0e0ce6f-e873-49c7-8ad7-8b840eb353ec">Extensão de marcação x:Type</related>
    <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=160010">Introdução à amostra de estilo e modelagem</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Windows.Style" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Style ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Style.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Style();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Windows.Style" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa chamada de construtor necessita de validação em atrasada <xref:System.Windows.Style.TargetType%2A> e <xref:System.Windows.Style.BasedOn%2A> tipo de estilo. Se isso for usado fora do contexto do analisador, o comportamento será indefinido.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Style (Type targetType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Type targetType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Style.#ctor(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (targetType As Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Style(Type ^ targetType);" />
      <MemberSignature Language="F#" Value="new System.Windows.Style : Type -&gt; System.Windows.Style" Usage="new System.Windows.Style targetType" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="targetType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="targetType">O tipo ao qual o estilo será aplicado.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Windows.Style" /> a ser usada no <see cref="T:System.Type" /> especificado.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Style (Type targetType, System.Windows.Style basedOn);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Type targetType, class System.Windows.Style basedOn) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Style.#ctor(System.Type,System.Windows.Style)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (targetType As Type, basedOn As Style)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Style(Type ^ targetType, System::Windows::Style ^ basedOn);" />
      <MemberSignature Language="F#" Value="new System.Windows.Style : Type * System.Windows.Style -&gt; System.Windows.Style" Usage="new System.Windows.Style (targetType, basedOn)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="targetType" Type="System.Type" />
        <Parameter Name="basedOn" Type="System.Windows.Style" />
      </Parameters>
      <Docs>
        <param name="targetType">O tipo ao qual o estilo será aplicado.</param>
        <param name="basedOn">O estilo no qual basear este estilo.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Windows.Style" /> a ser usada no <see cref="T:System.Type" /> especificado e baseada no <see cref="T:System.Windows.Style" /> especificado.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BasedOn">
      <MemberSignature Language="C#" Value="public System.Windows.Style BasedOn { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Style BasedOn" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Style.BasedOn" />
      <MemberSignature Language="VB.NET" Value="Public Property BasedOn As Style" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Style ^ BasedOn { System::Windows::Style ^ get(); void set(System::Windows::Style ^ value); };" />
      <MemberSignature Language="F#" Value="member this.BasedOn : System.Windows.Style with get, set" Usage="System.Windows.Style.BasedOn" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Windows.Markup.Ambient</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Style</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um estilo definido que é a base do estilo atual.</summary>
        <value>Um estilo definido que é a base do estilo atual. O valor padrão é <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cada estilo dá suporte apenas a um <xref:System.Windows.Style.BasedOn%2A> valor.  
  
<a name="xamlAttributeUsage_BasedOn"></a>   
## <a name="xaml-attribute-usage"></a>Uso do Atributo XAML  
  
```  
<object BasedOn="myStyle" .../>  
```  
  
<a name="xamlValues_BasedOn"></a>   
## <a name="xaml-values"></a>Valores XAML  
 *myStyle*  
 Um estilo existente. Normalmente, você usa o [extensões de marcação e XAML WPF](~/docs/framework/wpf/advanced/markup-extensions-and-wpf-xaml.md) para se referir a um estilo existente.  
  
   
  
## Examples  
 Há várias maneiras de estilos em [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] pode ser estendida ou herdado. Estilos podem ser baseados em outros estilos através desta propriedade. Quando você usa essa propriedade, o novo estilo herdará os valores do estilo original que não são explicitamente redefinidos no novo estilo. No exemplo a seguir `Style2` herda a <xref:System.Windows.Controls.Control.Background%2A?displayProperty=nameWithType> valor de `Yellow`e adiciona uma <xref:System.Windows.Controls.Control.Foreground%2A?displayProperty=nameWithType> valor de `Blue`.  
  
 [!code-xaml[StyleOvw01#ExtendingStyle](~/samples/snippets/csharp/VS_Snippets_Wpf/StyleOvw01/CS/Page1.xaml#extendingstyle)]   
  
 Da mesma forma, os estilos podem ser baseados no estilo de existente [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] elemento, como no exemplo a seguir, onde o novo estilo é baseado no estilo de um <xref:System.Windows.Controls.TextBlock> elemento.  
  
 [!code-xaml[PhotoStoreDemoStyled#2](~/samples/snippets/csharp/VS_Snippets_Wpf/PhotoStoreDemoStyled/CS/window1.xaml#2)]   
  
> [!NOTE]
>  Se você criar um estilo com uma <xref:System.Windows.Style.TargetType%2A> propriedade e base-lo em outro estilo que também define um <xref:System.Windows.Style.TargetType%2A> propriedade, o tipo de destino do estilo derivado deve ser igual ou ser derivado do tipo do estilo base.  
  
 Os estilos definidos para tipos específicos também podem ser baseados em outros estilos, como no exemplo a seguir.  
  
 [!code-xaml[StyleOvw01#ExtendingStyleTargetType](~/samples/snippets/csharp/VS_Snippets_Wpf/StyleOvw01/CS/Page1.xaml#extendingstyletargettype)]   
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=160010">Introdução à amostra de estilo e modelagem</related>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Style.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="abstract member GetHashCode : unit -&gt; int&#xA;override this.GetHashCode : unit -&gt; int" Usage="style.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna o código hash para este <see cref="T:System.Windows.Style" />.</summary>
        <returns>O código hash deste <see cref="T:System.Windows.Style" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSealed">
      <MemberSignature Language="C#" Value="public bool IsSealed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSealed" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Style.IsSealed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSealed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSealed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSealed : bool" Usage="System.Windows.Style.IsSealed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o estilo é somente leitura e não pode ser alterado.</summary>
        <value>
          <see langword="true" /> Se o estilo é lacrado; Caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um estilo é lacrado quando outro estilo com base nela ou quando ela é aplicada pela primeira vez.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Style.BasedOn" />
      </Docs>
    </Member>
    <Member MemberName="RegisterName">
      <MemberSignature Language="C#" Value="public void RegisterName (string name, object scopedElement);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RegisterName(string name, object scopedElement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Style.RegisterName(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterName (name As String, scopedElement As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RegisterName(System::String ^ name, System::Object ^ scopedElement);" />
      <MemberSignature Language="F#" Value="abstract member RegisterName : string * obj -&gt; unit&#xA;override this.RegisterName : string * obj -&gt; unit" Usage="style.RegisterName (name, scopedElement)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.INameScope.RegisterName(System.String,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="scopedElement" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="name">O nome para registrar.</param>
        <param name="scopedElement">O objeto a ser mapeado para o <c>nome</c> especificado.</param>
        <summary>Registra um novo par nome-objeto no namescope atual.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Resources">
      <MemberSignature Language="C#" Value="public System.Windows.ResourceDictionary Resources { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.ResourceDictionary Resources" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Style.Resources" />
      <MemberSignature Language="VB.NET" Value="Public Property Resources As ResourceDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::ResourceDictionary ^ Resources { System::Windows::ResourceDictionary ^ get(); void set(System::Windows::ResourceDictionary ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Resources : System.Windows.ResourceDictionary with get, set" Usage="System.Windows.Style.Resources" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Markup.IHaveResources.Resources</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Windows.Markup.Ambient</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.ResourceDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define a coleção de recursos que podem ser usados dentro do escopo desse estilo.</summary>
        <value>Os recursos que podem ser usados dentro do escopo desse estilo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="xamlPropertyElementUsage_Resources"></a>   
## <a name="xaml-property-element-usage"></a>Uso do elemento propriedade XAML  
  
```  
<object>  
  <object.Resources>  
    oneOrMoreResourceElements  
  </object.Resources>  
</object>  
- or -   
<object>  
  <object.Resources>  
    <ResourceDictionary Source="externalDictionarySource"/>  
  </object.Resources>  
</object>  
```  
  
<a name="xamlValues_Resources"></a>   
## <a name="xaml-values"></a>Valores XAML  
 *oneOrMoreResourceElements*  
 Um ou mais elementos de recurso. Seja referenciado posteriormente no [extensão de marcação StaticResource](~/docs/framework/wpf/advanced/staticresource-markup-extension.md) ou [extensão de marcação DynamicResource](~/docs/framework/wpf/advanced/dynamicresource-markup-extension.md) sintaxe [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], um elemento de recurso deve ter um `x:Key` atributo.  
  
 \<Origem de ResourceDictionary = " *externalDictionarySource*" / >  
 Uma fonte externa do dicionário. Para obter detalhes, consulte [dicionários de recursos mesclados](~/docs/framework/wpf/advanced/merged-resource-dictionaries.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Seal">
      <MemberSignature Language="C#" Value="public void Seal ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Seal() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Style.Seal" />
      <MemberSignature Language="VB.NET" Value="Public Sub Seal ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Seal();" />
      <MemberSignature Language="F#" Value="member this.Seal : unit -&gt; unit" Usage="style.Seal " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Bloqueia esse estilo e todos os gatilhos e fábricas de forma que não podem ser alterados.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Setters">
      <MemberSignature Language="C#" Value="public System.Windows.SetterBaseCollection Setters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.SetterBaseCollection Setters" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Style.Setters" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Setters As SetterBaseCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::SetterBaseCollection ^ Setters { System::Windows::SetterBaseCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Setters : System.Windows.SetterBaseCollection" Usage="System.Windows.Style.Setters" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.SetterBaseCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém uma coleção de objetos <see cref="T:System.Windows.Setter" /> e <see cref="T:System.Windows.EventSetter" />.</summary>
        <value>Uma coleção de objetos <see cref="T:System.Windows.Setter" /> e <see cref="T:System.Windows.EventSetter" />. O padrão é uma coleção vazia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Windows.Style.Setters%2A> propriedade de um <xref:System.Windows.Style> objeto pode consistir somente de objetos pode ser atribuídos à <xref:System.Windows.SetterBase>. Adicionando um <xref:System.Windows.SetterBase> filho para uma <xref:System.Windows.Style> objeto adiciona implicitamente, para o <xref:System.Windows.SetterBaseCollection> para o <xref:System.Windows.Style> objeto.  
  
 Um uso de elemento de propriedade explícita para <xref:System.Windows.Style.Setters%2A> também é relativamente comum. Essa é uma decisão de estilo de marcação que às vezes pode ajudar a distinguir <xref:System.Windows.Style.Setters%2A> partir <xref:System.Windows.Style.Resources%2A> e <xref:System.Windows.Style.Triggers%2A> itens em um estilo complexo. Por exemplo:  
  
```  
<Style>  
  <Style.Setters>  
    <!--one or more SetterBase derived object elements here-->  
  </Style.Setters>  
</Style>  
```  
  
<a name="xamlPropertyElementUsage_Setters"></a>   
## <a name="xaml-property-element-usage"></a>Uso do elemento propriedade XAML  
  
```  
<object>  
  oneOrMoreSetters  
</object>  
```  
  
<a name="xamlValues_Setters"></a>   
## <a name="xaml-values"></a>Valores XAML  
 *oneOrMoreSetters*  
 Um ou mais <xref:System.Windows.Setter> ou <xref:System.Windows.EventSetter> objetos.  
  
   
  
## Examples  
 O exemplo a seguir mostra como usar essa propriedade.  
  
 [!code-csharp[listboxitemstyle#1](~/samples/snippets/csharp/VS_Snippets_Wpf/ListBoxItemStyle/CSharp/Pane1.xaml.cs#1)]
 [!code-vb[listboxitemstyle#1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ListBoxItemStyle/VisualBasic/Pane1.xaml.vb#1)]  
  
 Adicionando um <xref:System.Windows.SetterBase> filho para uma <xref:System.Windows.Style> objeto adiciona implicitamente, para o <xref:System.Windows.SetterBaseCollection> para o <xref:System.Windows.Style> objeto. O seguinte <xref:System.Windows.EventSetter> é implicitamente adicionado para o <xref:System.Windows.SetterBaseCollection> do estilo:  
  
 [!code-xaml[eventovwsupport#XAML2](~/samples/snippets/csharp/VS_Snippets_Wpf/EventOvwSupport/CSharp/page2.xaml#xaml2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Setter" />
        <altmember cref="T:System.Windows.EventSetter" />
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=160010">Introdução à amostra de estilo e modelagem</related>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.ISealable.CanSeal">
      <MemberSignature Language="C#" Value="bool System.Windows.ISealable.CanSeal { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Windows.ISealable.CanSeal" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Style.System#Windows#ISealable#CanSeal" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property CanSeal As Boolean Implements ISealable.CanSeal" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Windows::ISealable::CanSeal { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Windows.ISealable.CanSeal" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.ISealable.IsSealed">
      <MemberSignature Language="C#" Value="bool System.Windows.ISealable.IsSealed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Windows.ISealable.IsSealed" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Style.System#Windows#ISealable#IsSealed" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsSealed As Boolean Implements ISealable.IsSealed" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Windows::ISealable::IsSealed { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Windows.ISealable.IsSealed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.ISealable.Seal">
      <MemberSignature Language="C#" Value="void ISealable.Seal ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.ISealable.Seal() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Style.System#Windows#ISealable#Seal" />
      <MemberSignature Language="VB.NET" Value="Sub Seal () Implements ISealable.Seal" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Windows.ISealable.Seal() = System::Windows::ISealable::Seal;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IAddChild.AddChild">
      <MemberSignature Language="C#" Value="void IAddChild.AddChild (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.Markup.IAddChild.AddChild(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Style.System#Windows#Markup#IAddChild#AddChild(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub AddChild (value As Object) Implements IAddChild.AddChild" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Windows.Markup.IAddChild.AddChild(System::Object ^ value) = System::Windows::Markup::IAddChild::AddChild;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IAddChild.AddChild(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">O objeto filho a ser adicionado.</param>
        <summary>Adiciona um objeto filho.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.Windows.Style> é convertida em uma interface de <xref:System.Windows.Markup.IAddChild>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IAddChild.AddText">
      <MemberSignature Language="C#" Value="void IAddChild.AddText (string text);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.Markup.IAddChild.AddText(string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Style.System#Windows#Markup#IAddChild#AddText(System.String)" />
      <MemberSignature Language="VB.NET" Value="Sub AddText (text As String) Implements IAddChild.AddText" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Windows.Markup.IAddChild.AddText(System::String ^ text) = System::Windows::Markup::IAddChild::AddText;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IAddChild.AddText(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="text">O texto a ser adicionado ao objeto.</param>
        <summary>Adiciona o conteúdo do texto de um nó ao objeto.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.Windows.Style> é convertida em uma interface de <xref:System.Windows.Markup.IAddChild>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.INameScope.FindName">
      <MemberSignature Language="C#" Value="object INameScope.FindName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.Windows.Markup.INameScope.FindName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Style.System#Windows#Markup#INameScope#FindName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function FindName (name As String) As Object Implements INameScope.FindName" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ System.Windows.Markup.INameScope.FindName(System::String ^ name) = System::Windows::Markup::INameScope::FindName;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.INameScope.FindName(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">O identificador de nome para o objeto que está sendo solicitado.</param>
        <summary>Retorna um objeto que tem o nome de identificação fornecido.</summary>
        <returns>O objeto, se encontrado. Retornará <see langword="null" /> se nenhum objeto com esse nome tiver sido encontrado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.Windows.Style> é convertida em uma interface de <xref:System.Windows.Markup.INameScope>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable">
      <MemberSignature Language="C#" Value="bool IQueryAmbient.IsAmbientPropertyAvailable (string propertyName);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(string propertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Style.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function IsAmbientPropertyAvailable (propertyName As String) As Boolean Implements IQueryAmbient.IsAmbientPropertyAvailable" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System::String ^ propertyName) = System::Windows::Markup::IQueryAmbient::IsAmbientPropertyAvailable;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="propertyName">O nome da propriedade de ambiente solicitada.</param>
        <summary>Consulta se uma propriedade de ambiente especificada está disponível no escopo atual.</summary>
        <returns>
          <see langword="true" /> se a propriedade de ambiente solicitada está disponível; caso contrário, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Windows.Markup.IQueryAmbient" />
      </Docs>
    </Member>
    <Member MemberName="TargetType">
      <MemberSignature Language="C#" Value="public Type TargetType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type TargetType" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Style.TargetType" />
      <MemberSignature Language="VB.NET" Value="Public Property TargetType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Type ^ TargetType { Type ^ get(); void set(Type ^ value); };" />
      <MemberSignature Language="F#" Value="member this.TargetType : Type with get, set" Usage="System.Windows.Style.TargetType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Windows.Markup.Ambient</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o tipo para o qual esse estilo foi projetado.</summary>
        <value>O tipo de destino desse estilo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você pode definir um estilo em qualquer elemento que é derivada de <xref:System.Windows.FrameworkElement> ou <xref:System.Windows.FrameworkContentElement>. Portanto, seu tipo de destino pode ser qualquer um desses elementos. No entanto, se você criar um estilo com uma <xref:System.Windows.Style.TargetType%2A> propriedade e base-lo em outro estilo que também define um <xref:System.Windows.Style.TargetType%2A> propriedade, o tipo de destino do estilo derivado deve ser igual ou ser derivado do tipo de destino do estilo base.  
  
 Se você não especificar uma <xref:System.Windows.Style.TargetType%2A>, em seguida, você deve especificar um `x:Key` para seu <xref:System.Windows.Style> e também qualificar as propriedades em seu estilo com um nome de classe.  
  
<a name="xamlAttributeUsage_TargetType"></a>   
## <a name="xaml-attribute-usage"></a>Uso do Atributo XAML  
  
```  
<object  TargetType="{x:Type typeName}"/>  
-or-  
<object  TargetType="typeName"/>  
```  
  
<a name="xamlValues_TargetType"></a>   
## <a name="xaml-values"></a>Valores XAML  
 `{x:Type ...}`  
 Uma [extensão de marcação X:Type](~/docs/framework/xaml-services/x-type-markup-extension.md) uso de extensão de marcação.  
  
 *typeName*  
 O nome do tipo da classe.  
  
   
  
## Examples  
 O exemplo a seguir define um estilo que será aplicado a todas as instâncias de <xref:System.Windows.Controls.TextBlock> elemento.  
  
 [!code-xaml[PhotoStoreDemoStyled#1](~/samples/snippets/csharp/VS_Snippets_Wpf/PhotoStoreDemoStyled/CS/window1.xaml#1)]   
  
 Definindo o <xref:System.Windows.Style.TargetType%2A> propriedade para o <xref:System.Windows.Controls.TextBlock> tipo sem definir uma `x:Key` define implicitamente a `x:Key` para `{x:Type TextBlock}`. Isso também significa que se você fornecer acima <xref:System.Windows.Style> uma `x:Key` valor de qualquer coisa diferente de `{x:Type TextBlock}`, o <xref:System.Windows.Style> não poderá ser aplicado a todos os <xref:System.Windows.Controls.TextBlock> elementos automaticamente. Em vez disso, você precisa aplicar o estilo para o <xref:System.Windows.Controls.TextBlock> elementos explicitamente.  
  
 Muitas [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] controles consistem em uma combinação de outros [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] controles, portanto, a criação de um estilo que se aplica a todos os controles de um tipo podem ter grande impacto. Por exemplo, se você criar um estilo que se destina a <xref:System.Windows.Controls.TextBox> controles em um <xref:System.Windows.Controls.Canvas>, o estilo é aplicado a todos os <xref:System.Windows.Controls.TextBox> controles na tela, mesmo se o <xref:System.Windows.Controls.TextBox> faz parte de outro controle, como um <xref:System.Windows.Controls.ComboBox>.  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=160010">Introdução à amostra de estilo e modelagem</related>
      </Docs>
    </Member>
    <Member MemberName="Triggers">
      <MemberSignature Language="C#" Value="public System.Windows.TriggerCollection Triggers { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.TriggerCollection Triggers" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Style.Triggers" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Triggers As TriggerCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::TriggerCollection ^ Triggers { System::Windows::TriggerCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Triggers : System.Windows.TriggerCollection" Usage="System.Windows.Style.Triggers" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.TriggerCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém uma coleção de objetos <see cref="T:System.Windows.TriggerBase" /> que se aplicam a valores de propriedade com base nas condições especificadas.</summary>
        <value>Uma coleção de objetos <see cref="T:System.Windows.TriggerBase" /> . O padrão é uma coleção vazia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] modelo de estilo e modelagem permite que você especifique gatilhos dentro de seu <xref:System.Windows.Style>. Essencialmente, os gatilhos são objetos que permitem que você aplicar as alterações quando determinadas condições (como quando um determinado valor de propriedade se torna `true`, ou quando ocorre um evento) estiver satisfeito.  
  
<a name="xamlPropertyElementUsage_Triggers"></a>   
## <a name="xaml-property-element-usage"></a>Uso do elemento propriedade XAML  
  
```  
<object>  
  <object.Triggers>  
    oneOrMoreTriggers  
  </object.Triggers>  
</object>  
```  
  
<a name="xamlValues_Triggers"></a>   
## <a name="xaml-values"></a>Valores XAML  
 *oneOrMoreTriggers*  
 Zero ou mais elementos de objeto que são classes derivadas de <xref:System.Windows.TriggerBase>.  
  
   
  
## Examples  
 O exemplo a seguir mostra uma nomeada <xref:System.Windows.Style> disponíveis para <xref:System.Windows.Controls.Button> controles. O <xref:System.Windows.Style> define uma <xref:System.Windows.Trigger> elemento que muda a <xref:System.Windows.Controls.Control.Foreground%2A> propriedade de um botão quando o <xref:System.Windows.Controls.Primitives.ButtonBase.IsPressed%2A> é de propriedade `true`.  
  
 [!code-xaml[BtnStyles#2](~/samples/snippets/csharp/VS_Snippets_Wpf/BtnStyles/CS/app.xaml#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.DataTrigger" />
        <altmember cref="T:System.Windows.EventTrigger" />
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=160010">Introdução à amostra de estilo e modelagem</related>
      </Docs>
    </Member>
    <Member MemberName="UnregisterName">
      <MemberSignature Language="C#" Value="public void UnregisterName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void UnregisterName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Style.UnregisterName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub UnregisterName (name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void UnregisterName(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member UnregisterName : string -&gt; unit&#xA;override this.UnregisterName : string -&gt; unit" Usage="style.UnregisterName name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.INameScope.UnregisterName(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">O nome do mapeamento a ser removido.</param>
        <summary>Remove um mapeamento de nome-objeto do namescope.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>