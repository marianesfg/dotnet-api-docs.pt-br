<Type Name="Style" FullName="System.Windows.Style">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="8a1121d73905393a90403f74db8e044229988c06" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="pt-BR" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36456913" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Style : System.Windows.Threading.DispatcherObject, System.Windows.ISealable, System.Windows.Markup.IAddChild, System.Windows.Markup.INameScope, System.Windows.Markup.IQueryAmbient" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi Style extends System.Windows.Threading.DispatcherObject implements class System.Windows.ISealable, class System.Windows.Markup.IAddChild, class System.Windows.Markup.INameScope, class System.Windows.Markup.IQueryAmbient" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Style" />
  <TypeSignature Language="VB.NET" Value="Public Class Style&#xA;Inherits DispatcherObject&#xA;Implements IAddChild, INameScope, IQueryAmbient, ISealable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Style : System::Windows::Threading::DispatcherObject, System::Windows::ISealable, System::Windows::Markup::IAddChild, System::Windows::Markup::INameScope, System::Windows::Markup::IQueryAmbient" />
  <TypeSignature Language="F#" Value="type Style = class&#xA;    inherit DispatcherObject&#xA;    interface INameScope&#xA;    interface IAddChild&#xA;    interface ISealable&#xA;    interface IQueryAmbient" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Threading.DispatcherObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Windows.ISealable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.Markup.IAddChild</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.Markup.INameScope</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.Markup.IQueryAmbient</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.Ignore)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.Markup.ContentProperty("Setters")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.Markup.DictionaryKeyProperty("TargetType")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Permite o compartilhamento de propriedades, recursos e manipuladores de eventos entre instâncias de um tipo.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você pode definir um <xref:System.Windows.Style> em qualquer elemento que é derivada de <xref:System.Windows.FrameworkElement> ou <xref:System.Windows.FrameworkContentElement>. Um estilo mais comumente é declarado como um recurso dentro do <xref:System.Windows.Application.Resources%2A> seção. Como os estilos são recursos, eles obedecem as mesmas regras de escopo que se aplicam a todos os recursos, caso em que você declarar um estilo afeta onde ele pode ser aplicado. Se, por exemplo, você pode declarar o estilo no elemento raiz de sua definição de aplicativo [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] arquivo, o estilo pode ser usado em qualquer lugar no seu aplicativo. Se você estiver criando um aplicativo de navegação e declarar o estilo em um do aplicativo [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] arquivos, o estilo podem ser usados apenas em que [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] arquivo. Para obter mais informações sobre regras de escopo para recursos, consulte [recursos XAML](~/docs/framework/wpf/advanced/xaml-resources.md).  
  
 A declaração de estilo consiste em um <xref:System.Windows.Style> objeto que contém uma coleção de um ou mais <xref:System.Windows.Setter> objetos. Cada <xref:System.Windows.Setter> consiste em uma <xref:System.Windows.Setter.Property%2A> e um <xref:System.Windows.Setter.Value%2A>. A propriedade é que o nome da propriedade do elemento de estilo é aplicar a. Depois que o estilo é declarado como um recurso, ele pode ser referenciado como qualquer outro recurso.  
  
> [!NOTE]
>  Se houver mais de um setter na coleção setter com o mesmo <xref:System.Windows.Setter.Property%2A> valor da propriedade, o setter que é declarado é usado pela última vez. Da mesma forma, se você definir um valor para a mesma propriedade em um estilo e em um elemento diretamente, o valor definido no elemento diretamente terá precedência.  
  
 O [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] estilos e modelagem de modelo permite que a manutenção e o compartilhamento de uma aparência, bem como a separação de apresentação e lógica. O modelo de estilos e modelagem inclui um conjunto de recursos que permitem que você personalize sua [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]. Este pacote de recursos inclui a <xref:System.Windows.Style> classe, bem como o seguinte:  
  
-   <xref:System.Windows.Trigger>  
  
-   <xref:System.Windows.EventTrigger> e <xref:System.Windows.Media.Animation.Storyboard>  
  
-   <xref:System.Windows.Controls.ControlTemplate>  
  
-   <xref:System.Windows.DataTemplate>  
  
 Para obter mais informações, consulte [Estilo e modelagem](~/docs/framework/wpf/controls/styling-and-templating.md).  
  
   
  
## Examples  
 O exemplo a seguir mostra uma declaração de estilo que afeta o <xref:System.Windows.Controls.Control.Background%2A> propriedade de um <xref:System.Windows.Controls.Control>.  
  
 [!code-xaml[StyleOvw01#StyleSimple](~/samples/snippets/csharp/VS_Snippets_Wpf/StyleOvw01/CS/Page1.xaml#stylesimple)]   
  
 Para aplicar o estilo acima, faça o seguinte:  
  
 [!code-xaml[StyleOvw01#StyleSimpleApplied](~/samples/snippets/csharp/VS_Snippets_Wpf/StyleOvw01/CS/Page1.xaml#stylesimpleapplied)]
  
 Você também pode aplicar estilos a todos os elementos de um determinado tipo usando o <xref:System.Windows.Style.TargetType%2A> propriedade. Adicionar o tipo de destino para o estilo significa que você não precisa qualificar totalmente a propriedade que você está definindo com o `ClassName.PropertyName` sintaxe. O exemplo a seguir define um estilo que será aplicado a todos <xref:System.Windows.Controls.TextBlock> elemento.  
  
 [!code-xaml[PhotoStoreDemoStyled#1](~/samples/snippets/csharp/VS_Snippets_Wpf/PhotoStoreDemoStyled/CS/window1.xaml#1)]   
  
> [!NOTE]
>  Muitos [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] controles consistem em uma combinação de outros [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] controles, para criar um estilo que se aplica a todos os controles de um tipo podem ter um grande impacto. Por exemplo, se você criar um estilo destinado a <xref:System.Windows.Controls.TextBlock> controles em um <xref:System.Windows.Controls.Canvas>, o estilo é aplicado a todos os <xref:System.Windows.Controls.TextBlock> controles na tela, mesmo se o <xref:System.Windows.Controls.TextBlock> faz parte de outro controle, como um <xref:System.Windows.Controls.ListBox>.  
  
 Para obter informações sobre como estender ou herdar de um estilo definido, consulte o <xref:System.Windows.Style.BasedOn%2A> página.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Windows.Style" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Style ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Style.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Style();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Windows.Style" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta chamada de construtor necessita de validação em atrasada <xref:System.Windows.Style.TargetType%2A> e <xref:System.Windows.Style.BasedOn%2A> estilo de tipo. Se isso for usado fora do contexto do analisador, o comportamento será indefinido.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Style (Type targetType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Type targetType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Style.#ctor(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (targetType As Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Style(Type ^ targetType);" />
      <MemberSignature Language="F#" Value="new System.Windows.Style : Type -&gt; System.Windows.Style" Usage="new System.Windows.Style targetType" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="targetType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="targetType">O tipo ao qual o estilo será aplicado.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Windows.Style" /> a ser usada no <see cref="T:System.Type" /> especificado.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Style (Type targetType, System.Windows.Style basedOn);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Type targetType, class System.Windows.Style basedOn) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Style.#ctor(System.Type,System.Windows.Style)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (targetType As Type, basedOn As Style)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Style(Type ^ targetType, System::Windows::Style ^ basedOn);" />
      <MemberSignature Language="F#" Value="new System.Windows.Style : Type * System.Windows.Style -&gt; System.Windows.Style" Usage="new System.Windows.Style (targetType, basedOn)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="targetType" Type="System.Type" />
        <Parameter Name="basedOn" Type="System.Windows.Style" />
      </Parameters>
      <Docs>
        <param name="targetType">O tipo ao qual o estilo será aplicado.</param>
        <param name="basedOn">O estilo no qual basear este estilo.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Windows.Style" /> a ser usada no <see cref="T:System.Type" /> especificado e baseada no <see cref="T:System.Windows.Style" /> especificado.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BasedOn">
      <MemberSignature Language="C#" Value="public System.Windows.Style BasedOn { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Style BasedOn" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Style.BasedOn" />
      <MemberSignature Language="VB.NET" Value="Public Property BasedOn As Style" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Style ^ BasedOn { System::Windows::Style ^ get(); void set(System::Windows::Style ^ value); };" />
      <MemberSignature Language="F#" Value="member this.BasedOn : System.Windows.Style with get, set" Usage="System.Windows.Style.BasedOn" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Markup.Ambient</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Style</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um estilo definido que é a base do estilo atual.</summary>
        <value>Um estilo definido que é a base do estilo atual. O valor padrão é <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cada estilo oferece suporte apenas a um <xref:System.Windows.Style.BasedOn%2A> valor.  
  
<a name="xamlAttributeUsage_BasedOn"></a>   
## <a name="xaml-attribute-usage"></a>Uso do Atributo XAML  
  
```  
<object BasedOn="myStyle" .../>  
```  
  
<a name="xamlValues_BasedOn"></a>   
## <a name="xaml-values"></a>Valores XAML  
 *myStyle*  
 Um estilo existente. Normalmente, você usa o [extensões de marcação e WPF XAML](~/docs/framework/wpf/advanced/markup-extensions-and-wpf-xaml.md) para se referir a um estilo existente.  
  
   
  
## Examples  
 Há várias maneiras de estilos em [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] pode ser estendida ou herdado. Estilos podem ser baseados nos outros estilos através desta propriedade. Quando você usar essa propriedade, o novo estilo herdará os valores do estilo original que não são explicitamente referenciados no novo estilo. No exemplo a seguir, `Style2` herda o <xref:System.Windows.Controls.Control.Background%2A?displayProperty=nameWithType> valor `Yellow`e adiciona um <xref:System.Windows.Controls.Control.Foreground%2A?displayProperty=nameWithType> valor `Blue`.  
  
 [!code-xaml[StyleOvw01#ExtendingStyle](~/samples/snippets/csharp/VS_Snippets_Wpf/StyleOvw01/CS/Page1.xaml#extendingstyle)]   
  
 Da mesma forma, os estilos podem se basear em estilo de um objeto existente [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] elemento, como no exemplo a seguir, onde o novo estilo é baseado no estilo de um <xref:System.Windows.Controls.TextBlock> elemento.  
  
 [!code-xaml[PhotoStoreDemoStyled#2](~/samples/snippets/csharp/VS_Snippets_Wpf/PhotoStoreDemoStyled/CS/window1.xaml#2)]   
  
> [!NOTE]
>  Se você criar um estilo com um <xref:System.Windows.Style.TargetType%2A> propriedade e base-lo em outro estilo que também define um <xref:System.Windows.Style.TargetType%2A> propriedade, o tipo de destino do estilo derivado deve ser igual ou ser derivado do tipo do estilo de base.  
  
 Os estilos definidos para tipos específicos também podem ser baseados nos outros estilos, como no exemplo a seguir.  
  
 [!code-xaml[StyleOvw01#ExtendingStyleTargetType](~/samples/snippets/csharp/VS_Snippets_Wpf/StyleOvw01/CS/Page1.xaml#extendingstyletargettype)]   
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Style.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="abstract member GetHashCode : unit -&gt; int&#xA;override this.GetHashCode : unit -&gt; int" Usage="style.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna o código hash para este <see cref="T:System.Windows.Style" />.</summary>
        <returns>O código hash deste <see cref="T:System.Windows.Style" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSealed">
      <MemberSignature Language="C#" Value="public bool IsSealed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSealed" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Style.IsSealed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSealed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSealed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSealed : bool" Usage="System.Windows.Style.IsSealed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o estilo é somente leitura e não pode ser alterado.</summary>
        <value>
          <see langword="true" /> Se o estilo for fechado; Caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um estilo é lacrado, quando outro estilo com base nela ou quando ela é aplicada pela primeira vez.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Style.BasedOn" />
      </Docs>
    </Member>
    <Member MemberName="RegisterName">
      <MemberSignature Language="C#" Value="public void RegisterName (string name, object scopedElement);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RegisterName(string name, object scopedElement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Style.RegisterName(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterName (name As String, scopedElement As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RegisterName(System::String ^ name, System::Object ^ scopedElement);" />
      <MemberSignature Language="F#" Value="abstract member RegisterName : string * obj -&gt; unit&#xA;override this.RegisterName : string * obj -&gt; unit" Usage="style.RegisterName (name, scopedElement)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.INameScope.RegisterName(System.String,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="scopedElement" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="name">O nome para registrar.</param>
        <param name="scopedElement">O objeto a ser mapeado para o <c>nome</c> especificado.</param>
        <summary>Registra um novo par nome-objeto no namescope atual.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Resources">
      <MemberSignature Language="C#" Value="public System.Windows.ResourceDictionary Resources { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.ResourceDictionary Resources" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Style.Resources" />
      <MemberSignature Language="VB.NET" Value="Public Property Resources As ResourceDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::ResourceDictionary ^ Resources { System::Windows::ResourceDictionary ^ get(); void set(System::Windows::ResourceDictionary ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Resources : System.Windows.ResourceDictionary with get, set" Usage="System.Windows.Style.Resources" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Markup.IHaveResources.Resources</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.Markup.Ambient</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.ResourceDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define a coleção de recursos que podem ser usados dentro do escopo desse estilo.</summary>
        <value>Os recursos que podem ser usados dentro do escopo desse estilo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="xamlPropertyElementUsage_Resources"></a>   
## <a name="xaml-property-element-usage"></a>Uso do elemento propriedade XAML  
  
```  
<object>  
  <object.Resources>  
    oneOrMoreResourceElements  
  </object.Resources>  
</object>  
- or -   
<object>  
  <object.Resources>  
    <ResourceDictionary Source="externalDictionarySource"/>  
  </object.Resources>  
</object>  
```  
  
<a name="xamlValues_Resources"></a>   
## <a name="xaml-values"></a>Valores XAML  
 *oneOrMoreResourceElements*  
 Um ou mais elementos de recurso. Para referência posterior no [StaticResource Markup Extension](~/docs/framework/wpf/advanced/staticresource-markup-extension.md) ou [DynamicResource Markup Extension](~/docs/framework/wpf/advanced/dynamicresource-markup-extension.md) sintaxe em [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], um elemento de recurso deve ter um `x:Key` atributo.  
  
 \<Origem de ResourceDictionary = " *externalDictionarySource*" / >  
 Uma fonte externa do dicionário. Para obter detalhes, consulte [dicionários de recursos mesclados](~/docs/framework/wpf/advanced/merged-resource-dictionaries.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Seal">
      <MemberSignature Language="C#" Value="public void Seal ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Seal() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Style.Seal" />
      <MemberSignature Language="VB.NET" Value="Public Sub Seal ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Seal();" />
      <MemberSignature Language="F#" Value="member this.Seal : unit -&gt; unit" Usage="style.Seal " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Bloqueia esse estilo e todos os gatilhos e fábricas de forma que não podem ser alterados.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Setters">
      <MemberSignature Language="C#" Value="public System.Windows.SetterBaseCollection Setters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.SetterBaseCollection Setters" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Style.Setters" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Setters As SetterBaseCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::SetterBaseCollection ^ Setters { System::Windows::SetterBaseCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Setters : System.Windows.SetterBaseCollection" Usage="System.Windows.Style.Setters" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.SetterBaseCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém uma coleção de objetos <see cref="T:System.Windows.Setter" /> e <see cref="T:System.Windows.EventSetter" />.</summary>
        <value>Uma coleção de objetos <see cref="T:System.Windows.Setter" /> e <see cref="T:System.Windows.EventSetter" />. O padrão é uma coleção vazia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Windows.Style.Setters%2A> propriedade de um <xref:System.Windows.Style> objeto pode consistir somente de objetos pode ser atribuídos a <xref:System.Windows.SetterBase>. Adicionando um <xref:System.Windows.SetterBase> filho para uma <xref:System.Windows.Style> objeto adiciona implicitamente para o <xref:System.Windows.SetterBaseCollection> para o <xref:System.Windows.Style> objeto.  
  
 Um uso de elemento de propriedade explícita para <xref:System.Windows.Style.Setters%2A> também é relativamente comum. Esta é uma decisão de estilo de marcação que às vezes pode ajudar a distinguir <xref:System.Windows.Style.Setters%2A> de <xref:System.Windows.Style.Resources%2A> e <xref:System.Windows.Style.Triggers%2A> itens em um estilo complexas. Por exemplo:  
  
```  
<Style>  
  <Style.Setters>  
    <!--one or more SetterBase derived object elements here-->  
  </Style.Setters>  
</Style>  
```  
  
<a name="xamlPropertyElementUsage_Setters"></a>   
## <a name="xaml-property-element-usage"></a>Uso do elemento propriedade XAML  
  
```  
<object>  
  oneOrMoreSetters  
</object>  
```  
  
<a name="xamlValues_Setters"></a>   
## <a name="xaml-values"></a>Valores XAML  
 *oneOrMoreSetters*  
 Um ou mais <xref:System.Windows.Setter> ou <xref:System.Windows.EventSetter> objetos.  
  
   
  
## Examples  
 O exemplo a seguir mostra como usar essa propriedade.  
  
 [!code-csharp[listboxitemstyle#1](~/samples/snippets/csharp/VS_Snippets_Wpf/ListBoxItemStyle/CSharp/Pane1.xaml.cs#1)]
 [!code-vb[listboxitemstyle#1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ListBoxItemStyle/VisualBasic/Pane1.xaml.vb#1)]  
  
 Adicionando um <xref:System.Windows.SetterBase> filho para uma <xref:System.Windows.Style> objeto adiciona implicitamente para o <xref:System.Windows.SetterBaseCollection> para o <xref:System.Windows.Style> objeto. O seguinte <xref:System.Windows.EventSetter> é implicitamente adicionado para o <xref:System.Windows.SetterBaseCollection> do estilo:  
  
 [!code-xaml[eventovwsupport#XAML2](~/samples/snippets/csharp/VS_Snippets_Wpf/EventOvwSupport/CSharp/page2.xaml#xaml2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Setter" />
        <altmember cref="T:System.Windows.EventSetter" />
      </Docs>
    </Member>
    <Member MemberName="System.Windows.ISealable.CanSeal">
      <MemberSignature Language="C#" Value="bool System.Windows.ISealable.CanSeal { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Windows.ISealable.CanSeal" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Style.System#Windows#ISealable#CanSeal" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property CanSeal As Boolean Implements ISealable.CanSeal" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Windows.ISealable.CanSeal { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Windows.Style.System.Windows.ISealable.CanSeal" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.ISealable.IsSealed">
      <MemberSignature Language="C#" Value="bool System.Windows.ISealable.IsSealed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Windows.ISealable.IsSealed" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Style.System#Windows#ISealable#IsSealed" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsSealed As Boolean Implements ISealable.IsSealed" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Windows.ISealable.IsSealed { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Windows.Style.System.Windows.ISealable.IsSealed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.ISealable.Seal">
      <MemberSignature Language="C#" Value="void ISealable.Seal ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.ISealable.Seal() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Style.System#Windows#ISealable#Seal" />
      <MemberSignature Language="VB.NET" Value="Sub Seal () Implements ISealable.Seal" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Windows.ISealable.Seal() = System::Windows::ISealable::Seal;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IAddChild.AddChild">
      <MemberSignature Language="C#" Value="void IAddChild.AddChild (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.Markup.IAddChild.AddChild(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Style.System#Windows#Markup#IAddChild#AddChild(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub AddChild (value As Object) Implements IAddChild.AddChild" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Windows.Markup.IAddChild.AddChild(System::Object ^ value) = System::Windows::Markup::IAddChild::AddChild;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IAddChild.AddChild(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">O objeto filho a ser adicionado.</param>
        <summary>Adiciona um objeto filho.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.Windows.Style> é convertida em uma interface de <xref:System.Windows.Markup.IAddChild>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IAddChild.AddText">
      <MemberSignature Language="C#" Value="void IAddChild.AddText (string text);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.Markup.IAddChild.AddText(string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Style.System#Windows#Markup#IAddChild#AddText(System.String)" />
      <MemberSignature Language="VB.NET" Value="Sub AddText (text As String) Implements IAddChild.AddText" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Windows.Markup.IAddChild.AddText(System::String ^ text) = System::Windows::Markup::IAddChild::AddText;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IAddChild.AddText(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="text">O texto a ser adicionado ao objeto.</param>
        <summary>Adiciona o conteúdo do texto de um nó ao objeto.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.Windows.Style> é convertida em uma interface de <xref:System.Windows.Markup.IAddChild>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.INameScope.FindName">
      <MemberSignature Language="C#" Value="object INameScope.FindName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.Windows.Markup.INameScope.FindName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Style.System#Windows#Markup#INameScope#FindName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function FindName (name As String) As Object Implements INameScope.FindName" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ System.Windows.Markup.INameScope.FindName(System::String ^ name) = System::Windows::Markup::INameScope::FindName;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.INameScope.FindName(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">O identificador de nome para o objeto que está sendo solicitado.</param>
        <summary>Retorna um objeto que tem o nome de identificação fornecido.</summary>
        <returns>O objeto, se encontrado. Retornará <see langword="null" /> se nenhum objeto com esse nome tiver sido encontrado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.Windows.Style> é convertida em uma interface de <xref:System.Windows.Markup.INameScope>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable">
      <MemberSignature Language="C#" Value="bool IQueryAmbient.IsAmbientPropertyAvailable (string propertyName);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(string propertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Style.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function IsAmbientPropertyAvailable (propertyName As String) As Boolean Implements IQueryAmbient.IsAmbientPropertyAvailable" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System::String ^ propertyName) = System::Windows::Markup::IQueryAmbient::IsAmbientPropertyAvailable;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="propertyName">O nome da propriedade de ambiente solicitada.</param>
        <summary>Consulta se uma propriedade de ambiente especificada está disponível no escopo atual.</summary>
        <returns>
          <see langword="true" /> se a propriedade de ambiente solicitada está disponível; caso contrário, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Windows.Markup.IQueryAmbient" />
      </Docs>
    </Member>
    <Member MemberName="TargetType">
      <MemberSignature Language="C#" Value="public Type TargetType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type TargetType" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Style.TargetType" />
      <MemberSignature Language="VB.NET" Value="Public Property TargetType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Type ^ TargetType { Type ^ get(); void set(Type ^ value); };" />
      <MemberSignature Language="F#" Value="member this.TargetType : Type with get, set" Usage="System.Windows.Style.TargetType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Markup.Ambient</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o tipo para o qual esse estilo foi projetado.</summary>
        <value>O tipo de destino desse estilo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você pode definir um estilo em qualquer elemento que é derivada de <xref:System.Windows.FrameworkElement> ou <xref:System.Windows.FrameworkContentElement>. Portanto, o tipo de destino pode ser qualquer um desses elementos. No entanto, se você criar um estilo com um <xref:System.Windows.Style.TargetType%2A> propriedade e base-lo em outro estilo que também define um <xref:System.Windows.Style.TargetType%2A> propriedade, o tipo de destino do estilo derivado deve ser igual ou ser derivado do tipo de destino do estilo de base.  
  
 Se você não especificar um <xref:System.Windows.Style.TargetType%2A>, em seguida, você deve especificar um `x:Key` para sua <xref:System.Windows.Style> e também qualificar as propriedades no seu estilo com um nome de classe.  
  
<a name="xamlAttributeUsage_TargetType"></a>   
## <a name="xaml-attribute-usage"></a>Uso do Atributo XAML  
  
```  
<object  TargetType="{x:Type typeName}"/>  
-or-  
<object  TargetType="typeName"/>  
```  
  
<a name="xamlValues_TargetType"></a>   
## <a name="xaml-values"></a>Valores XAML  
 `{x:Type ...}`  
 Um [x: tipo de extensão de marcação](~/docs/framework/xaml-services/x-type-markup-extension.md) uso de extensão de marcação.  
  
 *typeName*  
 O nome do tipo da classe.  
  
   
  
## Examples  
 O exemplo a seguir define um estilo que será aplicado a todas as instâncias de <xref:System.Windows.Controls.TextBlock> elemento.  
  
 [!code-xaml[PhotoStoreDemoStyled#1](~/samples/snippets/csharp/VS_Snippets_Wpf/PhotoStoreDemoStyled/CS/window1.xaml#1)]   
  
 Definindo o <xref:System.Windows.Style.TargetType%2A> propriedade para o <xref:System.Windows.Controls.TextBlock> tipo sem definir uma `x:Key` define implicitamente a `x:Key` para `{x:Type TextBlock}`. Isso também significa que, se você fornecer acima <xref:System.Windows.Style> um `x:Key` valor de qualquer coisa diferente de `{x:Type TextBlock}`, o <xref:System.Windows.Style> não poderá ser aplicado a todos os <xref:System.Windows.Controls.TextBlock> elementos automaticamente. Em vez disso, você precisa aplicar o estilo de <xref:System.Windows.Controls.TextBlock> elementos explicitamente.  
  
 Muitos [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] controles consistem em uma combinação de outros [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] controles, para criar um estilo que se aplica a todos os controles de um tipo podem ter um grande impacto. Por exemplo, se você criar um estilo destinado a <xref:System.Windows.Controls.TextBox> controles em um <xref:System.Windows.Controls.Canvas>, o estilo é aplicado a todos os <xref:System.Windows.Controls.TextBox> controles na tela, mesmo se o <xref:System.Windows.Controls.TextBox> faz parte de outro controle, como um <xref:System.Windows.Controls.ComboBox>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Triggers">
      <MemberSignature Language="C#" Value="public System.Windows.TriggerCollection Triggers { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.TriggerCollection Triggers" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Style.Triggers" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Triggers As TriggerCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::TriggerCollection ^ Triggers { System::Windows::TriggerCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Triggers : System.Windows.TriggerCollection" Usage="System.Windows.Style.Triggers" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.TriggerCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém uma coleção de objetos <see cref="T:System.Windows.TriggerBase" /> que se aplicam a valores de propriedade com base nas condições especificadas.</summary>
        <value>Uma coleção de objetos <see cref="T:System.Windows.TriggerBase" /> . O padrão é uma coleção vazia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] estilos e modelagem de modelo permite que você especifique acionadores em seu <xref:System.Windows.Style>. Essencialmente, os gatilhos são objetos que permitem que você aplicar alterações quando determinadas condições (como quando um determinado valor de propriedade torna-se `true`, ou quando ocorre um evento) são atendidos.  
  
<a name="xamlPropertyElementUsage_Triggers"></a>   
## <a name="xaml-property-element-usage"></a>Uso do elemento propriedade XAML  
  
```  
<object>  
  <object.Triggers>  
    oneOrMoreTriggers  
  </object.Triggers>  
</object>  
```  
  
<a name="xamlValues_Triggers"></a>   
## <a name="xaml-values"></a>Valores XAML  
 *oneOrMoreTriggers*  
 Zero ou mais elementos de objeto que são classes derivadas de <xref:System.Windows.TriggerBase>.  
  
   
  
## Examples  
 O exemplo a seguir mostra um conjunto nomeado <xref:System.Windows.Style> disponíveis para <xref:System.Windows.Controls.Button> controles. O <xref:System.Windows.Style> define uma <xref:System.Windows.Trigger> elemento altera o <xref:System.Windows.Controls.Control.Foreground%2A> propriedade de um botão quando o <xref:System.Windows.Controls.Primitives.ButtonBase.IsPressed%2A> é de propriedade `true`.  
  
 [!code-xaml[BtnStyles#2](~/samples/snippets/csharp/VS_Snippets_Wpf/BtnStyles/CS/app.xaml#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.DataTrigger" />
        <altmember cref="T:System.Windows.EventTrigger" />
      </Docs>
    </Member>
    <Member MemberName="UnregisterName">
      <MemberSignature Language="C#" Value="public void UnregisterName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void UnregisterName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Style.UnregisterName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub UnregisterName (name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void UnregisterName(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member UnregisterName : string -&gt; unit&#xA;override this.UnregisterName : string -&gt; unit" Usage="style.UnregisterName name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.INameScope.UnregisterName(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">O nome do mapeamento a ser removido.</param>
        <summary>Remove um mapeamento de nome-objeto do namescope.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>