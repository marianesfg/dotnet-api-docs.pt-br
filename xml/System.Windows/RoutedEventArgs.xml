<Type Name="RoutedEventArgs" FullName="System.Windows.RoutedEventArgs">
  <Metadata><Meta Name="ms.openlocfilehash" Value="a03c4f8cd6f46e0811f54af7dc69e0ab173f1753" /><Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="pt-BR" /><Meta Name="ms.lasthandoff" Value="10/04/2018" /><Meta Name="ms.locfileid" Value="48756002" /></Metadata><TypeSignature Language="C#" Value="public class RoutedEventArgs : EventArgs" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit RoutedEventArgs extends System.EventArgs" />
  <TypeSignature Language="DocId" Value="T:System.Windows.RoutedEventArgs" />
  <TypeSignature Language="VB.NET" Value="Public Class RoutedEventArgs&#xA;Inherits EventArgs" />
  <TypeSignature Language="C++ CLI" Value="public ref class RoutedEventArgs : EventArgs" />
  <TypeSignature Language="F#" Value="type RoutedEventArgs = class&#xA;    inherit EventArgs" />
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.EventArgs</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Contém informações de estado e dados de eventos associados a um evento roteado.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diferentes <xref:System.Windows.RoutedEventArgs> pode ser usado com um único <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A>. Essa classe é responsável pelo empacotamento de dados de evento para um <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A>, fornecendo informações de estado do evento extra e é usado pelo sistema de eventos para invocar o manipulador associado ao evento roteado.  
  
 ]]></format>
    </remarks>
    <altmember cref="P:System.Windows.RoutedEventArgs.RoutedEvent" />
    <altmember cref="T:System.Windows.EventManager" />
    <altmember cref="M:System.Windows.UIElement.RaiseEvent(System.Windows.RoutedEventArgs)" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Windows.RoutedEventArgs" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RoutedEventArgs ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RoutedEventArgs();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Windows.RoutedEventArgs" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ao usar esse construtor sem parâmetros, propriedades públicas tudo de novo <xref:System.Windows.RoutedEventArgs> instância supor que os seguintes valores padrão:  
  
-   <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A> o padrão é `null`.  
  
-   <xref:System.Windows.RoutedEventArgs.Handled%2A> padrão é `false`  
  
-   <xref:System.Windows.RoutedEventArgs.Source%2A> o padrão é `null`.  
  
-   <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> o padrão é `null`.  
  
 Valores nulos para <xref:System.Windows.RoutedEventArgs.Source%2A> e <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> significam apenas que o <xref:System.Windows.RoutedEventArgs> dados não fará nenhuma tentativa para especificar a origem. Quando essa instância é usada em uma chamada para <xref:System.Windows.UIElement.RaiseEvent%2A>, o <xref:System.Windows.RoutedEventArgs.Source%2A> e <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> valores são preenchidos com base no elemento que acionou o evento e é passado para os ouvintes por meio do roteamento.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.RoutedEventArgs.RoutedEvent" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RoutedEventArgs (System.Windows.RoutedEvent routedEvent);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.RoutedEvent routedEvent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.#ctor(System.Windows.RoutedEvent)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RoutedEventArgs(System::Windows::RoutedEvent ^ routedEvent);" />
      <MemberSignature Language="F#" Value="new System.Windows.RoutedEventArgs : System.Windows.RoutedEvent -&gt; System.Windows.RoutedEventArgs" Usage="new System.Windows.RoutedEventArgs routedEvent" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="routedEvent" Type="System.Windows.RoutedEvent" />
      </Parameters>
      <Docs>
        <param name="routedEvent">O identificador de evento roteado para essa instância da classe <see cref="T:System.Windows.RoutedEventArgs" />.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Windows.RoutedEventArgs" />, usando o identificador de evento roteado fornecido.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Propriedades do novo não for especificado ao usar esse construtor sobrecarregado, <xref:System.Windows.RoutedEventArgs> instância supor que os seguintes valores padrão:  
  
-   <xref:System.Windows.RoutedEventArgs.Handled%2A> padrão é `false`  
  
-   <xref:System.Windows.RoutedEventArgs.Source%2A> o padrão é `null`.  
  
-   <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> o padrão é `null`.  
  
 Valores nulos para <xref:System.Windows.RoutedEventArgs.Source%2A> e <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> significam apenas que isso <xref:System.Windows.RoutedEventArgs> não fará nenhuma tentativa para especificar a origem. Quando essa instância é usada em uma chamada para <xref:System.Windows.UIElement.RaiseEvent%2A>, o <xref:System.Windows.RoutedEventArgs.Source%2A> e <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> valores são preenchidos com base no elemento que acionou o evento e é passado para os ouvintes por meio do roteamento.  
  
   
  
## Examples  
 O exemplo a seguir constrói um novo <xref:System.Windows.RoutedEventArgs> para uso em uma chamada para <xref:System.Windows.UIElement.RaiseEvent%2A>.  
  
 [!code-csharp[RoutedEventCustom#RaiseEvent](~/samples/snippets/csharp/VS_Snippets_Wpf/RoutedEventCustom/CSharp/SDKSampleLibrary/class1.cs#raiseevent)]
 [!code-vb[RoutedEventCustom#RaiseEvent](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RoutedEventCustom/VB/SDKSampleLibrary/Class1.vb#raiseevent)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement.RaiseEvent(System.Windows.RoutedEventArgs)" />
        <altmember cref="P:System.Windows.RoutedEventArgs.RoutedEvent" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RoutedEventArgs (System.Windows.RoutedEvent routedEvent, object source);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.RoutedEvent routedEvent, object source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.#ctor(System.Windows.RoutedEvent,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RoutedEventArgs(System::Windows::RoutedEvent ^ routedEvent, System::Object ^ source);" />
      <MemberSignature Language="F#" Value="new System.Windows.RoutedEventArgs : System.Windows.RoutedEvent * obj -&gt; System.Windows.RoutedEventArgs" Usage="new System.Windows.RoutedEventArgs (routedEvent, source)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="routedEvent" Type="System.Windows.RoutedEvent" />
        <Parameter Name="source" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="routedEvent">O identificador de evento roteado para essa instância da classe <see cref="T:System.Windows.RoutedEventArgs" />.</param>
        <param name="source">Uma origem alternativa será relatada quando o evento for manipulado. Isso preenche previamente a propriedade <see cref="P:System.Windows.RoutedEventArgs.Source" />.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Windows.RoutedEventArgs" /> usando o identificador de evento roteado fornecido e dando a possibilidade de declarar uma origem diferente para o evento.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Propriedades do novo não for especificado ao usar esse construtor sobrecarregado, <xref:System.Windows.RoutedEventArgs> instância supor que os seguintes valores padrão:  
  
-   <xref:System.Windows.RoutedEventArgs.Handled%2A> padrão é `false`  
  
-   <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> o padrão é `null`.  
  
 Valores nulos para <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> são preenchidas com base no elemento que acionou o evento e passadas por meio do roteamento, mas lerá `null` antes da chamada.  
  
 Usar essa assinatura ao passar <xref:System.Windows.RoutedEventArgs> para virtuais, como <xref:System.Windows.Controls.Primitives.TextBoxBase.OnSelectionChanged%2A>, em que os argumentos são usados para chamar <xref:System.Windows.UIElement.RaiseEvent%2A> internamente.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Handled">
      <MemberSignature Language="C#" Value="public bool Handled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Handled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.RoutedEventArgs.Handled" />
      <MemberSignature Language="VB.NET" Value="Public Property Handled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Handled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Handled : bool with get, set" Usage="System.Windows.RoutedEventArgs.Handled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica o estado atual de manipulação de eventos para um evento roteado enquanto ele trafega na rota.</summary>
        <value>Se a configuração, definida como <see langword="true" /> se o evento deve ser marcado como tratado; caso contrário <see langword="false" />. Se for ler esse valor, <see langword="true" /> indica que um manipulador de classe ou algum manipulador de instância ao longo da rota já marcou este evento como manipulado. <see langword="false" />.indica que nenhum manipulador marcou o evento como manipulado.  
  
O valor padrão é <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Marcar o evento como manipulado limitará a visibilidade do evento roteado a ouvintes ao longo da rota de evento. O evento ainda o restante do roteiro de viagem, mas somente manipuladores adicionados especificamente com `HandledEventsToo` `true` no <xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> chamada de método será invocada na resposta. Padrão de manipuladores ouvintes de instância (como aqueles expresso em [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]) não será invocado. Manipulação de eventos que são marcados como manipulados não é um cenário comum.  
  
 Se você for um autor de controle definindo seus próprios eventos, as decisões tomadas sobre evento tratamento no nível da classe terá impacto sobre os usuários do seu controle, bem como todos os usuários da controles derivados e potencialmente outros elementos que são contidos pelo seu controle ou que contêm seu controle. Para obter mais informações, consulte [Marcar eventos roteados como manipulados e manipulação de classe](~/docs/framework/wpf/advanced/marking-routed-events-as-handled-and-class-handling.md).  
  
 Em circunstâncias muito raras, é apropriado manipular eventos em que <xref:System.Windows.RoutedEventArgs.Handled%2A> está marcada `true`e modifique os argumentos do evento alterando <xref:System.Windows.RoutedEventArgs.Handled%2A> para `false`. Isso pode ser necessário em determinadas áreas de eventos de entrada de controles, como tratamento de chaves do <xref:System.Windows.UIElement.KeyDown> versus <xref:System.Windows.UIElement.TextInput> nível baixo em que competem de eventos de entrada de alto níveis para o tratamento e cada um é tentar trabalhar com uma estratégia de roteamento diferente.  
  
   
  
## Examples  
 O exemplo a seguir implementa um manipulador de eventos que marca o evento como manipulado.  
  
 [!code-csharp[ClassHandling#OnStarClassHandler](~/samples/snippets/csharp/VS_Snippets_Wpf/ClassHandling/CSharp/SDKSampleLibrary/class1.cs#onstarclasshandler)]
 [!code-vb[ClassHandling#OnStarClassHandler](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ClassHandling/visualbasic/sdksamplelibrary/class1.vb#onstarclasshandler)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeEventHandler">
      <MemberSignature Language="C#" Value="protected virtual void InvokeEventHandler (Delegate genericHandler, object genericTarget);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void InvokeEventHandler(class System.Delegate genericHandler, object genericTarget) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.InvokeEventHandler(System.Delegate,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub InvokeEventHandler (genericHandler As Delegate, genericTarget As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void InvokeEventHandler(Delegate ^ genericHandler, System::Object ^ genericTarget);" />
      <MemberSignature Language="F#" Value="abstract member InvokeEventHandler : Delegate * obj -&gt; unit&#xA;override this.InvokeEventHandler : Delegate * obj -&gt; unit" Usage="routedEventArgs.InvokeEventHandler (genericHandler, genericTarget)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="genericHandler" Type="System.Delegate" />
        <Parameter Name="genericTarget" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="genericHandler">A implementação de manipulador/delegado genérica a ser invocada.</param>
        <param name="genericTarget">O destino no qual o manipulador fornecido deve ser invocado.</param>
        <summary>Quando substituído em uma classe derivada, fornece um modo de se invocar os manipuladores de eventos de uma maneira específica a um tipo, que pode aumentar a eficiência com relação à implementação base.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A implementação base incorpora a reflexão para determinar o manipulador correto para qualquer caso em que o manipulador não é literalmente <xref:System.Windows.RoutedEventHandler>, e essa etapa de reflexão tem algumas consequências de desempenho. Invocações podem ser feitas mais eficientes não depender de reflexão. Esse é o cenário que motiva a esse método está disponível para qualquer classe de argumentos do evento roteado que escolher para substituí-la. Implementações não devem chamar a base para esse método, porque sua implementação já deve ser responsável por invocar os manipuladores de tipo seguro.  
  
   
  
## Examples  
 Este é o pseudocódigo que ilustra um padrão básico que pode ser usado para implementação. Aqui, `MyRoutedEventHandler` é uma subclasse de <xref:System.Windows.RoutedEventHandler>.  
  
 [!code-csharp[CorePseudocode#RoutedEventArgs](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/corepseudocode.cs#routedeventargs)]
 [!code-vb[CorePseudocode#RoutedEventArgs](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CorePseudocode/visualbasic/corepseudocode.vb#routedeventargs)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Este método destina-se a ser substituído por classes de dados de evento derivado para fornecer a invocação mais eficiente de seus representantes. A implementação deverá converter fornecido <paramref name="genericHandler" /> específicos do tipo de delegado e, em seguida, invocar esse manipulador.  
  
A implementação padrão tenta invocar o manipulador fornecido, tentar convertê-la como <see cref="T:System.Windows.RoutedEventHandler" />. Se qualquer um dos <paramref name="genericHandler" /> ou <paramref name="genericTarget" /> é fornecido como <see langword="null" />, as exceções serão geradas.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnSetSource">
      <MemberSignature Language="C#" Value="protected virtual void OnSetSource (object source);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSetSource(object source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.OnSetSource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSetSource (source As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSetSource(System::Object ^ source);" />
      <MemberSignature Language="F#" Value="abstract member OnSetSource : obj -&gt; unit&#xA;override this.OnSetSource : obj -&gt; unit" Usage="routedEventArgs.OnSetSource source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="source">O novo valor para o qual o <see cref="P:System.Windows.RoutedEventArgs.Source" /> está sendo definido.</param>
        <summary>Quando substituído em uma classe derivada, fornece um ponto de entrada de retorno de chamada de notificação sempre que o valor da propriedade <see cref="P:System.Windows.RoutedEventArgs.Source" /> de uma instância muda.</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>Alterar a fonte relatada de um evento por meio de programação potencialmente pode exigir a atualização dos dados de tipo específico dentro do evento. Por esse motivo, o <see cref="M:System.Windows.RoutedEventArgs.OnSetSource(System.Object)" /> método virtual é protegido e se destina a ser substituído por subclasses de <see cref="T:System.Windows.RoutedEventArgs" />.  
  
Esse método não tem nenhuma implementação padrão.</para></block>
        <altmember cref="P:System.Windows.RoutedEventArgs.Source" />
      </Docs>
    </Member>
    <Member MemberName="OriginalSource">
      <MemberSignature Language="C#" Value="public object OriginalSource { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object OriginalSource" />
      <MemberSignature Language="DocId" Value="P:System.Windows.RoutedEventArgs.OriginalSource" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OriginalSource As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ OriginalSource { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OriginalSource : obj" Usage="System.Windows.RoutedEventArgs.OriginalSource" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém a origem de relatório original conforme determinada pelo teste de clique puro, antes de qualquer ajuste possível da <see cref="P:System.Windows.RoutedEventArgs.Source" /> por parte de uma classe pai.</summary>
        <value>A origem de relatório original, antes de qualquer ajuste <see cref="P:System.Windows.RoutedEventArgs.Source" /> possível realizado pelo tratamento de classe, que pode ter sido feito para mesclar árvores de elementos compostos.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa propriedade adquire seu valor uma vez, antes da aula manipuladores de eventos ou os manipuladores de instância são invocados e nunca é ajustado após este ponto. As informações de origem original são somente leitura para manipuladores de classe ou implementações de classe, exatamente como ele é relatado nos dados do evento.  
  
 Casos comuns em que a fonte pode ser ajustada incluem elementos de conteúdo dentro de um modelo de conteúdo para um controle (o conteúdo de um item de lista, por exemplo, relatará o elemento de item de lista como o <xref:System.Windows.RoutedEventArgs.Source%2A> e o elemento real dentro do item de lista será a <xref:System.Windows.RoutedEventArgs.OriginalSource%2A>.  
  
 Ajuste de origem por vários elementos e modelos de conteúdo varia para cada classe. Cada classe que ajusta a origens de eventos tenta prever qual fonte será mais útil relatar para mais cenários de entrada e os cenários para os quais destina-se a classe e, em seguida, conjuntos de fonte como o <xref:System.Windows.RoutedEventArgs.Source%2A>. Se essa fonte não é aquele que tem a relevância para a sua manipulação do evento, tente verificar <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> em vez disso, para ver se ele relata uma fonte diferente que seja mais adequada. Para obter mais detalhes sobre eventos de entrada, consulte [visão geral de entrada](~/docs/framework/wpf/advanced/input-overview.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.RoutedEventArgs.Source" />
      </Docs>
    </Member>
    <Member MemberName="RoutedEvent">
      <MemberSignature Language="C#" Value="public System.Windows.RoutedEvent RoutedEvent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.RoutedEvent RoutedEvent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.RoutedEventArgs.RoutedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Property RoutedEvent As RoutedEvent" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::RoutedEvent ^ RoutedEvent { System::Windows::RoutedEvent ^ get(); void set(System::Windows::RoutedEvent ^ value); };" />
      <MemberSignature Language="F#" Value="member this.RoutedEvent : System.Windows.RoutedEvent with get, set" Usage="System.Windows.RoutedEventArgs.RoutedEvent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o <see cref="P:System.Windows.RoutedEventArgs.RoutedEvent" /> associado a esta instância do <see cref="T:System.Windows.RoutedEventArgs" />.</summary>
        <value>O identificador do evento que foi invocado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 É possível definir esse valor em uma <xref:System.Windows.RoutedEventArgs> que já tiver sido roteada (por exemplo, se você adquiriu os argumentos por meio de um manipulador). Tentar fazer isso irá gerar uma exceção. Você pode defini-lo somente em uma instância que ainda não foi usada para gerar uma invocação do evento.  
  
 O valor de <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A> não pode ser `null` a qualquer momento.  
  
   
  
## Examples  
 O exemplo a seguir cria novos dados de evento roteado com um construtor inicial e, em seguida, define o <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A> a propriedade como uma operação subsequente. Você deve ter <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A> definido antes de acionar o evento roteado.  
  
 [!code-csharp[ColorPicker_v2#RoutedEventArgsRoutedEvent](~/samples/snippets/csharp/VS_Snippets_Wpf/ColorPicker_v2/CSharp/ColorPicker.cs#routedeventargsroutedevent)]
 [!code-vb[ColorPicker_v2#RoutedEventArgsRoutedEvent](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ColorPicker_v2/visualbasic/colorpicker.vb#routedeventargsroutedevent)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Tentou alterar o valor <see cref="P:System.Windows.RoutedEventArgs.RoutedEvent" /> enquanto o evento estava sendo roteado.</exception>
      </Docs>
    </Member>
    <Member MemberName="Source">
      <MemberSignature Language="C#" Value="public object Source { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Source" />
      <MemberSignature Language="DocId" Value="P:System.Windows.RoutedEventArgs.Source" />
      <MemberSignature Language="VB.NET" Value="Public Property Source As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Source { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Source : obj with get, set" Usage="System.Windows.RoutedEventArgs.Source" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define uma referência ao objeto que ativou o evento.</summary>
        <value>O objeto que gerencie o evento.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para qualquer propagação de evento que realmente percorreu a rota após o elemento que o gerou roteado e para qualquer túnel evento não foi roteado ainda encapsulado para baixo até o elemento que o gerou, o valor de <xref:System.Windows.RoutedEventArgs.Source%2A> será diferente do valor da `sender` parâmetro de classe de argumentos de evento. Qual dos dois elementos envolvido no evento é mais importante em qualquer determinado manipulador (<xref:System.Windows.RoutedEventArgs.Source%2A>, o elemento que o gerou, ou `sender`, o elemento que atualmente está tratando) depende do que é o manipulador de lógica do aplicativo endereçamento.  
  
 A definição dessa propriedade é geralmente feita somente quando substituindo ou implementar outros [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] que ajustar fontes de evento, por exemplo, quando um evento de manipulação de classe. Não é recomendável redefinir as fontes de evento aparente de manipuladores de instância, especialmente quando o manipulador não marca o evento como manipulado.  
  
 Se você redefinir <xref:System.Windows.RoutedEventArgs.Source%2A> para relatar uma fonte de eventos diferentes <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> continuará reportando a fonte como primeiro gerada por origem <xref:System.Windows.UIElement.RaiseEvent%2A> chamar.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.RoutedEventArgs.OriginalSource" />
      </Docs>
    </Member>
  </Members>
</Type>